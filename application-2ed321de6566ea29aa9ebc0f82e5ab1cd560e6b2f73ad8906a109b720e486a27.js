!function(t,n){"object"==typeof exports&&"undefined"!=typeof module?n(exports,require("react")):"function"==typeof define&&define.amd?define(["exports","react"],n):n(t.Recompose=t.Recompose||{},t.React)}(this,function(t,n){"use strict";function r(t,n){return t===n?0!==t||0!==n||1/t==1/n:t!==t&&n!==n}function e(t,n){if(r(t,n))return!0;if("object"!=typeof t||null===t||"object"!=typeof n||null===n)return!1;var e=Object.keys(t);if(e.length!==Object.keys(n).length)return!1;for(var o=0;e.length>o;o++)if(!O.call(n,e[o])||!r(t[e[o]],n[e[o]]))return!1;return!0}function o(){for(var t=arguments.length,n=Array(t),r=0;t>r;r++)n[r]=arguments[r];return 0===n.length?function(t){return t}:1===n.length?n[0]:n.reduce(function(t,n){return function(){return t(n.apply(void 0,arguments))}})}var u,i="default"in n?n.default:n,c=function(t,n){return function(r){return r[t]=n,r}},a=function(t){return c("displayName",t)},p=function(t){if("string"==typeof t)return t;if(t)return t.displayName||t.name||"Component"},s=function(t,n){return n+"("+p(t)+")"},f=function(t){return function(r){var e=n.createFactory(r);return function(n){return e(t(n))}}},l=function(t,n){if(!(t instanceof n))throw new TypeError("Cannot call a class as a function")},h=Object.assign||function(t){for(var n=1;arguments.length>n;n++){var r=arguments[n];for(var e in r)Object.prototype.hasOwnProperty.call(r,e)&&(t[e]=r[e])}return t},y=function(t,n){if("function"!=typeof n&&null!==n)throw new TypeError("Super expression must either be null or a function, not "+typeof n);t.prototype=Object.create(n&&n.prototype,{constructor:{value:t,enumerable:!1,writable:!0,configurable:!0}}),n&&(Object.setPrototypeOf?Object.setPrototypeOf(t,n):t.__proto__=n)},v=function(t,n){var r={};for(var e in t)0>n.indexOf(e)&&Object.prototype.hasOwnProperty.call(t,e)&&(r[e]=t[e]);return r},d=function(t,n){if(!t)throw new ReferenceError("this hasn't been initialised - super() hasn't been called");return!n||"object"!=typeof n&&"function"!=typeof n?t:n},m=function(t){return f(function(n){return h({},n,"function"==typeof t?t(n):t)})},b=function(t,n){for(var r={},e=0;n.length>e;e++){var o=n[e];t.hasOwnProperty(o)&&(r[o]=t[o])}return r},O=Object.prototype.hasOwnProperty,g=e,P=function(t,r){return function(e){var o=n.createFactory(e),u="function"==typeof t?t:function(n,r){return!g(b(n,t),b(r,t))};return function(t){function n(){var e,o,u;l(this,n);for(var i=arguments.length,c=Array(i),a=0;i>a;a++)c[a]=arguments[a];return e=o=d(this,t.call.apply(t,[this].concat(c))),o.computedProps=r(o.props),u=e,d(o,u)}return y(n,t),n.prototype.componentWillReceiveProps=function(t){u(this.props,t)&&(this.computedProps=r(t))},n.prototype.render=function(){return o(h({},this.props,this.computedProps))},n}(n.Component)}},S=function(t,n){var r={};for(var e in t)t.hasOwnProperty(e)&&(r[e]=n(t[e],e));return r},C=function(t){return function(r){var e=n.createFactory(r),o=function(){var n=this;this.cachedHandlers={},this.handlers=S("function"==typeof t?t(this.props):t,function(t,r){return function(){var e=n.cachedHandlers[r];if(e)return e.apply(void 0,arguments);var o=t(n.props);return n.cachedHandlers[r]=o,o.apply(void 0,arguments)}})};return function(t){function n(){var r,e,u;l(this,n);for(var i=arguments.length,c=Array(i),a=0;i>a;a++)c[a]=arguments[a];return r=e=d(this,t.call.apply(t,[this].concat(c))),o.call(e),u=r,d(e,u)}return y(n,t),n.prototype.componentWillReceiveProps=function(){this.cachedHandlers={}},n.prototype.render=function(){return e(h({},this.props,this.handlers))},n}(n.Component)}},E=function(t){return function(r){var e=n.createFactory(r),o=function(t){return e(t)};return o.defaultProps=t,o}},w=function(t,n){for(var r=v(t,[]),e=0;n.length>e;e++){var o=n[e];r.hasOwnProperty(o)&&delete r[o]}return r},x=function(t,n){return f(function(r){var e;return h({},w(r,[t]),(e={},e[n]=r[t],e))})},F=Object.keys,j=function(t,n){return F(t).reduce(function(r,e){var o=t[e];return r[n(o,e)]=o,r},{})},T=function(t){return f(function(n){return h({},w(n,F(t)),j(b(n,F(t)),function(n,r){return t[r]}))})},V=function(t){return function(r){var e=n.createFactory(r);return function(n){return e(h({},n,n[t]))}}},N=function(t,r,e){return function(o){var u=n.createFactory(o);return function(n){function o(){var t,r,u;l(this,o);for(var i=arguments.length,c=Array(i),a=0;i>a;a++)c[a]=arguments[a];return t=r=d(this,n.call.apply(n,[this].concat(c))),r.state={stateValue:"function"==typeof e?e(r.props):e},r.updateStateValue=function(t,n){return r.setState(function(n){var r=n.stateValue;return{stateValue:"function"==typeof t?t(r):t}},n)},u=t,d(r,u)}return y(o,n),o.prototype.render=function(){var n;return u(h({},this.props,(n={},n[t]=this.state.stateValue,n[r]=this.updateStateValue,n)))},o}(n.Component)}},A=function(t,r){return function(e){var o=n.createFactory(e),u=function(){var n=this;this.state="function"==typeof t?t(this.props):t,this.stateUpdaters=S(r,function(t){return function(r){for(var e=arguments.length,o=Array(e>1?e-1:0),u=1;e>u;u++)o[u-1]=arguments[u];r&&"function"==typeof r.persist&&r.persist(),n.setState(function(n,e){return t(n,e).apply(void 0,[r].concat(o))})}})};return function(t){function n(){var r,e,o;l(this,n);for(var i=arguments.length,c=Array(i),a=0;i>a;a++)c[a]=arguments[a];return r=e=d(this,t.call.apply(t,[this].concat(c))),u.call(e),o=r,d(e,o)}return y(n,t),n.prototype.shouldComponentUpdate=function(t,n){var r=t!==this.props,e=!g(n,this.state);return r||e},n.prototype.render=function(){return o(h({},this.props,this.state,this.stateUpdaters))},n}(n.Component)}},R=function(t,r,e,o){return function(u){var i=n.createFactory(u);return function(n){function u(){var t,r,o;l(this,u);for(var i=arguments.length,c=Array(i),a=0;i>a;a++)c[a]=arguments[a];return t=r=d(this,n.call.apply(n,[this].concat(c))),r.state={stateValue:r.initializeStateValue()},r.dispatch=function(t){return r.setState(function(n){return{stateValue:e(n.stateValue,t)}})},o=t,d(r,o)}return y(u,n),u.prototype.initializeStateValue=function(){return void 0!==o?"function"==typeof o?o(this.props):o:e(void 0,{type:"@@recompose/INIT"})},u.prototype.render=function(){var n;return i(h({},this.props,(n={},n[t]=this.state.stateValue,n[r]=this.dispatch,n)))},u}(n.Component)}},W=function(t){return t},U=function(t,r){var e=arguments.length>2&&void 0!==arguments[2]?arguments[2]:W;return function(o){var u=void 0,i=void 0;return function(c){return t(c)?(u=u||n.createFactory(r(o)))(c):(i=i||n.createFactory(e(o)))(c)}}},H=function(t){return function(r){var e=n.createFactory(t);return function(t){return e(t)}}},_=function(t){function n(){return l(this,n),d(this,t.apply(this,arguments))}return y(n,t),n.prototype.render=function(){return null},n}(n.Component),k=function(t){return _},D=function(t){return function(r){var e=n.createFactory(r);return function(n){function r(){return l(this,r),d(this,n.apply(this,arguments))}return y(r,n),r.prototype.shouldComponentUpdate=function(n){return t(this.props,n)},r.prototype.render=function(){return e(this.props)},r}(n.Component)}},M=function(t){return D(function(t,n){return!g(t,n)})(t)},$=function(t){return D(function(n,r){return!g(b(r,t),b(n,t))})},q=function(t){var n=t.propTypes,r=Object.keys(n||{});return $(r)(t)},z=function(t,r){return function(e){var o=n.createFactory(e),u=function(t){function n(){var e,o,u;l(this,n);for(var i=arguments.length,c=Array(i),a=0;i>a;a++)c[a]=arguments[a];return e=o=d(this,t.call.apply(t,[this].concat(c))),o.getChildContext=function(){return r(o.props)},u=e,d(o,u)}return y(n,t),n.prototype.render=function(){return o(this.props)},n}(n.Component);return u.childContextTypes=t,u}},I=function(t){return function(r){var e=n.createFactory(r),o=function(t,n){return e(h({},t,n))};return o.contextTypes=t,o}},K=function(t){return function(r){var e=n.createFactory(r),o=function(t){function n(){return l(this,n),d(this,t.apply(this,arguments))}return y(n,t),n.prototype.render=function(){return e(h({},this.props,this.state))},n}(n.Component);return Object.keys(t).forEach(function(n){return o.prototype[n]=t[n]}),o}},B=function(t){return!(!t||!t.prototype||"function"!=typeof t.prototype.render)},G=function(t){if(B(t))return t;var r=function(n){function r(){return l(this,r),d(this,n.apply(this,arguments))}return y(r,n),r.prototype.render=function(){return"string"==typeof t?i.createElement(t,this.props):t(this.props,this.context)},r}(n.Component);return r.displayName=p(t),r.propTypes=t.propTypes,r.contextTypes=t.contextTypes,r.defaultProps=t.defaultProps,r},J=function(t){return c("propTypes",t)},L=function(t){return function(n){function r(){return l(this,r),d(this,n.apply(this,arguments))}return y(r,n),r.prototype.componentWillMount=function(){t(this.props)},r.prototype.componentWillReceiveProps=function(n){t(n)},r.prototype.render=function(){return null},r}(n.Component)},Q=function(t){var r=function(r){return n.createElement(r[t],w(r,[t]))};return r.displayName="componentFromProp("+t+")",r},X=function(){for(var t=arguments.length,r=Array(t),e=0;t>e;e++)r[e]=arguments[e];var o=r.map(n.createFactory);return function(t){var n=v(t,[]),r=t.children;return o.reduceRight(function(t,r){return r(n,t)},r)}},Y={childContextTypes:!0,contextTypes:!0,defaultProps:!0,displayName:!0,getDefaultProps:!0,mixins:!0,propTypes:!0,type:!0},Z={name:!0,length:!0,prototype:!0,caller:!0,arguments:!0,arity:!0},tt="function"==typeof Object.getOwnPropertySymbols,nt=function(t,n,r){if("string"!=typeof n){var e=Object.getOwnPropertyNames(n);tt&&(e=e.concat(Object.getOwnPropertySymbols(n)));for(var o=0;e.length>o;++o)if(!(Y[e[o]]||Z[e[o]]||r&&r[e[o]]))try{t[e[o]]=n[e[o]]}catch(t){}}return t},rt=function(t){return function(n){var r=t(n);return nt(r,n),r}},et=function(t,n){return n={exports:{}},t(n,n.exports),n.exports}(function(t,n){Object.defineProperty(n,"__esModule",{value:!0});n.createChangeEmitter=function(){function t(){o===e&&(o=e.slice())}function n(n){if("function"!=typeof n)throw Error("Expected listener to be a function.");var r=!0;return t(),o.push(n),function(){if(r){r=!1,t();var e=o.indexOf(n);o.splice(e,1)}}}function r(){e=o;for(var t=e,n=0;t.length>n;n++)t[n].apply(t,arguments)}var e=[],o=e;return{listen:n,emit:r}}}),ot=et.createChangeEmitter;u="undefined"!=typeof self?self:"undefined"!=typeof window?window:"undefined"!=typeof global?global:"undefined"!=typeof module?module:Function("return this")();var ut=function(t){var n,r=t.Symbol;return"function"==typeof r?r.observable?n=r.observable:(n=r("observable"),r.observable=n):n="@@observable",n}(u),it={fromESObservable:null,toESObservable:null},ct=function(t){it=t},at={fromESObservable:function(t){return"function"==typeof it.fromESObservable?it.fromESObservable(t):t},toESObservable:function(t){return"function"==typeof it.toESObservable?it.toESObservable(t):t}},pt=function(t){return function(r){return function(n){function e(){var o,u,i,c;l(this,e);for(var a=arguments.length,p=Array(a),s=0;a>s;s++)p[s]=arguments[s];return u=i=d(this,n.call.apply(n,[this].concat(p))),i.state={vdom:null},i.propsEmitter=ot(),i.props$=t.fromESObservable((o={subscribe:function(t){return{unsubscribe:i.propsEmitter.listen(function(n){n?t.next(n):t.complete()})}}},o[ut]=function(){return this},o)),i.vdom$=t.toESObservable(r(i.props$)),c=u,d(i,c)}return y(e,n),e.prototype.componentWillMount=function(){var t=this;this.subscription=this.vdom$.subscribe({next:function(n){t.setState({vdom:n})}}),this.propsEmitter.emit(this.props)},e.prototype.componentWillReceiveProps=function(t){this.propsEmitter.emit(t)},e.prototype.shouldComponentUpdate=function(t,n){return n.vdom!==this.state.vdom},e.prototype.componentWillUnmount=function(){this.propsEmitter.emit(),this.subscription.unsubscribe()},e.prototype.render=function(){return this.state.vdom},e}(n.Component)}},st=function(t){return pt(at)(t)},ft=function(t){return t},lt=function(t){var r=pt({fromESObservable:ft,toESObservable:ft});return function(e){return function(o){var u=n.createFactory(o),i=t.fromESObservable,c=t.toESObservable;return r(function(t){var n;return n={subscribe:function(n){var r=c(e(i(t))).subscribe({next:function(t){return n.next(u(t))}});return{unsubscribe:function(){return r.unsubscribe()}}}},n[ut]=function(){return this},n})}}},ht=function(t){return lt(at)(t)},yt=function(t){return function(){var n,r=ot(),e=t.fromESObservable((n={subscribe:function(t){return{unsubscribe:r.listen(function(n){return t.next(n)})}}},n[ut]=function(){return this},n));return{handler:r.emit,stream:e}}},vt=yt(at);t.mapProps=f,t.withProps=m,t.withPropsOnChange=P,t.withHandlers=C,t.defaultProps=E,t.renameProp=x,t.renameProps=T,t.flattenProp=V,t.withState=N,t.withStateHandlers=A,t.withReducer=R,t.branch=U,t.renderComponent=H,t.renderNothing=k,t.shouldUpdate=D,t.pure=M,t.onlyUpdateForKeys=$,t.onlyUpdateForPropTypes=q,t.withContext=z,t.getContext=I,t.lifecycle=K,t.toClass=G,t.setStatic=c,t.setPropTypes=J,t.setDisplayName=a,t.compose=o,t.getDisplayName=p,t.wrapDisplayName=s,t.shallowEqual=g,t.isClassComponent=B,t.createSink=L,t.componentFromProp=Q,t.nest=X,t.hoistStatics=rt,t.componentFromStream=st,t.componentFromStreamWithConfig=pt,t.mapPropsStream=ht,t.mapPropsStreamWithConfig=lt,t.createEventHandler=vt,t.createEventHandlerWithConfig=yt,t.setObservableConfig=ct,Object.defineProperty(t,"__esModule",{value:!0})});
!function(t,n){"object"==typeof exports&&"undefined"!=typeof module?n(exports):"function"==typeof define&&define.amd?define(["exports"],n):n(t.R={})}(this,function(t){"use strict";function n(t){return null!=t&&"object"==typeof t&&!0===t["@@functional/placeholder"]}function r(t){return function r(e){return 0===arguments.length||n(e)?r:t.apply(this,arguments)}}function e(t){return function e(u,i){switch(arguments.length){case 0:return e;case 1:return n(u)?e:r(function(n){return t(u,n)});default:return n(u)&&n(i)?e:n(u)?r(function(n){return t(n,i)}):n(i)?r(function(n){return t(u,n)}):t(u,i)}}}function u(t,n){t=t||[],n=n||[];var r,e=t.length,u=n.length,i=[];for(r=0;e>r;)i[i.length]=t[r],r+=1;for(r=0;u>r;)i[i.length]=n[r],r+=1;return i}function i(t,n){switch(t){case 0:return function(){return n.apply(this,arguments)};case 1:return function(t){return n.apply(this,arguments)};case 2:return function(t,r){return n.apply(this,arguments)};case 3:return function(t,r,e){return n.apply(this,arguments)};case 4:return function(t,r,e,u){return n.apply(this,arguments)};case 5:return function(t,r,e,u,i){return n.apply(this,arguments)};case 6:return function(t,r,e,u,i,o){return n.apply(this,arguments)};case 7:return function(t,r,e,u,i,o,c){return n.apply(this,arguments)};case 8:return function(t,r,e,u,i,o,c,a){return n.apply(this,arguments)};case 9:return function(t,r,e,u,i,o,c,a,s){return n.apply(this,arguments)};case 10:return function(t,r,e,u,i,o,c,a,s,f){return n.apply(this,arguments)};default:throw Error("First argument to _arity must be a non-negative integer no greater than ten")}}function o(t,r,e){return function(){for(var u=[],c=0,a=t,s=0;r.length>s||arguments.length>c;){var f;s>=r.length||n(r[s])&&arguments.length>c?(f=arguments[c],c+=1):f=r[s],u[s]=f,n(f)||(a-=1),s+=1}return a>0?i(a,o(t,u,e)):e.apply(this,u)}}function c(t){return function u(i,o,c){switch(arguments.length){case 0:return u;case 1:return n(i)?u:e(function(n,r){return t(i,n,r)});case 2:return n(i)&&n(o)?u:n(i)?e(function(n,r){return t(n,o,r)}):n(o)?e(function(n,r){return t(i,n,r)}):r(function(n){return t(i,o,n)});default:return n(i)&&n(o)&&n(c)?u:n(i)&&n(o)?e(function(n,r){return t(n,r,c)}):n(i)&&n(c)?e(function(n,r){return t(n,o,r)}):n(o)&&n(c)?e(function(n,r){return t(i,n,r)}):n(i)?r(function(n){return t(n,o,c)}):n(o)?r(function(n){return t(i,n,c)}):n(c)?r(function(n){return t(i,o,n)}):t(i,o,c)}}}function a(t){return"function"==typeof t["@@transducer/step"]}function s(t,n,r){return function(){if(0===arguments.length)return r();var e=Array.prototype.slice.call(arguments,0),u=e.pop();if(!At(u)){for(var i=0;t.length>i;){if("function"==typeof u[t[i]])return u[t[i]].apply(u,e);i+=1}if(a(u))return n.apply(null,e)(u)}return r.apply(this,arguments)}}function f(t){return t&&t["@@transducer/reduced"]?t:{"@@transducer/value":t,"@@transducer/reduced":!0}}function l(t,n){this.xf=n,this.f=t,this.all=!0}function p(t,n){for(var r=0,e=n.length,u=Array(e);e>r;)u[r]=t(n[r]),r+=1;return u}function h(t){return"[object String]"===Object.prototype.toString.call(t)}function y(t){this.f=t}function d(t){return new y(t)}function g(t,n,r){for(var e=0,u=r.length;u>e;){if((n=t["@@transducer/step"](n,r[e]))&&n["@@transducer/reduced"]){n=n["@@transducer/value"];break}e+=1}return t["@@transducer/result"](n)}function v(t,n,r){for(var e=r.next();!e.done;){if((n=t["@@transducer/step"](n,e.value))&&n["@@transducer/reduced"]){n=n["@@transducer/value"];break}e=r.next()}return t["@@transducer/result"](n)}function m(t,n,r,e){return t["@@transducer/result"](r[e](qt(t["@@transducer/step"],t),n))}function b(t,n,r){if("function"==typeof t&&(t=d(t)),_t(r))return g(t,n,r);if("function"==typeof r["fantasy-land/reduce"])return m(t,n,r,"fantasy-land/reduce");if(null!=r[kt])return v(t,n,r[kt]());if("function"==typeof r.next)return v(t,n,r);if("function"==typeof r.reduce)return m(t,n,r,"reduce");throw new TypeError("reduce: list must be array or iterable")}function x(t,n){this.xf=n,this.f=t}function w(t,n){return Object.prototype.hasOwnProperty.call(n,t)}function j(t,n){this.xf=n,this.f=t,this.any=!1}function A(t,n){this.xf=n,this.pos=0,this.full=!1,this.acc=Array(t)}function O(t){return"[object Function]"===Object.prototype.toString.call(t)}function S(t){return function n(r){for(var e,u,i,o=[],c=0,a=r.length;a>c;){if(_t(r[c]))for(i=0,u=(e=t?n(r[c]):r[c]).length;u>i;)o[o.length]=e[i],i+=1;else o[o.length]=r[c];c+=1}return o}}function E(t){return{"@@transducer/value":t,"@@transducer/reduced":!0}}function _(t){return RegExp(t.source,(t.global?"g":"")+(t.ignoreCase?"i":"")+(t.multiline?"m":"")+(t.sticky?"y":"")+(t.unicode?"u":""))}function q(t,n,r,e){var u=function(u){for(var i=n.length,o=0;i>o;){if(t===n[o])return r[o];o+=1}n[o+1]=t,r[o+1]=u;for(var c in t)u[c]=e?q(t[c],n,r,!0):t[c];return u};switch(mn(t)){case"Object":return u({});case"Array":return u([]);case"Date":return new Date(t.valueOf());case"RegExp":return _(t);default:return t}}function k(t,n){return function(){return n.call(this,t.apply(this,arguments))}}function N(t,n){return function(){var r=arguments.length;if(0===r)return n();var e=arguments[r-1];return At(e)||"function"!=typeof e[t]?n.apply(this,arguments):e[t].apply(e,Array.prototype.slice.call(arguments,0,r-1))}}function I(){if(0===arguments.length)throw Error("pipe requires at least one argument");return i(arguments[0].length,Mt(k,arguments[0],On(arguments)))}function W(){if(0===arguments.length)throw Error("compose requires at least one argument");return I.apply(this,Sn(arguments))}function P(){if(0===arguments.length)throw Error("composeK requires at least one argument");var t=Array.prototype.slice.call(arguments),n=t.pop();return W(W.apply(this,Rt(gn,t)),n)}function C(t,n){return function(){var r=this;return t.apply(r,arguments).then(function(t){return n.call(r,t)})}}function T(){if(0===arguments.length)throw Error("pipeP requires at least one argument");return i(arguments[0].length,Mt(C,arguments[0],On(arguments)))}function B(t){for(var n,r=[];!(n=t.next()).done;)r.push(n.value);return r}function F(t,n,r){for(var e=0,u=r.length;u>e;){if(t(n,r[e]))return!0;e+=1}return!1}function R(t){var n=(t+"").match(/^function (\w*)/);return null==n?"":n[1]}function U(t,n,r,e){function u(t,n){return D(t,n,r.slice(),e.slice())}var i=B(t);return!F(function(t,n){return!F(u,n,t)},B(n),i)}function D(t,n,r,e){if(En(t,n))return!0;var u=mn(t);if(u!==mn(n))return!1;if(null==t||null==n)return!1;if("function"==typeof t["fantasy-land/equals"]||"function"==typeof n["fantasy-land/equals"])return"function"==typeof t["fantasy-land/equals"]&&t["fantasy-land/equals"](n)&&"function"==typeof n["fantasy-land/equals"]&&n["fantasy-land/equals"](t);if("function"==typeof t.equals||"function"==typeof n.equals)return"function"==typeof t.equals&&t.equals(n)&&"function"==typeof n.equals&&n.equals(t);switch(u){case"Arguments":case"Array":case"Object":if("function"==typeof t.constructor&&"Promise"===R(t.constructor))return t===n;break;case"Boolean":case"Number":case"String":if(typeof t!=typeof n||!En(t.valueOf(),n.valueOf()))return!1;break;case"Date":if(!En(t.valueOf(),n.valueOf()))return!1;break;case"Error":return t.name===n.name&&t.message===n.message;case"RegExp":if(t.source!==n.source||t.global!==n.global||t.ignoreCase!==n.ignoreCase||t.multiline!==n.multiline||t.sticky!==n.sticky||t.unicode!==n.unicode)return!1}for(var i=r.length-1;i>=0;){if(r[i]===t)return e[i]===n;i-=1}switch(u){case"Map":return t.size===n.size&&U(t.entries(),n.entries(),r.concat([t]),e.concat([n]));case"Set":return t.size===n.size&&U(t.values(),n.values(),r.concat([t]),e.concat([n]));case"Arguments":case"Array":case"Object":case"Boolean":case"Number":case"String":case"Date":case"Error":case"RegExp":case"Int8Array":case"Uint8Array":case"Uint8ClampedArray":case"Int16Array":case"Uint16Array":case"Int32Array":case"Uint32Array":case"Float32Array":case"Float64Array":case"ArrayBuffer":break;default:return!1}var o=Ft(t);if(o.length!==Ft(n).length)return!1;var c=r.concat([t]),a=e.concat([n]);for(i=o.length-1;i>=0;){var s=o[i];if(!w(s,n)||!D(n[s],t[s],c,a))return!1;i-=1}return!0}function z(t,n,r){var e,u;if("function"==typeof t.indexOf)switch(typeof n){case"number":if(0===n){for(e=1/n;t.length>r;){if(0===(u=t[r])&&1/u===e)return r;r+=1}return-1}if(n!==n){for(;t.length>r;){if("number"==typeof(u=t[r])&&u!==u)return r;r+=1}return-1}return t.indexOf(n,r);case"string":case"boolean":case"function":case"undefined":return t.indexOf(n,r);case"object":if(null===n)return t.indexOf(n,r)}for(;t.length>r;){if(_n(t[r],n))return r;r+=1}return-1}function M(t,n){return z(n,t,0)>=0}function L(t){return'"'+t.replace(/\\/g,"\\\\").replace(/[\b]/g,"\\b").replace(/\f/g,"\\f").replace(/\n/g,"\\n").replace(/\r/g,"\\r").replace(/\t/g,"\\t").replace(/\v/g,"\\v").replace(/\0/g,"\\0").replace(/"/g,'\\"')+'"'}function K(t){return function(){return!t.apply(this,arguments)}}function V(t,n){for(var r=0,e=n.length,u=[];e>r;)t(n[r])&&(u[u.length]=n[r]),r+=1;return u}function $(t){return"[object Object]"===Object.prototype.toString.call(t)}function H(t,n){this.xf=n,this.f=t}function J(t,n){var r=function(r){var e=n.concat([t]);return M(r,e)?"<Circular>":J(r,e)},e=function(t,n){return p(function(n){return L(n)+": "+r(t[n])},n.slice().sort())};switch(Object.prototype.toString.call(t)){case"[object Arguments]":return"(function() { return arguments; }("+p(r,t).join(", ")+"))";case"[object Array]":return"["+p(r,t).concat(e(t,In(function(t){return/^\d+$/.test(t)},Ft(t)))).join(", ")+"]";case"[object Boolean]":return"object"==typeof t?"new Boolean("+r(t.valueOf())+")":""+t;case"[object Date]":return"new Date("+(isNaN(t.valueOf())?r(NaN):L(kn(t)))+")";case"[object Null]":return"null";case"[object Number]":return"object"==typeof t?"new Number("+r(t.valueOf())+")":1/t==-1/0?"-0":t.toString(10);case"[object String]":return"object"==typeof t?"new String("+r(t.valueOf())+")":L(t);case"[object Undefined]":return"undefined";default:if("function"==typeof t.toString){var u=""+t;if("[object Object]"!==u)return u}return"{"+e(t,Ft(t)).join(", ")+"}"}}function X(t,n,r,e){this.valueFn=t,this.valueAcc=n,this.keyFn=r,this.xf=e,this.inputs={}}function Y(t,n){this.xf=n,this.n=t}function Z(t,n){this.xf=n,this.n=t,this.i=0}function G(t,n){this.xf=n,this.pos=0,this.full=!1,this.acc=Array(t)}function Q(t,n){this.f=t,this.retained=[],this.xf=n}function tt(t,n){this.xf=n,this.pred=t,this.lastValue=void 0,this.seenFirstValue=!1}function nt(t,n){this.xf=n,this.f=t}function rt(t,n){this.xf=n,this.f=t,this.found=!1}function et(t,n){this.xf=n,this.f=t,this.idx=-1,this.found=!1}function ut(t,n){this.xf=n,this.f=t}function it(t,n){this.xf=n,this.f=t,this.idx=-1,this.lastIdx=-1}function ot(t){return t}function ct(){this._nativeSet="function"==typeof Set?new Set:null,this._items={}}function at(t,n,r){var e,u=typeof t;switch(u){case"string":case"number":return 0===t&&1/t==-1/0?!!r._items["-0"]||(n&&(r._items["-0"]=!0),!1):null!==r._nativeSet?n?(e=r._nativeSet.size,r._nativeSet.add(t),r._nativeSet.size===e):r._nativeSet.has(t):u in r._items?t in r._items[u]||(n&&(r._items[u][t]=!0),!1):(n&&(r._items[u]={},r._items[u][t]=!0),!1);case"boolean":if(u in r._items){var i=t?1:0;return!!r._items[u][i]||(n&&(r._items[u][i]=!0),!1)}return n&&(r._items[u]=t?[!1,!0]:[!0,!1]),!1;case"function":return null!==r._nativeSet?n?(e=r._nativeSet.size,r._nativeSet.add(t),r._nativeSet.size===e):r._nativeSet.has(t):u in r._items?!!M(t,r._items[u])||(n&&r._items[u].push(t),!1):(n&&(r._items[u]=[t]),!1);case"undefined":return!!r._items[u]||(n&&(r._items[u]=!0),!1);case"object":if(null===t)return!!r._items.null||(n&&(r._items.null=!0),!1);default:return(u=Object.prototype.toString.call(t))in r._items?!!M(t,r._items[u])||(n&&r._items[u].push(t),!1):(n&&(r._items[u]=[t]),!1)}}function st(t){if(a(t))return t;if(_t(t))return $r;if("string"==typeof t)return Hr;if("object"==typeof t)return Jr;throw Error("Cannot create transformer for "+t)}function ft(t){return"[object Number]"===Object.prototype.toString.call(t)}function lt(t){return e(function(n,r){return i(Math.max(0,n.length-r.length),function(){return n.apply(this,t(r,arguments))})})}function pt(t,n){this.xf=n,this.f=t}function ht(t,n){this.xf=n,this.f=t}function yt(t){return"[object RegExp]"===Object.prototype.toString.call(t)}var dt=r(function(t){return function(){return t}}),gt=dt(!1),vt=dt(!0),mt={"@@functional/placeholder":!0},bt=e(function(t,n){return+t+ +n}),xt=e(function(t,n){return 1===t?r(n):i(t,o(t,[],n))}),wt=r(function(t){return xt(t.length,function(){var n=0,r=arguments[0],e=arguments[arguments.length-1],i=Array.prototype.slice.call(arguments,0);return i[0]=function(){var t=r.apply(this,u(arguments,[n,e]));return n+=1,t},t.apply(this,i)})}),jt=c(function(t,n,r){if(n>=r.length||-r.length>n)return r;var e=(0>n?r.length:0)+n,i=u(r);return i[e]=t(r[e]),i}),At=Array.isArray||function(t){return null!=t&&t.length>=0&&"[object Array]"===Object.prototype.toString.call(t)},Ot={init:function(){return this.xf["@@transducer/init"]()},result:function(t){return this.xf["@@transducer/result"](t)}};l.prototype["@@transducer/init"]=Ot.init,l.prototype["@@transducer/result"]=function(t){return this.all&&(t=this.xf["@@transducer/step"](t,!0)),this.xf["@@transducer/result"](t)},l.prototype["@@transducer/step"]=function(t,n){return this.f(n)||(this.all=!1,t=f(this.xf["@@transducer/step"](t,!1))),t};var St=e(s(["all"],e(function(t,n){return new l(t,n)}),function(t,n){for(var r=0;n.length>r;){if(!t(n[r]))return!1;r+=1}return!0})),Et=e(function(t,n){return n>t?n:t}),_t=r(function(t){return!!At(t)||!!t&&("object"==typeof t&&(!h(t)&&(1===t.nodeType?!!t.length:0===t.length||t.length>0&&(t.hasOwnProperty(0)&&t.hasOwnProperty(t.length-1)))))});y.prototype["@@transducer/init"]=function(){throw Error("init not implemented on XWrap")},y.prototype["@@transducer/result"]=function(t){return t},y.prototype["@@transducer/step"]=function(t,n){return this.f(t,n)};var qt=e(function(t,n){return i(t.length,function(){return t.apply(n,arguments)})}),kt="undefined"!=typeof Symbol?Symbol.iterator:"@@iterator";x.prototype["@@transducer/init"]=Ot.init,x.prototype["@@transducer/result"]=Ot.result,x.prototype["@@transducer/step"]=function(t,n){return this.xf["@@transducer/step"](t,this.f(n))};var Nt=e(function(t,n){return new x(t,n)}),It=Object.prototype.toString,Wt=function(){return"[object Arguments]"===It.call(arguments)?function(t){return"[object Arguments]"===It.call(t)}:function(t){return w("callee",t)}},Pt=!{toString:null}.propertyIsEnumerable("toString"),Ct=["constructor","valueOf","isPrototypeOf","toString","propertyIsEnumerable","hasOwnProperty","toLocaleString"],Tt=function(){return arguments.propertyIsEnumerable("length")}(),Bt=function(t,n){for(var r=0;t.length>r;){if(t[r]===n)return!0;r+=1}return!1},Ft=r("function"!=typeof Object.keys||Tt?function(t){if(Object(t)!==t)return[];var n,r,e=[],u=Tt&&Wt(t);for(n in t)!w(n,t)||u&&"length"===n||(e[e.length]=n);if(Pt)for(r=6;r>=0;)w(n=Ct[r],t)&&!Bt(e,n)&&(e[e.length]=n),r-=1;return e}:function(t){return Object(t)!==t?[]:Object.keys(t)}),Rt=e(s(["fantasy-land/map","map"],Nt,function(t,n){switch(Object.prototype.toString.call(n)){case"[object Function]":return xt(n.length,function(){return t.call(this,n.apply(this,arguments))});case"[object Object]":return b(function(r,e){return r[e]=t(n[e]),r},{},Ft(n));default:return p(t,n)}})),Ut=e(function(t,n){for(var r=n,e=0;t.length>e;){if(null==r)return;r=r[t[e]],e+=1}return r}),Dt=e(function(t,n){return Ut([t],n)}),zt=e(function(t,n){return Rt(Dt(t),n)}),Mt=c(b),Lt=r(function(t){return xt(Mt(Et,0,zt("length",t)),function(){for(var n=0,r=t.length;r>n;){if(!t[n].apply(this,arguments))return!1;n+=1}return!0})}),Kt=e(function(t,n){return t&&n});j.prototype["@@transducer/init"]=Ot.init,j.prototype["@@transducer/result"]=function(t){return this.any||(t=this.xf["@@transducer/step"](t,!1)),this.xf["@@transducer/result"](t)},j.prototype["@@transducer/step"]=function(t,n){return this.f(n)&&(this.any=!0,t=f(this.xf["@@transducer/step"](t,!0))),t};var Vt=e(function(t,n){return new j(t,n)}),$t=e(s(["any"],Vt,function(t,n){for(var r=0;n.length>r;){if(t(n[r]))return!0;r+=1}return!1})),Ht=r(function(t){return xt(Mt(Et,0,zt("length",t)),function(){for(var n=0,r=t.length;r>n;){if(t[n].apply(this,arguments))return!0;n+=1}return!1})}),Jt=e(function(t,n){return"function"==typeof n["fantasy-land/ap"]?n["fantasy-land/ap"](t):"function"==typeof t.ap?t.ap(n):"function"==typeof t?function(r){return t(r)(n(r))}:b(function(t,r){return u(t,Rt(r,n))},[],t)});A.prototype["@@transducer/init"]=Ot.init,A.prototype["@@transducer/result"]=function(t){return this.acc=null,this.xf["@@transducer/result"](t)},A.prototype["@@transducer/step"]=function(t,n){return this.store(n),this.full?this.xf["@@transducer/step"](t,this.getCopy()):t},A.prototype.store=function(t){this.acc[this.pos]=t,(this.pos+=1)===this.acc.length&&(this.pos=0,this.full=!0)},A.prototype.getCopy=function(){return u(Array.prototype.slice.call(this.acc,this.pos),Array.prototype.slice.call(this.acc,0,this.pos))};var Xt=e(s([],e(function(t,n){return new A(t,n)}),function(t,n){for(var r=0,e=n.length-(t-1),u=Array(0>e?0:e);e>r;)u[r]=Array.prototype.slice.call(n,r,r+t),r+=1;return u})),Yt=e(function(t,n){return u(n,[t])}),Zt=e(function(t,n){return t.apply(this,n)}),Gt=r(function(t){for(var n=Ft(t),r=n.length,e=[],u=0;r>u;)e[u]=t[n[u]],u+=1;return e}),Qt=r(function t(n){return n=Rt(function(n){return"function"==typeof n?n:t(n)},n),xt(Mt(Et,0,zt("length",Gt(n))),function(){var t=arguments;return Rt(function(n){return Zt(n,t)},n)})}),tn=e(function(t,n){return n(t)}),nn=c(function(t,n,r){var e=t(n),u=t(r);return u>e?-1:e>u?1:0}),rn=c(function(t,n,r){var e={};for(var u in r)e[u]=r[u];return e[t]=n,e}),en=Number.isInteger||function(t){return t<<0===t},un=r(function(t){return null==t}),on=c(function t(n,r,e){if(0===n.length)return r;var u=n[0];if(n.length>1){var i=!un(e)&&w(u,e)?e[u]:en(n[1])?[]:{};r=t(Array.prototype.slice.call(n,1),r,i)}if(en(u)&&At(e)){var o=[].concat(e);return o[u]=r,o}return rn(u,r,e)}),cn=e(function(t,n){switch(t){case 0:return function(){return n.call(this)};case 1:return function(t){return n.call(this,t)};case 2:return function(t,r){return n.call(this,t,r)};case 3:return function(t,r,e){return n.call(this,t,r,e)};case 4:return function(t,r,e,u){return n.call(this,t,r,e,u)};case 5:return function(t,r,e,u,i){return n.call(this,t,r,e,u,i)};case 6:return function(t,r,e,u,i,o){return n.call(this,t,r,e,u,i,o)};case 7:return function(t,r,e,u,i,o,c){return n.call(this,t,r,e,u,i,o,c)};case 8:return function(t,r,e,u,i,o,c,a){return n.call(this,t,r,e,u,i,o,c,a)};case 9:return function(t,r,e,u,i,o,c,a,s){return n.call(this,t,r,e,u,i,o,c,a,s)};case 10:return function(t,r,e,u,i,o,c,a,s,f){return n.call(this,t,r,e,u,i,o,c,a,s,f)};default:throw Error("First argument to nAry must be a non-negative integer no greater than ten")}}),an=r(function(t){return cn(2,t)}),sn=e(function(t,n){var r=xt(t,n);return xt(t,function(){return b(Jt,Rt(r,arguments[0]),Array.prototype.slice.call(arguments,1))})}),fn=r(function(t){return sn(t.length,t)}),ln=e(function(t,n){return O(t)?function(){return t.apply(this,arguments)&&n.apply(this,arguments)}:fn(Kt)(t,n)}),pn=r(function(t){return xt(t.length,t)}),hn=pn(function(t){return t.apply(this,Array.prototype.slice.call(arguments,1))}),yn=function(t){return{"@@transducer/init":Ot.init,"@@transducer/result":function(n){return t["@@transducer/result"](n)},"@@transducer/step":function(n,r){var e=t["@@transducer/step"](n,r);return e["@@transducer/reduced"]?E(e):e}}},dn=function(t){var n=yn(t);return{"@@transducer/init":Ot.init,"@@transducer/result":function(t){return n["@@transducer/result"](t)},"@@transducer/step":function(t,r){return _t(r)?b(n,t,r):b(n,t,[r])}}},gn=e(s(["fantasy-land/chain","chain"],e(function(t,n){return Rt(t,dn(n))}),function(t,n){return"function"==typeof n?function(r){return t(n(r))(r)}:S(!1)(Rt(t,n))})),vn=c(function(t,n,r){if(t>n)throw Error("min must not be greater than max in clamp(min, max, value)");return t>r?t:r>n?n:r}),mn=r(function(t){return null===t?"Null":void 0===t?"Undefined":Object.prototype.toString.call(t).slice(8,-1)}),bn=r(function(t){return null!=t&&"function"==typeof t.clone?t.clone():q(t,[],[],!0)}),xn=r(function(t){return function(n,r){return t(n,r)?-1:t(r,n)?1:0}}),wn=r(function(t){return!t}),jn=fn(wn),An=c(N("slice",function(t,n,r){return Array.prototype.slice.call(r,t,n)})),On=r(N("tail",An(1,1/0))),Sn=r(function(t){return h(t)?t.split("").reverse().join(""):Array.prototype.slice.call(t,0).reverse()}),En=e(function(t,n){return t===n?0!==t||1/t==1/n:t!==t&&n!==n}),_n=e(function(t,n){return D(t,n,[],[])}),qn=function(t){return(10>t?"0":"")+t},kn="function"==typeof Date.prototype.toISOString?function(t){return t.toISOString()}:function(t){return t.getUTCFullYear()+"-"+qn(t.getUTCMonth()+1)+"-"+qn(t.getUTCDate())+"T"+qn(t.getUTCHours())+":"+qn(t.getUTCMinutes())+":"+qn(t.getUTCSeconds())+"."+(t.getUTCMilliseconds()/1e3).toFixed(3).slice(2,5)+"Z"};H.prototype["@@transducer/init"]=Ot.init,H.prototype["@@transducer/result"]=Ot.result,H.prototype["@@transducer/step"]=function(t,n){return this.f(n)?this.xf["@@transducer/step"](t,n):t};var Nn=e(s(["filter"],e(function(t,n){return new H(t,n)}),function(t,n){return $(n)?b(function(r,e){return t(n[e])&&(r[e]=n[e]),r},{},Ft(n)):V(t,n)})),In=e(function(t,n){return Nn(K(t),n)}),Wn=r(function(t){return J(t,[])}),Pn=e(function(t,n){if(At(t)){if(At(n))return t.concat(n);throw new TypeError(Wn(n)+" is not an array")}if(h(t)){if(h(n))return t+n;throw new TypeError(Wn(n)+" is not a string")}if(null!=t&&O(t["fantasy-land/concat"]))return t["fantasy-land/concat"](n);if(null!=t&&O(t.concat))return t.concat(n);throw new TypeError(Wn(t)+' does not have a method named "concat" or "fantasy-land/concat"')}),Cn=r(function(t){return i(Mt(Et,0,Rt(function(t){return t[0].length},t)),function(){for(var n=0;t.length>n;){if(t[n][0].apply(this,arguments))return t[n][1].apply(this,arguments);n+=1}})}),Tn=e(function(t,n){if(t>10)throw Error("Constructor with greater than ten arguments");return 0===t?function(){return new n}:pn(cn(t,function(t,r,e,u,i,o,c,a,s,f){switch(arguments.length){case 1:return new n(t);case 2:return new n(t,r);case 3:return new n(t,r,e);case 4:return new n(t,r,e,u);case 5:return new n(t,r,e,u,i);case 6:return new n(t,r,e,u,i,o);case 7:return new n(t,r,e,u,i,o,c);case 8:return new n(t,r,e,u,i,o,c,a);case 9:return new n(t,r,e,u,i,o,c,a,s);case 10:return new n(t,r,e,u,i,o,c,a,s,f)}}))}),Bn=r(function(t){return Tn(t.length,t)}),Fn=e(M),Rn=e(function(t,n){return xt(Mt(Et,0,zt("length",n)),function(){var r=arguments,e=this;return t.apply(e,p(function(t){return t.apply(e,r)},n))})});X.prototype["@@transducer/init"]=Ot.init,X.prototype["@@transducer/result"]=function(t){var n;for(n in this.inputs)if(w(n,this.inputs)&&(t=this.xf["@@transducer/step"](t,this.inputs[n]))["@@transducer/reduced"]){t=t["@@transducer/value"];break}return this.inputs=null,this.xf["@@transducer/result"](t)},X.prototype["@@transducer/step"]=function(t,n){var r=this.keyFn(n);return this.inputs[r]=this.inputs[r]||[r,this.valueAcc],this.inputs[r][1]=this.valueFn(this.inputs[r][1],n),t};var Un=o(4,[],s([],o(4,[],function(t,n,r,e){return new X(t,n,r,e)}),function(t,n,r,e){return b(function(e,u){var i=r(u);return e[i]=t(w(i,e)?e[i]:n,u),e},{},e)})),Dn=Un(function(t,n){return t+1},0),zn=bt(-1),Mn=e(function(t,n){return null==n||n!==n?t:n}),Ln=c(function(t,n,r){var e=t(n),u=t(r);return e>u?-1:u>e?1:0}),Kn=e(function(t,n){for(var r=[],e=0,u=t.length;u>e;)M(t[e],n)||M(t[e],r)||(r[r.length]=t[e]),e+=1;return r}),Vn=c(function(t,n,r){for(var e=[],u=0,i=n.length;i>u;)F(t,n[u],r)||F(t,n[u],e)||e.push(n[u]),u+=1;return e}),$n=e(function(t,n){var r={};for(var e in n)r[e]=n[e];return delete r[t],r}),Hn=c(function(t,n,r){var e=Array.prototype.slice.call(r,0);return e.splice(t,n),e}),Jn=c(function(t,n,r){return jt(dt(n),t,r)}),Xn=e(function t(n,r){switch(n.length){case 0:return r;case 1:return en(n[0])?Hn(n[0],1,r):$n(n[0],r);default:var e=n[0],u=Array.prototype.slice.call(n,1);return null==r[e]?r:en(n[0])?Jn(e,t(u,r[e]),r):rn(e,t(u,r[e]),r)}}),Yn=e(function(t,n){return t/n});Y.prototype["@@transducer/init"]=Ot.init,Y.prototype["@@transducer/result"]=Ot.result,Y.prototype["@@transducer/step"]=function(t,n){return this.n>0?(this.n-=1,t):this.xf["@@transducer/step"](t,n)};var Zn=e(s(["drop"],e(function(t,n){return new Y(t,n)}),function(t,n){return An(Math.max(0,t),1/0,n)}));Z.prototype["@@transducer/init"]=Ot.init,Z.prototype["@@transducer/result"]=Ot.result,Z.prototype["@@transducer/step"]=function(t,n){this.i+=1;var r=0===this.n?t:this.xf["@@transducer/step"](t,n);return 0>this.n||this.n>this.i?r:f(r)};var Gn=e(s(["take"],e(function(t,n){return new Z(t,n)}),function(t,n){return An(0,0>t?1/0:t,n)}));G.prototype["@@transducer/init"]=Ot.init,G.prototype["@@transducer/result"]=function(t){return this.acc=null,this.xf["@@transducer/result"](t)},G.prototype["@@transducer/step"]=function(t,n){return this.full&&(t=this.xf["@@transducer/step"](t,this.acc[this.pos])),this.store(n),t},G.prototype.store=function(t){this.acc[this.pos]=t,(this.pos+=1)===this.acc.length&&(this.pos=0,this.full=!0)};var Qn=e(s([],e(function(t,n){return new G(t,n)}),function(t,n){return Gn(n.length>t?n.length-t:0,n)}));Q.prototype["@@transducer/init"]=Ot.init,Q.prototype["@@transducer/result"]=function(t){return this.retained=null,this.xf["@@transducer/result"](t)},Q.prototype["@@transducer/step"]=function(t,n){return this.f(n)?this.retain(t,n):this.flush(t,n)},Q.prototype.flush=function(t,n){return t=b(this.xf["@@transducer/step"],t,this.retained),this.retained=[],this.xf["@@transducer/step"](t,n)},Q.prototype.retain=function(t,n){return this.retained.push(n),t};var tr=e(s([],e(function(t,n){return new Q(t,n)}),function(t,n){for(var r=n.length-1;r>=0&&t(n[r]);)r-=1;return An(0,r+1,n)}));tt.prototype["@@transducer/init"]=Ot.init,tt.prototype["@@transducer/result"]=Ot.result,tt.prototype["@@transducer/step"]=function(t,n){var r=!1;return this.seenFirstValue?this.pred(this.lastValue,n)&&(r=!0):this.seenFirstValue=!0,this.lastValue=n,r?t:this.xf["@@transducer/step"](t,n)};var nr=e(function(t,n){return new tt(t,n)}),rr=e(function(t,n){var r=0>t?n.length+t:t;return h(n)?n.charAt(r):n[r]}),er=rr(-1),ur=e(s([],nr,function(t,n){var r=[],e=1,u=n.length;if(0!==u)for(r[0]=n[0];u>e;)t(er(r),n[e])||(r[r.length]=n[e]),e+=1;return r})),ir=r(s([],nr(_n),ur(_n)));nt.prototype["@@transducer/init"]=Ot.init,nt.prototype["@@transducer/result"]=Ot.result,nt.prototype["@@transducer/step"]=function(t,n){if(this.f){if(this.f(n))return t;this.f=null}return this.xf["@@transducer/step"](t,n)};var or=e(s(["dropWhile"],e(function(t,n){return new nt(t,n)}),function(t,n){for(var r=0,e=n.length;e>r&&t(n[r]);)r+=1;return An(r,1/0,n)})),cr=e(function(t,n){return t||n}),ar=e(function(t,n){return O(t)?function(){return t.apply(this,arguments)||n.apply(this,arguments)}:fn(cr)(t,n)}),sr=r(function(t){return null!=t&&"function"==typeof t["fantasy-land/empty"]?t["fantasy-land/empty"]():null!=t&&null!=t.constructor&&"function"==typeof t.constructor["fantasy-land/empty"]?t.constructor["fantasy-land/empty"]():null!=t&&"function"==typeof t.empty?t.empty():null!=t&&null!=t.constructor&&"function"==typeof t.constructor.empty?t.constructor.empty():At(t)?[]:h(t)?"":$(t)?{}:Wt(t)?function(){return arguments}():void 0}),fr=e(function(t,n){return Zn(0>t?0:n.length-t,n)}),lr=e(function(t,n){return _n(fr(t.length,n),t)}),pr=c(function(t,n,r){return _n(t(n),t(r))}),hr=c(function(t,n,r){return _n(n[t],r[t])}),yr=e(function t(n,r){var e,u,i,o={};for(u in r)i=typeof(e=n[u]),o[u]="function"===i?e(r[u]):e&&"object"===i?t(e,r[u]):r[u];return o});rt.prototype["@@transducer/init"]=Ot.init,rt.prototype["@@transducer/result"]=function(t){return this.found||(t=this.xf["@@transducer/step"](t,void 0)),this.xf["@@transducer/result"](t)},rt.prototype["@@transducer/step"]=function(t,n){return this.f(n)&&(this.found=!0,t=f(this.xf["@@transducer/step"](t,n))),t};var dr=e(s(["find"],e(function(t,n){return new rt(t,n)}),function(t,n){for(var r=0,e=n.length;e>r;){if(t(n[r]))return n[r];r+=1}}));et.prototype["@@transducer/init"]=Ot.init,et.prototype["@@transducer/result"]=function(t){return this.found||(t=this.xf["@@transducer/step"](t,-1)),this.xf["@@transducer/result"](t)},et.prototype["@@transducer/step"]=function(t,n){return this.idx+=1,this.f(n)&&(this.found=!0,t=f(this.xf["@@transducer/step"](t,this.idx))),t};var gr=e(s([],e(function(t,n){return new et(t,n)}),function(t,n){for(var r=0,e=n.length;e>r;){if(t(n[r]))return r;r+=1}return-1}));ut.prototype["@@transducer/init"]=Ot.init,ut.prototype["@@transducer/result"]=function(t){return this.xf["@@transducer/result"](this.xf["@@transducer/step"](t,this.last))},ut.prototype["@@transducer/step"]=function(t,n){return this.f(n)&&(this.last=n),t};var vr=e(s([],e(function(t,n){return new ut(t,n)}),function(t,n){for(var r=n.length-1;r>=0;){if(t(n[r]))return n[r];r-=1}}));it.prototype["@@transducer/init"]=Ot.init,it.prototype["@@transducer/result"]=function(t){return this.xf["@@transducer/result"](this.xf["@@transducer/step"](t,this.lastIdx))},it.prototype["@@transducer/step"]=function(t,n){return this.idx+=1,this.f(n)&&(this.lastIdx=this.idx),t};var mr=e(s([],e(function(t,n){return new it(t,n)}),function(t,n){for(var r=n.length-1;r>=0;){if(t(n[r]))return r;r-=1}return-1})),br=r(S(!0)),xr=r(function(t){return xt(t.length,function(n,r){var e=Array.prototype.slice.call(arguments,0);return e[0]=r,e[1]=n,t.apply(this,e)})}),wr=e(N("forEach",function(t,n){for(var r=n.length,e=0;r>e;)t(n[e]),e+=1;return n})),jr=e(function(t,n){for(var r=Ft(n),e=0;r.length>e;){var u=r[e];t(n[u],u,n),e+=1}return n}),Ar=r(function(t){for(var n={},r=0;t.length>r;)n[t[r][0]]=t[r][1],r+=1;return n}),Or=e(N("groupBy",Un(function(t,n){return null==t&&(t=[]),t.push(n),t},null))),Sr=e(function(t,n){for(var r=[],e=0,u=n.length;u>e;){for(var i=e+1;u>i&&t(n[i-1],n[i]);)i+=1;r.push(n.slice(e,i)),e=i}return r}),Er=e(function(t,n){return t>n}),_r=e(function(t,n){return t>=n}),qr=e(w),kr=e(function(t,n){return t in n}),Nr=rr(0),Ir=r(ot),Wr=c(function(t,n,r){return xt(Math.max(t.length,n.length,r.length),function(){return t.apply(this,arguments)?n.apply(this,arguments):r.apply(this,arguments)})}),Pr=bt(1),Cr=Un(function(t,n){return n},null),Tr=e(function(t,n){return"function"!=typeof n.indexOf||At(n)?z(n,t,0):n.indexOf(t)}),Br=An(0,-1),Fr=c(function(t,n,r){return V(function(n){return F(t,n,r)},n)}),Rr=c(function(t,n,r){t=r.length>t&&t>=0?t:r.length;var e=Array.prototype.slice.call(r,0);return e.splice(t,0,n),e}),Ur=c(function(t,n,r){return t=r.length>t&&t>=0?t:r.length,[].concat(Array.prototype.slice.call(r,0,t),n,Array.prototype.slice.call(r,t))});ct.prototype.add=function(t){return!at(t,!0,this)},ct.prototype.has=function(t){return at(t,!1,this)};var Dr=e(function(t,n){for(var r,e,u=new ct,i=[],o=0;n.length>o;)r=t(e=n[o]),u.add(r)&&i.push(e),o+=1;return i}),zr=Dr(Ir),Mr=e(function(t,n){var r,e;return t.length>n.length?(r=t,e=n):(r=n,e=t),zr(V(xr(M)(r),e))}),Lr=e(N("intersperse",function(t,n){for(var r=[],e=0,u=n.length;u>e;)e===u-1?r.push(n[e]):r.push(n[e],t),e+=1;return r})),Kr="function"==typeof Object.assign?Object.assign:function(t){if(null==t)throw new TypeError("Cannot convert undefined or null to object");for(var n=Object(t),r=1,e=arguments.length;e>r;){var u=arguments[r];if(null!=u)for(var i in u)w(i,u)&&(n[i]=u[i]);r+=1}return n},Vr=e(function(t,n){var r={};return r[t]=n,r}),$r={"@@transducer/init":Array,"@@transducer/step":function(t,n){return t.push(n),t},"@@transducer/result":ot},Hr={"@@transducer/init":String,"@@transducer/step":function(t,n){return t+n},"@@transducer/result":ot},Jr={"@@transducer/init":Object,"@@transducer/step":function(t,n){return Kr(t,_t(n)?Vr(n[0],n[1]):n)},"@@transducer/result":ot},Xr=c(function(t,n,r){return a(t)?b(n(t),t["@@transducer/init"](),r):b(n(st(t)),q(t,[],[],!1),r)}),Yr=r(function(t){for(var n=Ft(t),r=n.length,e=0,u={};r>e;){var i=n[e],o=t[i],c=w(o,u)?u[o]:u[o]=[];c[c.length]=i,e+=1}return u}),Zr=r(function(t){for(var n=Ft(t),r=n.length,e=0,u={};r>e;){var i=n[e];u[t[i]]=i,e+=1}return u}),Gr=e(function(t,n){return xt(t+1,function(){var r=arguments[t];if(null!=r&&O(r[n]))return r[n].apply(r,Array.prototype.slice.call(arguments,0,t));throw new TypeError(Wn(r)+' does not have a method named "'+n+'"')})}),Qr=e(function(t,n){return null!=n&&n.constructor===t||n instanceof t}),te=r(function(t){return null!=t&&_n(t,sr(t))}),ne=Gr(1,"join"),re=r(function(t){return Rn(function(){return Array.prototype.slice.call(arguments,0)},t)}),ee=r(function(t){var n,r=[];for(n in t)r[r.length]=n;return r}),ue=e(function(t,n){if("function"!=typeof n.lastIndexOf||At(n)){for(var r=n.length-1;r>=0;){if(_n(n[r],t))return r;r-=1}return-1}return n.lastIndexOf(t)}),ie=r(function(t){return null!=t&&ft(t.length)?t.length:NaN}),oe=e(function(t,n){return function(r){return function(e){return Rt(function(t){return n(t,e)},r(t(e)))}}}),ce=r(function(t){return oe(rr(t),Jn(t))}),ae=r(function(t){return oe(Ut(t),on(t))}),se=r(function(t){return oe(Dt(t),rn(t))}),fe=e(function(t,n){return n>t}),le=e(function(t,n){return n>=t}),pe=c(function(t,n,r){for(var e=0,u=r.length,i=[],o=[n];u>e;)o=t(o[0],r[e]),i[e]=o[1],e+=1;return[o[0],i]}),he=c(function(t,n,r){for(var e=r.length-1,u=[],i=[n];e>=0;)i=t(r[e],i[0]),u[e]=i[1],e-=1;return[u,i[0]]}),ye=e(function(t,n){return b(function(r,e){return r[e]=t(n[e],e,n),r},{},Ft(n))}),de=e(function(t,n){return n.match(t)||[]}),ge=e(function(t,n){return en(t)?!en(n)||1>n?NaN:(t%n+n)%n:NaN}),ve=c(function(t,n,r){return t(r)>t(n)?r:n}),me=Mt(bt,0),be=r(function(t){return me(t)/t.length}),xe=r(function(t){var n=t.length;if(0===n)return NaN;var r=2-n%2,e=(n-r)/2;return be(Array.prototype.slice.call(t,0).sort(function(t,n){return n>t?-1:t>n?1:0}).slice(e,e+r))}),we=e(function(t,n){var r={};return i(n.length,function(){var e=t.apply(this,arguments);return w(e,r)||(r[e]=n.apply(this,arguments)),r[e]})}),je=we(function(){return Wn(arguments)}),Ae=e(function(t,n){return Kr({},t,n)}),Oe=r(function(t){return Kr.apply(null,[{}].concat(t))}),Se=c(function(t,n,r){var e,u={};for(e in n)w(e,n)&&(u[e]=w(e,r)?t(e,n[e],r[e]):n[e]);for(e in r)w(e,r)&&!w(e,u)&&(u[e]=r[e]);return u}),Ee=c(function t(n,r,e){return Se(function(r,e,u){return $(e)&&$(u)?t(n,e,u):n(r,e,u)},r,e)}),_e=e(function(t,n){return Ee(function(t,n,r){return n},t,n)}),qe=e(function(t,n){return Ee(function(t,n,r){return r},t,n)}),ke=c(function(t,n,r){return Ee(function(n,r,e){return t(r,e)},n,r)}),Ne=c(function(t,n,r){return Se(function(n,r,e){return t(r,e)},n,r)}),Ie=e(function(t,n){return t>n?n:t}),We=c(function(t,n,r){return t(r)<t(n)?r:n}),Pe=e(function(t,n){return t%n}),Ce=e(function(t,n){return t*n}),Te=r(function(t){return-t}),Be=e(K(s(["any"],Vt,$t))),Fe=r(function(t){return xt(0>t?1:t+1,function(){return rr(t,arguments)})}),Re=c(function(t,n,r){return t(n(r))}),Ue=r(function(t){return[t]}),De=e(function(t,n){for(var r={},e={},u=0,i=t.length;i>u;)e[t[u]]=1,u+=1;for(var o in n)e.hasOwnProperty(o)||(r[o]=n[o]);return r}),ze=r(function(t){var n,r=!1;return i(t.length,function(){return r?n:(r=!0,n=t.apply(this,arguments))})}),Me=function(t){return{value:t,map:function(n){return Me(n(t))}}},Le=c(function(t,n,r){return t(function(t){return Me(n(t))})(r).value}),Ke=e(function(t,n){return[t,n]}),Ve=lt(u),$e=lt(xr(u)),He=re([Nn,In]),Je=c(function(t,n,r){return _n(Ut(t,r),n)}),Xe=c(function(t,n,r){return Mn(t,Ut(n,r))}),Ye=c(function(t,n,r){return n.length>0&&t(Ut(n,r))}),Ze=e(function(t,n){for(var r={},e=0;t.length>e;)t[e]in n&&(r[t[e]]=n[t[e]]),e+=1;return r}),Ge=e(function(t,n){for(var r={},e=0,u=t.length;u>e;){var i=t[e];r[i]=n[i],e+=1}return r}),Qe=e(function(t,n){var r={};for(var e in n)t(n[e],e,n)&&(r[e]=n[e]);return r}),tu=e(function(t,n){return u([t],n)}),nu=Mt(Ce,1),ru=e(function(t,n){return xt(n.length,function(){for(var r=[],e=0;n.length>e;)r.push(n[e].call(this,arguments[e])),e+=1;return t.apply(this,r.concat(Array.prototype.slice.call(arguments,n.length)))})}),eu=ru(p,[Ge,Ir]),uu=c(function(t,n,r){return _n(n,r[t])}),iu=c(function(t,n,r){return Qr(t,r[n])}),ou=c(function(t,n,r){return null!=r&&w(n,r)?r[n]:t}),cu=c(function(t,n,r){return t(r[n])}),au=e(function(t,n){for(var r=t.length,e=[],u=0;r>u;)e[u]=n[t[u]],u+=1;return e}),su=e(function(t,n){if(!ft(t)||!ft(n))throw new TypeError("Both arguments to range must be numbers");for(var r=[],e=t;n>e;)r.push(e),e+=1;return r}),fu=c(function(t,n,r){for(var e=r.length-1;e>=0;)n=t(r[e],n),e-=1;return n}),lu=o(4,[],function(t,n,r,e){return b(function(r,e){return t(r,e)?n(r,e):f(r)},r,e)}),pu=r(f),hu=e(function(t,n){var r,e=+n,u=0;if(0>e||isNaN(e))throw new RangeError("n must be a non-negative number");for(r=Array(e);e>u;)r[u]=t(u),u+=1;return r}),yu=e(function(t,n){return hu(dt(t),n)}),du=c(function(t,n,r){return r.replace(t,n)}),gu=c(function(t,n,r){for(var e=0,u=r.length,i=[n];u>e;)n=t(n,r[e]),i[e+1]=n,e+=1;return i}),vu=e(function(t,n){return"function"==typeof n.sequence?n.sequence(t):fu(function(t,n){return Jt(Rt(tu,t),n)},t([]),n)}),mu=c(function(t,n,r){return Le(t,dt(n),r)}),bu=e(function(t,n){return Array.prototype.slice.call(n,0).sort(t)}),xu=e(function(t,n){return Array.prototype.slice.call(n,0).sort(function(n,r){var e=t(n),u=t(r);return u>e?-1:e>u?1:0})}),wu=e(function(t,n){return Array.prototype.slice.call(n,0).sort(function(n,r){for(var e=0,u=0;0===e&&t.length>u;)e=t[u](n,r),u+=1;return e})}),ju=Gr(1,"split"),Au=e(function(t,n){return[An(0,t,n),An(t,ie(n),n)]}),Ou=e(function(t,n){if(0>=t)throw Error("First argument to splitEvery must be a positive integer");for(var r=[],e=0;n.length>e;)r.push(An(e,e+=t,n));return r}),Su=e(function(t,n){for(var r=0,e=n.length,u=[];e>r&&!t(n[r]);)u.push(n[r]),r+=1;return[u,Array.prototype.slice.call(n,r)]}),Eu=e(function(t,n){return _n(Gn(t.length,n),t)}),_u=e(function(t,n){return+t-+n}),qu=e(function(t,n){return Pn(Kn(t,n),Kn(n,t))}),ku=c(function(t,n,r){return Pn(Vn(t,n,r),Vn(t,r,n))}),Nu=e(function(t,n){for(var r=n.length-1;r>=0&&t(n[r]);)r-=1;return An(r+1,1/0,n)});pt.prototype["@@transducer/init"]=Ot.init,pt.prototype["@@transducer/result"]=Ot.result,pt.prototype["@@transducer/step"]=function(t,n){return this.f(n)?this.xf["@@transducer/step"](t,n):f(t)};var Iu=e(s(["takeWhile"],e(function(t,n){return new pt(t,n)}),function(t,n){for(var r=0,e=n.length;e>r&&t(n[r]);)r+=1;return An(0,r,n)}));ht.prototype["@@transducer/init"]=Ot.init,ht.prototype["@@transducer/result"]=Ot.result,ht.prototype["@@transducer/step"]=function(t,n){return this.f(n),this.xf["@@transducer/step"](t,n)};var Wu=e(s([],e(function(t,n){return new ht(t,n)}),function(t,n){return t(n),n})),Pu=e(function(t,n){if(!yt(t))throw new TypeError("‘test’ requires a value of type RegExp as its first argument; received "+Wn(t));return _(t).test(n)}),Cu=Gr(0,"toLowerCase"),Tu=r(function(t){var n=[];for(var r in t)w(r,t)&&(n[n.length]=[r,t[r]]);return n}),Bu=r(function(t){var n=[];for(var r in t)n[n.length]=[r,t[r]];return n}),Fu=Gr(0,"toUpperCase"),Ru=xt(4,function(t,n,r,e){return b(t("function"==typeof n?d(n):n),r,e)}),Uu=r(function(t){for(var n=0,r=[];t.length>n;){for(var e=t[n],u=0;e.length>u;)void 0===r[u]&&(r[u]=[]),r[u].push(e[u]),u+=1;n+=1}return r}),Du=c(function(t,n,r){return"function"==typeof r["fantasy-land/traverse"]?r["fantasy-land/traverse"](n,t):vu(t,Rt(n,r))}),zu="\t\n\v\f\r   ᠎             　\u2028\u2029\ufeff",Mu=r(!("function"==typeof String.prototype.trim)||zu.trim()?function(t){var n=RegExp("^["+zu+"]["+zu+"]*"),r=RegExp("["+zu+"]["+zu+"]*$");return t.replace(n,"").replace(r,"")}:function(t){return t.trim()}),Lu=e(function(t,n){return i(t.length,function(){try{return t.apply(this,arguments)}catch(t){return n.apply(this,u([t],arguments))}})}),Ku=r(function(t){return function(){return t(Array.prototype.slice.call(arguments,0))}}),Vu=r(function(t){return cn(1,t)}),$u=e(function(t,n){return xt(t,function(){for(var r,e=1,u=n,i=0;t>=e&&"function"==typeof u;)r=e===t?arguments.length:i+u.length,u=u.apply(this,Array.prototype.slice.call(arguments,i,r)),e+=1,i=r;return u})}),Hu=e(function(t,n){for(var r=t(n),e=[];r&&r.length;)e[e.length]=r[0],r=t(r[1]);return e}),Ju=e(W(zr,u)),Xu=e(function(t,n){for(var r,e=0,u=n.length,i=[];u>e;)F(t,r=n[e],i)||(i[i.length]=r),e+=1;return i}),Yu=c(function(t,n,r){return Xu(t,u(n,r))}),Zu=c(function(t,n,r){return t(r)?r:n(r)}),Gu=gn(ot),Qu=c(function(t,n,r){for(var e=r;!t(e);)e=n(e);return e}),ti=r(function(t){var n,r=[];for(n in t)r[r.length]=t[n];return r}),ni=function(t){return{value:t,"fantasy-land/map":function(){return this}}},ri=e(function(t,n){return t(ni)(n).value}),ei=c(function(t,n,r){return t(r)?n(r):r}),ui=e(function(t,n){for(var r in t)if(w(r,t)&&!t[r](n[r]))return!1;return!0}),ii=e(function(t,n){return ui(Rt(_n,t),n)}),oi=e(function(t,n){return In(xr(M)(t),n)}),ci=e(function(t,n){for(var r,e=0,u=t.length,i=n.length,o=[];u>e;){for(r=0;i>r;)o[o.length]=[t[e],n[r]],r+=1;e+=1}return o}),ai=e(function(t,n){for(var r=[],e=0,u=Math.min(t.length,n.length);u>e;)r[e]=[t[e],n[e]],e+=1;return r}),si=e(function(t,n){for(var r=0,e=Math.min(t.length,n.length),u={};e>r;)u[t[r]]=n[r],r+=1;return u}),fi=c(function(t,n,r){for(var e=[],u=0,i=Math.min(n.length,r.length);i>u;)e[u]=t(n[u],r[u]),u+=1;return e});t.F=gt,t.T=vt,t.__=mt,t.add=bt,t.addIndex=wt,t.adjust=jt,t.all=St,t.allPass=Lt,t.always=dt,t.and=Kt,t.any=$t,t.anyPass=Ht,t.ap=Jt,t.aperture=Xt,t.append=Yt,t.apply=Zt,t.applySpec=Qt,t.applyTo=tn,t.ascend=nn,t.assoc=rn,t.assocPath=on,t.binary=an,t.bind=qt,t.both=ln,t.call=hn,t.chain=gn,t.clamp=vn,t.clone=bn,t.comparator=xn,t.complement=jn,t.compose=W,t.composeK=P,t.composeP=function(){if(0===arguments.length)throw Error("composeP requires at least one argument");return T.apply(this,Sn(arguments))},t.concat=Pn,t.cond=Cn,t.construct=Bn,t.constructN=Tn,t.contains=Fn,t.converge=Rn,t.countBy=Dn,t.curry=pn,t.curryN=xt,t.dec=zn,t.defaultTo=Mn,t.descend=Ln,t.difference=Kn,t.differenceWith=Vn,t.dissoc=$n,t.dissocPath=Xn,t.divide=Yn,t.drop=Zn,t.dropLast=Qn,t.dropLastWhile=tr,t.dropRepeats=ir,t.dropRepeatsWith=ur,t.dropWhile=or,t.either=ar,t.empty=sr,t.endsWith=lr,t.eqBy=pr,t.eqProps=hr,t.equals=_n,t.evolve=yr,t.filter=Nn,t.find=dr,t.findIndex=gr,t.findLast=vr,t.findLastIndex=mr,t.flatten=br,t.flip=xr,t.forEach=wr,t.forEachObjIndexed=jr,t.fromPairs=Ar,t.groupBy=Or,t.groupWith=Sr,t.gt=Er,t.gte=_r,t.has=qr,t.hasIn=kr,t.head=Nr,t.identical=En,t.identity=Ir,t.ifElse=Wr,t.inc=Pr,t.indexBy=Cr,t.indexOf=Tr,t.init=Br,t.innerJoin=Fr,t.insert=Rr,t.insertAll=Ur,t.intersection=Mr,t.intersperse=Lr,t.into=Xr,t.invert=Yr,t.invertObj=Zr,t.invoker=Gr,t.is=Qr,t.isEmpty=te,t.isNil=un,t.join=ne,t.juxt=re,t.keys=Ft,t.keysIn=ee,t.last=er,t.lastIndexOf=ue,t.length=ie,t.lens=oe,t.lensIndex=ce,t.lensPath=ae,t.lensProp=se,t.lift=fn,t.liftN=sn,t.lt=fe,t.lte=le,t.map=Rt,t.mapAccum=pe,t.mapAccumRight=he,t.mapObjIndexed=ye,t.match=de,t.mathMod=ge,t.max=Et,t.maxBy=ve,t.mean=be,t.median=xe,t.memoize=je,t.memoizeWith=we,t.merge=Ae,t.mergeAll=Oe,t.mergeDeepLeft=_e,t.mergeDeepRight=qe,t.mergeDeepWith=ke,t.mergeDeepWithKey=Ee,t.mergeWith=Ne,t.mergeWithKey=Se,t.min=Ie,t.minBy=We,t.modulo=Pe,t.multiply=Ce,t.nAry=cn,t.negate=Te,t.none=Be,t.not=wn,t.nth=rr,t.nthArg=Fe,t.o=Re,t.objOf=Vr,t.of=Ue,t.omit=De,t.once=ze,t.or=cr,t.over=Le,t.pair=Ke,t.partial=Ve,t.partialRight=$e,t.partition=He,t.path=Ut,t.pathEq=Je,t.pathOr=Xe,t.pathSatisfies=Ye,t.pick=Ze,t.pickAll=Ge,t.pickBy=Qe,t.pipe=I,t.pipeK=function(){if(0===arguments.length)throw Error("pipeK requires at least one argument");return P.apply(this,Sn(arguments))},t.pipeP=T,t.pluck=zt,t.prepend=tu,t.product=nu,t.project=eu,t.prop=Dt,t.propEq=uu,t.propIs=iu,t.propOr=ou,t.propSatisfies=cu,t.props=au,t.range=su,t.reduce=Mt,t.reduceBy=Un,t.reduceRight=fu,t.reduceWhile=lu,t.reduced=pu,t.reject=In,t.remove=Hn,t.repeat=yu,t.replace=du,t.reverse=Sn,t.scan=gu,t.sequence=vu,t.set=mu,t.slice=An,t.sort=bu,t.sortBy=xu,t.sortWith=wu,t.split=ju,t.splitAt=Au,t.splitEvery=Ou,t.splitWhen=Su,t.startsWith=Eu,t.subtract=_u,t.sum=me,t.symmetricDifference=qu,t.symmetricDifferenceWith=ku,t.tail=On,t.take=Gn,t.takeLast=fr,t.takeLastWhile=Nu,t.takeWhile=Iu,t.tap=Wu,t.test=Pu,t.times=hu,t.toLower=Cu,t.toPairs=Tu,t.toPairsIn=Bu,t.toString=Wn,t.toUpper=Fu,t.transduce=Ru,t.transpose=Uu,t.traverse=Du,t.trim=Mu,t.tryCatch=Lu,t.type=mn,t.unapply=Ku,t.unary=Vu,t.uncurryN=$u,t.unfold=Hu,t.union=Ju,t.unionWith=Yu,t.uniq=zr,t.uniqBy=Dr,t.uniqWith=Xu,t.unless=Zu,t.unnest=Gu,t.until=Qu,t.update=Jn,t.useWith=ru,t.values=Gt,t.valuesIn=ti,t.view=ri,t.when=ei,t.where=ui,t.whereEq=ii,t.without=oi,t.xprod=ci,t.zip=ai,t.zipObj=si,t.zipWith=fi,Object.defineProperty(t,"__esModule",{value:!0})});
/**
 * @license Highcharts JS v6.2.0 (2018-10-17)
 *
 * (c) 2009-2016 Torstein Honsi
 *
 * License: www.highcharts.com/license
 */

'use strict';
(function (root, factory) {
	if (typeof module === 'object' && module.exports) {
		module.exports = root.document ?
			factory(root) :
			factory;
	} else if (typeof define === 'function' && define.amd) {
		define(function () {
			return factory(root);
		});
	} else {
		root.Highcharts = factory(root);
	}
}(typeof window !== 'undefined' ? window : this, function (win) {
	var Highcharts = (function () {
		/**
		 * (c) 2010-2018 Torstein Honsi
		 *
		 * License: www.highcharts.com/license
		 */
		/* global win, window */

		// glob is a temporary fix to allow our es-modules to work.
		var glob = typeof win === 'undefined' ? window : win,
		    doc = glob.document,
		    SVG_NS = 'http://www.w3.org/2000/svg',
		    userAgent = (glob.navigator && glob.navigator.userAgent) || '',
		    svg = (
		        doc &&
		        doc.createElementNS &&
		        !!doc.createElementNS(SVG_NS, 'svg').createSVGRect
		    ),
		    isMS = /(edge|msie|trident)/i.test(userAgent) && !glob.opera,
		    isFirefox = userAgent.indexOf('Firefox') !== -1,
		    isChrome = userAgent.indexOf('Chrome') !== -1,
		    hasBidiBug = (
		        isFirefox &&
		        parseInt(userAgent.split('Firefox/')[1], 10) < 4 // issue #38
		    );

		var Highcharts = glob.Highcharts ? glob.Highcharts.error(16, true) : {
		    product: 'Highcharts',
		    version: '6.2.0',
		    deg2rad: Math.PI * 2 / 360,
		    doc: doc,
		    hasBidiBug: hasBidiBug,
		    hasTouch: doc && doc.documentElement.ontouchstart !== undefined,
		    isMS: isMS,
		    isWebKit: userAgent.indexOf('AppleWebKit') !== -1,
		    isFirefox: isFirefox,
		    isChrome: isChrome,
		    isSafari: !isChrome && userAgent.indexOf('Safari') !== -1,
		    isTouchDevice: /(Mobile|Android|Windows Phone)/.test(userAgent),
		    SVG_NS: SVG_NS,
		    chartCount: 0,
		    seriesTypes: {},
		    symbolSizes: {},
		    svg: svg,
		    win: glob,
		    marginNames: ['plotTop', 'marginRight', 'marginBottom', 'plotLeft'],
		    noop: function () {
		        return undefined;
		    },
		    /**
		     * An array containing the current chart objects in the page. A chart's
		     * position in the array is preserved throughout the page's lifetime. When
		     * a chart is destroyed, the array item becomes `undefined`.
		     *
		     * @name Highcharts.charts
		     * @type {Array<Highcharts.Chart>}
		     */
		    charts: []
		};

		return Highcharts;
	}());
	(function (H) {
		/**
		 * (c) 2010-2018 Torstein Honsi
		 *
		 * License: www.highcharts.com/license
		 */

		/**
		 * Reference to the global SVGElement class as a workaround for a name conflict
		 * in the Highcharts namespace.
		 *
		 * @typedef {global.SVGElement} GlobalSVGElement
		 *
		 * @see https://developer.mozilla.org/en-US/docs/Web/API/SVGElement
		 */

		/**
		 * An animation configuration. Animation configurations can also be defined as
		 * booleans, where `false` turns off animation and `true` defaults to a duration
		 * of 500ms.
		 *
		 * @typedef Highcharts.AnimationOptionsObject
		 *
		 * @property {number} duration
		 *           The animation duration in milliseconds.
		 *
		 * @property {string} [easing]
		 *           The name of an easing function as defined on the `Math` object.
		 *
		 * @property {Function} [complete]
		 *           A callback function to exectute when the animation finishes.
		 *
		 * @property {Function} [step]
		 *           A callback function to execute on each step of each attribute or
		 *           CSS property that's being animated. The first argument contains
		 *           information about the animation and progress.
		 */

		/**
		 * A style object with camel case property names to define visual appearance of
		 * a SVG element or HTML element. The properties can be whatever styles are
		 * supported on the given SVG or HTML element.
		 *
		 * @example
		 * {
		 *    fontFamily: 'monospace',
		 *    fontSize: '1.2em'
		 * }
		 *
		 * @typedef Highcharts.CSSObject
		 *
		 * @property {boolean|number|string|undefined} [key:string]
		 *
		 * @property {string} [background]
		 *           Background style for the element.
		 *
		 * @property {Highcharts.ColorString} [backgroundColor]
		 *           Background color of the element.
		 *
		 * @property {string} [border]
		 *           Border style for the element.
		 *
		 * @property {number} [borderRadius]
		 *           Radius of the element border.
		 *
		 * @property {"contrast"|Highcharts.ColorString} [color]
		 *           Color used in the element. The "contrast" option is a Highcharts
		 *           custom property that results in black or white, depending on the
		 *           background of the element.
		 *
		 * @property {string} [cursor]
		 *           Style of the mouse cursor when resting over the element.
		 *
		 * @property {string} [fontFamily]
		 *           Font family of the element text. Multiple values have to be in
		 *           decreasing preference order and separated by comma.
		 *
		 * @property {string} [fontSize]
		 *           Font size of the element text.
		 *
		 * @property {string} [fontWeight]
		 *           Font weight of the element text.
		 *
		 * @property {number} [height]
		 *           Height of the element.
		 *
		 * @property {number} [lineWidth]
		 *           Width of the element border.
		 *
		 * @property {number} [opacity]
		 *           Opacity of the element.
		 *
		 * @property {string} [padding]
		 *           Space around the element content.
		 *
		 * @property {string} [pointerEvents]
		 *           Behaviour of the element when the mouse cursor rests over it.
		 *
		 * @property {string} [position]
		 *           Positioning of the element.
		 *
		 * @property {string} [textAlign]
		 *           Alignment of the element text.
		 *
		 * @property {string} [textOutline]
		 *           Outline style of the element text.
		 *
		 * @property {string} [textDecoration]
		 *           Additional decoration of the element text.
		 *
		 * @property {string} [textOverflow]
		 *           Line break style of the element text. Highcharts SVG elements
		 *           support `ellipsis` when a `width` is set.
		 *
		 * @property {string} [transition]
		 *           Animated transition of selected element properties.
		 *
		 * @property {string} [top]
		 *           Top spacing of the element relative to the parent element.
		 *
		 * @property {string} [whiteSpace]
		 *           Line break style of the element text.
		 *
		 * @property {number} [width]
		 *           Width of the element.
		 */

		/**
		 * Generic dictionary in TypeScript notation.
		 *
		 * @typedef Highcharts.Dictionary<T>
		 *
		 * @property {T} [key:string]
		 */

		/**
		 * An object of key-value pairs for HTML attributes.
		 *
		 * @typedef {Highcharts.Dictionary<boolean|number|string>} Highcharts.HTMLAttributes
		 */

		/**
		 * The iterator callback.
		 *
		 * @callback Highcharts.EachCallbackFunction<T>
		 *
		 * @param {T} item
		 *        The array item.
		 *
		 * @param {number} index
		 *        The item's index in the array.
		 *
		 * @param {Array<T>} arr
		 *        The array that each is being applied to.
		 */

		/**
		 * The function callback to execute when the event is fired. The `this` context
		 * contains the instance, that fired the event.
		 *
		 * @callback Highcharts.EventCallbackFunction
		 *
		 * @param {Highcharts.Dictionary<*>} [eventArguments]
		 *        Event arguments.
		 */

		/**
		 * Formats data as a string. Usually the data is accessible throught the `this`
		 * keyword.
		 *
		 * @callback Highcharts.FormatterCallbackFunction
		 *
		 * @return {string}
		 */

		/**
		 * An HTML DOM element. The type is a reference to the regular SVGElement in the
		 * global scope.
		 *
		 * @typedef {global.HTMLElement} Highcharts.HTMLDOMElement
		 *
		 * @see https://developer.mozilla.org/en-US/docs/Web/API/HTMLElement
		 */

		/**
		 * The iterator callback.
		 *
		 * @callback Highcharts.ObjectEachCallbackFunction
		 *
		 * @param {*} value
		 *        The property value.
		 *
		 * @param {string} key
		 *        The property key.
		 *
		 * @param {*} obj
		 *        The object that objectEach is being applied to.
		 */

		/**
		 * An object containing `left` and `top` properties for the position in the
		 * page.
		 *
		 * @typedef Highcharts.OffsetObject
		 *
		 * @property {number} left
		 *           Left distance to the page border.
		 *
		 * @property {number} top
		 *           Top distance to the page border.
		 */

		/**
		 * An object containing `x` and `y` properties for the position of an element.
		 *
		 * @typedef Highcharts.PositionObject
		 *
		 * @property {number} x
		 *           X position of the element.
		 *
		 * @property {number} y
		 *           Y position of the element.
		 */

		/**
		 * If a number is given, it defines the pixel length. If a percentage string is
		 * given, like for example `'50%'`, the setting defines a length relative to a
		 * base size, for example the size of a container.
		 *
		 * @typedef {number|string} Highcharts.RelativeSize
		 */

		/**
		 * An object of key-value pairs for SVG attributes. Attributes in Highcharts
		 * elements for the most parts correspond to SVG, but some are specific to
		 * Highcharts, like `zIndex`, `rotation`, `rotationOriginX`,
		 * `rotationOriginY`, `translateX`, `translateY`, `scaleX` and `scaleY`. SVG
		 * attributes containing a hyphen are _not_ camel-cased, they should be
		 * quoted to preserve the hyphen.
		 *
		 * @example
		 * {
		 *     'stroke': '#ff0000', // basic
		 *     'stroke-width': 2, // hyphenated
		 *     'rotation': 45 // custom
		 *     'd': ['M', 10, 10, 'L', 30, 30, 'z'] // path definition, note format
		 * }
		 *
		 * @typedef Highcharts.SVGAttributes
		 *
		 * @property {boolean|number|string|Array<any>|undefined} [key:string]
		 *
		 * @property {string|Highcharts.SVGPathArray} [d]
		 *
		 * @property {boolean} [inverted]
		 *
		 * @property {Array<number>} [matrix]
		 *
		 * @property {Highcharts.ColorString} [stroke]
		 *
		 * @property {string} [rotation]
		 *
		 * @property {number} [rotationOriginX]
		 *
		 * @property {number} [rotationOriginY]
		 *
		 * @property {number} [scaleX]
		 *
		 * @property {number} [scaleY]
		 *
		 * @property {number} [translateX]
		 *
		 * @property {number} [translateY]
		 *
		 * @property {number} [zIndex]
		 */

		/**
		 * An SVG DOM element. The type is a reference to the regular SVGElement in the
		 * global scope.
		 *
		 * @typedef {global.GlobalSVGElement} Highcharts.SVGDOMElement
		 *
		 * @see https://developer.mozilla.org/en-US/docs/Web/API/SVGElement
		 */

		/**
		 * Array of path commands, that will go into the `d` attribute of an SVG
		 * element.
		 *
		 * @typedef {Array<number|Highcharts.SVGPathCommand>} Highcharts.SVGPathArray
		 */

		/**
		 * Possible path commands in a SVG path array.
		 *
		 * @typedef {string} Highcharts.SVGPathCommand
		 * @validvalue ["a","c","h","l","m","q","s","t","v","z","A","C","H","L","M","Q","S","T","V","Z"]
		 */



		/**
		 * The Highcharts object is the placeholder for all other members, and various
		 * utility functions. The most important member of the namespace would be the
		 * chart constructor.
		 *
		 * @example
		 * var chart = Highcharts.chart('container', { ... });
		 *
		 * @namespace Highcharts
		 */

		H.timers = [];

		var charts = H.charts,
		    doc = H.doc,
		    win = H.win;

		/**
		 * Provide error messages for debugging, with links to online explanation. This
		 * function can be overridden to provide custom error handling.
		 *
		 * @sample highcharts/chart/highcharts-error/
		 *         Custom error handler
		 *
		 * @function Highcharts.error
		 *
		 * @param {number|string} code
		 *        The error code. See
		 *        [errors.xml]{@link https://github.com/highcharts/highcharts/blob/master/errors/errors.xml}
		 *        for available codes. If it is a string, the error message is printed
		 *        directly in the console.
		 *
		 * @param {boolean} [stop=false]
		 *        Whether to throw an error or just log a warning in the console.
		 */
		H.error = function (code, stop) {
		    var msg = H.isNumber(code) ?
		        'Highcharts error #' + code + ': www.highcharts.com/errors/' + code :
		        code;
		    if (stop) {
		        throw new Error(msg);
		    }
		    // else ...
		    if (win.console) {
		        console.log(msg); // eslint-disable-line no-console
		    }
		};

		/**
		 * An animator object used internally. One instance applies to one property
		 * (attribute or style prop) on one element. Animation is always initiated
		 * through {@link SVGElement#animate}.
		 *
		 * @example
		 * var rect = renderer.rect(0, 0, 10, 10).add();
		 * rect.animate({ width: 100 });
		 *
		 * @private
		 * @class Highcharts.Fx
		 *
		 * @param {Highcharts.HTMLDOMElement|Highcharts.SVGElement} elem
		 *        The element to animate.
		 *
		 * @param {Highcharts.AnimationOptionsObject} options
		 *        Animation options.
		 *
		 * @param {string} prop
		 *        The single attribute or CSS property to animate.
		 */
		H.Fx = function (elem, options, prop) {
		    this.options = options;
		    this.elem = elem;
		    this.prop = prop;
		};
		H.Fx.prototype = {

		    /**
		     * Set the current step of a path definition on SVGElement.
		     *
		     * @function Highcharts.Fx#dSetter
		     */
		    dSetter: function () {
		        var start = this.paths[0],
		            end = this.paths[1],
		            ret = [],
		            now = this.now,
		            i = start.length,
		            startVal;

		        // Land on the final path without adjustment points appended in the ends
		        if (now === 1) {
		            ret = this.toD;

		        } else if (i === end.length && now < 1) {
		            while (i--) {
		                startVal = parseFloat(start[i]);
		                ret[i] =
		                    isNaN(startVal) ? // a letter instruction like M or L
		                            end[i] :
		                            now * (parseFloat(end[i] - startVal)) + startVal;

		            }
		        // If animation is finished or length not matching, land on right value
		        } else {
		            ret = end;
		        }
		        this.elem.attr('d', ret, null, true);
		    },

		    /**
		     * Update the element with the current animation step.
		     *
		     * @function Highcharts.Fx#update
		     */
		    update: function () {
		        var elem = this.elem,
		            prop = this.prop, // if destroyed, it is null
		            now = this.now,
		            step = this.options.step;

		        // Animation setter defined from outside
		        if (this[prop + 'Setter']) {
		            this[prop + 'Setter']();

		        // Other animations on SVGElement
		        } else if (elem.attr) {
		            if (elem.element) {
		                elem.attr(prop, now, null, true);
		            }

		        // HTML styles, raw HTML content like container size
		        } else {
		            elem.style[prop] = now + this.unit;
		        }

		        if (step) {
		            step.call(elem, now, this);
		        }

		    },

		    /**
		     * Run an animation.
		     *
		     * @function Highcharts.Fx#run
		     *
		     * @param {number} from
		     *        The current value, value to start from.
		     *
		     * @param {number} to
		     *        The end value, value to land on.
		     *
		     * @param {string} [unit]
		     *        The property unit, for example `px`.
		     */
		    run: function (from, to, unit) {
		        var self = this,
		            options = self.options,
		            timer = function (gotoEnd) {
		                return timer.stopped ? false : self.step(gotoEnd);
		            },
		            requestAnimationFrame =
		                win.requestAnimationFrame ||
		                function (step) {
		                    setTimeout(step, 13);
		                },
		            step = function () {
		                for (var i = 0; i < H.timers.length; i++) {
		                    if (!H.timers[i]()) {
		                        H.timers.splice(i--, 1);
		                    }
		                }

		                if (H.timers.length) {
		                    requestAnimationFrame(step);
		                }
		            };

		        if (from === to && !this.elem['forceAnimate:' + this.prop]) {
		            delete options.curAnim[this.prop];
		            if (options.complete && H.keys(options.curAnim).length === 0) {
		                options.complete.call(this.elem);
		            }
		        } else { // #7166
		            this.startTime = +new Date();
		            this.start = from;
		            this.end = to;
		            this.unit = unit;
		            this.now = this.start;
		            this.pos = 0;

		            timer.elem = this.elem;
		            timer.prop = this.prop;

		            if (timer() && H.timers.push(timer) === 1) {
		                requestAnimationFrame(step);
		            }
		        }
		    },

		    /**
		     * Run a single step in the animation.
		     *
		     * @function Highcharts.Fx#step
		     *
		     * @param {boolean} [gotoEnd]
		     *        Whether to go to the endpoint of the animation after abort.
		     *
		     * @return {boolean}
		     *         Returns `true` if animation continues.
		     */
		    step: function (gotoEnd) {
		        var t = +new Date(),
		            ret,
		            done,
		            options = this.options,
		            elem = this.elem,
		            complete = options.complete,
		            duration = options.duration,
		            curAnim = options.curAnim;

		        if (elem.attr && !elem.element) { // #2616, element is destroyed
		            ret = false;

		        } else if (gotoEnd || t >= duration + this.startTime) {
		            this.now = this.end;
		            this.pos = 1;
		            this.update();

		            curAnim[this.prop] = true;

		            done = true;

		            H.objectEach(curAnim, function (val) {
		                if (val !== true) {
		                    done = false;
		                }
		            });

		            if (done && complete) {
		                complete.call(elem);
		            }
		            ret = false;

		        } else {
		            this.pos = options.easing((t - this.startTime) / duration);
		            this.now = this.start + ((this.end - this.start) * this.pos);
		            this.update();
		            ret = true;
		        }
		        return ret;
		    },

		    /**
		     * Prepare start and end values so that the path can be animated one to one.
		     *
		     * @function Highcharts.Fx#initPath
		     *
		     * @param {Highcharts.SVGElement} elem
		     *        The SVGElement item.
		     *
		     * @param {string} fromD
		     *        Starting path definition.
		     *
		     * @param {Highcharts.SVGPathArray} toD
		     *        Ending path definition.
		     *
		     * @return {Array<Highcharts.SVGPathArray>}
		     *         An array containing start and end paths in array form so that
		     *         they can be animated in parallel.
		     */
		    initPath: function (elem, fromD, toD) {
		        fromD = fromD || '';
		        var shift,
		            startX = elem.startX,
		            endX = elem.endX,
		            bezier = fromD.indexOf('C') > -1,
		            numParams = bezier ? 7 : 3,
		            fullLength,
		            slice,
		            i,
		            start = fromD.split(' '),
		            end = toD.slice(), // copy
		            isArea = elem.isArea,
		            positionFactor = isArea ? 2 : 1,
		            reverse;

		        /**
		         * In splines make moveTo and lineTo points have six parameters like
		         * bezier curves, to allow animation one-to-one.
		         */
		        function sixify(arr) {
		            var isOperator,
		                nextIsOperator;
		            i = arr.length;
		            while (i--) {

		                // Fill in dummy coordinates only if the next operator comes
		                // three places behind (#5788)
		                isOperator = arr[i] === 'M' || arr[i] === 'L';
		                nextIsOperator = /[a-zA-Z]/.test(arr[i + 3]);
		                if (isOperator && nextIsOperator) {
		                    arr.splice(
		                        i + 1, 0,
		                        arr[i + 1], arr[i + 2],
		                        arr[i + 1], arr[i + 2]
		                    );
		                }
		            }
		        }

		        /**
		         * Insert an array at the given position of another array
		         */
		        function insertSlice(arr, subArr, index) {
		            [].splice.apply(
		                arr,
		                [index, 0].concat(subArr)
		            );
		        }

		        /**
		         * If shifting points, prepend a dummy point to the end path.
		         */
		        function prepend(arr, other) {
		            while (arr.length < fullLength) {

		                // Move to, line to or curve to?
		                arr[0] = other[fullLength - arr.length];

		                // Prepend a copy of the first point
		                insertSlice(arr, arr.slice(0, numParams), 0);

		                // For areas, the bottom path goes back again to the left, so we
		                // need to append a copy of the last point.
		                if (isArea) {
		                    insertSlice(
		                        arr,
		                        arr.slice(arr.length - numParams), arr.length
		                    );
		                    i--;
		                }
		            }
		            arr[0] = 'M';
		        }

		        /**
		         * Copy and append last point until the length matches the end length.
		         */
		        function append(arr, other) {
		            var i = (fullLength - arr.length) / numParams;
		            while (i > 0 && i--) {

		                // Pull out the slice that is going to be appended or inserted.
		                // In a line graph, the positionFactor is 1, and the last point
		                // is sliced out. In an area graph, the positionFactor is 2,
		                // causing the middle two points to be sliced out, since an area
		                // path starts at left, follows the upper path then turns and
		                // follows the bottom back.
		                slice = arr.slice().splice(
		                    (arr.length / positionFactor) - numParams,
		                    numParams * positionFactor
		                );

		                // Move to, line to or curve to?
		                slice[0] = other[fullLength - numParams - (i * numParams)];

		                // Disable first control point
		                if (bezier) {
		                    slice[numParams - 6] = slice[numParams - 2];
		                    slice[numParams - 5] = slice[numParams - 1];
		                }

		                // Now insert the slice, either in the middle (for areas) or at
		                // the end (for lines)
		                insertSlice(arr, slice, arr.length / positionFactor);

		                if (isArea) {
		                    i--;
		                }
		            }
		        }

		        if (bezier) {
		            sixify(start);
		            sixify(end);
		        }

		        // For sideways animation, find out how much we need to shift to get the
		        // start path Xs to match the end path Xs.
		        if (startX && endX) {
		            for (i = 0; i < startX.length; i++) {
		                // Moving left, new points coming in on right
		                if (startX[i] === endX[0]) {
		                    shift = i;
		                    break;
		                // Moving right
		                } else if (startX[0] ===
		                        endX[endX.length - startX.length + i]) {
		                    shift = i;
		                    reverse = true;
		                    break;
		                }
		            }
		            if (shift === undefined) {
		                start = [];
		            }
		        }

		        if (start.length && H.isNumber(shift)) {

		            // The common target length for the start and end array, where both
		            // arrays are padded in opposite ends
		            fullLength = end.length + shift * positionFactor * numParams;

		            if (!reverse) {
		                prepend(end, start);
		                append(start, end);
		            } else {
		                prepend(start, end);
		                append(end, start);
		            }
		        }

		        return [start, end];
		    },

		    /**
		     * Handle animation of the color attributes directly.
		     *
		     * @function Highcharts.Fx#fillSetter
		     */
		    fillSetter: function () {
		        H.Fx.prototype.strokeSetter.apply(this, arguments);
		    },

		    /**
		     * Handle animation of the color attributes directly.
		     *
		     * @function Highcharts.Fx#strokeSetter
		     */
		    strokeSetter: function () {
		        this.elem.attr(
		            this.prop,
		            H.color(this.start).tweenTo(H.color(this.end), this.pos),
		            null,
		            true
		        );
		    }

		}; // End of Fx prototype



		/**
		 * Utility function to deep merge two or more objects and return a third object.
		 * The merge function can also be used with a single object argument to create a
		 * deep copy of an object.
		 *
		 * @function Highcharts.merge
		 *
		 * @param {*} a
		 *        The first object to extend. When only this is given, the function
		 *        returns a deep copy.
		 *
		 * @param {*} [n]
		 *        An object to merge into the previous one.
		 *
		 * @return {*}
		 *         The merged object. If the first argument is true, the return is the
		 *         same as the second argument.
		 *//**
		 * Utility function to deep merge two or more objects and return a third object.
		 * If the first argument is true, the contents of the second object is copied
		 * into the first object. The merge function can also be used with a single
		 * object argument to create a deep copy of an object.
		 *
		 * @function Highcharts.merge
		 *
		 * @param {boolean} extend
		 *        Whether to extend the left-side object (a) or return a whole new
		 *        object.
		 *
		 * @param {*} a
		 *        The first object to extend. When only this is given, the function
		 *        returns a deep copy.
		 *
		 * @param {*} [n]
		 *        An object to merge into the previous one.
		 *
		 * @return {*}
		 *         The merged object. If the first argument is true, the return is the
		 *         same as the second argument.
		 */
		H.merge = function () {
		    var i,
		        args = arguments,
		        len,
		        ret = {},
		        doCopy = function (copy, original) {
		            // An object is replacing a primitive
		            if (typeof copy !== 'object') {
		                copy = {};
		            }

		            H.objectEach(original, function (value, key) {

		                // Copy the contents of objects, but not arrays or DOM nodes
		                if (
		                        H.isObject(value, true) &&
		                        !H.isClass(value) &&
		                        !H.isDOMElement(value)
		                ) {
		                    copy[key] = doCopy(copy[key] || {}, value);

		                // Primitives and arrays are copied over directly
		                } else {
		                    copy[key] = original[key];
		                }
		            });
		            return copy;
		        };

		    // If first argument is true, copy into the existing object. Used in
		    // setOptions.
		    if (args[0] === true) {
		        ret = args[1];
		        args = Array.prototype.slice.call(args, 2);
		    }

		    // For each argument, extend the return
		    len = args.length;
		    for (i = 0; i < len; i++) {
		        ret = doCopy(ret, args[i]);
		    }

		    return ret;
		};

		/**
		 * Shortcut for parseInt
		 *
		 * @private
		 * @function Highcharts.pInt
		 *
		 * @param {*} s
		 *
		 * @param {number} mag
		 *        Magnitude
		 *
		 * @return {number}
		 */
		H.pInt = function (s, mag) {
		    return parseInt(s, mag || 10);
		};

		/**
		 * Utility function to check for string type.
		 *
		 * @function Highcharts.isString
		 *
		 * @param {*} s
		 *        The item to check.
		 *
		 * @return {boolean}
		 *         True if the argument is a string.
		 */
		H.isString = function (s) {
		    return typeof s === 'string';
		};

		/**
		 * Utility function to check if an item is an array.
		 *
		 * @function Highcharts.isArray
		 *
		 * @param {*} obj
		 *        The item to check.
		 *
		 * @return {boolean}
		 *         True if the argument is an array.
		 */
		H.isArray = function (obj) {
		    var str = Object.prototype.toString.call(obj);
		    return str === '[object Array]' || str === '[object Array Iterator]';
		};

		/**
		 * Utility function to check if an item is of type object.
		 *
		 * @function Highcharts.isObject
		 *
		 * @param {*} obj
		 *        The item to check.
		 *
		 * @param {boolean} [strict=false]
		 *        Also checks that the object is not an array.
		 *
		 * @return {boolean}
		 *         True if the argument is an object.
		 */
		H.isObject = function (obj, strict) {
		    return !!obj && typeof obj === 'object' && (!strict || !H.isArray(obj));
		};

		/**
		 * Utility function to check if an Object is a HTML Element.
		 *
		 * @function Highcharts.isDOMElement
		 *
		 * @param {*} obj
		 *        The item to check.
		 *
		 * @return {boolean}
		 *         True if the argument is a HTML Element.
		 */
		H.isDOMElement = function (obj) {
		    return H.isObject(obj) && typeof obj.nodeType === 'number';
		};

		/**
		 * Utility function to check if an Object is an class.
		 *
		 * @function Highcharts.isClass
		 *
		 * @param {*} obj
		 *        The item to check.
		 *
		 * @return {boolean}
		 *         True if the argument is an class.
		 */
		H.isClass = function (obj) {
		    var c = obj && obj.constructor;
		    return !!(
		        H.isObject(obj, true) &&
		        !H.isDOMElement(obj) &&
		        (c && c.name && c.name !== 'Object')
		    );
		};

		/**
		 * Utility function to check if an item is a number and it is finite (not NaN,
		 * Infinity or -Infinity).
		 *
		 * @function Highcharts.isNumber
		 *
		 * @param {*} n
		 *        The item to check.
		 *
		 * @return {boolean}
		 *         True if the item is a finite number
		 */
		H.isNumber = function (n) {
		    return typeof n === 'number' && !isNaN(n) && n < Infinity && n > -Infinity;
		};

		/**
		 * Remove the last occurence of an item from an array.
		 *
		 * @function Highcharts.erase
		 *
		 * @param {Array} arr
		 *        The array.
		 *
		 * @param {*} item
		 *        The item to remove.
		 */
		H.erase = function (arr, item) {
		    var i = arr.length;
		    while (i--) {
		        if (arr[i] === item) {
		            arr.splice(i, 1);
		            break;
		        }
		    }
		};

		/**
		 * Check if an object is null or undefined.
		 *
		 * @function Highcharts.defined
		 *
		 * @param {*} obj
		 *        The object to check.
		 *
		 * @return {boolean}
		 *         False if the object is null or undefined, otherwise true.
		 */
		H.defined = function (obj) {
		    return obj !== undefined && obj !== null;
		};

		/**
		 * Set or get an attribute or an object of attributes. To use as a setter, pass
		 * a key and a value, or let the second argument be a collection of keys and
		 * values. To use as a getter, pass only a string as the second argument.
		 *
		 * @function Highcharts.attr
		 *
		 * @param {Highcharts.HTMLDOMElement|Highcharts.SVGDOMElement} elem
		 *        The DOM element to receive the attribute(s).
		 *
		 * @param {string|Highcharts.HTMLAttributes|Highcharts.SVGAttributes} [prop]
		 *        The property or an object of key-value pairs.
		 *
		 * @param {string} [value]
		 *        The value if a single property is set.
		 *
		 * @return {*}
		 *         When used as a getter, return the value.
		 */
		H.attr = function (elem, prop, value) {
		    var ret;

		    // if the prop is a string
		    if (H.isString(prop)) {
		        // set the value
		        if (H.defined(value)) {
		            elem.setAttribute(prop, value);

		        // get the value
		        } else if (elem && elem.getAttribute) {
		            ret = elem.getAttribute(prop);

		            // IE7 and below cannot get class through getAttribute (#7850)
		            if (!ret && prop === 'class') {
		                ret = elem.getAttribute(prop + 'Name');
		            }
		        }

		    // else if prop is defined, it is a hash of key/value pairs
		    } else if (H.defined(prop) && H.isObject(prop)) {
		        H.objectEach(prop, function (val, key) {
		            elem.setAttribute(key, val);
		        });
		    }
		    return ret;
		};

		/**
		 * Check if an element is an array, and if not, make it into an array.
		 *
		 * @function Highcharts.splat
		 *
		 * @param {*} obj
		 *        The object to splat.
		 *
		 * @return {Array}
		 *         The produced or original array.
		 */
		H.splat = function (obj) {
		    return H.isArray(obj) ? obj : [obj];
		};

		/**
		 * Set a timeout if the delay is given, otherwise perform the function
		 * synchronously.
		 *
		 * @function Highcharts.syncTimeout
		 *
		 * @param {Function} fn
		 *        The function callback.
		 *
		 * @param {number} delay
		 *        Delay in milliseconds.
		 *
		 * @param {*} [context]
		 *        The context.
		 *
		 * @return {number}
		 *         An identifier for the timeout that can later be cleared with
		 *         Highcharts.clearTimeout.
		 */
		H.syncTimeout = function (fn, delay, context) {
		    if (delay) {
		        return setTimeout(fn, delay, context);
		    }
		    fn.call(0, context);
		};

		/**
		 * Internal clear timeout. The function checks that the `id` was not removed
		 * (e.g. by `chart.destroy()`). For the details see
		 * [issue #7901](https://github.com/highcharts/highcharts/issues/7901).
		 *
		 * @function Highcharts.clearTimeout
		 *
		 * @param {number} id
		 *        Id of a timeout.
		 */
		H.clearTimeout = function (id) {
		    if (H.defined(id)) {
		        clearTimeout(id);
		    }
		};

		/**
		 * Utility function to extend an object with the members of another.
		 *
		 * @function Highcharts.extend
		 *
		 * @param {Highcharts.Dictionary<*>} a
		 *        The object to be extended.
		 *
		 * @param {Highcharts.Dictionary<*>} b
		 *        The object to add to the first one.
		 *
		 * @return {Highcharts.Dictionary<*>}
		 *         Object a, the original object.
		 */
		H.extend = function (a, b) {
		    var n;
		    if (!a) {
		        a = {};
		    }
		    for (n in b) {
		        a[n] = b[n];
		    }
		    return a;
		};


		/**
		 * Return the first value that is not null or undefined.
		 *
		 * @function Highcharts.pick
		 *
		 * @param {...*} items
		 *        Variable number of arguments to inspect.
		 *
		 * @return {*}
		 *         The value of the first argument that is not null or undefined.
		 */
		H.pick = function () {
		    var args = arguments,
		        i,
		        arg,
		        length = args.length;
		    for (i = 0; i < length; i++) {
		        arg = args[i];
		        if (arg !== undefined && arg !== null) {
		            return arg;
		        }
		    }
		};

		/**
		 * Set CSS on a given element.
		 *
		 * @function Highcharts.css
		 *
		 * @param {Highcharts.HTMLDOMElement} el
		 *        An HTML DOM element.
		 *
		 * @param {Highcharts.CSSObject} styles
		 *        Style object with camel case property names.
		 */
		H.css = function (el, styles) {
		    if (H.isMS && !H.svg) { // #2686
		        if (styles && styles.opacity !== undefined) {
		            styles.filter = 'alpha(opacity=' + (styles.opacity * 100) + ')';
		        }
		    }
		    H.extend(el.style, styles);
		};

		/**
		 * Utility function to create an HTML element with attributes and styles.
		 *
		 * @function Highcharts.createElement
		 *
		 * @param {string} tag
		 *        The HTML tag.
		 *
		 * @param {Highcharts.HTMLAttributes} [attribs]
		 *        Attributes as an object of key-value pairs.
		 *
		 * @param {Highcharts.CSSObject} [styles]
		 *        Styles as an object of key-value pairs.
		 *
		 * @param {Highcharts.HTMLDOMElement} [parent]
		 *        The parent HTML object.
		 *
		 * @param {boolean} [nopad=false]
		 *        If true, remove all padding, border and margin.
		 *
		 * @return {Highcharts.HTMLDOMElement}
		 *         The created DOM element.
		 */
		H.createElement = function (tag, attribs, styles, parent, nopad) {
		    var el = doc.createElement(tag),
		        css = H.css;
		    if (attribs) {
		        H.extend(el, attribs);
		    }
		    if (nopad) {
		        css(el, { padding: 0, border: 'none', margin: 0 });
		    }
		    if (styles) {
		        css(el, styles);
		    }
		    if (parent) {
		        parent.appendChild(el);
		    }
		    return el;
		};

		/**
		 * Extend a prototyped class by new members.
		 *
		 * @function Highcharts.extendClass
		 *
		 * @param {*} parent
		 *        The parent prototype to inherit.
		 *
		 * @param {Highcharts.Dictionary<*>} members
		 *        A collection of prototype members to add or override compared to the
		 *        parent prototype.
		 *
		 * @return {*}
		 *         A new prototype.
		 */
		H.extendClass = function (parent, members) {
		    var object = function () {};
		    object.prototype = new parent(); // eslint-disable-line new-cap
		    H.extend(object.prototype, members);
		    return object;
		};

		/**
		 * Left-pad a string to a given length by adding a character repetetively.
		 *
		 * @function Highcharts.pad
		 *
		 * @param {number} number
		 *        The input string or number.
		 *
		 * @param {number} length
		 *        The desired string length.
		 *
		 * @param {string} [padder=0]
		 *        The character to pad with.
		 *
		 * @return {string}
		 *         The padded string.
		 */
		H.pad = function (number, length, padder) {
		    return new Array(
		            (length || 2) +
		            1 -
		            String(number)
		                .replace('-', '')
		                .length
		        ).join(padder || 0) + number;
		};

		/**
		 * Return a length based on either the integer value, or a percentage of a base.
		 *
		 * @function Highcharts.relativeLength
		 *
		 * @param {Highcharts.RelativeSize} value
		 *        A percentage string or a number.
		 *
		 * @param {number} base
		 *        The full length that represents 100%.
		 *
		 * @param {number} [offset=0]
		 *        A pixel offset to apply for percentage values. Used internally in
		 *        axis positioning.
		 *
		 * @return {number}
		 *         The computed length.
		 */
		H.relativeLength = function (value, base, offset) {
		    return (/%$/).test(value) ?
		        (base * parseFloat(value) / 100) + (offset || 0) :
		        parseFloat(value);
		};

		/**
		 * Wrap a method with extended functionality, preserving the original function.
		 *
		 * @function Highcharts.wrap
		 *
		 * @param {*} obj
		 *        The context object that the method belongs to. In real cases, this is
		 *        often a prototype.
		 *
		 * @param {string} method
		 *        The name of the method to extend.
		 *
		 * @param {Function} func
		 *        A wrapper function callback. This function is called with the same
		 *        arguments as the original function, except that the original function
		 *        is unshifted and passed as the first argument.
		 */
		H.wrap = function (obj, method, func) {
		    var proceed = obj[method];
		    obj[method] = function () {
		        var args = Array.prototype.slice.call(arguments),
		            outerArgs = arguments,
		            ctx = this,
		            ret;
		        ctx.proceed = function () {
		            proceed.apply(ctx, arguments.length ? arguments : outerArgs);
		        };
		        args.unshift(proceed);
		        ret = func.apply(this, args);
		        ctx.proceed = null;
		        return ret;
		    };
		};



		/**
		 * Recursively converts all Date properties to timestamps.
		 *
		 * @param  {Object} object - any object to convert properties of
		 */
		H.datePropsToTimestamps = function (object) {
		    H.objectEach(object, function (val, key) {
		        if (H.isObject(val) && typeof val.getTime === 'function') {
		            object[key] = val.getTime();
		        } else if (H.isObject(val) || H.isArray(val)) {
		            H.datePropsToTimestamps(val);
		        }
		    });
		};

		/**
		 * Format a single variable. Similar to sprintf, without the % prefix.
		 *
		 * @example
		 * formatSingle('.2f', 5); // => '5.00'.
		 *
		 * @function Highcharts.formatSingle
		 *
		 * @param {string} format
		 *        The format string.
		 *
		 * @param {*} val
		 *        The value.
		 *
		 * @param {Highcharts.Time} [time]
		 *        A `Time` instance that determines the date formatting, for example
		 *        for applying time zone corrections to the formatted date.
		 *
		 * @return {string}
		 *         The formatted representation of the value.
		 */
		H.formatSingle = function (format, val, time) {
		    var floatRegex = /f$/,
		        decRegex = /\.([0-9])/,
		        lang = H.defaultOptions.lang,
		        decimals;

		    if (floatRegex.test(format)) { // float
		        decimals = format.match(decRegex);
		        decimals = decimals ? decimals[1] : -1;
		        if (val !== null) {
		            val = H.numberFormat(
		                val,
		                decimals,
		                lang.decimalPoint,
		                format.indexOf(',') > -1 ? lang.thousandsSep : ''
		            );
		        }
		    } else {
		        val = (time || H.time).dateFormat(format, val);
		    }
		    return val;
		};

		/**
		 * Format a string according to a subset of the rules of Python's String.format
		 * method.
		 *
		 * @example
		 * var s = Highcharts.format(
		 *     'The {color} fox was {len:.2f} feet long',
		 *     { color: 'red', len: Math.PI }
		 * );
		 * // => The red fox was 3.14 feet long
		 *
		 * @function Highcharts.format
		 *
		 * @param {string} str
		 *        The string to format.
		 *
		 * @param {*} ctx
		 *        The context, a collection of key-value pairs where each key is
		 *        replaced by its value.
		 *
		 * @param {Highcharts.Time} [time]
		 *        A `Time` instance that determines the date formatting, for example
		 *        for applying time zone corrections to the formatted date.
		 *
		 * @return {string}
		 *         The formatted string.
		 */
		H.format = function (str, ctx, time) {
		    var splitter = '{',
		        isInside = false,
		        segment,
		        valueAndFormat,
		        path,
		        i,
		        len,
		        ret = [],
		        val,
		        index;

		    while (str) {
		        index = str.indexOf(splitter);
		        if (index === -1) {
		            break;
		        }

		        segment = str.slice(0, index);
		        if (isInside) { // we're on the closing bracket looking back

		            valueAndFormat = segment.split(':');
		            path = valueAndFormat.shift().split('.'); // get first and leave
		            len = path.length;
		            val = ctx;

		            // Assign deeper paths
		            for (i = 0; i < len; i++) {
		                if (val) {
		                    val = val[path[i]];
		                }
		            }

		            // Format the replacement
		            if (valueAndFormat.length) {
		                val = H.formatSingle(valueAndFormat.join(':'), val, time);
		            }

		            // Push the result and advance the cursor
		            ret.push(val);

		        } else {
		            ret.push(segment);

		        }
		        str = str.slice(index + 1); // the rest
		        isInside = !isInside; // toggle
		        splitter = isInside ? '}' : '{'; // now look for next matching bracket
		    }
		    ret.push(str);
		    return ret.join('');
		};

		/**
		 * Get the magnitude of a number.
		 *
		 * @function Highcharts.getMagnitude
		 *
		 * @param {number} number
		 *        The number.
		 *
		 * @return {number}
		 *         The magnitude, where 1-9 are magnitude 1, 10-99 magnitude 2 etc.
		 */
		H.getMagnitude = function (num) {
		    return Math.pow(10, Math.floor(Math.log(num) / Math.LN10));
		};

		/**
		 * Take an interval and normalize it to multiples of round numbers.
		 *
		 * @deprecated
		 * @function Highcharts.normalizeTickInterval
		 *
		 * @param {number} interval
		 *        The raw, un-rounded interval.
		 *
		 * @param {Array} [multiples]
		 *        Allowed multiples.
		 *
		 * @param {number} [magnitude]
		 *        The magnitude of the number.
		 *
		 * @param {boolean} [allowDecimals]
		 *        Whether to allow decimals.
		 *
		 * @param {boolean} [hasTickAmount]
		 *        If it has tickAmount, avoid landing on tick intervals lower than
		 *        original.
		 *
		 * @return {number}
		 *         The normalized interval.
		 *
		 * @todo
		 * Move this function to the Axis prototype. It is here only for historical
		 * reasons.
		 */
		H.normalizeTickInterval = function (interval, multiples, magnitude,
		        allowDecimals, hasTickAmount) {
		    var normalized,
		        i,
		        retInterval = interval;

		    // round to a tenfold of 1, 2, 2.5 or 5
		    magnitude = H.pick(magnitude, 1);
		    normalized = interval / magnitude;

		    // multiples for a linear scale
		    if (!multiples) {
		        multiples = hasTickAmount ?
		            // Finer grained ticks when the tick amount is hard set, including
		            // when alignTicks is true on multiple axes (#4580).
		            [1, 1.2, 1.5, 2, 2.5, 3, 4, 5, 6, 8, 10] :

		            // Else, let ticks fall on rounder numbers
		            [1, 2, 2.5, 5, 10];


		        // the allowDecimals option
		        if (allowDecimals === false) {
		            if (magnitude === 1) {
		                multiples = H.grep(multiples, function (num) {
		                    return num % 1 === 0;
		                });
		            } else if (magnitude <= 0.1) {
		                multiples = [1 / magnitude];
		            }
		        }
		    }

		    // normalize the interval to the nearest multiple
		    for (i = 0; i < multiples.length; i++) {
		        retInterval = multiples[i];
		        // only allow tick amounts smaller than natural
		        if (
		            (
		                hasTickAmount &&
		                retInterval * magnitude >= interval
		            ) ||
		            (
		                !hasTickAmount &&
		                (
		                    normalized <=
		                    (
		                        multiples[i] +
		                        (multiples[i + 1] || multiples[i])
		                    ) / 2
		                )
		            )
		        ) {
		            break;
		        }
		    }

		    // Multiply back to the correct magnitude. Correct floats to appropriate
		    // precision (#6085).
		    retInterval = H.correctFloat(
		        retInterval * magnitude,
		        -Math.round(Math.log(0.001) / Math.LN10)
		    );

		    return retInterval;
		};


		/**
		 * Sort an object array and keep the order of equal items. The ECMAScript
		 * standard does not specify the behaviour when items are equal.
		 *
		 * @function Highcharts.stableSort
		 *
		 * @param {Array} arr
		 *        The array to sort.
		 *
		 * @param {Function} sortFunction
		 *        The function to sort it with, like with regular Array.prototype.sort.
		 */
		H.stableSort = function (arr, sortFunction) {
		    var length = arr.length,
		        sortValue,
		        i;

		    // Add index to each item
		    for (i = 0; i < length; i++) {
		        arr[i].safeI = i; // stable sort index
		    }

		    arr.sort(function (a, b) {
		        sortValue = sortFunction(a, b);
		        return sortValue === 0 ? a.safeI - b.safeI : sortValue;
		    });

		    // Remove index from items
		    for (i = 0; i < length; i++) {
		        delete arr[i].safeI; // stable sort index
		    }
		};

		/**
		 * Non-recursive method to find the lowest member of an array. `Math.min` raises
		 * a maximum call stack size exceeded error in Chrome when trying to apply more
		 * than 150.000 points. This method is slightly slower, but safe.
		 *
		 * @function Highcharts.arrayMin
		 *
		 * @param {Array} data
		 *        An array of numbers.
		 *
		 * @return {number}
		 *         The lowest number.
		 */
		H.arrayMin = function (data) {
		    var i = data.length,
		        min = data[0];

		    while (i--) {
		        if (data[i] < min) {
		            min = data[i];
		        }
		    }
		    return min;
		};

		/**
		 * Non-recursive method to find the lowest member of an array. `Math.max` raises
		 * a maximum call stack size exceeded error in Chrome when trying to apply more
		 * than 150.000 points. This method is slightly slower, but safe.
		 *
		 * @function Highcharts.arrayMax
		 *
		 * @param {Array} data
		 *        An array of numbers.
		 *
		 * @return {number}
		 *         The highest number.
		 */
		H.arrayMax = function (data) {
		    var i = data.length,
		        max = data[0];

		    while (i--) {
		        if (data[i] > max) {
		            max = data[i];
		        }
		    }
		    return max;
		};

		/**
		 * Utility method that destroys any SVGElement instances that are properties on
		 * the given object. It loops all properties and invokes destroy if there is a
		 * destroy method. The property is then delete.
		 *
		 * @function Highcharts.destroyObjectProperties
		 *
		 * @param {*} obj
		 *        The object to destroy properties on.
		 *
		 * @param {*} [except]
		 *        Exception, do not destroy this property, only delete it.
		 */
		H.destroyObjectProperties = function (obj, except) {
		    H.objectEach(obj, function (val, n) {
		        // If the object is non-null and destroy is defined
		        if (val && val !== except && val.destroy) {
		            // Invoke the destroy
		            val.destroy();
		        }

		        // Delete the property from the object.
		        delete obj[n];
		    });
		};


		/**
		 * Discard a HTML element by moving it to the bin and delete.
		 *
		 * @function Highcharts.discardElement
		 *
		 * @param {Highcharts.HTMLDOMElement} element
		 *        The HTML node to discard.
		 */
		H.discardElement = function (element) {
		    var garbageBin = H.garbageBin;
		    // create a garbage bin element, not part of the DOM
		    if (!garbageBin) {
		        garbageBin = H.createElement('div');
		    }

		    // move the node and empty bin
		    if (element) {
		        garbageBin.appendChild(element);
		    }
		    garbageBin.innerHTML = '';
		};

		/**
		 * Fix JS round off float errors.
		 *
		 * @function Highcharts.correctFloat
		 *
		 * @param {number} num
		 *        A float number to fix.
		 *
		 * @param {number} [prec=14]
		 *        The precision.
		 *
		 * @return {number}
		 *         The corrected float number.
		 */
		H.correctFloat = function (num, prec) {
		    return parseFloat(
		        num.toPrecision(prec || 14)
		    );
		};

		/**
		 * Set the global animation to either a given value, or fall back to the given
		 * chart's animation option.
		 *
		 * @function Highcharts.setAnimation
		 *
		 * @param {boolean|Highcharts.AnimationOptionsObject} animation
		 *        The animation object.
		 *
		 * @param {Highcharts.Chart} chart
		 *        The chart instance.
		 *
		 * @todo
		 * This function always relates to a chart, and sets a property on the renderer,
		 * so it should be moved to the SVGRenderer.
		 */
		H.setAnimation = function (animation, chart) {
		    chart.renderer.globalAnimation = H.pick(
		        animation,
		        chart.options.chart.animation,
		        true
		    );
		};

		/**
		 * Get the animation in object form, where a disabled animation is always
		 * returned as `{ duration: 0 }`.
		 *
		 * @function Highcharts.animObject
		 *
		 * @param {boolean|Highcharts.AnimationOptionsObject} animation
		 *        An animation setting. Can be an object with duration, complete and
		 *        easing properties, or a boolean to enable or disable.
		 *
		 * @return {Highcharts.AnimationOptionsObject}
		 *         An object with at least a duration property.
		 */
		H.animObject = function (animation) {
		    return H.isObject(animation) ?
		        H.merge(animation) :
		        { duration: animation ? 500 : 0 };
		};

		/**
		 * The time unit lookup
		 *
		 * @ignore
		 */
		H.timeUnits = {
		    millisecond: 1,
		    second: 1000,
		    minute: 60000,
		    hour: 3600000,
		    day: 24 * 3600000,
		    week: 7 * 24 * 3600000,
		    month: 28 * 24 * 3600000,
		    year: 364 * 24 * 3600000
		};

		/**
		 * Format a number and return a string based on input settings.
		 *
		 * @sample highcharts/members/highcharts-numberformat/
		 *         Custom number format
		 *
		 * @function Highcharts.numberFormat
		 *
		 * @param {number} number
		 *        The input number to format.
		 *
		 * @param {number} decimals
		 *        The amount of decimals. A value of -1 preserves the amount in the
		 *        input number.
		 *
		 * @param {string} [decimalPoint]
		 *        The decimal point, defaults to the one given in the lang options, or
		 *        a dot.
		 *
		 * @param {string} [thousandsSep]
		 *        The thousands separator, defaults to the one given in the lang
		 *        options, or a space character.
		 *
		 * @return {string}
		 *         The formatted number.
		 */
		H.numberFormat = function (number, decimals, decimalPoint, thousandsSep) {
		    number = +number || 0;
		    decimals = +decimals;

		    var lang = H.defaultOptions.lang,
		        origDec = (number.toString().split('.')[1] || '').split('e')[0].length,
		        strinteger,
		        thousands,
		        ret,
		        roundedNumber,
		        exponent = number.toString().split('e'),
		        fractionDigits;

		    if (decimals === -1) {
		        // Preserve decimals. Not huge numbers (#3793).
		        decimals = Math.min(origDec, 20);
		    } else if (!H.isNumber(decimals)) {
		        decimals = 2;
		    } else if (decimals && exponent[1] && exponent[1] < 0) {
		        // Expose decimals from exponential notation (#7042)
		        fractionDigits = decimals + +exponent[1];
		        if (fractionDigits >= 0) {
		            // remove too small part of the number while keeping the notation
		            exponent[0] = (+exponent[0]).toExponential(fractionDigits)
		                .split('e')[0];
		            decimals = fractionDigits;
		        } else {
		            // fractionDigits < 0
		            exponent[0] = exponent[0].split('.')[0] || 0;

		            if (decimals < 20) {
		                // use number instead of exponential notation (#7405)
		                number = (exponent[0] * Math.pow(10, exponent[1]))
		                    .toFixed(decimals);
		            } else {
		                // or zero
		                number = 0;
		            }
		            exponent[1] = 0;
		        }
		    }

		    // Add another decimal to avoid rounding errors of float numbers. (#4573)
		    // Then use toFixed to handle rounding.
		    roundedNumber = (
		        Math.abs(exponent[1] ? exponent[0] : number) +
		        Math.pow(10, -Math.max(decimals, origDec) - 1)
		    ).toFixed(decimals);

		    // A string containing the positive integer component of the number
		    strinteger = String(H.pInt(roundedNumber));

		    // Leftover after grouping into thousands. Can be 0, 1 or 2.
		    thousands = strinteger.length > 3 ? strinteger.length % 3 : 0;

		    // Language
		    decimalPoint = H.pick(decimalPoint, lang.decimalPoint);
		    thousandsSep = H.pick(thousandsSep, lang.thousandsSep);

		    // Start building the return
		    ret = number < 0 ? '-' : '';

		    // Add the leftover after grouping into thousands. For example, in the
		    // number 42 000 000, this line adds 42.
		    ret += thousands ? strinteger.substr(0, thousands) + thousandsSep : '';

		    // Add the remaining thousands groups, joined by the thousands separator
		    ret += strinteger
		        .substr(thousands)
		        .replace(/(\d{3})(?=\d)/g, '$1' + thousandsSep);

		    // Add the decimal point and the decimal component
		    if (decimals) {
		        // Get the decimal component
		        ret += decimalPoint + roundedNumber.slice(-decimals);
		    }

		    if (exponent[1] && +ret !== 0) {
		        ret += 'e' + exponent[1];
		    }

		    return ret;
		};

		/**
		 * Easing definition
		 *
		 * @private
		 * @function Math.easeInOutSine
		 *
		 * @param {number} pos
		 *        Current position, ranging from 0 to 1.
		 *
		 * @return {number}
		 */
		Math.easeInOutSine = function (pos) {
		    return -0.5 * (Math.cos(Math.PI * pos) - 1);
		};

		/**
		 * Get the computed CSS value for given element and property, only for numerical
		 * properties. For width and height, the dimension of the inner box (excluding
		 * padding) is returned. Used for fitting the chart within the container.
		 *
		 * @function Highcharts.getStyle
		 *
		 * @param {Highcharts.HTMLDOMElement} el
		 *        An HTML element.
		 *
		 * @param {string} prop
		 *        The property name.
		 *
		 * @param {boolean} [toInt=true]
		 *        Parse to integer.
		 *
		 * @return {number}
		 *         The numeric value.
		 */
		H.getStyle = function (el, prop, toInt) {

		    var style;

		    // For width and height, return the actual inner pixel size (#4913)
		    if (prop === 'width') {
		        return Math.max(
		            0, // #8377
		            Math.min(el.offsetWidth, el.scrollWidth) -
		                H.getStyle(el, 'padding-left') -
		                H.getStyle(el, 'padding-right')
		        );
		    } else if (prop === 'height') {
		        return Math.max(
		            0, // #8377
		            Math.min(el.offsetHeight, el.scrollHeight) -
		                H.getStyle(el, 'padding-top') -
		                H.getStyle(el, 'padding-bottom')
		        );
		    }

		    if (!win.getComputedStyle) {
		        // SVG not supported, forgot to load oldie.js?
		        H.error(27, true);
		    }

		    // Otherwise, get the computed style
		    style = win.getComputedStyle(el, undefined);
		    if (style) {
		        style = style.getPropertyValue(prop);
		        if (H.pick(toInt, prop !== 'opacity')) {
		            style = H.pInt(style);
		        }
		    }
		    return style;
		};

		/**
		 * Search for an item in an array.
		 *
		 * @function Highcharts.inArray
		 *
		 * @param {*} item
		 *        The item to search for.
		 *
		 * @param {Array} arr
		 *        The array or node collection to search in.
		 *
		 * @param {number} [fromIndex=0]
		 *        The index to start searching from.
		 *
		 * @return {number}
		 *         The index within the array, or -1 if not found.
		 */
		H.inArray = function (item, arr, fromIndex) {
		    return (
		        H.indexOfPolyfill ||
		        Array.prototype.indexOf
		    ).call(arr, item, fromIndex);
		};

		/**
		 * Filter an array by a callback.
		 *
		 * @function Highcharts.grep
		 *
		 * @param {Array} arr
		 *        The array to filter.
		 *
		 * @param {Function} callback
		 *        The callback function. The function receives the item as the first
		 *        argument. Return `true` if the item is to be preserved.
		 *
		 * @return {Array}
		 *         A new, filtered array.
		 */
		H.grep = function (arr, callback) {
		    return (H.filterPolyfill || Array.prototype.filter).call(arr, callback);
		};

		/**
		 * Return the value of the first element in the array that satisfies the
		 * provided testing function.
		 *
		 * @function Highcharts.find
		 *
		 * @param {Array} arr
		 *        The array to test.
		 *
		 * @param {Function} callback
		 *        The callback function. The function receives the item as the first
		 *        argument. Return `true` if this item satisfies the condition.
		 *
		 * @return {*}
		 *         The value of the element.
		 */
		H.find = Array.prototype.find ?
		    function (arr, callback) {
		        return arr.find(callback);
		    } :
		    // Legacy implementation. PhantomJS, IE <= 11 etc. #7223.
		    function (arr, fn) {
		        var i,
		            length = arr.length;

		        for (i = 0; i < length; i++) {
		            if (fn(arr[i], i)) {
		                return arr[i];
		            }
		        }
		    };

		/**
		 * Test whether at least one element in the array passes the test implemented by
		 * the provided function.
		 *
		 * @function Highcharts.some
		 *
		 * @param {Array} arr
		 *        The array to test
		 *
		 * @param {Function} fn
		 *        The function to run on each item. Return truty to pass the test.
		 *        Receives arguments `currentValue`, `index` and `array`.
		 *
		 * @param {*} ctx
		 *        The context.
		 *
		 * @return {boolean}
		 */
		H.some = function (arr, fn, ctx) {
		    return (H.somePolyfill || Array.prototype.some).call(arr, fn, ctx);
		};

		/**
		 * Map an array by a callback.
		 *
		 * @function Highcharts.map
		 *
		 * @param {Array} arr
		 *        The array to map.
		 *
		 * @param {Function} fn
		 *        The callback function. Return the new value for the new array.
		 *
		 * @return {Array}
		 *         A new array item with modified items.
		 */
		H.map = function (arr, fn) {
		    var results = [],
		        i = 0,
		        len = arr.length;

		    for (; i < len; i++) {
		        results[i] = fn.call(arr[i], arr[i], i, arr);
		    }

		    return results;
		};

		/**
		 * Returns an array of a given object's own properties.
		 *
		 * @function Highcharts.keys
		 *
		 * @param {*} obj
		 *        The object of which the properties are to be returned.
		 *
		 * @return {Array<string>}
		 *         An array of strings that represents all the properties.
		 */
		H.keys = function (obj) {
		    return (H.keysPolyfill || Object.keys).call(undefined, obj);
		};

		/**
		 * Reduce an array to a single value.
		 *
		 * @function Highcharts.reduce
		 *
		 * @param {Array<*>} arr
		 *        The array to reduce.
		 *
		 * @param {Function} fn
		 *        The callback function. Return the reduced value. Receives 4
		 *        arguments: Accumulated/reduced value, current value, current array
		 *        index, and the array.
		 *
		 * @param {*} initialValue
		 *        The initial value of the accumulator.
		 *
		 * @return {*}
		 *         The reduced value.
		 */
		H.reduce = function (arr, func, initialValue) {
		    var fn = (H.reducePolyfill || Array.prototype.reduce);
		    return fn.apply(
		        arr,
		        (arguments.length > 2 ? [func, initialValue] : [func])
		    );
		};

		/**
		 * Get the element's offset position, corrected for `overflow: auto`.
		 *
		 * @function Highcharts.offset
		 *
		 * @param {Highcharts.HTMLDOMElement} el
		 *        The HTML element.
		 *
		 * @return {Highcharts.OffsetObject}
		 *         An object containing `left` and `top` properties for the position in
		 *         the page.
		 */
		H.offset = function (el) {
		    var docElem = doc.documentElement,
		        box = (el.parentElement || el.parentNode) ?
		            el.getBoundingClientRect() :
		            { top: 0, left: 0 };

		    return {
		        top: box.top + (win.pageYOffset || docElem.scrollTop) -
		            (docElem.clientTop || 0),
		        left: box.left + (win.pageXOffset || docElem.scrollLeft) -
		            (docElem.clientLeft || 0)
		    };
		};

		/**
		 * Stop running animation.
		 *
		 * @function Highcharts.stop
		 *
		 * @param {Highcharts.SVGElement} el
		 *        The SVGElement to stop animation on.
		 *
		 * @param {string} [prop]
		 *        The property to stop animating. If given, the stop method will stop a
		 *        single property from animating, while others continue.
		 *
		 * @todo
		 * A possible extension to this would be to stop a single property, when
		 * we want to continue animating others. Then assign the prop to the timer
		 * in the Fx.run method, and check for the prop here. This would be an
		 * improvement in all cases where we stop the animation from .attr. Instead of
		 * stopping everything, we can just stop the actual attributes we're setting.
		 */
		H.stop = function (el, prop) {

		    var i = H.timers.length;

		    // Remove timers related to this element (#4519)
		    while (i--) {
		        if (H.timers[i].elem === el && (!prop || prop === H.timers[i].prop)) {
		            H.timers[i].stopped = true; // #4667
		        }
		    }
		};

		/**
		 * Iterate over an array.
		 *
		 * @function Highcharts.each<T>
		 *
		 * @param {Array<T>} arr
		 *        The array to iterate over.
		 *
		 * @param {Highcharts.EachCallbackFunction<T>} fn
		 *        The iterator callback. It passes three arguments:
		 *        * item - The array item.
		 *        * index - The item's index in the array.
		 *        * arr - The array that each is being applied to.
		 *
		 * @param {*} [ctx]
		 *        The context.
		 */
		H.each = function (arr, fn, ctx) { // modern browsers
		    return (H.forEachPolyfill || Array.prototype.forEach).call(arr, fn, ctx);
		};

		/**
		 * Iterate over object key pairs in an object.
		 *
		 * @function Highcharts.objectEach
		 *
		 * @param {*} obj
		 *        The object to iterate over.
		 *
		 * @param {Highcharts.ObjectEachCallbackFunction} fn
		 *        The iterator callback. It passes three arguments:
		 *        * value - The property value.
		 *        * key - The property key.
		 *        * obj - The object that objectEach is being applied to.
		 *
		 * @param {*} [ctx]
		 *        The context.
		 */
		H.objectEach = function (obj, fn, ctx) {
		    for (var key in obj) {
		        if (obj.hasOwnProperty(key)) {
		            fn.call(ctx || obj[key], obj[key], key, obj);
		        }
		    }
		};

		/**
		 * Add an event listener.
		 *
		 * @function Highcharts.addEvent
		 *
		 * @param {*} el
		 *        The element or object to add a listener to. It can be a
		 *        {@link HTMLDOMElement}, an {@link SVGElement} or any other object.
		 *
		 * @param {string} type
		 *        The event type.
		 *
		 * @param {Highcharts.EventCallbackFunction} fn
		 *        The function callback to execute when the event is fired.
		 *
		 * @param {Highcharts.Dictionary<*>} options
		 *        Event options
		 *
		 * @param {number} options.order
		 *        The order the event handler should be called. This opens for having
		 *        one handler be called before another, independent of in which order
		 *        they were added.
		 *
		 * @return {Function}
		 *         A callback function to remove the added event.
		 */
		H.addEvent = function (el, type, fn, options) {

		    var events,
		        addEventListener = el.addEventListener || H.addEventListenerPolyfill;

		    // If we're setting events directly on the constructor, use a separate
		    // collection, `protoEvents` to distinguish it from the item events in
		    // `hcEvents`.
		    if (typeof el === 'function' && el.prototype) {
		        events = el.prototype.protoEvents = el.prototype.protoEvents || {};
		    } else {
		        events = el.hcEvents = el.hcEvents || {};
		    }

		    // Allow click events added to points, otherwise they will be prevented by
		    // the TouchPointer.pinch function after a pinch zoom operation (#7091).
		    if (H.Point && el instanceof H.Point && el.series && el.series.chart) {
		        el.series.chart.runTrackerClick = true;
		    }

		    // Handle DOM events
		    if (addEventListener) {
		        addEventListener.call(el, type, fn, false);
		    }

		    if (!events[type]) {
		        events[type] = [];
		    }

		    events[type].push(fn);

		    // Order the calls
		    if (options && H.isNumber(options.order)) {
		        fn.order = options.order;
		        events[type].sort(function (a, b) {
		            return a.order - b.order;
		        });
		    }

		    // Return a function that can be called to remove this event.
		    return function () {
		        H.removeEvent(el, type, fn);
		    };
		};

		/**
		 * Remove an event that was added with {@link Highcharts#addEvent}.
		 *
		 * @function Highcharts.removeEvent
		 *
		 * @param {*} el
		 *        The element to remove events on.
		 *
		 * @param {string} [type]
		 *        The type of events to remove. If undefined, all events are removed
		 *        from the element.
		 *
		 * @param {Function} [fn]
		 *        The specific callback to remove. If undefined, all events that match
		 *        the element and optionally the type are removed.
		 */
		H.removeEvent = function (el, type, fn) {

		    var events,
		        index;

		    function removeOneEvent(type, fn) {
		        var removeEventListener =
		            el.removeEventListener || H.removeEventListenerPolyfill;

		        if (removeEventListener) {
		            removeEventListener.call(el, type, fn, false);
		        }
		    }

		    function removeAllEvents(eventCollection) {
		        var types,
		            len;

		        if (!el.nodeName) {
		            return; // break on non-DOM events
		        }

		        if (type) {
		            types = {};
		            types[type] = true;
		        } else {
		            types = eventCollection;
		        }

		        H.objectEach(types, function (val, n) {
		            if (eventCollection[n]) {
		                len = eventCollection[n].length;
		                while (len--) {
		                    removeOneEvent(n, eventCollection[n][len]);
		                }
		            }
		        });
		    }

		    H.each(['protoEvents', 'hcEvents'], function (coll) {
		        var eventCollection = el[coll];
		        if (eventCollection) {
		            if (type) {
		                events = eventCollection[type] || [];
		                if (fn) {
		                    index = H.inArray(fn, events);
		                    if (index > -1) {
		                        events.splice(index, 1);
		                        eventCollection[type] = events;
		                    }
		                    removeOneEvent(type, fn);

		                } else {
		                    removeAllEvents(eventCollection);
		                    eventCollection[type] = [];
		                }
		            } else {
		                removeAllEvents(eventCollection);
		                el[coll] = {};
		            }
		        }
		    });
		};

		/**
		 * Fire an event that was registered with {@link Highcharts#addEvent}.
		 *
		 * @function Highcharts.fireEvent
		 *
		 * @param {*} el
		 *        The object to fire the event on. It can be a {@link HTMLDOMElement},
		 *        an {@link SVGElement} or any other object.
		 *
		 * @param {string} type
		 *        The type of event.
		 *
		 * @param {Highcharts.Dictionary<*>} [eventArguments]
		 *        Custom event arguments that are passed on as an argument to the event
		 *        handler.
		 *
		 * @param {Function} [defaultFunction]
		 *        The default function to execute if the other listeners haven't
		 *        returned false.
		 */
		H.fireEvent = function (el, type, eventArguments, defaultFunction) {
		    var e,
		        events,
		        len,
		        i,
		        fn;

		    eventArguments = eventArguments || {};

		    if (doc.createEvent && (el.dispatchEvent || el.fireEvent)) {
		        e = doc.createEvent('Events');
		        e.initEvent(type, true, true);

		        H.extend(e, eventArguments);

		        if (el.dispatchEvent) {
		            el.dispatchEvent(e);
		        } else {
		            el.fireEvent(type, e);
		        }

		    } else {

		        H.each(['protoEvents', 'hcEvents'], function (coll) {

		            if (el[coll]) {
		                events = el[coll][type] || [];
		                len = events.length;

		                if (!eventArguments.target) { // We're running a custom event

		                    H.extend(eventArguments, {
		                        // Attach a simple preventDefault function to skip
		                        // default handler if called. The built-in
		                        // defaultPrevented property is not overwritable (#5112)
		                        preventDefault: function () {
		                            eventArguments.defaultPrevented = true;
		                        },
		                        // Setting target to native events fails with clicking
		                        // the zoom-out button in Chrome.
		                        target: el,
		                        // If the type is not set, we're running a custom event
		                        // (#2297). If it is set, we're running a browser event,
		                        // and setting it will cause en error in IE8 (#2465).
		                        type: type
		                    });
		                }


		                for (i = 0; i < len; i++) {
		                    fn = events[i];

		                    // If the event handler return false, prevent the default
		                    // handler from executing
		                    if (fn && fn.call(el, eventArguments) === false) {
		                        eventArguments.preventDefault();
		                    }
		                }
		            }
		        });
		    }

		    // Run the default if not prevented
		    if (defaultFunction && !eventArguments.defaultPrevented) {
		        defaultFunction.call(el, eventArguments);
		    }
		};

		/**
		 * The global animate method, which uses Fx to create individual animators.
		 *
		 * @function Highcharts.animate
		 *
		 * @param {Highcharts.HTMLDOMElement|Highcharts.SVGElement} el
		 *        The element to animate.
		 *
		 * @param {Highcharts.HTMLAttributes|Highcharts.SVGAttributes} params
		 *        An object containing key-value pairs of the properties to animate.
		 *        Supports numeric as pixel-based CSS properties for HTML objects and
		 *        attributes for SVGElements.
		 *
		 * @param {Highcharts.AnimationOptionsObject} [opt]
		 *        Animation options.
		 */
		H.animate = function (el, params, opt) {
		    var start,
		        unit = '',
		        end,
		        fx,
		        args;

		    if (!H.isObject(opt)) { // Number or undefined/null
		        args = arguments;
		        opt = {
		            duration: args[2],
		            easing: args[3],
		            complete: args[4]
		        };
		    }
		    if (!H.isNumber(opt.duration)) {
		        opt.duration = 400;
		    }
		    opt.easing = typeof opt.easing === 'function' ?
		        opt.easing :
		        (Math[opt.easing] || Math.easeInOutSine);
		    opt.curAnim = H.merge(params);

		    H.objectEach(params, function (val, prop) {
		        // Stop current running animation of this property
		        H.stop(el, prop);

		        fx = new H.Fx(el, opt, prop);
		        end = null;

		        if (prop === 'd') {
		            fx.paths = fx.initPath(
		                el,
		                el.d,
		                params.d
		            );
		            fx.toD = params.d;
		            start = 0;
		            end = 1;
		        } else if (el.attr) {
		            start = el.attr(prop);
		        } else {
		            start = parseFloat(H.getStyle(el, prop)) || 0;
		            if (prop !== 'opacity') {
		                unit = 'px';
		            }
		        }

		        if (!end) {
		            end = val;
		        }
		        if (end && end.match && end.match('px')) {
		            end = end.replace(/px/g, ''); // #4351
		        }
		        fx.run(start, end, unit);
		    });
		};

		/**
		 * Factory to create new series prototypes.
		 *
		 * @function Highcharts.seriesType
		 *
		 * @param {string} type
		 *        The series type name.
		 *
		 * @param {string} parent
		 *        The parent series type name. Use `line` to inherit from the basic
		 *        {@link Series} object.
		 *
		 * @param {*} options
		 *        The additional default options that is merged with the parent's
		 *        options.
		 *
		 * @param {*} props
		 *        The properties (functions and primitives) to set on the new
		 *        prototype.
		 *
		 * @param {*} [pointProps]
		 *        Members for a series-specific extension of the {@link Point}
		 *        prototype if needed.
		 *
		 * @return {Highcharts.Series}
		 *         The newly created prototype as extended from {@link Series} or its
		 *         derivatives.
		 */
		// docs: add to API + extending Highcharts
		H.seriesType = function (type, parent, options, props, pointProps) {
		    var defaultOptions = H.getOptions(),
		        seriesTypes = H.seriesTypes;

		    // Merge the options
		    defaultOptions.plotOptions[type] = H.merge(
		        defaultOptions.plotOptions[parent],
		        options
		    );

		    // Create the class
		    seriesTypes[type] = H.extendClass(seriesTypes[parent] ||
		        function () {}, props);
		    seriesTypes[type].prototype.type = type;

		    // Create the point class if needed
		    if (pointProps) {
		        seriesTypes[type].prototype.pointClass =
		            H.extendClass(H.Point, pointProps);
		    }

		    return seriesTypes[type];
		};

		/**
		 * Get a unique key for using in internal element id's and pointers. The key is
		 * composed of a random hash specific to this Highcharts instance, and a
		 * counter.
		 *
		 * @example
		 * var id = H.uniqueKey(); // => 'highcharts-x45f6hp-0'
		 *
		 * @function Highcharts.uniqueKey
		 *
		 * @return {string}
		 *         A unique key.
		 */
		H.uniqueKey = (function () {

		    var uniqueKeyHash = Math.random().toString(36).substring(2, 9),
		        idCounter = 0;

		    return function () {
		        return 'highcharts-' + uniqueKeyHash + '-' + idCounter++;
		    };
		}());

		// Register Highcharts as a plugin in jQuery
		if (win.jQuery) {

		    /**
		     * Highcharts-extended JQuery.
		     *
		     * @external JQuery
		     */

		    /**
		     * Factory function to create a chart in the current JQuery selector
		     * element.
		     *
		     * @function external:JQuery#highcharts
		     *
		     * @param {"Chart"|"Map"|"StockChart"|string} [className]
		     *        Name of the factory class in the Highcharts namespace.
		     *
		     * @param {Highcharts.Options} options
		     *        The chart options structure.
		     *
		     * @param {Highcharts.ChartCallbackFunction} [callback]
		     *        Function to run when the chart has loaded and and all external
		     *        images are loaded. Defining a [chart.event.load
		     *        ](https://api.highcharts.com/highcharts/chart.events.load) handler
		     *        is equivalent.
		     *
		     * @return {JQuery}
		     *         The current JQuery selector.
		     */
		    win.jQuery.fn.highcharts = function () {
		        var args = [].slice.call(arguments);

		        if (this[0]) { // this[0] is the renderTo div

		            // Create the chart
		            if (args[0]) {
		                new H[ // eslint-disable-line no-new
		                    // Constructor defaults to Chart
		                    H.isString(args[0]) ? args.shift() : 'Chart'
		                ](this[0], args[0], args[1]);
		                return this;
		            }

		            // When called without parameters or with the return argument,
		            // return an existing chart
		            return charts[H.attr(this[0], 'data-highcharts-chart')];
		        }
		    };
		}

	}(Highcharts));
	(function (H) {
		/**
		 * (c) 2010-2018 Torstein Honsi
		 *
		 * License: www.highcharts.com/license
		 */

		/**
		 * A valid color to be parsed and handled by Highcharts. Highcharts internally
		 * supports hex colors like `#ffffff`, rgb colors like `rgb(255,255,255)` and
		 * rgba colors like `rgba(255,255,255,1)`. Other colors may be supported by the
		 * browsers and displayed correctly, but Highcharts is not able to process them
		 * and apply concepts like opacity and brightening.
		 *
		 * @typedef {string} Highcharts.ColorString
		 */



		var each = H.each,
		    isNumber = H.isNumber,
		    map = H.map,
		    merge = H.merge,
		    pInt = H.pInt;

		/**
		 * Handle color operations. The object methods are chainable.
		 *
		 * @private
		 * @class
		 * @name Highcharts.Color
		 *
		 * @param {Highcharts.ColorString} input
		 *        The input color in either rbga or hex format
		 */
		H.Color = function (input) {
		    // Backwards compatibility, allow instanciation without new
		    if (!(this instanceof H.Color)) {
		        return new H.Color(input);
		    }
		    // Initialize
		    this.init(input);
		};
		H.Color.prototype = {

		    // Collection of parsers. This can be extended from the outside by pushing
		    // parsers to Highcharts.Color.prototype.parsers.
		    parsers: [{
		        // RGBA color
		        regex: /rgba\(\s*([0-9]{1,3})\s*,\s*([0-9]{1,3})\s*,\s*([0-9]{1,3})\s*,\s*([0-9]?(?:\.[0-9]+)?)\s*\)/, // eslint-disable-line security/detect-unsafe-regex
		        parse: function (result) {
		            return [
		                pInt(result[1]),
		                pInt(result[2]),
		                pInt(result[3]),
		                parseFloat(result[4], 10)
		            ];
		        }
		    }, {
		        // RGB color
		        regex:
		            /rgb\(\s*([0-9]{1,3})\s*,\s*([0-9]{1,3})\s*,\s*([0-9]{1,3})\s*\)/,
		        parse: function (result) {
		            return [pInt(result[1]), pInt(result[2]), pInt(result[3]), 1];
		        }
		    }],

		    // Collection of named colors. Can be extended from the outside by adding
		    // colors to Highcharts.Color.prototype.names.
		    names: {
		        white: '#ffffff',
		        black: '#000000'
		    },

		    /**
		     * Parse the input color to rgba array
		     *
		     * @private
		     * @function Highcharts.Color#init
		     *
		     * @param {Highcharts.ColorString} input
		     *        The input color in either rbga or hex format
		     */
		    init: function (input) {
		        var result,
		            rgba,
		            i,
		            parser,
		            len;

		        this.input = input = this.names[
		                                input && input.toLowerCase ?
		                                    input.toLowerCase() :
		                                    ''
		                            ] || input;

		        // Gradients
		        if (input && input.stops) {
		            this.stops = map(input.stops, function (stop) {
		                return new H.Color(stop[1]);
		            });

		        // Solid colors
		        } else {

		            // Bitmasking as input[0] is not working for legacy IE.
		            if (input && input.charAt && input.charAt() === '#') {

		                len = input.length;
		                input = parseInt(input.substr(1), 16);

		                // Handle long-form, e.g. #AABBCC
		                if (len === 7) {

		                    rgba = [
		                        (input & 0xFF0000) >> 16,
		                        (input & 0xFF00) >> 8,
		                        (input & 0xFF),
		                        1
		                    ];

		                // Handle short-form, e.g. #ABC
		                // In short form, the value is assumed to be the same
		                // for both nibbles for each component. e.g. #ABC = #AABBCC
		                } else if (len === 4) {

		                    rgba = [
		                        ((input & 0xF00) >> 4) | (input & 0xF00) >> 8,
		                        ((input & 0xF0) >> 4) | (input & 0xF0),
		                        ((input & 0xF) << 4) | (input & 0xF),
		                        1
		                    ];
		                }
		            }

		            // Otherwise, check regex parsers
		            if (!rgba) {
		                i = this.parsers.length;
		                while (i-- && !rgba) {
		                    parser = this.parsers[i];
		                    result = parser.regex.exec(input);
		                    if (result) {
		                        rgba = parser.parse(result);
		                    }
		                }
		            }
		        }
		        this.rgba = rgba || [];
		    },

		    /**
		     * Return the color in the specified format
		     *
		     * @function Highcharts.Color#get
		     *
		     * @param {string} format
		     *        Possible values are 'a', 'rgb', undefined
		     *
		     * @return {Highcharts.ColorString}
		     *         This color as a string.
		     */
		    get: function (format) {
		        var input = this.input,
		            rgba = this.rgba,
		            ret;

		        if (this.stops) {
		            ret = merge(input);
		            ret.stops = [].concat(ret.stops);
		            each(this.stops, function (stop, i) {
		                ret.stops[i] = [ret.stops[i][0], stop.get(format)];
		            });

		        // it's NaN if gradient colors on a column chart
		        } else if (rgba && isNumber(rgba[0])) {
		            if (format === 'rgb' || (!format && rgba[3] === 1)) {
		                ret = 'rgb(' + rgba[0] + ',' + rgba[1] + ',' + rgba[2] + ')';
		            } else if (format === 'a') {
		                ret = rgba[3];
		            } else {
		                ret = 'rgba(' + rgba.join(',') + ')';
		            }
		        } else {
		            ret = input;
		        }
		        return ret;
		    },

		    /**
		     * Brighten the color instance.
		     *
		     * @function Highcharts.Color#brighten
		     *
		     * @param {number} alpha
		     *        The alpha value.
		     *
		     * @return {Highcharts.ColorString}
		     *         This color with modifications.
		     */
		    brighten: function (alpha) {
		        var i,
		            rgba = this.rgba;

		        if (this.stops) {
		            each(this.stops, function (stop) {
		                stop.brighten(alpha);
		            });

		        } else if (isNumber(alpha) && alpha !== 0) {
		            for (i = 0; i < 3; i++) {
		                rgba[i] += pInt(alpha * 255);

		                if (rgba[i] < 0) {
		                    rgba[i] = 0;
		                }
		                if (rgba[i] > 255) {
		                    rgba[i] = 255;
		                }
		            }
		        }
		        return this;
		    },

		    /**
		     * Set the color's opacity to a given alpha value.
		     *
		     * @function Highcharts.Color#setOpacity
		     *
		     * @param {number} alpha
		     *        Opacity between 0 and 1.
		     *
		     * @return {Highcharts.ColorString}
		     *         Color with modifications.
		     */
		    setOpacity: function (alpha) {
		        this.rgba[3] = alpha;
		        return this;
		    },

		    /**
		     * Return an intermediate color between two colors.
		     *
		     * @function Highcharts.Color#tweenTo
		     *
		     * @param {Highcharts.Color} to
		     *        The color object to tween to.
		     *
		     * @param {number} pos
		     *        The intermediate position, where 0 is the from color (current
		     *        color item), and 1 is the `to` color.
		     *
		     * @return {Highcharts.ColorString}
		     *         The intermediate color in rgba notation.
		     */
		    tweenTo: function (to, pos) {
		        // Check for has alpha, because rgba colors perform worse due to lack of
		        // support in WebKit.
		        var fromRgba = this.rgba,
		            toRgba = to.rgba,
		            hasAlpha,
		            ret;

		        // Unsupported color, return to-color (#3920, #7034)
		        if (!toRgba.length || !fromRgba || !fromRgba.length) {
		            ret = to.input || 'none';

		        // Interpolate
		        } else {
		            hasAlpha = (toRgba[3] !== 1 || fromRgba[3] !== 1);
		            ret = (hasAlpha ? 'rgba(' : 'rgb(') +
		                Math.round(toRgba[0] + (fromRgba[0] - toRgba[0]) * (1 - pos)) +
		                ',' +
		                Math.round(toRgba[1] + (fromRgba[1] - toRgba[1]) * (1 - pos)) +
		                ',' +
		                Math.round(toRgba[2] + (fromRgba[2] - toRgba[2]) * (1 - pos)) +
		                (
		                    hasAlpha ?
		                        (
		                            ',' +
		                            (toRgba[3] + (fromRgba[3] - toRgba[3]) * (1 - pos))
		                        ) :
		                        ''
		                ) +
		                ')';
		        }
		        return ret;
		    }
		};

		/**
		 * Creates a color instance out of a color string.
		 *
		 * @private
		 * @function Highcharts.color
		 *
		 * @param {Highcharts.ColorString} input
		 *        The input color in either rbga or hex format
		 */
		H.color = function (input) {
		    return new H.Color(input);
		};

	}(Highcharts));
	(function (H) {
		/**
		 * (c) 2010-2018 Torstein Honsi
		 *
		 * License: www.highcharts.com/license
		 */

		/**
		 * Options to align the element relative to the chart or another box.
		 *
		 * @typedef Highcharts.AlignObject
		 *
		 * @property {string} [align='left']
		 *           Horizontal alignment. Can be one of `left`, `center` and
		 *           `right`.
		 *
		 * @property {string} [verticalAlign='top']
		 *           Vertical alignment. Can be one of `top`, `middle` and `bottom`.
		 *
		 * @property {number} [x=0]
		 *           Horizontal pixel offset from alignment.
		 *
		 * @property {number} [y=0]
		 *           Vertical pixel offset from alignment.
		 *
		 * @property {boolean} [alignByTranslate=false]
		 *           Use the `transform` attribute with translateX and translateY
		 *           custom attributes to align this elements rather than `x` and
		 *           `y` attributes.
		 */

		/**
		 * Bounding box of an element.
		 *
		 * @typedef Highcharts.BBoxObject
		 *
		 * @property {number} height
		 *           Height of the bounding box.
		 *
		 * @property {number} width
		 *           Width of the bounding box.
		 *
		 * @property {number} x
		 *           Horizontal position of the bounding box.
		 *
		 * @property {number} y
		 *           Vertical position of the bounding box.
		 */

		/**
		 * A clipping rectangle that can be applied to one or more
		 * {@link SVGElement} instances. It is instanciated with the
		 * {@link SVGRenderer#clipRect} function and applied with the
		 * {@link SVGElement#clip} function.
		 *
		 * @example
		 * var circle = renderer.circle(100, 100, 100)
		 *     .attr({ fill: 'red' })
		 *     .add();
		 * var clipRect = renderer.clipRect(100, 100, 100, 100);
		 *
		 * // Leave only the lower right quarter visible
		 * circle.clip(clipRect);
		 *
		 * @typedef {Highcharts.SVGElement} Highcharts.ClipRectElement
		 */

		/**
		 * The font metrics.
		 *
		 * @typedef Highcharts.FontMetricsObject
		 *
		 * @property {number} b
		 *           The baseline relative to the top of the box.
		 *
		 * @property {number} h
		 *           The line height.
		 *
		 * @property {number} f
		 *           The font size.
		 */

		/**
		 * Gradient options instead of a solid color.
		 *
		 * @example
		 * // Linear gradient used as a color option
		 * color: {
		 *     linearGradient: { x1: 0, x2: 0, y1: 0, y2: 1 },
		 *         stops: [
		 *             [0, '#003399'], // start
		 *             [0.5, '#ffffff'], // middle
		 *             [1, '#3366AA'] // end
		 *         ]
		 *     }
		 * }
		 *
		 * @private
		 * @typedef Highcharts.GradientColorObject
		 *
		 * @property {Highcharts.LinearGradientColorObject} linearGradient
		 *           Holds an object that defines the start position and the end
		 *           position relative to the shape.
		 *
		 * @property {Highcharts.RadialGradientColorObject} radialGradient
		 *           Holds an object that defines the center position and the
		 *           radius.
		 *
		 * @property {Array<Array<number|string>>} stops
		 *           The first item in each tuple is the position in the gradient,
		 *           where 0 is the start of the gradient and 1 is the end of the
		 *           gradient. Multiple stops can be applied. The second item is the
		 *           color for each stop. This color can also be given in the rgba
		 *           format.
		 */

		/**
		 * Defines the start position and the end position for a gradient relative
		 * to the shape.
		 *
		 * @private
		 * @typedef Highcharts.LinearGradientColorObject
		 *
		 * @property {number} x1
		 *           Start horizontal position of the gradient. Ranges 0-1.
		 *
		 * @property {number} x2
		 *           End horizontal position of the gradient. Ranges 0-1.
		 *
		 * @property {number} y1
		 *           Start vertical position of the gradient. Ranges 0-1.
		 *
		 * @property {number} y2
		 *           End vertical position of the gradient. Ranges 0-1.
		 */

		/**
		 * Defines the center position and the radius for a gradient.
		 *
		 * @private
		 * @typedef Highcharts.RadialGradientColorObject
		 *
		 * @property {number} cx
		 *           Center horizontal position relative to the shape. Ranges 0-1.
		 *
		 * @property {number} cy
		 *           Center vertical position relative to the shape. Ranges 0-1.
		 *
		 * @property {number} r
		 *           Radius relative to the shape. Ranges 0-1.
		 */

		/**
		 * A rectangle.
		 *
		 * @typedef Highcharts.RectangleObject
		 *
		 * @property {number} height
		 *           Height of the rectangle.
		 *
		 * @property {number} width
		 *           Width of the rectangle.
		 *
		 * @property {number} x
		 *           Horizontal position of the rectangle.
		 *
		 * @property {number} y
		 *           Vertical position of the rectangle.
		 */

		/**
		 * The shadow options.
		 *
		 * @typedef Highcharts.ShadowOptionsObject
		 *
		 * @property {string} [color=#000000]
		 *           The shadow color.
		 *
		 * @property {number} [offsetX=1]
		 *           The horizontal offset from the element.
		 *
		 * @property {number} [offsetY=1]
		 *           The vertical offset from the element.
		 *
		 * @property {number} [opacity=0.15]
		 *           The shadow opacity.
		 *
		 * @property {number} [width=3]
		 *           The shadow width or distance from the element.
		 */

		/**
		 * Serialized form of an SVG definition, including children. Some key
		 * property names are reserved: tagName, textContent, and children.
		 *
		 * @typedef Highcharts.SVGDefinitionObject
		 *
		 * @property {number|string|Array<Highcharts.SVGDefinitionObject>|undefined} [key:string]
		 *
		 * @property {Array<Highcharts.SVGDefinitionObject>} [children]
		 *
		 * @property {string} [tagName]
		 *
		 * @property {string} [textContent]
		 */

		/**
		 * An extendable collection of functions for defining symbol paths.
		 *
		 * @typedef Highcharts.SymbolDictionary
		 *
		 * @property {Function} [key:Highcharts.SymbolKey]
		 */

		/**
		 * Can be one of `arc`, `callout`, `circle`, `diamond`, `square`,
		 * `triangle`, `triangle-down`. Symbols are used internally for point
		 * markers, button and label borders and backgrounds, or custom shapes.
		 * Extendable by adding to {@link SVGRenderer#symbols}.
		 *
		 * @typedef {string} Highcharts.SymbolKey
		 *
		 * @validvalue ["arc", "callout", "circle", "diamond", "square", "triangle",
		 *             "triangle-down"]
		 */

		/**
		 * Additional options, depending on the actual symbol drawn.
		 *
		 * @typedef Highcharts.SymbolOptionsObject
		 *
		 * @property {number} anchorX
		 *           The anchor X position for the `callout` symbol. This is where
		 *           the chevron points to.
		 *
		 * @property {number} anchorY
		 *           The anchor Y position for the `callout` symbol. This is where
		 *           the chevron points to.
		 *
		 * @property {number} end
		 *           The end angle of an `arc` symbol.
		 *
		 * @property {boolean} open
		 *           Whether to draw `arc` symbol open or closed.
		 *
		 * @property {number} r
		 *           The radius of an `arc` symbol, or the border radius for the
		 *           `callout` symbol.
		 *
		 * @property {number} start
		 *           The start angle of an `arc` symbol.
		 */



		var SVGElement,
		    SVGRenderer,

		    addEvent = H.addEvent,
		    animate = H.animate,
		    attr = H.attr,
		    charts = H.charts,
		    color = H.color,
		    css = H.css,
		    createElement = H.createElement,
		    defined = H.defined,
		    deg2rad = H.deg2rad,
		    destroyObjectProperties = H.destroyObjectProperties,
		    doc = H.doc,
		    each = H.each,
		    extend = H.extend,
		    erase = H.erase,
		    grep = H.grep,
		    hasTouch = H.hasTouch,
		    inArray = H.inArray,
		    isArray = H.isArray,
		    isFirefox = H.isFirefox,
		    isMS = H.isMS,
		    isObject = H.isObject,
		    isString = H.isString,
		    isWebKit = H.isWebKit,
		    merge = H.merge,
		    noop = H.noop,
		    objectEach = H.objectEach,
		    pick = H.pick,
		    pInt = H.pInt,
		    removeEvent = H.removeEvent,
		    splat = H.splat,
		    stop = H.stop,
		    svg = H.svg,
		    SVG_NS = H.SVG_NS,
		    symbolSizes = H.symbolSizes,
		    win = H.win;

		/**
		 * The SVGElement prototype is a JavaScript wrapper for SVG elements used in the
		 * rendering layer of Highcharts. Combined with the {@link
		 * Highcharts.SVGRenderer} object, these prototypes allow freeform annotation
		 * in the charts or even in HTML pages without instanciating a chart. The
		 * SVGElement can also wrap HTML labels, when `text` or `label` elements are
		 * created with the `useHTML` parameter.
		 *
		 * The SVGElement instances are created through factory functions on the
		 * {@link Highcharts.SVGRenderer} object, like
		 * [rect]{@link Highcharts.SVGRenderer#rect}, [path]{@link
		 * Highcharts.SVGRenderer#path}, [text]{@link Highcharts.SVGRenderer#text},
		 * [label]{@link Highcharts.SVGRenderer#label}, [g]{@link
		 * Highcharts.SVGRenderer#g} and more.
		 *
		 * @class
		 * @name Highcharts.SVGElement
		 */
		SVGElement = H.SVGElement = function () {
		    return this;
		};
		extend(SVGElement.prototype, /** @lends Highcharts.SVGElement.prototype */ {

		    // Default base for animation
		    opacity: 1,
		    SVG_NS: SVG_NS,

		    /**
		     * For labels, these CSS properties are applied to the `text` node directly.
		     *
		     * @private
		     * @name Highcharts.SVGElement#textProps
		     * @type {Array<string>}
		     */
		    textProps: ['direction', 'fontSize', 'fontWeight', 'fontFamily',
		        'fontStyle', 'color', 'lineHeight', 'width', 'textAlign',
		        'textDecoration', 'textOverflow', 'textOutline', 'cursor'],

		    /**
		     * Initialize the SVG element. This function only exists to make the
		     * initiation process overridable. It should not be called directly.
		     *
		     * @function Highcharts.SVGElement#init
		     *
		     * @param {Highcharts.SVGRenderer} renderer
		     *        The SVGRenderer instance to initialize to.
		     *
		     * @param {string} nodeName
		     *        The SVG node name.
		     */
		    init: function (renderer, nodeName) {

		        /**
		         * The primary DOM node. Each `SVGElement` instance wraps a main DOM
		         * node, but may also represent more nodes.
		         *
		         * @name Highcharts.SVGElement#element
		         * @type {Highcharts.SVGDOMElement|Highcharts.HTMLDOMElement}
		         */
		        this.element = nodeName === 'span' ?
		            createElement(nodeName) :
		            doc.createElementNS(this.SVG_NS, nodeName);

		        /**
		         * The renderer that the SVGElement belongs to.
		         *
		         * @name Highcharts.SVGElement#renderer
		         * @type {Highcharts.SVGRenderer}
		         */
		        this.renderer = renderer;
		    },

		    /**
		     * Animate to given attributes or CSS properties.
		     *
		     * @sample highcharts/members/element-on/
		     *         Setting some attributes by animation
		     *
		     * @function Highcharts.SVGElement#animate
		     *
		     * @param {Highcharts.SVGAttributes} params
		     *        SVG attributes or CSS to animate.
		     *
		     * @param {Highcharts.AnimationOptionsObject} [options]
		     *        Animation options.
		     *
		     * @param {Function} [complete]
		     *        Function to perform at the end of animation.
		     *
		     * @return {Highcharts.SVGElement}
		     *         Returns the SVGElement for chaining.
		     */
		    animate: function (params, options, complete) {
		        var animOptions = H.animObject(
		            pick(options, this.renderer.globalAnimation, true)
		        );
		        if (animOptions.duration !== 0) {
		            // allows using a callback with the global animation without
		            // overwriting it
		            if (complete) {
		                animOptions.complete = complete;
		            }
		            animate(this, params, animOptions);
		        } else {
		            this.attr(params, null, complete);
		            if (animOptions.step) {
		                animOptions.step.call(this);
		            }
		        }
		        return this;
		    },

		    /**
		     * Build and apply an SVG gradient out of a common JavaScript configuration
		     * object. This function is called from the attribute setters. An event
		     * hook is added for supporting other complex color types.
		     *
		     * @private
		     * @function Highcharts.SVGElement#complexColor
		     *
		     * @param {Highcharts.GradientColorObject} color
		     *        The gradient options structure.
		     *
		     * @param {string} prop
		     *        The property to apply, can either be `fill` or `stroke`.
		     *
		     * @param {Highcharts.SVGDOMElement} elem
		     *        SVG DOM element to apply the gradient on.
		     */
		    complexColor: function (color, prop, elem) {
		        var renderer = this.renderer,
		            colorObject,
		            gradName,
		            gradAttr,
		            radAttr,
		            gradients,
		            gradientObject,
		            stops,
		            stopColor,
		            stopOpacity,
		            radialReference,
		            id,
		            key = [],
		            value;

		        H.fireEvent(this.renderer, 'complexColor', {
		            args: arguments
		        }, function () {
		            // Apply linear or radial gradients
		            if (color.radialGradient) {
		                gradName = 'radialGradient';
		            } else if (color.linearGradient) {
		                gradName = 'linearGradient';
		            }

		            if (gradName) {
		                gradAttr = color[gradName];
		                gradients = renderer.gradients;
		                stops = color.stops;
		                radialReference = elem.radialReference;

		                // Keep < 2.2 kompatibility
		                if (isArray(gradAttr)) {
		                    color[gradName] = gradAttr = {
		                        x1: gradAttr[0],
		                        y1: gradAttr[1],
		                        x2: gradAttr[2],
		                        y2: gradAttr[3],
		                        gradientUnits: 'userSpaceOnUse'
		                    };
		                }

		                // Correct the radial gradient for the radial reference system
		                if (
		                    gradName === 'radialGradient' &&
		                    radialReference &&
		                    !defined(gradAttr.gradientUnits)
		                ) {
		                    // Save the radial attributes for updating
		                    radAttr = gradAttr;
		                    gradAttr = merge(
		                        gradAttr,
		                        renderer.getRadialAttr(radialReference, radAttr),
		                        { gradientUnits: 'userSpaceOnUse' }
		                    );
		                }

		                // Build the unique key to detect whether we need to create a
		                // new element (#1282)
		                objectEach(gradAttr, function (val, n) {
		                    if (n !== 'id') {
		                        key.push(n, val);
		                    }
		                });
		                objectEach(stops, function (val) {
		                    key.push(val);
		                });
		                key = key.join(',');

		                // Check if a gradient object with the same config object is
		                // created within this renderer
		                if (gradients[key]) {
		                    id = gradients[key].attr('id');

		                } else {

		                    // Set the id and create the element
		                    gradAttr.id = id = H.uniqueKey();
		                    gradients[key] = gradientObject =
		                        renderer.createElement(gradName)
		                            .attr(gradAttr)
		                            .add(renderer.defs);

		                    gradientObject.radAttr = radAttr;

		                    // The gradient needs to keep a list of stops to be able to
		                    // destroy them
		                    gradientObject.stops = [];
		                    each(stops, function (stop) {
		                        var stopObject;
		                        if (stop[1].indexOf('rgba') === 0) {
		                            colorObject = H.color(stop[1]);
		                            stopColor = colorObject.get('rgb');
		                            stopOpacity = colorObject.get('a');
		                        } else {
		                            stopColor = stop[1];
		                            stopOpacity = 1;
		                        }
		                        stopObject = renderer.createElement('stop').attr({
		                            offset: stop[0],
		                            'stop-color': stopColor,
		                            'stop-opacity': stopOpacity
		                        }).add(gradientObject);

		                        // Add the stop element to the gradient
		                        gradientObject.stops.push(stopObject);
		                    });
		                }

		                // Set the reference to the gradient object
		                value = 'url(' + renderer.url + '#' + id + ')';
		                elem.setAttribute(prop, value);
		                elem.gradient = key;

		                // Allow the color to be concatenated into tooltips formatters
		                // etc. (#2995)
		                color.toString = function () {
		                    return value;
		                };
		            }
		        });
		    },

		    /**
		     * Apply a text outline through a custom CSS property, by copying the text
		     * element and apply stroke to the copy. Used internally. Contrast checks at
		     * {@link https://jsfiddle.net/highcharts/43soe9m1/2/}.
		     *
		     * @example
		     * // Specific color
		     * text.css({
		     *    textOutline: '1px black'
		     * });
		     * // Automatic contrast
		     * text.css({
		     *    color: '#000000', // black text
		     *    textOutline: '1px contrast' // => white outline
		     * });
		     *
		     * @private
		     * @function Highcharts.SVGElement#applyTextOutline
		     *
		     * @param {string} textOutline
		     *        A custom CSS `text-outline` setting, defined by `width color`.
		     */
		    applyTextOutline: function (textOutline) {
		        var elem = this.element,
		            tspans,
		            tspan,
		            hasContrast = textOutline.indexOf('contrast') !== -1,
		            styles = {},
		            color,
		            strokeWidth,
		            firstRealChild,
		            i;

		        // When the text shadow is set to contrast, use dark stroke for light
		        // text and vice versa.
		        if (hasContrast) {
		            styles.textOutline = textOutline = textOutline.replace(
		                /contrast/g,
		                this.renderer.getContrast(elem.style.fill)
		            );
		        }

		        // Extract the stroke width and color
		        textOutline = textOutline.split(' ');
		        color = textOutline[textOutline.length - 1];
		        strokeWidth = textOutline[0];

		        if (strokeWidth && strokeWidth !== 'none' && H.svg) {

		            this.fakeTS = true; // Fake text shadow

		            tspans = [].slice.call(elem.getElementsByTagName('tspan'));

		            // In order to get the right y position of the clone,
		            // copy over the y setter
		            this.ySetter = this.xSetter;

		            // Since the stroke is applied on center of the actual outline, we
		            // need to double it to get the correct stroke-width outside the
		            // glyphs.
		            strokeWidth = strokeWidth.replace(
		                /(^[\d\.]+)(.*?)$/g,
		                function (match, digit, unit) {
		                    return (2 * digit) + unit;
		                }
		            );

		            // Remove shadows from previous runs. Iterate from the end to
		            // support removing items inside the cycle (#6472).
		            i = tspans.length;
		            while (i--) {
		                tspan = tspans[i];
		                if (tspan.getAttribute('class') === 'highcharts-text-outline') {
		                    // Remove then erase
		                    erase(tspans, elem.removeChild(tspan));
		                }
		            }

		            // For each of the tspans, create a stroked copy behind it.
		            firstRealChild = elem.firstChild;
		            each(tspans, function (tspan, y) {
		                var clone;

		                // Let the first line start at the correct X position
		                if (y === 0) {
		                    tspan.setAttribute('x', elem.getAttribute('x'));
		                    y = elem.getAttribute('y');
		                    tspan.setAttribute('y', y || 0);
		                    if (y === null) {
		                        elem.setAttribute('y', 0);
		                    }
		                }

		                // Create the clone and apply outline properties
		                clone = tspan.cloneNode(1);
		                attr(clone, {
		                    'class': 'highcharts-text-outline',
		                    'fill': color,
		                    'stroke': color,
		                    'stroke-width': strokeWidth,
		                    'stroke-linejoin': 'round'
		                });
		                elem.insertBefore(clone, firstRealChild);
		            });
		        }
		    },

		    /**
		     * Apply native and custom attributes to the SVG elements.
		     *
		     * In order to set the rotation center for rotation, set x and y to 0 and
		     * use `translateX` and `translateY` attributes to position the element
		     * instead.
		     *
		     * Attributes frequently used in Highcharts are `fill`, `stroke`,
		     * `stroke-width`.
		     *
		     * @sample highcharts/members/renderer-rect/
		     *         Setting some attributes
		     *
		     * @example
		     * // Set multiple attributes
		     * element.attr({
		     *     stroke: 'red',
		     *     fill: 'blue',
		     *     x: 10,
		     *     y: 10
		     * });
		     *
		     * // Set a single attribute
		     * element.attr('stroke', 'red');
		     *
		     * // Get an attribute
		     * element.attr('stroke'); // => 'red'
		     *
		     * @function Highcharts.SVGElement#attr
		     *
		     * @param {string|Highcharts.SVGAttributes} [hash]
		     *        The native and custom SVG attributes.
		     *
		     * @param {string} [val]
		     *        If the type of the first argument is `string`, the second can be a
		     *        value, which will serve as a single attribute setter. If the first
		     *        argument is a string and the second is undefined, the function
		     *        serves as a getter and the current value of the property is
		     *        returned.
		     *
		     * @param {Function} [complete]
		     *        A callback function to execute after setting the attributes. This
		     *        makes the function compliant and interchangeable with the
		     *        {@link SVGElement#animate} function.
		     *
		     * @param {boolean} [continueAnimation=true]
		     *        Used internally when `.attr` is called as part of an animation
		     *        step. Otherwise, calling `.attr` for an attribute will stop
		     *        animation for that attribute.
		     *
		     * @return {number|string|Highcharts.SVGElement}
		     *         If used as a setter, it returns the current
		     *         {@link Highcharts.SVGElement} so the calls can be chained. If
		     *         used as a getter, the current value of the attribute is returned.
		     */
		    attr: function (hash, val, complete, continueAnimation) {
		        var key,
		            element = this.element,
		            hasSetSymbolSize,
		            ret = this,
		            skipAttr,
		            setter;

		        // single key-value pair
		        if (typeof hash === 'string' && val !== undefined) {
		            key = hash;
		            hash = {};
		            hash[key] = val;
		        }

		        // used as a getter: first argument is a string, second is undefined
		        if (typeof hash === 'string') {
		            ret = (this[hash + 'Getter'] || this._defaultGetter).call(
		                this,
		                hash,
		                element
		            );

		        // setter
		        } else {

		            objectEach(hash, function eachAttribute(val, key) {
		                skipAttr = false;

		                // Unless .attr is from the animator update, stop current
		                // running animation of this property
		                if (!continueAnimation) {
		                    stop(this, key);
		                }

		                // Special handling of symbol attributes
		                if (
		                    this.symbolName &&
		                    /^(x|y|width|height|r|start|end|innerR|anchorX|anchorY)$/
		                    .test(key)
		                ) {
		                    if (!hasSetSymbolSize) {
		                        this.symbolAttr(hash);
		                        hasSetSymbolSize = true;
		                    }
		                    skipAttr = true;
		                }

		                if (this.rotation && (key === 'x' || key === 'y')) {
		                    this.doTransform = true;
		                }

		                if (!skipAttr) {
		                    setter = this[key + 'Setter'] || this._defaultSetter;
		                    setter.call(this, val, key, element);


		                    // Let the shadow follow the main element
		                    if (
		                        this.shadows &&
		                        /^(width|height|visibility|x|y|d|transform|cx|cy|r)$/
		                            .test(key)
		                    ) {
		                        this.updateShadows(key, val, setter);
		                    }

		                }
		            }, this);

		            this.afterSetters();
		        }

		        // In accordance with animate, run a complete callback
		        if (complete) {
		            complete.call(this);
		        }

		        return ret;
		    },

		    /**
		     * This method is executed in the end of `attr()`, after setting all
		     * attributes in the hash. In can be used to efficiently consolidate
		     * multiple attributes in one SVG property -- e.g., translate, rotate and
		     * scale are merged in one "transform" attribute in the SVG node.
		     *
		     * @private
		     * @function Highcharts.SVGElement#afterSetters
		     */
		    afterSetters: function () {
		        // Update transform. Do this outside the loop to prevent redundant
		        // updating for batch setting of attributes.
		        if (this.doTransform) {
		            this.updateTransform();
		            this.doTransform = false;
		        }
		    },


		    /**
		     * Update the shadow elements with new attributes.
		     *
		     * @private
		     * @function Highcharts.SVGElement#updateShadows
		     *
		     * @param {string} key
		     *        The attribute name.
		     *
		     * @param {string|number} value
		     *        The value of the attribute.
		     *
		     * @param {Function} setter
		     *        The setter function, inherited from the parent wrapper.
		     */
		    updateShadows: function (key, value, setter) {
		        var shadows = this.shadows,
		            i = shadows.length;

		        while (i--) {
		            setter.call(
		                shadows[i],
		                key === 'height' ?
		                    Math.max(value - (shadows[i].cutHeight || 0), 0) :
		                    key === 'd' ? this.d : value,
		                key,
		                shadows[i]
		            );
		        }
		    },


		    /**
		     * Add a class name to an element.
		     *
		     * @function Highcharts.SVGElement#addClass
		     *
		     * @param {string} className
		     *        The new class name to add.
		     *
		     * @param {boolean} [replace=false]
		     *        When true, the existing class name(s) will be overwritten with
		     *        the new one. When false, the new one is added.
		     *
		     * @return {Highcharts.SVGElement}
		     *         Return the SVG element for chainability.
		     */
		    addClass: function (className, replace) {
		        var currentClassName = this.attr('class') || '';
		        if (currentClassName.indexOf(className) === -1) {
		            if (!replace) {
		                className =
		                    (currentClassName + (currentClassName ? ' ' : '') +
		                    className).replace('  ', ' ');
		            }
		            this.attr('class', className);
		        }

		        return this;
		    },

		    /**
		     * Check if an element has the given class name.
		     *
		     * @function Highcharts.SVGElement#hasClass
		     *
		     * @param {string} className
		     *        The class name to check for.
		     *
		     * @return {boolean}
		     *         Whether the class name is found.
		     */
		    hasClass: function (className) {
		        return inArray(
		            className,
		            (this.attr('class') || '').split(' ')
		        ) !== -1;
		    },

		    /**
		     * Remove a class name from the element.
		     *
		     * @function Highcharts.SVGElement#removeClass
		     *
		     * @param {string|RegExp} className
		     *        The class name to remove.
		     *
		     * @return {Highcharts.SVGElement} Returns the SVG element for chainability.
		     */
		    removeClass: function (className) {
		        return this.attr(
		            'class',
		            (this.attr('class') || '').replace(className, '')
		        );
		    },

		    /**
		     * If one of the symbol size affecting parameters are changed,
		     * check all the others only once for each call to an element's
		     * .attr() method
		     *
		     * @private
		     * @function Highcharts.SVGElement#symbolAttr
		     *
		     * @param {Highcharts.Dictionary<number|string>} hash
		     *        The attributes to set.
		     */
		    symbolAttr: function (hash) {
		        var wrapper = this;

		        each([
		            'x',
		            'y',
		            'r',
		            'start',
		            'end',
		            'width',
		            'height',
		            'innerR',
		            'anchorX',
		            'anchorY'
		        ], function (key) {
		            wrapper[key] = pick(hash[key], wrapper[key]);
		        });

		        wrapper.attr({
		            d: wrapper.renderer.symbols[wrapper.symbolName](
		                wrapper.x,
		                wrapper.y,
		                wrapper.width,
		                wrapper.height,
		                wrapper
		            )
		        });
		    },

		    /**
		     * Apply a clipping rectangle to this element.
		     *
		     * @function Highcharts.SVGElement#clip
		     *
		     * @param {Highcharts.ClipRectElement} [clipRect]
		     *        The clipping rectangle. If skipped, the current clip is removed.
		     *
		     * @return {Highcharts.SVGElement}
		     *         Returns the SVG element to allow chaining.
		     */
		    clip: function (clipRect) {
		        return this.attr(
		            'clip-path',
		            clipRect ?
		                'url(' + this.renderer.url + '#' + clipRect.id + ')' :
		                'none'
		        );
		    },

		    /**
		     * Calculate the coordinates needed for drawing a rectangle crisply and
		     * return the calculated attributes.
		     *
		     * @function Highcharts.SVGElement#crisp
		     *
		     * @param {Highcharts.RectangleObject} rect
		     *        Rectangle to crisp.
		     *
		     * @param {number} [strokeWidth]
		     *        The stroke width to consider when computing crisp positioning. It
		     *        can also be set directly on the rect parameter.
		     *
		     * @return {Highcharts.RectangleObject}
		     *         The modified rectangle arguments.
		     */
		    crisp: function (rect, strokeWidth) {

		        var wrapper = this,
		            normalizer;

		        strokeWidth = strokeWidth || rect.strokeWidth || 0;
		        // Math.round because strokeWidth can sometimes have roundoff errors
		        normalizer = Math.round(strokeWidth) % 2 / 2;

		        // normalize for crisp edges
		        rect.x = Math.floor(rect.x || wrapper.x || 0) + normalizer;
		        rect.y = Math.floor(rect.y || wrapper.y || 0) + normalizer;
		        rect.width = Math.floor(
		            (rect.width || wrapper.width || 0) - 2 * normalizer
		        );
		        rect.height = Math.floor(
		            (rect.height || wrapper.height || 0) - 2 * normalizer
		        );
		        if (defined(rect.strokeWidth)) {
		            rect.strokeWidth = strokeWidth;
		        }
		        return rect;
		    },

		    /**
		     * Set styles for the element. In addition to CSS styles supported by
		     * native SVG and HTML elements, there are also some custom made for
		     * Highcharts, like `width`, `ellipsis` and `textOverflow` for SVG text
		     * elements.
		     *
		     * @sample highcharts/members/renderer-text-on-chart/
		     *         Styled text
		     *
		     * @function Highcharts.SVGElement#css
		     *
		     * @param {Highcharts.CSSObject} styles
		     *        The new CSS styles.
		     *
		     * @return {Highcharts.SVGElement}
		     *         Return the SVG element for chaining.
		     */
		    css: function (styles) {
		        var oldStyles = this.styles,
		            newStyles = {},
		            elem = this.element,
		            textWidth,
		            serializedCss = '',
		            hyphenate,
		            hasNew = !oldStyles,
		            // These CSS properties are interpreted internally by the SVG
		            // renderer, but are not supported by SVG and should not be added to
		            // the DOM. In styled mode, no CSS should find its way to the DOM
		            // whatsoever (#6173, #6474).
		            svgPseudoProps = ['textOutline', 'textOverflow', 'width'];

		        // convert legacy
		        if (styles && styles.color) {
		            styles.fill = styles.color;
		        }

		        // Filter out existing styles to increase performance (#2640)
		        if (oldStyles) {
		            objectEach(styles, function (style, n) {
		                if (style !== oldStyles[n]) {
		                    newStyles[n] = style;
		                    hasNew = true;
		                }
		            });
		        }
		        if (hasNew) {

		            // Merge the new styles with the old ones
		            if (oldStyles) {
		                styles = extend(
		                    oldStyles,
		                    newStyles
		                );
		            }

		            // Get the text width from style
		            if (styles) {
		                // Previously set, unset it (#8234)
		                if (styles.width === null || styles.width === 'auto') {
		                    delete this.textWidth;

		                // Apply new
		                } else if (
		                    elem.nodeName.toLowerCase() === 'text' &&
		                    styles.width
		                ) {
		                    textWidth = this.textWidth = pInt(styles.width);
		                }
		            }

		            // store object
		            this.styles = styles;

		            if (textWidth && (!svg && this.renderer.forExport)) {
		                delete styles.width;
		            }

		            // Serialize and set style attribute
		            if (elem.namespaceURI === this.SVG_NS) { // #7633
		                hyphenate = function (a, b) {
		                    return '-' + b.toLowerCase();
		                };
		                objectEach(styles, function (style, n) {
		                    if (inArray(n, svgPseudoProps) === -1) {
		                        serializedCss +=
		                        n.replace(/([A-Z])/g, hyphenate) + ':' +
		                        style + ';';
		                    }
		                });
		                if (serializedCss) {
		                    attr(elem, 'style', serializedCss); // #1881
		                }
		            } else {
		                css(elem, styles);
		            }


		            if (this.added) {

		                // Rebuild text after added. Cache mechanisms in the buildText
		                // will prevent building if there are no significant changes.
		                if (this.element.nodeName === 'text') {
		                    this.renderer.buildText(this);
		                }

		                // Apply text outline after added
		                if (styles && styles.textOutline) {
		                    this.applyTextOutline(styles.textOutline);
		                }
		            }
		        }

		        return this;
		    },


		    /**
		     * Get the current stroke width. In classic mode, the setter registers it
		     * directly on the element.
		     *
		     * @ignore
		     * @function Highcharts.SVGElement#strokeWidth
		     *
		     * @return {number}
		     *         The stroke width in pixels.
		     */
		    strokeWidth: function () {
		        return this['stroke-width'] || 0;
		    },


		    /**
		     * Add an event listener. This is a simple setter that replaces all other
		     * events of the same type, opposed to the {@link Highcharts#addEvent}
		     * function.
		     *
		     * @sample highcharts/members/element-on/
		     *         A clickable rectangle
		     *
		     * @function Highcharts.SVGElement#on
		     *
		     * @param {string} eventType
		     *        The event type. If the type is `click`, Highcharts will internally
		     *        translate it to a `touchstart` event on touch devices, to prevent
		     *        the browser from waiting for a click event from firing.
		     *
		     * @param {Function} handler
		     *        The handler callback.
		     *
		     * @return {Highcharts.SVGElement}
		     *         The SVGElement for chaining.
		     */
		    on: function (eventType, handler) {
		        var svgElement = this,
		            element = svgElement.element;

		        // touch
		        if (hasTouch && eventType === 'click') {
		            element.ontouchstart = function (e) {
		                svgElement.touchEventFired = Date.now(); // #2269
		                e.preventDefault();
		                handler.call(element, e);
		            };
		            element.onclick = function (e) {
		                if (win.navigator.userAgent.indexOf('Android') === -1 ||
		                        Date.now() - (svgElement.touchEventFired || 0) > 1100) {
		                    handler.call(element, e);
		                }
		            };
		        } else {
		            // simplest possible event model for internal use
		            element['on' + eventType] = handler;
		        }
		        return this;
		    },

		    /**
		     * Set the coordinates needed to draw a consistent radial gradient across
		     * a shape regardless of positioning inside the chart. Used on pie slices
		     * to make all the slices have the same radial reference point.
		     *
		     * @function Highcharts.SVGElement#setRadialReference
		     *
		     * @param {Array<number>} coordinates
		     *        The center reference. The format is `[centerX, centerY, diameter]`
		     *        in pixels.
		     *
		     * @return {Highcharts.SVGElement}
		     *         Returns the SVGElement for chaining.
		     */
		    setRadialReference: function (coordinates) {
		        var existingGradient = this.renderer.gradients[this.element.gradient];

		        this.element.radialReference = coordinates;

		        // On redrawing objects with an existing gradient, the gradient needs
		        // to be repositioned (#3801)
		        if (existingGradient && existingGradient.radAttr) {
		            existingGradient.animate(
		                this.renderer.getRadialAttr(
		                    coordinates,
		                    existingGradient.radAttr
		                )
		            );
		        }

		        return this;
		    },

		    /**
		     * Move an object and its children by x and y values.
		     *
		     * @function Highcharts.SVGElement#translate
		     *
		     * @param {number} x
		     *        The x value.
		     *
		     * @param {number} y
		     *        The y value.
		     */
		    translate: function (x, y) {
		        return this.attr({
		            translateX: x,
		            translateY: y
		        });
		    },

		    /**
		     * Invert a group, rotate and flip. This is used internally on inverted
		     * charts, where the points and graphs are drawn as if not inverted, then
		     * the series group elements are inverted.
		     *
		     * @function Highcharts.SVGElement#invert
		     *
		     * @param {boolean} inverted
		     *        Whether to invert or not. An inverted shape can be un-inverted by
		     *        setting it to false.
		     *
		     * @return {Highcharts.SVGElement}
		     *         Return the SVGElement for chaining.
		     */
		    invert: function (inverted) {
		        var wrapper = this;
		        wrapper.inverted = inverted;
		        wrapper.updateTransform();
		        return wrapper;
		    },

		    /**
		     * Update the transform attribute based on internal properties. Deals with
		     * the custom `translateX`, `translateY`, `rotation`, `scaleX` and `scaleY`
		     * attributes and updates the SVG `transform` attribute.
		     *
		     * @private
		     * @function Highcharts.SVGElement#updateTransform
		     */
		    updateTransform: function () {
		        var wrapper = this,
		            translateX = wrapper.translateX || 0,
		            translateY = wrapper.translateY || 0,
		            scaleX = wrapper.scaleX,
		            scaleY = wrapper.scaleY,
		            inverted = wrapper.inverted,
		            rotation = wrapper.rotation,
		            matrix = wrapper.matrix,
		            element = wrapper.element,
		            transform;

		        // Flipping affects translate as adjustment for flipping around the
		        // group's axis
		        if (inverted) {
		            translateX += wrapper.width;
		            translateY += wrapper.height;
		        }

		        // Apply translate. Nearly all transformed elements have translation,
		        // so instead of checking for translate = 0, do it always (#1767,
		        // #1846).
		        transform = ['translate(' + translateX + ',' + translateY + ')'];

		        // apply matrix
		        if (defined(matrix)) {
		            transform.push(
		                'matrix(' + matrix.join(',') + ')'
		            );
		        }

		        // apply rotation
		        if (inverted) {
		            transform.push('rotate(90) scale(-1,1)');
		        } else if (rotation) { // text rotation
		            transform.push(
		                'rotate(' + rotation + ' ' +
		                pick(this.rotationOriginX, element.getAttribute('x'), 0) +
		                ' ' +
		                pick(this.rotationOriginY, element.getAttribute('y') || 0) + ')'
		            );
		        }

		        // apply scale
		        if (defined(scaleX) || defined(scaleY)) {
		            transform.push(
		                'scale(' + pick(scaleX, 1) + ' ' + pick(scaleY, 1) + ')'
		            );
		        }

		        if (transform.length) {
		            element.setAttribute('transform', transform.join(' '));
		        }
		    },

		    /**
		     * Bring the element to the front. Alternatively, a new zIndex can be set.
		     *
		     * @sample highcharts/members/element-tofront/
		     *         Click an element to bring it to front
		     *
		     * @function Highcharts.SVGElement#toFront
		     *
		     * @return {Highcharts.SVGElement}
		     *         Returns the SVGElement for chaining.
		     */
		    toFront: function () {
		        var element = this.element;
		        element.parentNode.appendChild(element);
		        return this;
		    },


		    /**
		     * Align the element relative to the chart or another box.
		     *
		     * @function Highcharts.SVGElement#align
		     *
		     * @param {Highcharts.AlignObject} [alignOptions]
		     *        The alignment options. The function can be called without this
		     *        parameter in order to re-align an element after the box has been
		     *        updated.
		     *
		     * @param {boolean} [alignByTranslate]
		     *        Align element by translation.
		     *
		     * @param {string|Highcharts.BBoxObject} [box]
		     *        The box to align to, needs a width and height. When the box is a
		     *        string, it refers to an object in the Renderer. For example, when
		     *        box is `spacingBox`, it refers to `Renderer.spacingBox` which
		     *        holds `width`, `height`, `x` and `y` properties.
		     *
		     * @return {Highcharts.SVGElement} Returns the SVGElement for chaining.
		     */
		    align: function (alignOptions, alignByTranslate, box) {
		        var align,
		            vAlign,
		            x,
		            y,
		            attribs = {},
		            alignTo,
		            renderer = this.renderer,
		            alignedObjects = renderer.alignedObjects,
		            alignFactor,
		            vAlignFactor;

		        // First call on instanciate
		        if (alignOptions) {
		            this.alignOptions = alignOptions;
		            this.alignByTranslate = alignByTranslate;
		            if (!box || isString(box)) {
		                this.alignTo = alignTo = box || 'renderer';
		                // prevent duplicates, like legendGroup after resize
		                erase(alignedObjects, this);
		                alignedObjects.push(this);
		                box = null; // reassign it below
		            }

		        // When called on resize, no arguments are supplied
		        } else {
		            alignOptions = this.alignOptions;
		            alignByTranslate = this.alignByTranslate;
		            alignTo = this.alignTo;
		        }

		        box = pick(box, renderer[alignTo], renderer);

		        // Assign variables
		        align = alignOptions.align;
		        vAlign = alignOptions.verticalAlign;
		        x = (box.x || 0) + (alignOptions.x || 0); // default: left align
		        y = (box.y || 0) + (alignOptions.y || 0); // default: top align

		        // Align
		        if (align === 'right') {
		            alignFactor = 1;
		        } else if (align === 'center') {
		            alignFactor = 2;
		        }
		        if (alignFactor) {
		            x += (box.width - (alignOptions.width || 0)) / alignFactor;
		        }
		        attribs[alignByTranslate ? 'translateX' : 'x'] = Math.round(x);


		        // Vertical align
		        if (vAlign === 'bottom') {
		            vAlignFactor = 1;
		        } else if (vAlign === 'middle') {
		            vAlignFactor = 2;
		        }
		        if (vAlignFactor) {
		            y += (box.height - (alignOptions.height || 0)) / vAlignFactor;
		        }
		        attribs[alignByTranslate ? 'translateY' : 'y'] = Math.round(y);

		        // Animate only if already placed
		        this[this.placed ? 'animate' : 'attr'](attribs);
		        this.placed = true;
		        this.alignAttr = attribs;

		        return this;
		    },

		    /**
		     * Get the bounding box (width, height, x and y) for the element. Generally
		     * used to get rendered text size. Since this is called a lot in charts,
		     * the results are cached based on text properties, in order to save DOM
		     * traffic. The returned bounding box includes the rotation, so for example
		     * a single text line of rotation 90 will report a greater height, and a
		     * width corresponding to the line-height.
		     *
		     * @sample highcharts/members/renderer-on-chart/
		     *         Draw a rectangle based on a text's bounding box
		     *
		     * @function Highcharts.SVGElement#getBBox
		     *
		     * @param {boolean} [reload]
		     *        Skip the cache and get the updated DOM bouding box.
		     *
		     * @param {number} [rot]
		     *        Override the element's rotation. This is internally used on axis
		     *        labels with a value of 0 to find out what the bounding box would
		     *        be have been if it were not rotated.
		     *
		     * @return {Highcharts.BBoxObject}
		     *         The bounding box with `x`, `y`, `width` and `height` properties.
		     */
		    getBBox: function (reload, rot) {
		        var wrapper = this,
		            bBox, // = wrapper.bBox,
		            renderer = wrapper.renderer,
		            width,
		            height,
		            rotation,
		            rad,
		            element = wrapper.element,
		            styles = wrapper.styles,
		            fontSize,
		            textStr = wrapper.textStr,
		            toggleTextShadowShim,
		            cache = renderer.cache,
		            cacheKeys = renderer.cacheKeys,
		            isSVG = element.namespaceURI === wrapper.SVG_NS,
		            cacheKey;

		        rotation = pick(rot, wrapper.rotation);
		        rad = rotation * deg2rad;


		        fontSize = styles && styles.fontSize;


		        // Avoid undefined and null (#7316)
		        if (defined(textStr)) {

		            cacheKey = textStr.toString();

		            // Since numbers are monospaced, and numerical labels appear a lot
		            // in a chart, we assume that a label of n characters has the same
		            // bounding box as others of the same length. Unless there is inner
		            // HTML in the label. In that case, leave the numbers as is (#5899).
		            if (cacheKey.indexOf('<') === -1) {
		                cacheKey = cacheKey.replace(/[0-9]/g, '0');
		            }

		            // Properties that affect bounding box
		            cacheKey += [
		                '',
		                rotation || 0,
		                fontSize,
		                wrapper.textWidth, // #7874, also useHTML
		                styles && styles.textOverflow // #5968
		            ]
		            .join(',');

		        }

		        if (cacheKey && !reload) {
		            bBox = cache[cacheKey];
		        }

		        // No cache found
		        if (!bBox) {

		            // SVG elements
		            if (isSVG || renderer.forExport) {
		                try { // Fails in Firefox if the container has display: none.

		                    // When the text shadow shim is used, we need to hide the
		                    // fake shadows to get the correct bounding box (#3872)
		                    toggleTextShadowShim = this.fakeTS && function (display) {
		                        each(
		                            element.querySelectorAll(
		                                '.highcharts-text-outline'
		                            ),
		                            function (tspan) {
		                                tspan.style.display = display;
		                            }
		                        );
		                    };

		                    // Workaround for #3842, Firefox reporting wrong bounding
		                    // box for shadows
		                    if (toggleTextShadowShim) {
		                        toggleTextShadowShim('none');
		                    }

		                    bBox = element.getBBox ?
		                        // SVG: use extend because IE9 is not allowed to change
		                        // width and height in case of rotation (below)
		                        extend({}, element.getBBox()) : {

		                            // Legacy IE in export mode
		                            width: element.offsetWidth,
		                            height: element.offsetHeight
		                        };

		                    // #3842
		                    if (toggleTextShadowShim) {
		                        toggleTextShadowShim('');
		                    }
		                } catch (e) {}

		                // If the bBox is not set, the try-catch block above failed. The
		                // other condition is for Opera that returns a width of
		                // -Infinity on hidden elements.
		                if (!bBox || bBox.width < 0) {
		                    bBox = { width: 0, height: 0 };
		                }


		            // VML Renderer or useHTML within SVG
		            } else {

		                bBox = wrapper.htmlGetBBox();

		            }

		            // True SVG elements as well as HTML elements in modern browsers
		            // using the .useHTML option need to compensated for rotation
		            if (renderer.isSVG) {
		                width = bBox.width;
		                height = bBox.height;

		                // Workaround for wrong bounding box in IE, Edge and Chrome on
		                // Windows. With Highcharts' default font, IE and Edge report
		                // a box height of 16.899 and Chrome rounds it to 17. If this
		                // stands uncorrected, it results in more padding added below
		                // the text than above when adding a label border or background.
		                // Also vertical positioning is affected.
		                // https://jsfiddle.net/highcharts/em37nvuj/
		                // (#1101, #1505, #1669, #2568, #6213).
		                if (isSVG) {
		                    bBox.height = height = (
		                        {
		                            '11px,17': 14,
		                            '13px,20': 16
		                        }[
		                            styles && styles.fontSize + ',' + Math.round(height)
		                        ] ||
		                        height
		                    );
		                }

		                // Adjust for rotated text
		                if (rotation) {
		                    bBox.width = Math.abs(height * Math.sin(rad)) +
		                        Math.abs(width * Math.cos(rad));
		                    bBox.height = Math.abs(height * Math.cos(rad)) +
		                        Math.abs(width * Math.sin(rad));
		                }
		            }

		            // Cache it. When loading a chart in a hidden iframe in Firefox and
		            // IE/Edge, the bounding box height is 0, so don't cache it (#5620).
		            if (cacheKey && bBox.height > 0) {

		                // Rotate (#4681)
		                while (cacheKeys.length > 250) {
		                    delete cache[cacheKeys.shift()];
		                }

		                if (!cache[cacheKey]) {
		                    cacheKeys.push(cacheKey);
		                }
		                cache[cacheKey] = bBox;
		            }
		        }
		        return bBox;
		    },

		    /**
		     * Show the element after it has been hidden.
		     *
		     * @function Highcharts.SVGElement#show
		     *
		     * @param {boolean} [inherit=false]
		     *        Set the visibility attribute to `inherit` rather than `visible`.
		     *        The difference is that an element with `visibility="visible"`
		     *        will be visible even if the parent is hidden.
		     *
		     * @return {Highcharts.SVGElement}
		     *         Returns the SVGElement for chaining.
		     */
		    show: function (inherit) {
		        return this.attr({ visibility: inherit ? 'inherit' : 'visible' });
		    },

		    /**
		     * Hide the element, equivalent to setting the `visibility` attribute to
		     * `hidden`.
		     *
		     * @function Highcharts.SVGElement#hide
		     *
		     * @return {Highcharts.SVGElement}
		     *         Returns the SVGElement for chaining.
		     */
		    hide: function () {
		        return this.attr({ visibility: 'hidden' });
		    },

		    /**
		     * Fade out an element by animating its opacity down to 0, and hide it on
		     * complete. Used internally for the tooltip.
		     *
		     * @function Highcharts.SVGElement#fadeOut
		     *
		     * @param {number} [duration=150]
		     *        The fade duration in milliseconds.
		     */
		    fadeOut: function (duration) {
		        var elemWrapper = this;
		        elemWrapper.animate({
		            opacity: 0
		        }, {
		            duration: duration || 150,
		            complete: function () {
		                // #3088, assuming we're only using this for tooltips
		                elemWrapper.attr({ y: -9999 });
		            }
		        });
		    },

		    /**
		     * Add the element to the DOM. All elements must be added this way.
		     *
		     * @sample highcharts/members/renderer-g
		     *         Elements added to a group
		     *
		     * @function Highcharts.SVGElement#add
		     *
		     * @param {Highcharts.SVGElement|Highcharts.SVGDOMElement} [parent]
		     *        The parent item to add it to. If undefined, the element is added
		     *        to the {@link Highcharts.SVGRenderer.box}.
		     *
		     * @return {Highcharts.SVGElement}
		     *         Returns the SVGElement for chaining.
		     */
		    add: function (parent) {

		        var renderer = this.renderer,
		            element = this.element,
		            inserted;

		        if (parent) {
		            this.parentGroup = parent;
		        }

		        // mark as inverted
		        this.parentInverted = parent && parent.inverted;

		        // build formatted text
		        if (this.textStr !== undefined) {
		            renderer.buildText(this);
		        }

		        // Mark as added
		        this.added = true;

		        // If we're adding to renderer root, or other elements in the group
		        // have a z index, we need to handle it
		        if (!parent || parent.handleZ || this.zIndex) {
		            inserted = this.zIndexSetter();
		        }

		        // If zIndex is not handled, append at the end
		        if (!inserted) {
		            (parent ? parent.element : renderer.box).appendChild(element);
		        }

		        // fire an event for internal hooks
		        if (this.onAdd) {
		            this.onAdd();
		        }

		        return this;
		    },

		    /**
		     * Removes an element from the DOM.
		     *
		     * @private
		     * @function Highcharts.SVGElement#safeRemoveChild
		     *
		     * @param {Highcharts.SVGDOMElement|Highcharts.HTMLDOMElement} element
		     *        The DOM node to remove.
		     */
		    safeRemoveChild: function (element) {
		        var parentNode = element.parentNode;
		        if (parentNode) {
		            parentNode.removeChild(element);
		        }
		    },

		    /**
		     * Destroy the element and element wrapper and clear up the DOM and event
		     * hooks.
		     *
		     * @function Highcharts.SVGElement#destroy
		     */
		    destroy: function () {
		        var wrapper = this,
		            element = wrapper.element || {},
		            parentToClean =
		                wrapper.renderer.isSVG &&
		                element.nodeName === 'SPAN' &&
		                wrapper.parentGroup,
		            grandParent,
		            ownerSVGElement = element.ownerSVGElement,
		            i,
		            clipPath = wrapper.clipPath;

		        // remove events
		        element.onclick = element.onmouseout = element.onmouseover =
		            element.onmousemove = element.point = null;
		        stop(wrapper); // stop running animations

		        if (clipPath && ownerSVGElement) {
		            // Look for existing references to this clipPath and remove them
		            // before destroying the element (#6196).
		            each(
		                // The upper case version is for Edge
		                ownerSVGElement.querySelectorAll('[clip-path],[CLIP-PATH]'),
		                function (el) {
		                    var clipPathAttr = el.getAttribute('clip-path'),
		                        clipPathId = clipPath.element.id;
		                    // Include the closing paranthesis in the test to rule out
		                    // id's from 10 and above (#6550). Edge puts quotes inside
		                    // the url, others not.
		                    if (
		                        clipPathAttr.indexOf('(#' + clipPathId + ')') > -1 ||
		                        clipPathAttr.indexOf('("#' + clipPathId + '")') > -1
		                    ) {
		                        el.removeAttribute('clip-path');
		                    }
		                }
		            );
		            wrapper.clipPath = clipPath.destroy();
		        }

		        // Destroy stops in case this is a gradient object
		        if (wrapper.stops) {
		            for (i = 0; i < wrapper.stops.length; i++) {
		                wrapper.stops[i] = wrapper.stops[i].destroy();
		            }
		            wrapper.stops = null;
		        }

		        // remove element
		        wrapper.safeRemoveChild(element);


		        wrapper.destroyShadows();


		        // In case of useHTML, clean up empty containers emulating SVG groups
		        // (#1960, #2393, #2697).
		        while (
		            parentToClean &&
		            parentToClean.div &&
		            parentToClean.div.childNodes.length === 0
		        ) {
		            grandParent = parentToClean.parentGroup;
		            wrapper.safeRemoveChild(parentToClean.div);
		            delete parentToClean.div;
		            parentToClean = grandParent;
		        }

		        // remove from alignObjects
		        if (wrapper.alignTo) {
		            erase(wrapper.renderer.alignedObjects, wrapper);
		        }

		        objectEach(wrapper, function (val, key) {
		            delete wrapper[key];
		        });

		        return null;
		    },



		    /**
		     * Add a shadow to the element. Must be called after the element is added to
		     * the DOM. In styled mode, this method is not used, instead use `defs` and
		     * filters.
		     *
		     * @example
		     * renderer.rect(10, 100, 100, 100)
		     *     .attr({ fill: 'red' })
		     *     .shadow(true);
		     *
		     * @function Highcharts.SVGElement#shadow
		     *
		     * @param {boolean|Highcharts.ShadowOptionsObject} shadowOptions
		     *        The shadow options. If `true`, the default options are applied. If
		     *        `false`, the current shadow will be removed.
		     *
		     * @param {Highcharts.SVGElement} [group]
		     *        The SVG group element where the shadows will be applied. The
		     *        default is to add it to the same parent as the current element.
		     *        Internally, this is ised for pie slices, where all the shadows are
		     *        added to an element behind all the slices.
		     *
		     * @param {boolean} [cutOff]
		     *        Used internally for column shadows.
		     *
		     * @return {Highcharts.SVGElement}
		     *         Returns the SVGElement for chaining.
		     */
		    shadow: function (shadowOptions, group, cutOff) {
		        var shadows = [],
		            i,
		            shadow,
		            element = this.element,
		            strokeWidth,
		            shadowWidth,
		            shadowElementOpacity,

		            // compensate for inverted plot area
		            transform;

		        if (!shadowOptions) {
		            this.destroyShadows();

		        } else if (!this.shadows) {
		            shadowWidth = pick(shadowOptions.width, 3);
		            shadowElementOpacity = (shadowOptions.opacity || 0.15) /
		                shadowWidth;
		            transform = this.parentInverted ?
		                    '(-1,-1)' :
		                    '(' + pick(shadowOptions.offsetX, 1) + ', ' +
		                        pick(shadowOptions.offsetY, 1) + ')';
		            for (i = 1; i <= shadowWidth; i++) {
		                shadow = element.cloneNode(0);
		                strokeWidth = (shadowWidth * 2) + 1 - (2 * i);
		                attr(shadow, {
		                    'stroke':
		                        shadowOptions.color || '#000000',
		                    'stroke-opacity': shadowElementOpacity * i,
		                    'stroke-width': strokeWidth,
		                    'transform': 'translate' + transform,
		                    'fill': 'none'
		                });
		                shadow.setAttribute(
		                    'class',
		                    (shadow.getAttribute('class') || '') + ' highcharts-shadow'
		                );
		                if (cutOff) {
		                    attr(
		                        shadow,
		                        'height',
		                        Math.max(attr(shadow, 'height') - strokeWidth, 0)
		                    );
		                    shadow.cutHeight = strokeWidth;
		                }

		                if (group) {
		                    group.element.appendChild(shadow);
		                } else if (element.parentNode) {
		                    element.parentNode.insertBefore(shadow, element);
		                }

		                shadows.push(shadow);
		            }

		            this.shadows = shadows;
		        }
		        return this;

		    },

		    /**
		     * Destroy shadows on the element.
		     *
		     * @private
		     * @function Highcharts.SVGElement#destroyShadows
		     */
		    destroyShadows: function () {
		        each(this.shadows || [], function (shadow) {
		            this.safeRemoveChild(shadow);
		        }, this);
		        this.shadows = undefined;
		    },



		    /**
		     * @private
		     * @function Highcharts.SVGElement#xGetter
		     *
		     * @param {string} key
		     *
		     * @return {number|string|null}
		     */
		    xGetter: function (key) {
		        if (this.element.nodeName === 'circle') {
		            if (key === 'x') {
		                key = 'cx';
		            } else if (key === 'y') {
		                key = 'cy';
		            }
		        }
		        return this._defaultGetter(key);
		    },

		    /**
		     * Get the current value of an attribute or pseudo attribute,
		     * used mainly for animation. Called internally from
		     * the {@link Highcharts.SVGRenderer#attr} function.
		     *
		     * @private
		     * @function Highcharts.SVGElement#_defaultGetter
		     *
		     * @param {string} key
		     *        Property key.
		     *
		     * @return {number|string|null}
		     *         Property value.
		     */
		    _defaultGetter: function (key) {
		        var ret = pick(
		            this[key + 'Value'], // align getter
		            this[key],
		            this.element ? this.element.getAttribute(key) : null,
		            0
		        );

		        if (/^[\-0-9\.]+$/.test(ret)) { // is numerical
		            ret = parseFloat(ret);
		        }
		        return ret;
		    },

		    /**
		     * @private
		     * @function Highcharts.SVGElement#dSettter
		     *
		     * @param {number|string|Highcharts.SVGPathArray} value
		     *
		     * @param {string} key
		     *
		     * @param {Highcharts.SVGDOMElement} element
		     */
		    dSetter: function (value, key, element) {
		        if (value && value.join) { // join path
		            value = value.join(' ');
		        }
		        if (/(NaN| {2}|^$)/.test(value)) {
		            value = 'M 0 0';
		        }

		        // Check for cache before resetting. Resetting causes disturbance in the
		        // DOM, causing flickering in some cases in Edge/IE (#6747). Also
		        // possible performance gain.
		        if (this[key] !== value) {
		            element.setAttribute(key, value);
		            this[key] = value;
		        }

		    },



		    /**
		     * @private
		     * @function Highcharts.SVGElement#dashstyleSetter
		     *
		     * @param {string} value
		     */
		    dashstyleSetter: function (value) {
		        var i,
		            strokeWidth = this['stroke-width'];

		        // If "inherit", like maps in IE, assume 1 (#4981). With HC5 and the new
		        // strokeWidth function, we should be able to use that instead.
		        if (strokeWidth === 'inherit') {
		            strokeWidth = 1;
		        }
		        value = value && value.toLowerCase();
		        if (value) {
		            value = value
		                .replace('shortdashdotdot', '3,1,1,1,1,1,')
		                .replace('shortdashdot', '3,1,1,1')
		                .replace('shortdot', '1,1,')
		                .replace('shortdash', '3,1,')
		                .replace('longdash', '8,3,')
		                .replace(/dot/g, '1,3,')
		                .replace('dash', '4,3,')
		                .replace(/,$/, '')
		                .split(','); // ending comma

		            i = value.length;
		            while (i--) {
		                value[i] = pInt(value[i]) * strokeWidth;
		            }
		            value = value.join(',')
		                .replace(/NaN/g, 'none'); // #3226
		            this.element.setAttribute('stroke-dasharray', value);
		        }
		    },



		    /**
		     * @private
		     * @function Highcharts.SVGElement#alignSetter
		     *
		     * @param {"start"|"middle"|"end"} value
		     */
		    alignSetter: function (value) {
		        var convert = { left: 'start', center: 'middle', right: 'end' };
		        this.alignValue = value;
		        this.element.setAttribute('text-anchor', convert[value]);
		    },
		    /**
		     * @private
		     * @function Highcharts.SVGElement#opacitySetter
		     *
		     * @param {string} value
		     *
		     * @param {string} key
		     *
		     * @param {Highcharts.SVGDOMElement} element
		     */
		    opacitySetter: function (value, key, element) {
		        this[key] = value;
		        element.setAttribute(key, value);
		    },
		    /**
		     * @private
		     * @function Highcharts.SVGElement#titleSetter
		     *
		     * @param {string} value
		     */
		    titleSetter: function (value) {
		        var titleNode = this.element.getElementsByTagName('title')[0];
		        if (!titleNode) {
		            titleNode = doc.createElementNS(this.SVG_NS, 'title');
		            this.element.appendChild(titleNode);
		        }

		        // Remove text content if it exists
		        if (titleNode.firstChild) {
		            titleNode.removeChild(titleNode.firstChild);
		        }

		        titleNode.appendChild(
		            doc.createTextNode(
		                // #3276, #3895
		                (String(pick(value), ''))
		                    .replace(/<[^>]*>/g, '')
		                    .replace(/&lt;/g, '<')
		                    .replace(/&gt;/g, '>')
		            )
		        );
		    },
		    /**
		     * @private
		     * @function Highcharts.SVGElement#textSetter
		     *
		     * @param {string} value
		     */
		    textSetter: function (value) {
		        if (value !== this.textStr) {
		            // Delete bBox memo when the text changes
		            delete this.bBox;

		            this.textStr = value;
		            if (this.added) {
		                this.renderer.buildText(this);
		            }
		        }
		    },
		    /**
		     * @private
		     * @function Highcharts.SVGElement#fillSetter
		     *
		     * @param {Highcharts.Color|Highcharts.ColorString} value
		     *
		     * @param {string} key
		     *
		     * @param {Highcharts.SVGDOMElement} element
		     */
		    fillSetter: function (value, key, element) {
		        if (typeof value === 'string') {
		            element.setAttribute(key, value);
		        } else if (value) {
		            this.complexColor(value, key, element);
		        }
		    },
		    /**
		     * @private
		     * @function Highcharts.SVGElement#visibilitySetter
		     *
		     * @param {string} value
		     *
		     * @param {string} key
		     *
		     * @param {Highcharts.SVGDOMElement} element
		     */
		    visibilitySetter: function (value, key, element) {
		        // IE9-11 doesn't handle visibilty:inherit well, so we remove the
		        // attribute instead (#2881, #3909)
		        if (value === 'inherit') {
		            element.removeAttribute(key);
		        } else if (this[key] !== value) { // #6747
		            element.setAttribute(key, value);
		        }
		        this[key] = value;
		    },
		    /**
		     * @private
		     * @function Highcharts.SVGElement#zIndexSetter
		     *
		     * @param {string} value
		     *
		     * @param {string} key
		     *
		     * @return {boolean}
		     */
		    zIndexSetter: function (value, key) {
		        var renderer = this.renderer,
		            parentGroup = this.parentGroup,
		            parentWrapper = parentGroup || renderer,
		            parentNode = parentWrapper.element || renderer.box,
		            childNodes,
		            otherElement,
		            otherZIndex,
		            element = this.element,
		            inserted,
		            undefinedOtherZIndex,
		            svgParent = parentNode === renderer.box,
		            run = this.added,
		            i;

		        if (defined(value)) {
		            // So we can read it for other elements in the group
		            element.setAttribute('data-z-index', value);

		            value = +value;
		            if (this[key] === value) { // Only update when needed (#3865)
		                run = false;
		            }
		        } else if (defined(this[key])) {
		            element.removeAttribute('data-z-index');
		        }

		        this[key] = value;

		        // Insert according to this and other elements' zIndex. Before .add() is
		        // called, nothing is done. Then on add, or by later calls to
		        // zIndexSetter, the node is placed on the right place in the DOM.
		        if (run) {
		            value = this.zIndex;

		            if (value && parentGroup) {
		                parentGroup.handleZ = true;
		            }

		            childNodes = parentNode.childNodes;
		            for (i = childNodes.length - 1; i >= 0 && !inserted; i--) {
		                otherElement = childNodes[i];
		                otherZIndex = otherElement.getAttribute('data-z-index');
		                undefinedOtherZIndex = !defined(otherZIndex);

		                if (otherElement !== element) {
		                    if (
		                        // Negative zIndex versus no zIndex:
		                        // On all levels except the highest. If the parent is
		                        // <svg>, then we don't want to put items before <desc>
		                        // or <defs>
		                        (value < 0 && undefinedOtherZIndex && !svgParent && !i)
		                    ) {
		                        parentNode.insertBefore(element, childNodes[i]);
		                        inserted = true;
		                    } else if (
		                        // Insert after the first element with a lower zIndex
		                        pInt(otherZIndex) <= value ||
		                        // If negative zIndex, add this before first undefined
		                        // zIndex element
		                        (
		                            undefinedOtherZIndex &&
		                            (!defined(value) || value >= 0)
		                        )
		                    ) {
		                        parentNode.insertBefore(
		                            element,
		                            childNodes[i + 1] || null // null for oldIE export
		                        );
		                        inserted = true;
		                    }
		                }
		            }

		            if (!inserted) {
		                parentNode.insertBefore(
		                    element,
		                    childNodes[svgParent ? 3 : 0] || null // null for oldIE
		                );
		                inserted = true;
		            }
		        }
		        return inserted;
		    },
		    /**
		     * @private
		     * @function Highcharts.SVGElement#_defaultSetter
		     *
		     * @param {string} value
		     *
		     * @param {string} key
		     *
		     * @param {Highcharts.SVGDOMElement} element
		     */
		    _defaultSetter: function (value, key, element) {
		        element.setAttribute(key, value);
		    }
		});

		// Some shared setters and getters
		SVGElement.prototype.yGetter =
		SVGElement.prototype.xGetter;
		SVGElement.prototype.translateXSetter =
		SVGElement.prototype.translateYSetter =
		SVGElement.prototype.rotationSetter =
		SVGElement.prototype.verticalAlignSetter =
		SVGElement.prototype.rotationOriginXSetter =
		SVGElement.prototype.rotationOriginYSetter =
		SVGElement.prototype.scaleXSetter =
		SVGElement.prototype.scaleYSetter =
		SVGElement.prototype.matrixSetter = function (value, key) {
		    this[key] = value;
		    this.doTransform = true;
		};


		// WebKit and Batik have problems with a stroke-width of zero, so in this case
		// we remove the stroke attribute altogether. #1270, #1369, #3065, #3072.
		SVGElement.prototype['stroke-widthSetter'] =
		/**
		 * @private
		 * @function Highcharts.SVGElement#strokeSetter
		 *
		 * @param {number|string} value
		 *
		 * @param {string} key
		 *
		 * @param {Highcharts.SVGDOMElement} element
		 */
		SVGElement.prototype.strokeSetter = function (value, key, element) {
		    this[key] = value;
		    // Only apply the stroke attribute if the stroke width is defined and larger
		    // than 0
		    if (this.stroke && this['stroke-width']) {
		        // Use prototype as instance may be overridden
		        SVGElement.prototype.fillSetter.call(
		            this,
		            this.stroke,
		            'stroke',
		            element
		        );

		        element.setAttribute('stroke-width', this['stroke-width']);
		        this.hasStroke = true;
		    } else if (key === 'stroke-width' && value === 0 && this.hasStroke) {
		        element.removeAttribute('stroke');
		        this.hasStroke = false;
		    }
		};


		/**
		 * Allows direct access to the Highcharts rendering layer in order to draw
		 * primitive shapes like circles, rectangles, paths or text directly on a chart,
		 * or independent from any chart. The SVGRenderer represents a wrapper object
		 * for SVG in modern browsers. Through the VMLRenderer, part of the `oldie.js`
		 * module, it also brings vector graphics to IE <= 8.
		 *
		 * An existing chart's renderer can be accessed through {@link Chart.renderer}.
		 * The renderer can also be used completely decoupled from a chart.
		 *
		 * @sample highcharts/members/renderer-on-chart
		 *         Annotating a chart programmatically.
		 * @sample highcharts/members/renderer-basic
		 *         Independent SVG drawing.
		 *
		 * @example
		 * // Use directly without a chart object.
		 * var renderer = new Highcharts.Renderer(parentNode, 600, 400);
		 *
		 * @class
		 * @name Highcharts.SVGRenderer
		 *
		 * @param {Highcharts.HTMLDOMElement} container
		 *        Where to put the SVG in the web page.
		 *
		 * @param {number} width
		 *        The width of the SVG.
		 *
		 * @param {number} height
		 *        The height of the SVG.
		 *
		 * @param {boolean} [forExport=false]
		 *        Whether the rendered content is intended for export.
		 *
		 * @param {boolean} [allowHTML=true]
		 *        Whether the renderer is allowed to include HTML text, which will be
		 *        projected on top of the SVG.
		 */
		SVGRenderer = H.SVGRenderer = function () {
		    this.init.apply(this, arguments);
		};
		extend(SVGRenderer.prototype, /** @lends Highcharts.SVGRenderer.prototype */ {
		    /**
		     * A pointer to the renderer's associated Element class. The VMLRenderer
		     * will have a pointer to VMLElement here.
		     *
		     * @name Highcharts.SVGRenderer#Element
		     * @type {Highcharts.SVGElement}
		     */
		    Element: SVGElement,

		    SVG_NS: SVG_NS,

		    /**
		     * Initialize the SVGRenderer. Overridable initiator function that takes
		     * the same parameters as the constructor.
		     *
		     * @function Highcharts.SVGRenderer#init
		     *
		     * @param {Highcharts.HTMLDOMElement} container
		     *        Where to put the SVG in the web page.
		     *
		     * @param {number} width
		     *        The width of the SVG.
		     *
		     * @param {number} height
		     *        The height of the SVG.
		     *
		     * @param {boolean} [forExport=false]
		     *        Whether the rendered content is intended for export.
		     *
		     * @param {boolean} [allowHTML=true]
		     *        Whether the renderer is allowed to include HTML text, which will
		     *        be projected on top of the SVG.
		     */
		    init: function (container, width, height, style, forExport, allowHTML) {
		        var renderer = this,
		            boxWrapper,
		            element,
		            desc;

		        boxWrapper = renderer.createElement('svg')
		            .attr({
		                'version': '1.1',
		                'class': 'highcharts-root'
		            })

		            .css(this.getStyle(style))
		            ;
		        element = boxWrapper.element;
		        container.appendChild(element);

		        // Always use ltr on the container, otherwise text-anchor will be
		        // flipped and text appear outside labels, buttons, tooltip etc (#3482)
		        attr(container, 'dir', 'ltr');

		        // For browsers other than IE, add the namespace attribute (#1978)
		        if (container.innerHTML.indexOf('xmlns') === -1) {
		            attr(element, 'xmlns', this.SVG_NS);
		        }

		        // object properties
		        renderer.isSVG = true;

		        /**
		         * The root `svg` node of the renderer.
		         *
		         * @name Highcharts.SVGRenderer#box
		         * @type {Highcharts.SVGDOMElement}
		         */
		        this.box = element;
		        /**
		         * The wrapper for the root `svg` node of the renderer.
		         *
		         * @name Highcharts.SVGRenderer#boxWrapper
		         * @type {Highcharts.SVGElement}
		         */
		        this.boxWrapper = boxWrapper;
		        renderer.alignedObjects = [];

		        /**
		         * Page url used for internal references.
		         *
		         * @private
		         * @name Highcharts.SVGRenderer#url
		         * @type {string}
		         */
		        // #24, #672, #1070
		        this.url = (
		                (isFirefox || isWebKit) &&
		                doc.getElementsByTagName('base').length
		            ) ?
		                win.location.href
		                    .split('#')[0] // remove the hash
		                    .replace(/<[^>]*>/g, '') // wing cut HTML
		                    // escape parantheses and quotes
		                    .replace(/([\('\)])/g, '\\$1')
		                    // replace spaces (needed for Safari only)
		                    .replace(/ /g, '%20') :
		                '';

		        // Add description
		        desc = this.createElement('desc').add();
		        desc.element.appendChild(
		            doc.createTextNode('Created with Highcharts 6.2.0')
		        );

		        /**
		         * A pointer to the `defs` node of the root SVG.
		         *
		         * @name Highcharts.SVGRenderer#defs
		         * @type {Highcharts.SVGElement}
		         */
		        renderer.defs = this.createElement('defs').add();
		        renderer.allowHTML = allowHTML;
		        renderer.forExport = forExport;
		        renderer.gradients = {}; // Object where gradient SvgElements are stored
		        renderer.cache = {}; // Cache for numerical bounding boxes
		        renderer.cacheKeys = [];
		        renderer.imgCount = 0;

		        renderer.setSize(width, height, false);



		        // Issue 110 workaround:
		        // In Firefox, if a div is positioned by percentage, its pixel position
		        // may land between pixels. The container itself doesn't display this,
		        // but an SVG element inside this container will be drawn at subpixel
		        // precision. In order to draw sharp lines, this must be compensated
		        // for. This doesn't seem to work inside iframes though (like in
		        // jsFiddle).
		        var subPixelFix, rect;
		        if (isFirefox && container.getBoundingClientRect) {
		            subPixelFix = function () {
		                css(container, { left: 0, top: 0 });
		                rect = container.getBoundingClientRect();
		                css(container, {
		                    left: (Math.ceil(rect.left) - rect.left) + 'px',
		                    top: (Math.ceil(rect.top) - rect.top) + 'px'
		                });
		            };

		            // run the fix now
		            subPixelFix();

		            // run it on resize
		            renderer.unSubPixelFix = addEvent(win, 'resize', subPixelFix);
		        }
		    },





		    /**
		     * Get the global style setting for the renderer.
		     *
		     * @private
		     * @function Highcharts.SVGRenderer#getStyle
		     *
		     * @param {Highcharts.CSSObject} style
		     *        Style settings.
		     *
		     * @return {Highcharts.CSSObject}
		     *         The style settings mixed with defaults.
		     */
		    getStyle: function (style) {
		        this.style = extend({

		            fontFamily: '"Lucida Grande", "Lucida Sans Unicode", ' +
		                'Arial, Helvetica, sans-serif',
		            fontSize: '12px'

		        }, style);
		        return this.style;
		    },

		    /**
		     * Apply the global style on the renderer, mixed with the default styles.
		     *
		     * @function Highcharts.SVGRenderer#setStyle
		     *
		     * @param {Highcharts.CSSObject} style
		     *        CSS to apply.
		     */
		    setStyle: function (style) {
		        this.boxWrapper.css(this.getStyle(style));
		    },



		    /**
		     * Detect whether the renderer is hidden. This happens when one of the
		     * parent elements has `display: none`. Used internally to detect when we
		     * needto render preliminarily in another div to get the text bounding boxes
		     * right.
		     *
		     * @function Highcharts.SVGRenderer#isHidden
		     *
		     * @return {boolean}
		     *         True if it is hidden.
		     */
		    isHidden: function () { // #608
		        return !this.boxWrapper.getBBox().width;
		    },

		    /**
		     * Destroys the renderer and its allocated members.
		     *
		     * @function Highcharts.SVGRenderer#destroy
		     */
		    destroy: function () {
		        var renderer = this,
		            rendererDefs = renderer.defs;
		        renderer.box = null;
		        renderer.boxWrapper = renderer.boxWrapper.destroy();

		        // Call destroy on all gradient elements
		        destroyObjectProperties(renderer.gradients || {});
		        renderer.gradients = null;

		        // Defs are null in VMLRenderer
		        // Otherwise, destroy them here.
		        if (rendererDefs) {
		            renderer.defs = rendererDefs.destroy();
		        }

		        // Remove sub pixel fix handler (#982)
		        if (renderer.unSubPixelFix) {
		            renderer.unSubPixelFix();
		        }

		        renderer.alignedObjects = null;

		        return null;
		    },

		    /**
		     * Create a wrapper for an SVG element. Serves as a factory for
		     * {@link SVGElement}, but this function is itself mostly called from
		     * primitive factories like {@link SVGRenderer#path}, {@link
		     * SVGRenderer#rect} or {@link SVGRenderer#text}.
		     *
		     * @function Highcharts.SVGRenderer#createElement
		     *
		     * @param {string} nodeName
		     *        The node name, for example `rect`, `g` etc.
		     *
		     * @return {Highcharts.SVGElement}
		     *         The generated SVGElement.
		     */
		    createElement: function (nodeName) {
		        var wrapper = new this.Element();
		        wrapper.init(this, nodeName);
		        return wrapper;
		    },

		    /**
		     * Dummy function for plugins, called every time the renderer is updated.
		     * Prior to Highcharts 5, this was used for the canvg renderer.
		     *
		     * @deprecated
		     * @function Highcharts.SVGRenderer#draw
		     */
		    draw: noop,

		    /**
		     * Get converted radial gradient attributes according to the radial
		     * reference. Used internally from the {@link SVGElement#colorGradient}
		     * function.
		     *
		     * @private
		     * @function Highcharts.SVGRenderer#getRadialAttr
		     *
		     * @param {Array<number>} radialReference
		     *
		     * @param {Highcharts.SVGAttributes} gradAttr
		     *
		     * @return {Highcharts.SVGAttributes}
		     */
		    getRadialAttr: function (radialReference, gradAttr) {
		        return {
		            cx: (radialReference[0] - radialReference[2] / 2) +
		                gradAttr.cx * radialReference[2],
		            cy: (radialReference[1] - radialReference[2] / 2) +
		                gradAttr.cy * radialReference[2],
		            r: gradAttr.r * radialReference[2]
		        };
		    },

		    /**
		     * Truncate the text node contents to a given length. Used when the css
		     * width is set. If the `textOverflow` is `ellipsis`, the text is truncated
		     * character by character to the given length. If not, the text is
		     * word-wrapped line by line.
		     *
		     * @private
		     * @function Highcharts.SVGRenderer#truncate
		     *
		     * @param {Highcharts.SVGElement} wrapper
		     *
		     * @param {Highcharts.SVGDOMElement} tspan
		     *
		     * @param {string} text
		     *
		     * @param {Array.<string>} words
		     *
		     * @param {number} width
		     *
		     * @param {Function} getString
		     *
		     * @return {boolean}
		     *         True if tspan is too long.
		     */
		    truncate: function (
		        wrapper,
		        tspan,
		        text,
		        words,
		        startAt,
		        width,
		        getString
		    ) {
		        var renderer = this,
		            rotation = wrapper.rotation,
		            str,
		            // Word wrap can not be truncated to shorter than one word, ellipsis
		            // text can be completely blank.
		            minIndex = words ? 1 : 0,
		            maxIndex = (text || words).length,
		            currentIndex = maxIndex,
		            // Cache the lengths to avoid checking the same twice
		            lengths = [],
		            updateTSpan = function (s) {
		                if (tspan.firstChild) {
		                    tspan.removeChild(tspan.firstChild);
		                }
		                if (s) {
		                    tspan.appendChild(doc.createTextNode(s));
		                }
		            },
		            getSubStringLength = function (charEnd, concatenatedEnd) {
		                // charEnd is useed when finding the character-by-character
		                // break for ellipsis, concatenatedEnd is used for word-by-word
		                // break for word wrapping.
		                var end = concatenatedEnd || charEnd;
		                if (lengths[end] === undefined) {
		                    // Modern browsers
		                    if (tspan.getSubStringLength) {
		                        // Fails with DOM exception on unit-tests/legend/members
		                        // of unknown reason. Desired width is 0, text content
		                        // is "5" and end is 1.
		                        try {
		                            lengths[end] = startAt + tspan.getSubStringLength(
		                                0,
		                                words ? end + 1 : end
		                            );

		                        } catch (e) {}

		                    // Legacy
		                    } else if (renderer.getSpanWidth) { // #9058 jsdom
		                        updateTSpan(getString(text || words, charEnd));
		                        lengths[end] = startAt +
		                            renderer.getSpanWidth(wrapper, tspan);
		                    }
		                }
		                return lengths[end];
		            },
		            actualWidth,
		            truncated;

		        wrapper.rotation = 0; // discard rotation when computing box
		        actualWidth = getSubStringLength(tspan.textContent.length);
		        truncated = startAt + actualWidth > width;
		        if (truncated) {

		            // Do a binary search for the index where to truncate the text
		            while (minIndex <= maxIndex) {
		                currentIndex = Math.ceil((minIndex + maxIndex) / 2);

		                // When checking words for word-wrap, we need to build the
		                // string and measure the subStringLength at the concatenated
		                // word length.
		                if (words) {
		                    str = getString(words, currentIndex);
		                }
		                actualWidth = getSubStringLength(
		                    currentIndex,
		                    str && str.length - 1
		                );

		                if (minIndex === maxIndex) {
		                    // Complete
		                    minIndex = maxIndex + 1;
		                } else if (actualWidth > width) {
		                    // Too large. Set max index to current.
		                    maxIndex = currentIndex - 1;
		                } else {
		                    // Within width. Set min index to current.
		                    minIndex = currentIndex;
		                }
		            }
		            // If max index was 0 it means the shortest possible text was also
		            // too large. For ellipsis that means only the ellipsis, while for
		            // word wrap it means the whole first word.
		            if (maxIndex === 0) {
		                // Remove ellipsis
		                updateTSpan('');

		            // If the new text length is one less than the original, we don't
		            // need the ellipsis
		            } else if (!(text && maxIndex === text.length - 1)) {
		                updateTSpan(str || getString(text || words, currentIndex));
		            }
		        }

		        // When doing line wrapping, prepare for the next line by removing the
		        // items from this line.
		        if (words) {
		            words.splice(0, currentIndex);
		        }

		        wrapper.actualWidth = actualWidth;
		        wrapper.rotation = rotation; // Apply rotation again.
		        return truncated;
		    },

		    /**
		     * A collection of characters mapped to HTML entities. When `useHTML` on an
		     * element is true, these entities will be rendered correctly by HTML. In
		     * the SVG pseudo-HTML, they need to be unescaped back to simple characters,
		     * so for example `&lt;` will render as `<`.
		     *
		     * @example
		     * // Add support for unescaping quotes
		     * Highcharts.SVGRenderer.prototype.escapes['"'] = '&quot;';
		     *
		     * @name Highcharts.SVGRenderer#escapes
		     * @type {Highcharts.Dictionary<string>}
		     */
		    escapes: {
		        '&': '&amp;',
		        '<': '&lt;',
		        '>': '&gt;',
		        "'": '&#39;', // eslint-disable-line quotes
		        '"': '&quot;'
		    },

		    /**
		     * Parse a simple HTML string into SVG tspans. Called internally when text
		     * is set on an SVGElement. The function supports a subset of HTML tags, CSS
		     * text features like `width`, `text-overflow`, `white-space`, and also
		     * attributes like `href` and `style`.
		     *
		     * @private
		     * @function Highcharts.SVGRenderer#buildText
		     *
		     * @param {Highcharts.SVGElement} wrapper
		     *        The parent SVGElement.
		     */
		    buildText: function (wrapper) {
		        var textNode = wrapper.element,
		            renderer = this,
		            forExport = renderer.forExport,
		            textStr = pick(wrapper.textStr, '').toString(),
		            hasMarkup = textStr.indexOf('<') !== -1,
		            lines,
		            childNodes = textNode.childNodes,
		            truncated,
		            parentX = attr(textNode, 'x'),
		            textStyles = wrapper.styles,
		            width = wrapper.textWidth,
		            textLineHeight = textStyles && textStyles.lineHeight,
		            textOutline = textStyles && textStyles.textOutline,
		            ellipsis = textStyles && textStyles.textOverflow === 'ellipsis',
		            noWrap = textStyles && textStyles.whiteSpace === 'nowrap',
		            fontSize = textStyles && textStyles.fontSize,
		            textCache,
		            isSubsequentLine,
		            i = childNodes.length,
		            tempParent = width && !wrapper.added && this.box,
		            getLineHeight = function (tspan) {
		                var fontSizeStyle;

		                fontSizeStyle = /(px|em)$/.test(tspan && tspan.style.fontSize) ?
		                    tspan.style.fontSize :
		                    (fontSize || renderer.style.fontSize || 12);


		                return textLineHeight ?
		                    pInt(textLineHeight) :
		                    renderer.fontMetrics(
		                        fontSizeStyle,
		                        // Get the computed size from parent if not explicit
		                        tspan.getAttribute('style') ? tspan : textNode
		                    ).h;
		            },
		            unescapeEntities = function (inputStr, except) {
		                objectEach(renderer.escapes, function (value, key) {
		                    if (!except || inArray(value, except) === -1) {
		                        inputStr = inputStr.toString().replace(
		                            new RegExp(value, 'g'), // eslint-disable-line security/detect-non-literal-regexp
		                            key
		                        );
		                    }
		                });
		                return inputStr;
		            },
		            parseAttribute = function (s, attr) {
		                var start,
		                    delimiter;

		                start = s.indexOf('<');
		                s = s.substring(start, s.indexOf('>') - start);

		                start = s.indexOf(attr + '=');
		                if (start !== -1) {
		                    start = start + attr.length + 1;
		                    delimiter = s.charAt(start);
		                    if (delimiter === '"' || delimiter === "'") { // eslint-disable-line quotes
		                        s = s.substring(start + 1);
		                        return s.substring(0, s.indexOf(delimiter));
		                    }
		                }
		            };

		        // The buildText code is quite heavy, so if we're not changing something
		        // that affects the text, skip it (#6113).
		        textCache = [
		            textStr,
		            ellipsis,
		            noWrap,
		            textLineHeight,
		            textOutline,
		            fontSize,
		            width
		        ].join(',');
		        if (textCache === wrapper.textCache) {
		            return;
		        }
		        wrapper.textCache = textCache;

		        // Remove old text
		        while (i--) {
		            textNode.removeChild(childNodes[i]);
		        }

		        // Skip tspans, add text directly to text node. The forceTSpan is a hook
		        // used in text outline hack.
		        if (
		            !hasMarkup &&
		            !textOutline &&
		            !ellipsis &&
		            !width &&
		            textStr.indexOf(' ') === -1
		        ) {
		            textNode.appendChild(doc.createTextNode(unescapeEntities(textStr)));

		        // Complex strings, add more logic
		        } else {

		            if (tempParent) {
		                // attach it to the DOM to read offset width
		                tempParent.appendChild(textNode);
		            }

		            if (hasMarkup) {
		                lines = textStr

		                    .replace(/<(b|strong)>/g, '<span style="font-weight:bold">')
		                    .replace(/<(i|em)>/g, '<span style="font-style:italic">')

		                    .replace(/<a/g, '<span')
		                    .replace(/<\/(b|strong|i|em|a)>/g, '</span>')
		                    .split(/<br.*?>/g);

		            } else {
		                lines = [textStr];
		            }


		            // Trim empty lines (#5261)
		            lines = grep(lines, function (line) {
		                return line !== '';
		            });


		            // build the lines
		            each(lines, function buildTextLines(line, lineNo) {
		                var spans,
		                    spanNo = 0,
		                    lineLength = 0;
		                line = line
		                    // Trim to prevent useless/costly process on the spaces
		                    // (#5258)
		                    .replace(/^\s+|\s+$/g, '')
		                    .replace(/<span/g, '|||<span')
		                    .replace(/<\/span>/g, '</span>|||');
		                spans = line.split('|||');

		                each(spans, function buildTextSpans(span) {
		                    if (span !== '' || spans.length === 1) {
		                        var attributes = {},
		                            tspan = doc.createElementNS(
		                                renderer.SVG_NS,
		                                'tspan'
		                            ),
		                            classAttribute,
		                            styleAttribute, // #390
		                            hrefAttribute;

		                        classAttribute = parseAttribute(span, 'class');
		                        if (classAttribute) {
		                            attr(tspan, 'class', classAttribute);
		                        }

		                        styleAttribute = parseAttribute(span, 'style');
		                        if (styleAttribute) {
		                            styleAttribute = styleAttribute.replace(
		                                /(;| |^)color([ :])/,
		                                '$1fill$2'
		                            );
		                            attr(tspan, 'style', styleAttribute);
		                        }

		                        // Not for export - #1529
		                        hrefAttribute = parseAttribute(span, 'href');
		                        if (hrefAttribute && !forExport) {
		                            attr(
		                                tspan,
		                                'onclick',
		                                'location.href=\"' + hrefAttribute + '\"'
		                            );
		                            attr(tspan, 'class', 'highcharts-anchor');

		                            css(tspan, { cursor: 'pointer' });

		                        }

		                        // Strip away unsupported HTML tags (#7126)
		                        span = unescapeEntities(
		                            span.replace(/<[a-zA-Z\/](.|\n)*?>/g, '') || ' '
		                        );

		                        // Nested tags aren't supported, and cause crash in
		                        // Safari (#1596)
		                        if (span !== ' ') {

		                            // add the text node
		                            tspan.appendChild(doc.createTextNode(span));

		                            // First span in a line, align it to the left
		                            if (!spanNo) {
		                                if (lineNo && parentX !== null) {
		                                    attributes.x = parentX;
		                                }
		                            } else {
		                                attributes.dx = 0; // #16
		                            }

		                            // add attributes
		                            attr(tspan, attributes);

		                            // Append it
		                            textNode.appendChild(tspan);

		                            // first span on subsequent line, add the line
		                            // height
		                            if (!spanNo && isSubsequentLine) {

		                                // allow getting the right offset height in
		                                // exporting in IE
		                                if (!svg && forExport) {
		                                    css(tspan, { display: 'block' });
		                                }

		                                // Set the line height based on the font size of
		                                // either the text element or the tspan element
		                                attr(
		                                    tspan,
		                                    'dy',
		                                    getLineHeight(tspan)
		                                );
		                            }

		                            // Check width and apply soft breaks or ellipsis
		                            if (width) {
		                                var words = span.replace(
		                                        /([^\^])-/g,
		                                        '$1- '
		                                    ).split(' '), // #1273
		                                    hasWhiteSpace = !noWrap && (
		                                        spans.length > 1 ||
		                                        lineNo ||
		                                        words.length > 1
		                                    ),
		                                    wrapLineNo = 0,
		                                    dy = getLineHeight(tspan);

		                                if (ellipsis) {
		                                    truncated = renderer.truncate(
		                                        wrapper,
		                                        tspan,
		                                        span,
		                                        undefined,
		                                        0,
		                                        // Target width
		                                        Math.max(
		                                            0,
		                                            // Substract the font face to make
		                                            // room for the ellipsis itself
		                                            width - parseInt(fontSize || 12, 10)
		                                        ),
		                                        // Build the text to test for
		                                        function (text, currentIndex) {
		                                            return text.substring(
		                                                0,
		                                                currentIndex
		                                            ) + '\u2026';
		                                        }
		                                    );
		                                } else if (hasWhiteSpace) {

		                                    while (words.length) {

		                                        // For subsequent lines, create tspans
		                                        // with the same style attributes as the
		                                        // parent text node.
		                                        if (
		                                            words.length &&
		                                            !noWrap &&
		                                            wrapLineNo > 0
		                                        ) {

		                                            tspan = doc.createElementNS(
		                                                SVG_NS,
		                                                'tspan'
		                                            );
		                                            attr(tspan, {
		                                                dy: dy,
		                                                x: parentX
		                                            });
		                                            if (styleAttribute) { // #390
		                                                attr(
		                                                    tspan,
		                                                    'style',
		                                                    styleAttribute
		                                                );
		                                            }
		                                            // Start by appending the full
		                                            // remaining text
		                                            tspan.appendChild(
		                                                doc.createTextNode(
		                                                    words.join(' ')
		                                                        .replace(/- /g, '-')
		                                                )
		                                            );
		                                            textNode.appendChild(tspan);
		                                        }

		                                        // For each line, truncate the remaining
		                                        // words into the line length.
		                                        renderer.truncate(
		                                            wrapper,
		                                            tspan,
		                                            null,
		                                            words,
		                                            wrapLineNo === 0 ? lineLength : 0,
		                                            width,
		                                            // Build the text to test for
		                                            function (text, currentIndex) {
		                                                return words
		                                                    .slice(0, currentIndex)
		                                                    .join(' ')
		                                                    .replace(/- /g, '-');
		                                            }
		                                        );

		                                        lineLength = wrapper.actualWidth;
		                                        wrapLineNo++;
		                                    }
		                                }
		                            }

		                            spanNo++;
		                        }

		                    }

		                });

		                // To avoid beginning lines that doesn't add to the textNode
		                // (#6144)
		                isSubsequentLine = (
		                    isSubsequentLine ||
		                    textNode.childNodes.length
		                );
		            });

		            if (ellipsis && truncated) {
		                wrapper.attr(
		                    'title',
		                    unescapeEntities(wrapper.textStr, ['&lt;', '&gt;']) // #7179
		                );
		            }
		            if (tempParent) {
		                tempParent.removeChild(textNode);
		            }

		            // Apply the text outline
		            if (textOutline && wrapper.applyTextOutline) {
		                wrapper.applyTextOutline(textOutline);
		            }
		        }
		    },

		    /**
		     * Returns white for dark colors and black for bright colors.
		     *
		     * @function Highcharts.SVGRenderer#getContrast
		     *
		     * @param {Highcharts.ColorString} rgba
		     *        The color to get the contrast for.
		     *
		     * @return {string}
		     *         The contrast color, either `#000000` or `#FFFFFF`.
		     */
		    getContrast: function (rgba) {
		        rgba = color(rgba).rgba;

		        // The threshold may be discussed. Here's a proposal for adding
		        // different weight to the color channels (#6216)
		        rgba[0] *= 1; // red
		        rgba[1] *= 1.2; // green
		        rgba[2] *= 0.5; // blue

		        return rgba[0] + rgba[1] + rgba[2] > 1.8 * 255 ? '#000000' : '#FFFFFF';
		    },

		    /**
		     * Create a button with preset states.
		     *
		     * @function Highcharts.SVGRenderer#button
		     *
		     * @param {string} text
		     *        The text or HTML to draw.
		     *
		     * @param {number} x
		     *        The x position of the button's left side.
		     *
		     * @param {number} y
		     *        The y position of the button's top side.
		     *
		     * @param {Function} callback
		     *        The function to execute on button click or touch.
		     *
		     * @param {Highcharts.SVGAttributes} [normalState]
		     *        SVG attributes for the normal state.
		     *
		     * @param {Highcharts.SVGAttributes} [hoverState]
		     *        SVG attributes for the hover state.
		     *
		     * @param {Highcharts.SVGAttributes} [pressedState]
		     *        SVG attributes for the pressed state.
		     *
		     * @param {Highcharts.SVGAttributes} [disabledState]
		     *        SVG attributes for the disabled state.
		     *
		     * @param {Highcharts.SymbolKey} [shape=rect]
		     *        The shape type.
		     *
		     * @return {Highcharts.SVGElement}
		     *         The button element.
		     */
		    button: function (
		        text,
		        x,
		        y,
		        callback,
		        normalState,
		        hoverState,
		        pressedState,
		        disabledState,
		        shape
		    ) {
		        var label = this.label(
		                text,
		                x,
		                y,
		                shape,
		                null,
		                null,
		                null,
		                null,
		                'button'
		            ),
		            curState = 0;

		        // Default, non-stylable attributes
		        label.attr(merge({
		            'padding': 8,
		            'r': 2
		        }, normalState));


		        // Presentational
		        var normalStyle,
		            hoverStyle,
		            pressedStyle,
		            disabledStyle;

		        // Normal state - prepare the attributes
		        normalState = merge({
		            fill: '#f7f7f7',
		            stroke: '#cccccc',
		            'stroke-width': 1,
		            style: {
		                color: '#333333',
		                cursor: 'pointer',
		                fontWeight: 'normal'
		            }
		        }, normalState);
		        normalStyle = normalState.style;
		        delete normalState.style;

		        // Hover state
		        hoverState = merge(normalState, {
		            fill: '#e6e6e6'
		        }, hoverState);
		        hoverStyle = hoverState.style;
		        delete hoverState.style;

		        // Pressed state
		        pressedState = merge(normalState, {
		            fill: '#e6ebf5',
		            style: {
		                color: '#000000',
		                fontWeight: 'bold'
		            }
		        }, pressedState);
		        pressedStyle = pressedState.style;
		        delete pressedState.style;

		        // Disabled state
		        disabledState = merge(normalState, {
		            style: {
		                color: '#cccccc'
		            }
		        }, disabledState);
		        disabledStyle = disabledState.style;
		        delete disabledState.style;


		        // Add the events. IE9 and IE10 need mouseover and mouseout to funciton
		        // (#667).
		        addEvent(label.element, isMS ? 'mouseover' : 'mouseenter', function () {
		            if (curState !== 3) {
		                label.setState(1);
		            }
		        });
		        addEvent(label.element, isMS ? 'mouseout' : 'mouseleave', function () {
		            if (curState !== 3) {
		                label.setState(curState);
		            }
		        });

		        label.setState = function (state) {
		            // Hover state is temporary, don't record it
		            if (state !== 1) {
		                label.state = curState = state;
		            }
		            // Update visuals
		            label.removeClass(
		                    /highcharts-button-(normal|hover|pressed|disabled)/
		                )
		                .addClass(
		                    'highcharts-button-' +
		                    ['normal', 'hover', 'pressed', 'disabled'][state || 0]
		                );


		            label.attr([
		                normalState,
		                hoverState,
		                pressedState,
		                disabledState
		            ][state || 0])
		            .css([
		                normalStyle,
		                hoverStyle,
		                pressedStyle,
		                disabledStyle
		            ][state || 0]);

		        };



		        // Presentational attributes
		        label
		            .attr(normalState)
		            .css(extend({ cursor: 'default' }, normalStyle));


		        return label
		            .on('click', function (e) {
		                if (curState !== 3) {
		                    callback.call(label, e);
		                }
		            });
		    },

		    /**
		     * Make a straight line crisper by not spilling out to neighbour pixels.
		     *
		     * @function Highcharts.SVGRenderer#crispLine
		     *
		     * @param {Highcharts.SVGPathArray} points
		     *        The original points on the format `['M', 0, 0, 'L', 100, 0]`.
		     *
		     * @param {number} width
		     *        The width of the line.
		     *
		     * @return {Highcharts.SVGPathArray}
		     *         The original points array, but modified to render crisply.
		     */
		    crispLine: function (points, width) {
		        // normalize to a crisp line
		        if (points[1] === points[4]) {
		            // Substract due to #1129. Now bottom and left axis gridlines behave
		            // the same.
		            points[1] = points[4] = Math.round(points[1]) - (width % 2 / 2);
		        }
		        if (points[2] === points[5]) {
		            points[2] = points[5] = Math.round(points[2]) + (width % 2 / 2);
		        }
		        return points;
		    },


		    /**
		     * Draw a path, wraps the SVG `path` element.
		     *
		     * @sample highcharts/members/renderer-path-on-chart/
		     *         Draw a path in a chart
		     * @sample highcharts/members/renderer-path/
		     *         Draw a path independent from a chart
		     *
		     * @example
		     * var path = renderer.path(['M', 10, 10, 'L', 30, 30, 'z'])
		     *     .attr({ stroke: '#ff00ff' })
		     *     .add();
		     *
		     * @function Highcharts.SVGRenderer#path
		     *
		     * @param {Highcharts.SVGPathArray} [path]
		     *        An SVG path definition in array form.
		     *
		     * @return {Highcharts.SVGElement}
		     *         The generated wrapper element.
		     *
		     *//**
		     * Draw a path, wraps the SVG `path` element.
		     *
		     * @function Highcharts.SVGRenderer#path
		     *
		     * @param {Highcharts.SVGAttributes} [attribs]
		     *        The initial attributes.
		     *
		     * @return {Highcharts.SVGElement}
		     *         The generated wrapper element.
		     */
		    path: function (path) {
		        var attribs = {

		            fill: 'none'

		        };
		        if (isArray(path)) {
		            attribs.d = path;
		        } else if (isObject(path)) { // attributes
		            extend(attribs, path);
		        }
		        return this.createElement('path').attr(attribs);
		    },

		    /**
		     * Draw a circle, wraps the SVG `circle` element.
		     *
		     * @sample highcharts/members/renderer-circle/
		     *         Drawing a circle
		     *
		     * @function Highcharts.SVGRenderer#circle
		     *
		     * @param {number} [x]
		     *        The center x position.
		     *
		     * @param {number} [y]
		     *        The center y position.
		     *
		     * @param {number} [r]
		     *        The radius.
		     *
		     * @return {Highcharts.SVGElement}
		     *         The generated wrapper element.
		     *//**
		     * Draw a circle, wraps the SVG `circle` element.
		     *
		     * @function Highcharts.SVGRenderer#circle
		     *
		     * @param {Highcharts.SVGAttributes} [attribs]
		     *        The initial attributes.
		     *
		     * @return {Highcharts.SVGElement}
		     *         The generated wrapper element.
		     */
		    circle: function (x, y, r) {
		        var attribs = isObject(x) ? x : { x: x, y: y, r: r },
		            wrapper = this.createElement('circle');

		        // Setting x or y translates to cx and cy
		        wrapper.xSetter = wrapper.ySetter = function (value, key, element) {
		            element.setAttribute('c' + key, value);
		        };

		        return wrapper.attr(attribs);
		    },

		    /**
		     * Draw and return an arc.
		     *
		     * @sample highcharts/members/renderer-arc/
		     *         Drawing an arc
		     *
		     * @function Highcharts.SVGRenderer#arc
		     *
		     * @param {number} [x=0]
		     *        Center X position.
		     *
		     * @param {number} [y=0]
		     *        Center Y position.
		     *
		     * @param {number} [r=0]
		     *        The outer radius of the arc.
		     *
		     * @param {number} [innerR=0]
		     *        Inner radius like used in donut charts.
		     *
		     * @param {number} [start=0]
		     *        The starting angle of the arc in radians, where 0 is to the right
		     *         and `-Math.PI/2` is up.
		     *
		     * @param {number} [end=0]
		     *        The ending angle of the arc in radians, where 0 is to the right
		     *        and `-Math.PI/2` is up.
		     *
		     * @return {Highcharts.SVGElement}
		     *         The generated wrapper element.
		     *//**
		     * Draw and return an arc. Overloaded function that takes arguments object.
		     *
		     * @function Highcharts.SVGRenderer#arc
		     *
		     * @param {Highcharts.SVGAttributes} attribs
		     *        Initial SVG attributes.
		     *
		     * @return {Highcharts.SVGElement}
		     *         The generated wrapper element.
		     */
		    arc: function (x, y, r, innerR, start, end) {
		        var arc,
		            options;

		        if (isObject(x)) {
		            options = x;
		            y = options.y;
		            r = options.r;
		            innerR = options.innerR;
		            start = options.start;
		            end = options.end;
		            x = options.x;
		        } else {
		            options = {
		                innerR: innerR,
		                start: start,
		                end: end
		            };
		        }

		        // Arcs are defined as symbols for the ability to set
		        // attributes in attr and animate
		        arc = this.symbol('arc', x, y, r, r, options);
		        arc.r = r; // #959
		        return arc;
		    },

		    /**
		     * Draw and return a rectangle.
		     *
		     * @function Highcharts.SVGRenderer#rect
		     *
		     * @param {number} [x]
		     *        Left position.
		     *
		     * @param {number} [y]
		     *        Top position.
		     *
		     * @param {number} [width]
		     *        Width of the rectangle.
		     *
		     * @param {number} [height]
		     *        Height of the rectangle.
		     *
		     * @param {number} [r]
		     *        Border corner radius.
		     *
		     * @param {number} [strokeWidth]
		     *        A stroke width can be supplied to allow crisp drawing.
		     *
		     * @return {Highcharts.SVGElement}
		     *         The generated wrapper element.
		     *//**
		     * Draw and return a rectangle.
		     *
		     * @sample highcharts/members/renderer-rect-on-chart/
		     *         Draw a rectangle in a chart
		     * @sample highcharts/members/renderer-rect/
		     *         Draw a rectangle independent from a chart
		     *
		     * @function Highcharts.SVGRenderer#rect
		     *
		     * @param {Highcharts.SVGAttributes} [attributes]
		     *        General SVG attributes for the rectangle.
		     *
		     * @return {Highcharts.SVGElement}
		     *         The generated wrapper element.
		     */
		    rect: function (x, y, width, height, r, strokeWidth) {

		        r = isObject(x) ? x.r : r;

		        var wrapper = this.createElement('rect'),
		            attribs = isObject(x) ? x : x === undefined ? {} : {
		                x: x,
		                y: y,
		                width: Math.max(width, 0),
		                height: Math.max(height, 0)
		            };


		        if (strokeWidth !== undefined) {
		            attribs.strokeWidth = strokeWidth;
		            attribs = wrapper.crisp(attribs);
		        }
		        attribs.fill = 'none';


		        if (r) {
		            attribs.r = r;
		        }

		        wrapper.rSetter = function (value, key, element) {
		            attr(element, {
		                rx: value,
		                ry: value
		            });
		        };

		        return wrapper.attr(attribs);
		    },

		    /**
		     * Resize the {@link SVGRenderer#box} and re-align all aligned child
		     * elements.
		     *
		     * @sample highcharts/members/renderer-g/
		     *         Show and hide grouped objects
		     *
		     * @function Highcharts.SVGRenderer#setSize
		     *
		     * @param {number} width
		     *        The new pixel width.
		     *
		     * @param {number} height
		     *        The new pixel height.
		     *
		     * @param {boolean|Highcharts.AnimationOptionsObject} [animate=true]
		     *        Whether and how to animate.
		     */
		    setSize: function (width, height, animate) {
		        var renderer = this,
		            alignedObjects = renderer.alignedObjects,
		            i = alignedObjects.length;

		        renderer.width = width;
		        renderer.height = height;

		        renderer.boxWrapper.animate({
		            width: width,
		            height: height
		        }, {
		            step: function () {
		                this.attr({
		                    viewBox: '0 0 ' + this.attr('width') + ' ' +
		                        this.attr('height')
		                });
		            },
		            duration: pick(animate, true) ? undefined : 0
		        });

		        while (i--) {
		            alignedObjects[i].align();
		        }
		    },

		    /**
		     * Create and return an svg group element. Child
		     * {@link Highcharts.SVGElement} objects are added to the group by using the
		     * group as the first parameter in {@link Highcharts.SVGElement#add|add()}.
		     *
		     * @function Highcharts.SVGRenderer#g
		     *
		     * @param {string} [name]
		     *        The group will be given a class name of `highcharts-{name}`. This
		     *        can be used for styling and scripting.
		     *
		     * @return {Highcharts.SVGElement}
		     *         The generated wrapper element.
		     */
		    g: function (name) {
		        var elem = this.createElement('g');
		        return name ? elem.attr({ 'class': 'highcharts-' + name }) : elem;
		    },

		    /**
		     * Display an image.
		     *
		     * @sample highcharts/members/renderer-image-on-chart/
		     *         Add an image in a chart
		     * @sample highcharts/members/renderer-image/
		     *         Add an image independent of a chart
		     *
		     * @function Highcharts.SVGRenderer#image
		     *
		     * @param {string} src
		     *        The image source.
		     *
		     * @param {number} [x]
		     *        The X position.
		     *
		     * @param {number} [y]
		     *        The Y position.
		     *
		     * @param {number} [width]
		     *        The image width. If omitted, it defaults to the image file width.
		     *
		     * @param {number} [height]
		     *        The image height. If omitted it defaults to the image file
		     *        height.
		     *
		     * @param {Function} [onload]
		     *        Event handler for image load.
		     *
		     * @return {Highcharts.SVGElement}
		     *         The generated wrapper element.
		     */
		    image: function (src, x, y, width, height, onload) {
		        var attribs = {
		                preserveAspectRatio: 'none'
		            },
		            elemWrapper,
		            dummy,
		            setSVGImageSource = function (el, src) {
		                // Set the href in the xlink namespace
		                if (el.setAttributeNS) {
		                    el.setAttributeNS(
		                        'http://www.w3.org/1999/xlink', 'href', src
		                    );
		                } else {
		                    // could be exporting in IE
		                    // using href throws "not supported" in ie7 and under,
		                    // requries regex shim to fix later
		                    el.setAttribute('hc-svg-href', src);
		                }
		            },
		            onDummyLoad = function (e) {
		                setSVGImageSource(elemWrapper.element, src);
		                onload.call(elemWrapper, e);
		            };

		        // optional properties
		        if (arguments.length > 1) {
		            extend(attribs, {
		                x: x,
		                y: y,
		                width: width,
		                height: height
		            });
		        }

		        elemWrapper = this.createElement('image').attr(attribs);

		        // Add load event if supplied
		        if (onload) {
		            // We have to use a dummy HTML image since IE support for SVG image
		            // load events is very buggy. First set a transparent src, wait for
		            // dummy to load, and then add the real src to the SVG image.
		            setSVGImageSource(
		                elemWrapper.element,
		                'data:image/gif;base64,R0lGODlhAQABAAAAACH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==' /* eslint-disable-line */
		            );
		            dummy = new win.Image();
		            addEvent(dummy, 'load', onDummyLoad);
		            dummy.src = src;
		            if (dummy.complete) {
		                onDummyLoad({});
		            }
		        } else {
		            setSVGImageSource(elemWrapper.element, src);
		        }

		        return elemWrapper;
		    },

		    /**
		     * Draw a symbol out of pre-defined shape paths from
		     * {@link SVGRenderer#symbols}.
		     * It is used in Highcharts for point makers, which cake a `symbol` option,
		     * and label and button backgrounds like in the tooltip and stock flags.
		     *
		     * @function Highcharts.SVGRenderer#symbol
		     *
		     * @param {symbol} symbol
		     *        The symbol name.
		     *
		     * @param {number} x
		     *        The X coordinate for the top left position.
		     *
		     * @param {number} y
		     *        The Y coordinate for the top left position.
		     *
		     * @param {number} width
		     *        The pixel width.
		     *
		     * @param {number} height
		     *        The pixel height.
		     *
		     * @param {Highcharts.SymbolOptionsObject} [options]
		     *        Additional options, depending on the actual symbol drawn.
		     *
		     * @return {Highcharts.SVGElement}
		     */
		    symbol: function (symbol, x, y, width, height, options) {

		        var ren = this,
		            obj,
		            imageRegex = /^url\((.*?)\)$/,
		            isImage = imageRegex.test(symbol),
		            sym = !isImage && (this.symbols[symbol] ? symbol : 'circle'),


		            // get the symbol definition function
		            symbolFn = sym && this.symbols[sym],

		            // check if there's a path defined for this symbol
		            path = defined(x) && symbolFn && symbolFn.call(
		                this.symbols,
		                Math.round(x),
		                Math.round(y),
		                width,
		                height,
		                options
		            ),
		            imageSrc,
		            centerImage;

		        if (symbolFn) {
		            obj = this.path(path);


		            obj.attr('fill', 'none');


		            // expando properties for use in animate and attr
		            extend(obj, {
		                symbolName: sym,
		                x: x,
		                y: y,
		                width: width,
		                height: height
		            });
		            if (options) {
		                extend(obj, options);
		            }


		        // Image symbols
		        } else if (isImage) {


		            imageSrc = symbol.match(imageRegex)[1];

		            // Create the image synchronously, add attribs async
		            obj = this.image(imageSrc);

		            // The image width is not always the same as the symbol width. The
		            // image may be centered within the symbol, as is the case when
		            // image shapes are used as label backgrounds, for example in flags.
		            obj.imgwidth = pick(
		                symbolSizes[imageSrc] && symbolSizes[imageSrc].width,
		                options && options.width
		            );
		            obj.imgheight = pick(
		                symbolSizes[imageSrc] && symbolSizes[imageSrc].height,
		                options && options.height
		            );
		            /**
		             * Set the size and position
		             */
		            centerImage = function () {
		                obj.attr({
		                    width: obj.width,
		                    height: obj.height
		                });
		            };

		            /**
		             * Width and height setters that take both the image's physical size
		             * and the label size into consideration, and translates the image
		             * to center within the label.
		             */
		            each(['width', 'height'], function (key) {
		                obj[key + 'Setter'] = function (value, key) {
		                    var attribs = {},
		                        imgSize = this['img' + key],
		                        trans = key === 'width' ? 'translateX' : 'translateY';
		                    this[key] = value;
		                    if (defined(imgSize)) {
		                        if (this.element) {
		                            this.element.setAttribute(key, imgSize);
		                        }
		                        if (!this.alignByTranslate) {
		                            attribs[trans] = ((this[key] || 0) - imgSize) / 2;
		                            this.attr(attribs);
		                        }
		                    }
		                };
		            });


		            if (defined(x)) {
		                obj.attr({
		                    x: x,
		                    y: y
		                });
		            }
		            obj.isImg = true;

		            if (defined(obj.imgwidth) && defined(obj.imgheight)) {
		                centerImage();
		            } else {
		                // Initialize image to be 0 size so export will still function
		                // if there's no cached sizes.
		                obj.attr({ width: 0, height: 0 });

		                // Create a dummy JavaScript image to get the width and height.
		                createElement('img', {
		                    onload: function () {

		                        var chart = charts[ren.chartIndex];

		                        // Special case for SVGs on IE11, the width is not
		                        // accessible until the image is part of the DOM
		                        // (#2854).
		                        if (this.width === 0) {
		                            css(this, {
		                                position: 'absolute',
		                                top: '-999em'
		                            });
		                            doc.body.appendChild(this);
		                        }

		                        // Center the image
		                        symbolSizes[imageSrc] = { // Cache for next
		                            width: this.width,
		                            height: this.height
		                        };
		                        obj.imgwidth = this.width;
		                        obj.imgheight = this.height;

		                        if (obj.element) {
		                            centerImage();
		                        }

		                        // Clean up after #2854 workaround.
		                        if (this.parentNode) {
		                            this.parentNode.removeChild(this);
		                        }

		                        // Fire the load event when all external images are
		                        // loaded
		                        ren.imgCount--;
		                        if (!ren.imgCount && chart && chart.onload) {
		                            chart.onload();
		                        }
		                    },
		                    src: imageSrc
		                });
		                this.imgCount++;
		            }
		        }

		        return obj;
		    },

		    /**
		     * An extendable collection of functions for defining symbol paths.
		     *
		     * @name Highcharts.SVGRenderer#symbols
		     * @type {Highcharts.SymbolDictionary}
		     */
		    symbols: {
		        'circle': function (x, y, w, h) {
		            // Return a full arc
		            return this.arc(x + w / 2, y + h / 2, w / 2, h / 2, {
		                start: 0,
		                end: Math.PI * 2,
		                open: false
		            });
		        },

		        'square': function (x, y, w, h) {
		            return [
		                'M', x, y,
		                'L', x + w, y,
		                x + w, y + h,
		                x, y + h,
		                'Z'
		            ];
		        },

		        'triangle': function (x, y, w, h) {
		            return [
		                'M', x + w / 2, y,
		                'L', x + w, y + h,
		                x, y + h,
		                'Z'
		            ];
		        },

		        'triangle-down': function (x, y, w, h) {
		            return [
		                'M', x, y,
		                'L', x + w, y,
		                x + w / 2, y + h,
		                'Z'
		            ];
		        },
		        'diamond': function (x, y, w, h) {
		            return [
		                'M', x + w / 2, y,
		                'L', x + w, y + h / 2,
		                x + w / 2, y + h,
		                x, y + h / 2,
		                'Z'
		            ];
		        },
		        'arc': function (x, y, w, h, options) {
		            var start = options.start,
		                rx = options.r || w,
		                ry = options.r || h || w,
		                proximity = 0.001,
		                fullCircle =
		                    Math.abs(options.end - options.start - 2 * Math.PI) <
		                    proximity,
		                // Substract a small number to prevent cos and sin of start and
		                // end from becoming equal on 360 arcs (related: #1561)
		                end = options.end - proximity,
		                innerRadius = options.innerR,
		                open = pick(options.open, fullCircle),
		                cosStart = Math.cos(start),
		                sinStart = Math.sin(start),
		                cosEnd = Math.cos(end),
		                sinEnd = Math.sin(end),
		                // Proximity takes care of rounding errors around PI (#6971)
		                longArc = options.end - start - Math.PI < proximity ? 0 : 1,
		                arc;

		            arc = [
		                'M',
		                x + rx * cosStart,
		                y + ry * sinStart,
		                'A', // arcTo
		                rx, // x radius
		                ry, // y radius
		                0, // slanting
		                longArc, // long or short arc
		                1, // clockwise
		                x + rx * cosEnd,
		                y + ry * sinEnd
		            ];

		            if (defined(innerRadius)) {
		                arc.push(
		                    open ? 'M' : 'L',
		                    x + innerRadius * cosEnd,
		                    y + innerRadius * sinEnd,
		                    'A', // arcTo
		                    innerRadius, // x radius
		                    innerRadius, // y radius
		                    0, // slanting
		                    longArc, // long or short arc
		                    0, // clockwise
		                    x + innerRadius * cosStart,
		                    y + innerRadius * sinStart
		                );
		            }

		            arc.push(open ? '' : 'Z'); // close
		            return arc;
		        },

		        /**
		         * Callout shape used for default tooltips, also used for rounded
		         * rectangles in VML
		         */
		        'callout': function (x, y, w, h, options) {
		            var arrowLength = 6,
		                halfDistance = 6,
		                r = Math.min((options && options.r) || 0, w, h),
		                safeDistance = r + halfDistance,
		                anchorX = options && options.anchorX,
		                anchorY = options && options.anchorY,
		                path;

		            path = [
		                'M', x + r, y,
		                'L', x + w - r, y, // top side
		                'C', x + w, y, x + w, y, x + w, y + r, // top-right corner
		                'L', x + w, y + h - r, // right side
		                'C', x + w, y + h, x + w, y + h, x + w - r, y + h, // bottom-rgt
		                'L', x + r, y + h, // bottom side
		                'C', x, y + h, x, y + h, x, y + h - r, // bottom-left corner
		                'L', x, y + r, // left side
		                'C', x, y, x, y, x + r, y // top-left corner
		            ];

		            // Anchor on right side
		            if (anchorX && anchorX > w) {

		                // Chevron
		                if (
		                    anchorY > y + safeDistance &&
		                    anchorY < y + h - safeDistance
		                ) {
		                    path.splice(13, 3,
		                        'L', x + w, anchorY - halfDistance,
		                        x + w + arrowLength, anchorY,
		                        x + w, anchorY + halfDistance,
		                        x + w, y + h - r
		                    );

		                // Simple connector
		                } else {
		                    path.splice(13, 3,
		                        'L', x + w, h / 2,
		                        anchorX, anchorY,
		                        x + w, h / 2,
		                        x + w, y + h - r
		                    );
		                }

		            // Anchor on left side
		            } else if (anchorX && anchorX < 0) {

		                // Chevron
		                if (
		                    anchorY > y + safeDistance &&
		                    anchorY < y + h - safeDistance
		                ) {
		                    path.splice(33, 3,
		                        'L', x, anchorY + halfDistance,
		                        x - arrowLength, anchorY,
		                        x, anchorY - halfDistance,
		                        x, y + r
		                    );

		                // Simple connector
		                } else {
		                    path.splice(33, 3,
		                        'L', x, h / 2,
		                        anchorX, anchorY,
		                        x, h / 2,
		                        x, y + r
		                    );
		                }

		            } else if ( // replace bottom
		                anchorY &&
		                anchorY > h &&
		                anchorX > x + safeDistance &&
		                anchorX < x + w - safeDistance
		            ) {
		                path.splice(23, 3,
		                    'L', anchorX + halfDistance, y + h,
		                    anchorX, y + h + arrowLength,
		                    anchorX - halfDistance, y + h,
		                    x + r, y + h
		                    );

		            } else if ( // replace top
		                anchorY &&
		                anchorY < 0 &&
		                anchorX > x + safeDistance &&
		                anchorX < x + w - safeDistance
		            ) {
		                path.splice(3, 3,
		                    'L', anchorX - halfDistance, y,
		                    anchorX, y - arrowLength,
		                    anchorX + halfDistance, y,
		                    w - r, y
		                );
		            }

		            return path;
		        }
		    },

		    /**
		     * Define a clipping rectangle. The clipping rectangle is later applied
		     * to {@link SVGElement} objects through the {@link SVGElement#clip}
		     * function.
		     *
		     * @example
		     * var circle = renderer.circle(100, 100, 100)
		     *     .attr({ fill: 'red' })
		     *     .add();
		     * var clipRect = renderer.clipRect(100, 100, 100, 100);
		     *
		     * // Leave only the lower right quarter visible
		     * circle.clip(clipRect);
		     *
		     * @function Highcharts.SVGRenderer#clipRect
		     *
		     * @param {string} id
		     *
		     * @param {number} x
		     *
		     * @param {number} y
		     *
		     * @param {number} width
		     *
		     * @param {number} height
		     *
		     * @return {Highcharts.ClipRectElement}
		     *         A clipping rectangle.
		     */
		    clipRect: function (x, y, width, height) {
		        var wrapper,
		            id = H.uniqueKey(),

		            clipPath = this.createElement('clipPath').attr({
		                id: id
		            }).add(this.defs);

		        wrapper = this.rect(x, y, width, height, 0).add(clipPath);
		        wrapper.id = id;
		        wrapper.clipPath = clipPath;
		        wrapper.count = 0;

		        return wrapper;
		    },





		    /**
		     * Draw text. The text can contain a subset of HTML, like spans and anchors
		     * and some basic text styling of these. For more advanced features like
		     * border and background, use {@link Highcharts.SVGRenderer#label} instead.
		     * To update the text after render, run `text.attr({ text: 'New text' })`.
		     *
		     * @sample highcharts/members/renderer-text-on-chart/
		     *         Annotate the chart freely
		     * @sample highcharts/members/renderer-on-chart/
		     *         Annotate with a border and in response to the data
		     * @sample highcharts/members/renderer-text/
		     *         Formatted text
		     *
		     * @function Highcharts.SVGRenderer#text
		     *
		     * @param {string} str
		     *        The text of (subset) HTML to draw.
		     *
		     * @param {number} x
		     *        The x position of the text's lower left corner.
		     *
		     * @param {number} y
		     *        The y position of the text's lower left corner.
		     *
		     * @param {boolean} [useHTML=false]
		     *        Use HTML to render the text.
		     *
		     * @return {Highcharts.SVGElement}
		     *         The text object.
		     */
		    text: function (str, x, y, useHTML) {

		        // declare variables
		        var renderer = this,
		            wrapper,
		            attribs = {};

		        if (useHTML && (renderer.allowHTML || !renderer.forExport)) {
		            return renderer.html(str, x, y);
		        }

		        attribs.x = Math.round(x || 0); // X always needed for line-wrap logic
		        if (y) {
		            attribs.y = Math.round(y);
		        }
		        if (defined(str)) {
		            attribs.text = str;
		        }

		        wrapper = renderer.createElement('text')
		            .attr(attribs);

		        if (!useHTML) {
		            wrapper.xSetter = function (value, key, element) {
		                var tspans = element.getElementsByTagName('tspan'),
		                    tspan,
		                    parentVal = element.getAttribute(key),
		                    i;
		                for (i = 0; i < tspans.length; i++) {
		                    tspan = tspans[i];
		                    // If the x values are equal, the tspan represents a
		                    // linebreak
		                    if (tspan.getAttribute(key) === parentVal) {
		                        tspan.setAttribute(key, value);
		                    }
		                }
		                element.setAttribute(key, value);
		            };
		        }

		        return wrapper;
		    },

		    /**
		     * Utility to return the baseline offset and total line height from the font
		     * size.
		     *
		     * @function Highcharts.SVGRenderer#fontMetrics
		     *
		     * @param {string} [fontSize]
		     *        The current font size to inspect. If not given, the font size
		     *        will be found from the DOM element.
		     *
		     * @param {Highcharts.SVGElement|Highcharts.SVGDOMElement} [elem]
		     *        The element to inspect for a current font size.
		     *
		     * @return {Highcharts.FontMetricsObject}
		     *         The font metrics.
		     */
		    fontMetrics: function (fontSize, elem) {
		        var lineHeight,
		            baseline;


		        fontSize = fontSize ||
		            // When the elem is a DOM element (#5932)
		            (elem && elem.style && elem.style.fontSize) ||
		            // Fall back on the renderer style default
		            (this.style && this.style.fontSize);



		        // Handle different units
		        if (/px/.test(fontSize)) {
		            fontSize = pInt(fontSize);
		        } else if (/em/.test(fontSize)) {
		            // The em unit depends on parent items
		            fontSize = parseFloat(fontSize) *
		                (elem ? this.fontMetrics(null, elem.parentNode).f : 16);
		        } else {
		            fontSize = 12;
		        }

		        // Empirical values found by comparing font size and bounding box
		        // height. Applies to the default font family.
		        // https://jsfiddle.net/highcharts/7xvn7/
		        lineHeight = fontSize < 24 ? fontSize + 3 : Math.round(fontSize * 1.2);
		        baseline = Math.round(lineHeight * 0.8);

		        return {
		            h: lineHeight,
		            b: baseline,
		            f: fontSize
		        };
		    },

		    /**
		     * Correct X and Y positioning of a label for rotation (#1764).
		     *
		     * @private
		     * @function Highcharts.SVGRenderer#rotCorr
		     *
		     * @param {number} baseline
		     *
		     * @param {number} rotation
		     *
		     * @param {boolean} alterY
		     */
		    rotCorr: function (baseline, rotation, alterY) {
		        var y = baseline;
		        if (rotation && alterY) {
		            y = Math.max(y * Math.cos(rotation * deg2rad), 4);
		        }
		        return {
		            x: (-baseline / 3) * Math.sin(rotation * deg2rad),
		            y: y
		        };
		    },

		    /**
		     * Draw a label, which is an extended text element with support for border
		     * and background. Highcharts creates a `g` element with a text and a `path`
		     * or `rect` inside, to make it behave somewhat like a HTML div. Border and
		     * background are set through `stroke`, `stroke-width` and `fill` attributes
		     * using the {@link Highcharts.SVGElement#attr|attr} method. To update the
		     * text after render, run `label.attr({ text: 'New text' })`.
		     *
		     * @sample highcharts/members/renderer-label-on-chart/
		     *         A label on the chart
		     *
		     * @function Highcharts.SVGRenderer#label
		     *
		     * @param {string} str
		     *        The initial text string or (subset) HTML to render.
		     *
		     * @param {number} x
		     *        The x position of the label's left side.
		     *
		     * @param {number} y
		     *        The y position of the label's top side or baseline, depending on
		     *        the `baseline` parameter.
		     *
		     * @param {string} [shape='rect']
		     *        The shape of the label's border/background, if any. Defaults to
		     *        `rect`. Other possible values are `callout` or other shapes
		     *        defined in {@link Highcharts.SVGRenderer#symbols}.
		     *
		     * @param {string} [shape='rect']
		     *        The shape of the label's border/background, if any. Defaults to
		     *        `rect`. Other possible values are `callout` or other shapes
		     *        defined in {@link Highcharts.SVGRenderer#symbols}.
		     *
		     * @param {number} [anchorX]
		     *        In case the `shape` has a pointer, like a flag, this is the
		     *        coordinates it should be pinned to.
		     *
		     * @param {number} [anchorY]
		     *        In case the `shape` has a pointer, like a flag, this is the
		     *        coordinates it should be pinned to.
		     *
		     * @param {boolean} [useHTML=false]
		     *        Wether to use HTML to render the label.
		     *
		     * @param {boolean} [baseline=false]
		     *        Whether to position the label relative to the text baseline,
		     *        like {@link Highcharts.SVGRenderer#text|renderer.text}, or to the
		     *        upper border of the rectangle.
		     *
		     * @param {string} [className]
		     *        Class name for the group.
		     *
		     * @return {Highcharts.SVGElement}
		     *         The generated label.
		     */
		    label: function (
		        str,
		        x,
		        y,
		        shape,
		        anchorX,
		        anchorY,
		        useHTML,
		        baseline,
		        className
		    ) {

		        var renderer = this,
		            wrapper = renderer.g(className !== 'button' && 'label'),
		            text = wrapper.text = renderer.text('', 0, 0, useHTML)
		                .attr({
		                    zIndex: 1
		                }),
		            box,
		            bBox,
		            alignFactor = 0,
		            padding = 3,
		            paddingLeft = 0,
		            width,
		            height,
		            wrapperX,
		            wrapperY,
		            textAlign,
		            deferredAttr = {},
		            strokeWidth,
		            baselineOffset,
		            hasBGImage = /^url\((.*?)\)$/.test(shape),
		            needsBox = hasBGImage,
		            getCrispAdjust,
		            updateBoxSize,
		            updateTextPadding,
		            boxAttr;

		        if (className) {
		            wrapper.addClass('highcharts-' + className);
		        }


		        needsBox = hasBGImage;
		        getCrispAdjust = function () {
		            return (strokeWidth || 0) % 2 / 2;
		        };



		        /*
		         * This function runs after the label is added to the DOM (when the
		         * bounding box is available), and after the text of the label is
		         * updated to detect the new bounding box and reflect it in the border
		         * box.
		         */
		        updateBoxSize = function () {
		            var style = text.element.style,
		                crispAdjust,
		                attribs = {};

		            bBox = (
		                (width === undefined || height === undefined || textAlign) &&
		                defined(text.textStr) &&
		                text.getBBox()
		            ); // #3295 && 3514 box failure when string equals 0

		            wrapper.width = (
		                (width || bBox.width || 0) +
		                2 * padding +
		                paddingLeft
		            );
		            wrapper.height = (height || bBox.height || 0) + 2 * padding;

		            // Update the label-scoped y offset
		            baselineOffset = padding +
		                renderer.fontMetrics(style && style.fontSize, text).b;

		            if (needsBox) {

		                // Create the border box if it is not already present
		                if (!box) {
		                    // Symbol definition exists (#5324)
		                    wrapper.box = box = renderer.symbols[shape] || hasBGImage ?
		                        renderer.symbol(shape) :
		                        renderer.rect();

		                    box.addClass( // Don't use label className for buttons
		                        (className === 'button' ? '' : 'highcharts-label-box') +
		                        (className ? ' highcharts-' + className + '-box' : '')
		                    );

		                    box.add(wrapper);

		                    crispAdjust = getCrispAdjust();
		                    attribs.x = crispAdjust;
		                    attribs.y = (baseline ? -baselineOffset : 0) + crispAdjust;
		                }

		                // Apply the box attributes
		                attribs.width = Math.round(wrapper.width);
		                attribs.height = Math.round(wrapper.height);

		                box.attr(extend(attribs, deferredAttr));
		                deferredAttr = {};
		            }
		        };

		        /*
		         * This function runs after setting text or padding, but only if padding
		         * is changed.
		         */
		        updateTextPadding = function () {
		            var textX = paddingLeft + padding,
		                textY;

		            // determin y based on the baseline
		            textY = baseline ? 0 : baselineOffset;

		            // compensate for alignment
		            if (
		                defined(width) &&
		                bBox &&
		                (textAlign === 'center' || textAlign === 'right')
		            ) {
		                textX += { center: 0.5, right: 1 }[textAlign] *
		                    (width - bBox.width);
		            }

		            // update if anything changed
		            if (textX !== text.x || textY !== text.y) {
		                text.attr('x', textX);
		                // #8159 - prevent misplaced data labels in treemap
		                // (useHTML: true)
		                if (text.hasBoxWidthChanged) {
		                    bBox = text.getBBox(true);
		                    updateBoxSize();
		                }
		                if (textY !== undefined) {
		                    text.attr('y', textY);
		                }
		            }

		            // record current values
		            text.x = textX;
		            text.y = textY;
		        };

		        /*
		         * Set a box attribute, or defer it if the box is not yet created
		         */
		        boxAttr = function (key, value) {
		            if (box) {
		                box.attr(key, value);
		            } else {
		                deferredAttr[key] = value;
		            }
		        };

		        /*
		         * After the text element is added, get the desired size of the border
		         * box and add it before the text in the DOM.
		         */
		        wrapper.onAdd = function () {
		            text.add(wrapper);
		            wrapper.attr({
		                // Alignment is available now  (#3295, 0 not rendered if given
		                // as a value)
		                text: (str || str === 0) ? str : '',
		                x: x,
		                y: y
		            });

		            if (box && defined(anchorX)) {
		                wrapper.attr({
		                    anchorX: anchorX,
		                    anchorY: anchorY
		                });
		            }
		        };

		        /*
		         * Add specific attribute setters.
		         */

		        // only change local variables
		        wrapper.widthSetter = function (value) {
		            width = H.isNumber(value) ? value : null; // width:auto => null
		        };
		        wrapper.heightSetter = function (value) {
		            height = value;
		        };
		        wrapper['text-alignSetter'] = function (value) {
		            textAlign = value;
		        };
		        wrapper.paddingSetter = function (value) {
		            if (defined(value) && value !== padding) {
		                padding = wrapper.padding = value;
		                updateTextPadding();
		            }
		        };
		        wrapper.paddingLeftSetter = function (value) {
		            if (defined(value) && value !== paddingLeft) {
		                paddingLeft = value;
		                updateTextPadding();
		            }
		        };


		        // change local variable and prevent setting attribute on the group
		        wrapper.alignSetter = function (value) {
		            value = { left: 0, center: 0.5, right: 1 }[value];
		            if (value !== alignFactor) {
		                alignFactor = value;
		                // Bounding box exists, means we're dynamically changing
		                if (bBox) {
		                    wrapper.attr({ x: wrapperX }); // #5134
		                }
		            }
		        };

		        // apply these to the box and the text alike
		        wrapper.textSetter = function (value) {
		            if (value !== undefined) {
		                text.textSetter(value);
		            }
		            updateBoxSize();
		            updateTextPadding();
		        };

		        // apply these to the box but not to the text
		        wrapper['stroke-widthSetter'] = function (value, key) {
		            if (value) {
		                needsBox = true;
		            }
		            strokeWidth = this['stroke-width'] = value;
		            boxAttr(key, value);
		        };

		        wrapper.strokeSetter =
		        wrapper.fillSetter =
		        wrapper.rSetter = function (value, key) {
		            if (key !== 'r') {
		                if (key === 'fill' && value) {
		                    needsBox = true;
		                }
		                // for animation getter (#6776)
		                wrapper[key] = value;
		            }
		            boxAttr(key, value);
		        };

		        wrapper.anchorXSetter = function (value, key) {
		            anchorX = wrapper.anchorX = value;
		            boxAttr(key, Math.round(value) - getCrispAdjust() - wrapperX);
		        };
		        wrapper.anchorYSetter = function (value, key) {
		            anchorY = wrapper.anchorY = value;
		            boxAttr(key, value - wrapperY);
		        };

		        // rename attributes
		        wrapper.xSetter = function (value) {
		            wrapper.x = value; // for animation getter
		            if (alignFactor) {
		                value -= alignFactor * ((width || bBox.width) + 2 * padding);

		                // Force animation even when setting to the same value (#7898)
		                wrapper['forceAnimate:x'] = true;
		            }
		            wrapperX = Math.round(value);
		            wrapper.attr('translateX', wrapperX);
		        };
		        wrapper.ySetter = function (value) {
		            wrapperY = wrapper.y = Math.round(value);
		            wrapper.attr('translateY', wrapperY);
		        };

		        // Redirect certain methods to either the box or the text
		        var baseCss = wrapper.css;
		        return extend(wrapper, {
		            /*
		             * Pick up some properties and apply them to the text instead of the
		             * wrapper.
		             */
		            css: function (styles) {
		                if (styles) {
		                    var textStyles = {};
		                    // Create a copy to avoid altering the original object
		                    // (#537)
		                    styles = merge(styles);
		                    each(wrapper.textProps, function (prop) {
		                        if (styles[prop] !== undefined) {
		                            textStyles[prop] = styles[prop];
		                            delete styles[prop];
		                        }
		                    });
		                    text.css(textStyles);

		                    if ('width' in textStyles) {
		                        updateBoxSize();
		                    }
		                }
		                return baseCss.call(wrapper, styles);
		            },
		            /*
		             * Return the bounding box of the box, not the group.
		             */
		            getBBox: function () {
		                return {
		                    width: bBox.width + 2 * padding,
		                    height: bBox.height + 2 * padding,
		                    x: bBox.x - padding,
		                    y: bBox.y - padding
		                };
		            },

		            /*
		             * Apply the shadow to the box.
		             */
		            shadow: function (b) {
		                if (b) {
		                    updateBoxSize();
		                    if (box) {
		                        box.shadow(b);
		                    }
		                }
		                return wrapper;
		            },

		            /*
		             * Destroy and release memory.
		             */
		            destroy: function () {

		                // Added by button implementation
		                removeEvent(wrapper.element, 'mouseenter');
		                removeEvent(wrapper.element, 'mouseleave');

		                if (text) {
		                    text = text.destroy();
		                }
		                if (box) {
		                    box = box.destroy();
		                }
		                // Call base implementation to destroy the rest
		                SVGElement.prototype.destroy.call(wrapper);

		                // Release local pointers (#1298)
		                wrapper =
		                renderer =
		                updateBoxSize =
		                updateTextPadding =
		                boxAttr = null;
		            }
		        });
		    }
		}); // end SVGRenderer


		// general renderer
		H.Renderer = SVGRenderer;

	}(Highcharts));
	(function (H) {
		/**
		 * (c) 2010-2018 Torstein Honsi
		 *
		 * License: www.highcharts.com/license
		 */



		var attr = H.attr,
		    createElement = H.createElement,
		    css = H.css,
		    defined = H.defined,
		    each = H.each,
		    extend = H.extend,
		    isFirefox = H.isFirefox,
		    isMS = H.isMS,
		    isWebKit = H.isWebKit,
		    pick = H.pick,
		    pInt = H.pInt,
		    SVGElement = H.SVGElement,
		    SVGRenderer = H.SVGRenderer,
		    win = H.win,
		    wrap = H.wrap;

		// Extend SvgElement for useHTML option.
		extend(SVGElement.prototype, /** @lends SVGElement.prototype */ {

		    /**
		     * Apply CSS to HTML elements. This is used in text within SVG rendering and
		     * by the VML renderer
		     *
		     * @private
		     * @function Highcharts.SVGElement#htmlCss
		     *
		     * @param {Highcharts.CSSObject} styles
		     *
		     * @return {Highcharts.SVGElement}
		     */
		    htmlCss: function (styles) {
		        var wrapper = this,
		            element = wrapper.element,
		            // When setting or unsetting the width style, we need to update
		            // transform (#8809)
		            isSettingWidth = (
		                element.tagName === 'SPAN' &&
		                styles &&
		                'width' in styles
		            ),
		            textWidth = pick(
		                isSettingWidth && styles.width,
		                undefined
		            );

		        if (isSettingWidth) {
		            delete styles.width;
		            wrapper.textWidth = textWidth;
		            wrapper.htmlUpdateTransform();
		        }
		        if (styles && styles.textOverflow === 'ellipsis') {
		            styles.whiteSpace = 'nowrap';
		            styles.overflow = 'hidden';
		        }
		        wrapper.styles = extend(wrapper.styles, styles);
		        css(wrapper.element, styles);

		        return wrapper;
		    },

		    /**
		     * VML and useHTML method for calculating the bounding box based on offsets.
		     *
		     * @private
		     * @function Highcharts.SVGElement#htmlGetBBox
		     *
		     * @param {boolean} refresh
		     *        Whether to force a fresh value from the DOM or to use the cached
		     *        value.
		     *
		     * @return {Highcharts.BBoxObject}
		     *         A hash containing values for x, y, width and height.
		     */
		    htmlGetBBox: function () {
		        var wrapper = this,
		            element = wrapper.element;

		        return {
		            x: element.offsetLeft,
		            y: element.offsetTop,
		            width: element.offsetWidth,
		            height: element.offsetHeight
		        };
		    },

		    /**
		     * VML override private method to update elements based on internal
		     * properties based on SVG transform.
		     *
		     * @private
		     * @function Highcharts.SVGElement#htmlUpdateTransform
		     */
		    htmlUpdateTransform: function () {
		        // aligning non added elements is expensive
		        if (!this.added) {
		            this.alignOnAdd = true;
		            return;
		        }

		        var wrapper = this,
		            renderer = wrapper.renderer,
		            elem = wrapper.element,
		            translateX = wrapper.translateX || 0,
		            translateY = wrapper.translateY || 0,
		            x = wrapper.x || 0,
		            y = wrapper.y || 0,
		            align = wrapper.textAlign || 'left',
		            alignCorrection = { left: 0, center: 0.5, right: 1 }[align],
		            styles = wrapper.styles,
		            whiteSpace = styles && styles.whiteSpace;

		        function getTextPxLength() {
		            // Reset multiline/ellipsis in order to read width (#4928,
		            // #5417)
		            css(elem, {
		                width: '',
		                whiteSpace: whiteSpace || 'nowrap'
		            });
		            return elem.offsetWidth;
		        }

		        // apply translate
		        css(elem, {
		            marginLeft: translateX,
		            marginTop: translateY
		        });


		        if (wrapper.shadows) { // used in labels/tooltip
		            each(wrapper.shadows, function (shadow) {
		                css(shadow, {
		                    marginLeft: translateX + 1,
		                    marginTop: translateY + 1
		                });
		            });
		        }


		        // apply inversion
		        if (wrapper.inverted) { // wrapper is a group
		            each(elem.childNodes, function (child) {
		                renderer.invertChild(child, elem);
		            });
		        }

		        if (elem.tagName === 'SPAN') {

		            var rotation = wrapper.rotation,
		                baseline,
		                textWidth = wrapper.textWidth && pInt(wrapper.textWidth),
		                currentTextTransform = [
		                    rotation,
		                    align,
		                    elem.innerHTML,
		                    wrapper.textWidth,
		                    wrapper.textAlign
		                ].join(',');

		            // Update textWidth. Use the memoized textPxLength if possible, to
		            // avoid the getTextPxLength function using elem.offsetWidth.
		            // Calling offsetWidth affects rendering time as it forces layout
		            // (#7656).
		            if (
		                textWidth !== wrapper.oldTextWidth &&
		                (
		                    (textWidth > wrapper.oldTextWidth) ||
		                    (wrapper.textPxLength || getTextPxLength()) > textWidth
		                ) &&
		                /[ \-]/.test(elem.textContent || elem.innerText)
		            ) { // #983, #1254
		                css(elem, {
		                    width: textWidth + 'px',
		                    display: 'block',
		                    whiteSpace: whiteSpace || 'normal' // #3331
		                });
		                wrapper.oldTextWidth = textWidth;
		                wrapper.hasBoxWidthChanged = true; // #8159
		            } else {
		                wrapper.hasBoxWidthChanged = false; // #8159
		            }

		            // Do the calculations and DOM access only if properties changed
		            if (currentTextTransform !== wrapper.cTT) {
		                baseline = renderer.fontMetrics(elem.style.fontSize).b;

		                // Renderer specific handling of span rotation, but only if we
		                // have something to update.
		                if (
		                    defined(rotation) &&
		                    (
		                        (rotation !== (wrapper.oldRotation || 0)) ||
		                        (align !== wrapper.oldAlign)
		                    )
		                ) {
		                    wrapper.setSpanRotation(
		                        rotation,
		                        alignCorrection,
		                        baseline
		                    );
		                }

		                wrapper.getSpanCorrection(
		                    // Avoid elem.offsetWidth if we can, it affects rendering
		                    // time heavily (#7656)
		                    (
		                        (!defined(rotation) && wrapper.textPxLength) || // #7920
		                        elem.offsetWidth
		                    ),
		                    baseline,
		                    alignCorrection,
		                    rotation,
		                    align
		                );
		            }

		            // apply position with correction
		            css(elem, {
		                left: (x + (wrapper.xCorr || 0)) + 'px',
		                top: (y + (wrapper.yCorr || 0)) + 'px'
		            });

		            // record current text transform
		            wrapper.cTT = currentTextTransform;
		            wrapper.oldRotation = rotation;
		            wrapper.oldAlign = align;
		        }
		    },

		    /**
		     * Set the rotation of an individual HTML span.
		     *
		     * @private
		     * @function Highcharts.SVGElement#setSpanRotation
		     *
		     * @param {number} rotation
		     *
		     * @param {number} alignCorrection
		     *
		     * @param {number} baseline
		     */
		    setSpanRotation: function (rotation, alignCorrection, baseline) {
		        var rotationStyle = {},
		            cssTransformKey = this.renderer.getTransformKey();

		        rotationStyle[cssTransformKey] = rotationStyle.transform =
		            'rotate(' + rotation + 'deg)';
		        rotationStyle[cssTransformKey + (isFirefox ? 'Origin' : '-origin')] =
		        rotationStyle.transformOrigin =
		            (alignCorrection * 100) + '% ' + baseline + 'px';
		        css(this.element, rotationStyle);
		    },

		    /**
		     * Get the correction in X and Y positioning as the element is rotated.
		     *
		     * @private
		     * @function Highcharts.SVGElement#getSpanCorrection
		     *
		     * @param {number} width
		     *
		     * @param {number} baseline
		     *
		     * @param {number} alignCorrection
		     */
		    getSpanCorrection: function (width, baseline, alignCorrection) {
		        this.xCorr = -width * alignCorrection;
		        this.yCorr = -baseline;
		    }
		});

		// Extend SvgRenderer for useHTML option.
		extend(SVGRenderer.prototype, /** @lends SVGRenderer.prototype */ {

		    /**
		     * @private
		     * @function Highcharts.SVGRenderer#getTransformKey
		     *
		     * @return {string}
		     */
		    getTransformKey: function () {
		        return isMS && !/Edge/.test(win.navigator.userAgent) ?
		            '-ms-transform' :
		            isWebKit ?
		                '-webkit-transform' :
		                isFirefox ?
		                    'MozTransform' :
		                    win.opera ?
		                        '-o-transform' :
		                        '';
		    },

		    /**
		     * Create HTML text node. This is used by the VML renderer as well as the
		     * SVG renderer through the useHTML option.
		     *
		     * @private
		     * @function Highcharts.SVGRenderer#html
		     *
		     * @param {string} str
		     *        The text of (subset) HTML to draw.
		     *
		     * @param {number} x
		     *        The x position of the text's lower left corner.
		     *
		     * @param {number} y
		     *        The y position of the text's lower left corner.
		     *
		     * @return {Highcharts.HTMLDOMElement}
		     */
		    html: function (str, x, y) {
		        var wrapper = this.createElement('span'),
		            element = wrapper.element,
		            renderer = wrapper.renderer,
		            isSVG = renderer.isSVG,
		            addSetters = function (element, style) {
		                // These properties are set as attributes on the SVG group, and
		                // as identical CSS properties on the div. (#3542)
		                each(['opacity', 'visibility'], function (prop) {
		                    wrap(element, prop + 'Setter', function (
		                        proceed,
		                        value,
		                        key,
		                        elem
		                    ) {
		                        proceed.call(this, value, key, elem);
		                        style[key] = value;
		                    });
		                });
		                element.addedSetters = true;
		            };

		        // Text setter
		        wrapper.textSetter = function (value) {
		            if (value !== element.innerHTML) {
		                delete this.bBox;
		            }
		            this.textStr = value;
		            element.innerHTML = pick(value, '');
		            wrapper.doTransform = true;
		        };

		        // Add setters for the element itself (#4938)
		        if (isSVG) { // #4938, only for HTML within SVG
		            addSetters(wrapper, wrapper.element.style);
		        }

		        // Various setters which rely on update transform
		        wrapper.xSetter =
		        wrapper.ySetter =
		        wrapper.alignSetter =
		        wrapper.rotationSetter =
		        function (value, key) {
		            if (key === 'align') {
		                // Do not overwrite the SVGElement.align method. Same as VML.
		                key = 'textAlign';
		            }
		            wrapper[key] = value;
		            wrapper.doTransform = true;
		        };

		        // Runs at the end of .attr()
		        wrapper.afterSetters = function () {
		            // Update transform. Do this outside the loop to prevent redundant
		            // updating for batch setting of attributes.
		            if (this.doTransform) {
		                this.htmlUpdateTransform();
		                this.doTransform = false;
		            }
		        };

		        // Set the default attributes
		        wrapper
		            .attr({
		                text: str,
		                x: Math.round(x),
		                y: Math.round(y)
		            })
		            .css({

		                fontFamily: this.style.fontFamily,
		                fontSize: this.style.fontSize,

		                position: 'absolute'
		            });

		        // Keep the whiteSpace style outside the wrapper.styles collection
		        element.style.whiteSpace = 'nowrap';

		        // Use the HTML specific .css method
		        wrapper.css = wrapper.htmlCss;

		        // This is specific for HTML within SVG
		        if (isSVG) {
		            wrapper.add = function (svgGroupWrapper) {

		                var htmlGroup,
		                    container = renderer.box.parentNode,
		                    parentGroup,
		                    parents = [];

		                this.parentGroup = svgGroupWrapper;

		                // Create a mock group to hold the HTML elements
		                if (svgGroupWrapper) {
		                    htmlGroup = svgGroupWrapper.div;
		                    if (!htmlGroup) {

		                        // Read the parent chain into an array and read from top
		                        // down
		                        parentGroup = svgGroupWrapper;
		                        while (parentGroup) {

		                            parents.push(parentGroup);

		                            // Move up to the next parent group
		                            parentGroup = parentGroup.parentGroup;
		                        }

		                        // Ensure dynamically updating position when any parent
		                        // is translated
		                        each(parents.reverse(), function (parentGroup) {
		                            var htmlGroupStyle,
		                                cls = attr(parentGroup.element, 'class');

		                            // Common translate setter for X and Y on the HTML
		                            // group. Reverted the fix for #6957 du to
		                            // positioning problems and offline export (#7254,
		                            // #7280, #7529)
		                            function translateSetter(value, key) {
		                                parentGroup[key] = value;

		                                if (key === 'translateX') {
		                                    htmlGroupStyle.left = value + 'px';
		                                } else {
		                                    htmlGroupStyle.top = value + 'px';
		                                }

		                                parentGroup.doTransform = true;
		                            }

		                            if (cls) {
		                                cls = { className: cls };
		                            } // else null

		                            // Create a HTML div and append it to the parent div
		                            // to emulate the SVG group structure
		                            htmlGroup =
		                            parentGroup.div =
		                            parentGroup.div || createElement('div', cls, {
		                                position: 'absolute',
		                                left: (parentGroup.translateX || 0) + 'px',
		                                top: (parentGroup.translateY || 0) + 'px',
		                                display: parentGroup.display,
		                                opacity: parentGroup.opacity, // #5075
		                                pointerEvents: (
		                                    parentGroup.styles &&
		                                    parentGroup.styles.pointerEvents
		                                ) // #5595

		                            // the top group is appended to container
		                            }, htmlGroup || container);

		                            // Shortcut
		                            htmlGroupStyle = htmlGroup.style;

		                            // Set listeners to update the HTML div's position
		                            // whenever the SVG group position is changed.
		                            extend(parentGroup, {
		                                // (#7287) Pass htmlGroup to use
		                                // the related group
		                                classSetter: (function (htmlGroup) {
		                                    return function (value) {
		                                        this.element.setAttribute(
		                                            'class',
		                                            value
		                                        );
		                                        htmlGroup.className = value;
		                                    };
		                                }(htmlGroup)),
		                                on: function () {
		                                    if (parents[0].div) { // #6418
		                                        wrapper.on.apply(
		                                            { element: parents[0].div },
		                                            arguments
		                                        );
		                                    }
		                                    return parentGroup;
		                                },
		                                translateXSetter: translateSetter,
		                                translateYSetter: translateSetter
		                            });
		                            if (!parentGroup.addedSetters) {
		                                addSetters(parentGroup, htmlGroupStyle);
		                            }
		                        });

		                    }
		                } else {
		                    htmlGroup = container;
		                }

		                htmlGroup.appendChild(element);

		                // Shared with VML:
		                wrapper.added = true;
		                if (wrapper.alignOnAdd) {
		                    wrapper.htmlUpdateTransform();
		                }

		                return wrapper;
		            };
		        }
		        return wrapper;
		    }
		});

	}(Highcharts));
	(function (Highcharts) {
		/**
		 * (c) 2010-2018 Torstein Honsi
		 *
		 * License: www.highcharts.com/license
		 */

		/**
		 * Normalized interval.
		 *
		 * @typedef Highcharts.NormalizedIntervalObject
		 *
		 * @property {number} unitRange
		 *           The interval in axis values (ms)
		 *
		 * @property {number} count
		 *           The count
		 */

		/**
		 * Additonal time tick information.
		 *
		 * @typedef {Highcharts.NormalizedIntervalObject} Highcharts.TimeTicksInfoObject
		 *
		 * @property {Array<string>} higherRanks
		 *
		 * @property {number} totalRange
		 */

		/**
		 * Time ticks.
		 *
		 * @typedef {Array<number>} Highcharts.TimeTicksObject
		 *
		 * @property {Highcharts.TimeTicksInfoObject} info
		 */



		var H = Highcharts,
		    defined = H.defined,
		    each = H.each,
		    extend = H.extend,
		    merge = H.merge,
		    pick = H.pick,
		    timeUnits = H.timeUnits,
		    win = H.win;

		/**
		 * The Time class. Time settings are applied in general for each page using
		 * `Highcharts.setOptions`, or individually for each Chart item through the
		 * [time](https://api.highcharts.com/highcharts/time) options set.
		 *
		 * The Time object is available from
		 * [Chart.time](http://api.highcharts.com/class-reference/Highcharts.Chart#.time),
		 * which refers to  `Highcharts.time` if no individual time settings are
		 * applied.
		 *
		 * @example
		 * // Apply time settings globally
		 * Highcharts.setOptions({
		 *     time: {
		 *         timezone: 'Europe/London'
		 *     }
		 * });
		 *
		 * // Apply time settings by instance
		 * var chart = Highcharts.chart('container', {
		 *     time: {
		 *         timezone: 'America/New_York'
		 *     },
		 *     series: [{
		 *         data: [1, 4, 3, 5]
		 *     }]
		 * });
		 *
		 * // Use the Time object
		 * console.log(
		 *        'Current time in New York',
		 *        chart.time.dateFormat('%Y-%m-%d %H:%M:%S', Date.now())
		 * );
		 *
		 * @class
		 * @name Highcharts.Time
		 *
		 * @param {Highcharts.TimeOptions} options
		 *        Time options as defined in [chart.options.time](/highcharts/time).
		 *
		 * @since 6.0.5
		 */
		Highcharts.Time = function (options) {
		    this.update(options, false);
		};

		Highcharts.Time.prototype = {

		    /**
		     * Time options that can apply globally or to individual charts. These
		     * settings affect how `datetime` axes are laid out, how tooltips are
		     * formatted, how series
		     * [pointIntervalUnit](#plotOptions.series.pointIntervalUnit) works and how
		     * the Highstock range selector handles time.
		     *
		     * The common use case is that all charts in the same Highcharts object
		     * share the same time settings, in which case the global settings are set
		     * using `setOptions`.
		     *
		     * ```js
		     * // Apply time settings globally
		     * Highcharts.setOptions({
		     *     time: {
		     *         timezone: 'Europe/London'
		     *     }
		     * });
		     * // Apply time settings by instance
		     * var chart = Highcharts.chart('container', {
		     *     time: {
		     *         timezone: 'America/New_York'
		     *     },
		     *     series: [{
		     *         data: [1, 4, 3, 5]
		     *     }]
		     * });
		     *
		     * // Use the Time object
		     * console.log(
		     *        'Current time in New York',
		     *        chart.time.dateFormat('%Y-%m-%d %H:%M:%S', Date.now())
		     * );
		     * ```
		     *
		     * Since v6.0.5, the time options were moved from the `global` obect to the
		     * `time` object, and time options can be set on each individual chart.
		     *
		     * @sample {highcharts|highstock}
		     *         highcharts/time/timezone/
		     *         Set the timezone globally
		     * @sample {highcharts}
		     *         highcharts/time/individual/
		     *         Set the timezone per chart instance
		     * @sample {highstock}
		     *         stock/time/individual/
		     *         Set the timezone per chart instance
		     *
		     * @since     6.0.5
		     * @apioption time
		     */

		    /**
		     * Whether to use UTC time for axis scaling, tickmark placement and
		     * time display in `Highcharts.dateFormat`. Advantages of using UTC
		     * is that the time displays equally regardless of the user agent's
		     * time zone settings. Local time can be used when the data is loaded
		     * in real time or when correct Daylight Saving Time transitions are
		     * required.
		     *
		     * @sample {highcharts} highcharts/time/useutc-true/
		     *         True by default
		     * @sample {highcharts} highcharts/time/useutc-false/
		     *         False
		     *
		     * @type      {boolean}
		     * @default   true
		     * @apioption time.useUTC
		     */

		    /**
		     * A custom `Date` class for advanced date handling. For example,
		     * [JDate](https://github.com/tahajahangir/jdate) can be hooked in to
		     * handle Jalali dates.
		     *
		     * @type      {*}
		     * @since     4.0.4
		     * @product   highcharts highstock gantt
		     * @apioption time.Date
		     */

		    /**
		     * A callback to return the time zone offset for a given datetime. It
		     * takes the timestamp in terms of milliseconds since January 1 1970,
		     * and returns the timezone offset in minutes. This provides a hook
		     * for drawing time based charts in specific time zones using their
		     * local DST crossover dates, with the help of external libraries.
		     *
		     * @see [global.timezoneOffset](#global.timezoneOffset)
		     *
		     * @sample {highcharts|highstock} highcharts/time/gettimezoneoffset/
		     *         Use moment.js to draw Oslo time regardless of browser locale
		     *
		     * @type      {Function}
		     * @since     4.1.0
		     * @product   highcharts highstock gantt
		     * @apioption time.getTimezoneOffset
		     */

		    /**
		     * Requires [moment.js](http://momentjs.com/). If the timezone option
		     * is specified, it creates a default
		     * [getTimezoneOffset](#time.getTimezoneOffset) function that looks
		     * up the specified timezone in moment.js. If moment.js is not included,
		     * this throws a Highcharts error in the console, but does not crash the
		     * chart.
		     *
		     * @see [getTimezoneOffset](#time.getTimezoneOffset)
		     *
		     * @sample {highcharts|highstock} highcharts/time/timezone/
		     *         Europe/Oslo
		     *
		     * @type      {string}
		     * @since     5.0.7
		     * @product   highcharts highstock gantt
		     * @apioption time.timezone
		     */

		    /**
		     * The timezone offset in minutes. Positive values are west, negative
		     * values are east of UTC, as in the ECMAScript
		     * [getTimezoneOffset](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Date/getTimezoneOffset)
		     * method. Use this to display UTC based data in a predefined time zone.
		     *
		     * @see [time.getTimezoneOffset](#time.getTimezoneOffset)
		     *
		     * @sample {highcharts|highstock} highcharts/time/timezoneoffset/
		     *         Timezone offset
		     *
		     * @type      {number}
		     * @default   0
		     * @since     3.0.8
		     * @product   highcharts highstock gantt
		     * @apioption time.timezoneOffset
		     */

		    defaultOptions: {},

		    /**
		     * Update the Time object with current options. It is called internally on
		     * initiating Highcharts, after running `Highcharts.setOptions` and on
		     * `Chart.update`.
		     *
		     * @private
		     * @function Highcharts.Time#update
		     *
		     * @param {Highcharts.TimeOptions} options
		     */
		    update: function (options) {
		        var useUTC = pick(options && options.useUTC, true),
		            time = this;

		        this.options = options = merge(true, this.options || {}, options);

		        // Allow using a different Date class
		        this.Date = options.Date || win.Date;

		        this.useUTC = useUTC;
		        this.timezoneOffset = useUTC && options.timezoneOffset;

		        /**
		         * Get the time zone offset based on the current timezone information as
		         * set in the global options.
		         *
		         * @function Highcharts.Time#getTimezoneOffset
		         *
		         * @param {number} timestamp
		         *        The JavaScript timestamp to inspect.
		         *
		         * @return {number}
		         *         The timezone offset in minutes compared to UTC.
		         */
		        this.getTimezoneOffset = this.timezoneOffsetFunction();

		        /*
		         * The time object has options allowing for variable time zones, meaning
		         * the axis ticks or series data needs to consider this.
		         */
		        this.variableTimezone = !!(
		            !useUTC ||
		            options.getTimezoneOffset ||
		            options.timezone
		        );

		        // UTC time with timezone handling
		        if (this.variableTimezone || this.timezoneOffset) {
		            this.get = function (unit, date) {
		                var realMs = date.getTime(),
		                    ms = realMs - time.getTimezoneOffset(date),
		                    ret;

		                date.setTime(ms); // Temporary adjust to timezone
		                ret = date['getUTC' + unit]();
		                date.setTime(realMs); // Reset

		                return ret;
		            };
		            this.set = function (unit, date, value) {
		                var ms, offset, newOffset;

		                // For lower order time units, just set it directly using local
		                // time
		                if (
		                    unit === 'Milliseconds' ||
		                    unit === 'Seconds' ||

		                    // If we're dealting with minutes, we only need to
		                    // consider timezone if we're in Indian time zones with
		                    // half-hour offsets (#8768).
		                    (
		                        unit === 'Minutes' &&
		                        date.getTimezoneOffset() % 60 === 0
		                    )
		                ) {
		                    date['set' + unit](value);

		                // Higher order time units need to take the time zone into
		                // account
		                } else {

		                    // Adjust by timezone
		                    offset = time.getTimezoneOffset(date);
		                    ms = date.getTime() - offset;
		                    date.setTime(ms);

		                    date['setUTC' + unit](value);
		                    newOffset = time.getTimezoneOffset(date);

		                    ms = date.getTime() + newOffset;
		                    date.setTime(ms);
		                }

		            };

		        // UTC time with no timezone handling
		        } else if (useUTC) {
		            this.get = function (unit, date) {
		                return date['getUTC' + unit]();
		            };
		            this.set = function (unit, date, value) {
		                return date['setUTC' + unit](value);
		            };

		        // Local time
		        } else {
		            this.get = function (unit, date) {
		                return date['get' + unit]();
		            };
		            this.set = function (unit, date, value) {
		                return date['set' + unit](value);
		            };
		        }

		    },

		    /**
		     * Make a time and returns milliseconds. Interprets the inputs as UTC time,
		     * local time or a specific timezone time depending on the current time
		     * settings.
		     *
		     * @function Highcharts.Time#makeTime
		     *
		     * @param {number} year
		     *        The year
		     *
		     * @param {number} month
		     *        The month. Zero-based, so January is 0.
		     *
		     * @param {number} [date=1]
		     *        The day of the month
		     *
		     * @param {number} [hours=0]
		     *        The hour of the day, 0-23.
		     *
		     * @param {number} [minutes=0]
		     *        The minutes
		     *
		     * @param {number} [seconds=0]
		     *        The seconds
		     *
		     * @return {number}
		     *         The time in milliseconds since January 1st 1970.
		     */
		    makeTime: function (year, month, date, hours, minutes, seconds) {
		        var d, offset, newOffset;
		        if (this.useUTC) {
		            d = this.Date.UTC.apply(0, arguments);
		            offset = this.getTimezoneOffset(d);
		            d += offset;
		            newOffset = this.getTimezoneOffset(d);

		            if (offset !== newOffset) {
		                d += newOffset - offset;

		            // A special case for transitioning from summer time to winter time.
		            // When the clock is set back, the same time is repeated twice, i.e.
		            // 02:30 am is repeated since the clock is set back from 3 am to
		            // 2 am. We need to make the same time as local Date does.
		            } else if (
		                offset - 36e5 === this.getTimezoneOffset(d - 36e5) &&
		                !H.isSafari
		            ) {
		                d -= 36e5;
		            }

		        } else {
		            d = new this.Date(
		                year,
		                month,
		                pick(date, 1),
		                pick(hours, 0),
		                pick(minutes, 0),
		                pick(seconds, 0)
		            ).getTime();
		        }
		        return d;
		    },

		    /**
		     * Sets the getTimezoneOffset function. If the `timezone` option is set, a
		     * default getTimezoneOffset function with that timezone is returned. If
		     * a `getTimezoneOffset` option is defined, it is returned. If neither are
		     * specified, the function using the `timezoneOffset` option or 0 offset is
		     * returned.
		     *
		     * @private
		     * @function Highcharts.Time#timezoneOffsetFunction
		     *
		     * @return {Function}
		     *         A getTimezoneOffset function
		     */
		    timezoneOffsetFunction: function () {
		        var time = this,
		            options = this.options,
		            moment = win.moment;

		        if (!this.useUTC) {
		            return function (timestamp) {
		                return new Date(timestamp).getTimezoneOffset() * 60000;
		            };
		        }

		        if (options.timezone) {
		            if (!moment) {
		                // getTimezoneOffset-function stays undefined because it depends
		                // on Moment.js
		                H.error(25);

		            } else {
		                return function (timestamp) {
		                    return -moment.tz(
		                        timestamp,
		                        options.timezone
		                    ).utcOffset() * 60000;
		                };
		            }
		        }

		        // If not timezone is set, look for the getTimezoneOffset callback
		        if (this.useUTC && options.getTimezoneOffset) {
		            return function (timestamp) {
		                return options.getTimezoneOffset(timestamp) * 60000;
		            };
		        }

		        // Last, use the `timezoneOffset` option if set
		        return function () {
		            return (time.timezoneOffset || 0) * 60000;
		        };
		    },

		    /**
		     * Formats a JavaScript date timestamp (milliseconds since Jan 1st 1970)
		     * into a human readable date string. The format is a subset of the formats
		     * for PHP's [strftime](http://www.php.net/manual/en/function.strftime.php)
		     * function. Additional formats can be given in the
		     * {@link Highcharts.dateFormats} hook.
		     *
		     * @function Highcharts.Time#dateFormat
		     *
		     * @param {string} [format]
		     *        The desired format where various time representations are
		     *        prefixed with %.
		     *
		     * @param {number} timestamp
		     *        The JavaScript timestamp.
		     *
		     * @param {boolean} [capitalize=false]
		     *        Upper case first letter in the return.
		     *
		     * @return {string}
		     *         The formatted date.
		     */
		    dateFormat: function (format, timestamp, capitalize) {
		        if (!H.defined(timestamp) || isNaN(timestamp)) {
		            return H.defaultOptions.lang.invalidDate || '';
		        }
		        format = H.pick(format, '%Y-%m-%d %H:%M:%S');

		        var time = this,
		            date = new this.Date(timestamp),
		            // get the basic time values
		            hours = this.get('Hours', date),
		            day = this.get('Day', date),
		            dayOfMonth = this.get('Date', date),
		            month = this.get('Month', date),
		            fullYear = this.get('FullYear', date),
		            lang = H.defaultOptions.lang,
		            langWeekdays = lang.weekdays,
		            shortWeekdays = lang.shortWeekdays,
		            pad = H.pad,

		            // List all format keys. Custom formats can be added from the
		            // outside.
		            replacements = H.extend(
		                {

		                    // Day
		                    // Short weekday, like 'Mon'
		                    'a': shortWeekdays ?
		                        shortWeekdays[day] :
		                        langWeekdays[day].substr(0, 3),
		                    // Long weekday, like 'Monday'
		                    'A': langWeekdays[day],
		                    // Two digit day of the month, 01 to 31
		                    'd': pad(dayOfMonth),
		                    // Day of the month, 1 through 31
		                    'e': pad(dayOfMonth, 2, ' '),
		                    'w': day,

		                    // Week (none implemented)
		                    // 'W': weekNumber(),

		                    // Month
		                    // Short month, like 'Jan'
		                    'b': lang.shortMonths[month],
		                    // Long month, like 'January'
		                    'B': lang.months[month],
		                    // Two digit month number, 01 through 12
		                    'm': pad(month + 1),
		                    // Month number, 1 through 12 (#8150)
		                    'o': month + 1,

		                    // Year
		                    // Two digits year, like 09 for 2009
		                    'y': fullYear.toString().substr(2, 2),
		                    // Four digits year, like 2009
		                    'Y': fullYear,

		                    // Time
		                    // Two digits hours in 24h format, 00 through 23
		                    'H': pad(hours),
		                    // Hours in 24h format, 0 through 23
		                    'k': hours,
		                    // Two digits hours in 12h format, 00 through 11
		                    'I': pad((hours % 12) || 12),
		                    // Hours in 12h format, 1 through 12
		                    'l': (hours % 12) || 12,
		                    // Two digits minutes, 00 through 59
		                    'M': pad(time.get('Minutes', date)),
		                    // Upper case AM or PM
		                    'p': hours < 12 ? 'AM' : 'PM',
		                    // Lower case AM or PM
		                    'P': hours < 12 ? 'am' : 'pm',
		                    // Two digits seconds, 00 through  59
		                    'S': pad(date.getSeconds()),
		                    // Milliseconds (naming from Ruby)
		                    'L': pad(Math.floor(timestamp % 1000), 3)
		                },

		                /**
		                 * A hook for defining additional date format specifiers. New
		                 * specifiers are defined as key-value pairs by using the
		                 * specifier as key, and a function which takes the timestamp as
		                 * value. This function returns the formatted portion of the
		                 * date.
		                 *
		                 * @sample highcharts/global/dateformats/
		                 *         Adding support for week number
		                 *
		                 * @name Highcharts.dateFormats
		                 * @type {Highcharts.Dictionary<Function>}
		                 */
		                H.dateFormats
		            );


		        // Do the replaces
		        H.objectEach(replacements, function (val, key) {
		            // Regex would do it in one line, but this is faster
		            while (format.indexOf('%' + key) !== -1) {
		                format = format.replace(
		                    '%' + key,
		                    typeof val === 'function' ? val.call(time, timestamp) : val
		                );
		            }

		        });

		        // Optionally capitalize the string and return
		        return capitalize ?
		            format.substr(0, 1).toUpperCase() + format.substr(1) :
		            format;
		    },

		    /**
		     * Resolve legacy formats of dateTimeLabelFormats (strings and arrays) into
		     * an object.
		     * @param  {String|Array|Object} f General format description
		     * @return {Object}   The object definition
		     */
		    resolveDTLFormat: function (f) {
		        if (!H.isObject(f, true)) {
		            f = H.splat(f);
		            return {
		                main: f[0],
		                from: f[1],
		                to: f[2]
		            };
		        }
		        return f;
		    },

		    /**
		     * Return an array with time positions distributed on round time values
		     * right and right after min and max. Used in datetime axes as well as for
		     * grouping data on a datetime axis.
		     *
		     * @function Highcharts.Time#getTimeTicks
		     *
		     * @param {Highcharts.NormalizedIntervalObject} normalizedInterval
		     *        The interval in axis values (ms) and the count
		     *
		     * @param {number} [min]
		     *        The minimum in axis values
		     *
		     * @param {number} [max]
		     *        The maximum in axis values
		     *
		     * @param {number} [startOfWeek=1]
		     *
		     * @return {Highcharts.TimeTicksObject}
		     */
		    getTimeTicks: function (
		        normalizedInterval,
		        min,
		        max,
		        startOfWeek
		    ) {
		        var time = this,
		            Date = time.Date,
		            tickPositions = [],
		            i,
		            higherRanks = {},
		            minYear, // used in months and years as a basis for Date.UTC()
		            // When crossing DST, use the max. Resolves #6278.
		            minDate = new Date(min),
		            interval = normalizedInterval.unitRange,
		            count = normalizedInterval.count || 1,
		            variableDayLength,
		            minDay;

		        startOfWeek = pick(startOfWeek, 1);

		        if (defined(min)) { // #1300
		            time.set(
		                'Milliseconds',
		                minDate,
		                interval >= timeUnits.second ?
		                    0 : // #3935
		                    count * Math.floor(
		                        time.get('Milliseconds', minDate) / count
		                    )
		            ); // #3652, #3654

		            if (interval >= timeUnits.second) { // second
		                time.set('Seconds',
		                    minDate,
		                    interval >= timeUnits.minute ?
		                        0 : // #3935
		                        count * Math.floor(time.get('Seconds', minDate) / count)
		                );
		            }

		            if (interval >= timeUnits.minute) { // minute
		                time.set('Minutes', minDate,
		                    interval >= timeUnits.hour ?
		                        0 :
		                        count * Math.floor(time.get('Minutes', minDate) / count)
		                );
		            }

		            if (interval >= timeUnits.hour) { // hour
		                time.set(
		                    'Hours',
		                    minDate,
		                    interval >= timeUnits.day ?
		                        0 :
		                        count * Math.floor(
		                            time.get('Hours', minDate) / count
		                        )
		                );
		            }

		            if (interval >= timeUnits.day) { // day
		                time.set(
		                    'Date',
		                    minDate,
		                    interval >= timeUnits.month ?
		                        1 :
		                        count * Math.floor(time.get('Date', minDate) / count)
		                    );
		            }

		            if (interval >= timeUnits.month) { // month
		                time.set(
		                    'Month',
		                    minDate,
		                    interval >= timeUnits.year ? 0 :
		                        count * Math.floor(time.get('Month', minDate) / count)
		                );
		                minYear = time.get('FullYear', minDate);
		            }

		            if (interval >= timeUnits.year) { // year
		                minYear -= minYear % count;
		                time.set('FullYear', minDate, minYear);
		            }

		            // week is a special case that runs outside the hierarchy
		            if (interval === timeUnits.week) {
		                // get start of current week, independent of count
		                minDay = time.get('Day', minDate);
		                time.set(
		                    'Date',
		                    minDate,
		                    (
		                        time.get('Date', minDate) -
		                        minDay + startOfWeek +
		                        // We don't want to skip days that are before
		                        // startOfWeek (#7051)
		                        (minDay < startOfWeek ? -7 : 0)
		                    )
		                );
		            }


		            // Get basics for variable time spans
		            minYear = time.get('FullYear', minDate);
		            var minMonth = time.get('Month', minDate),
		                minDateDate = time.get('Date', minDate),
		                minHours = time.get('Hours', minDate);

		            // Redefine min to the floored/rounded minimum time (#7432)
		            min = minDate.getTime();

		            // Handle local timezone offset
		            if (time.variableTimezone) {

		                // Detect whether we need to take the DST crossover into
		                // consideration. If we're crossing over DST, the day length may
		                // be 23h or 25h and we need to compute the exact clock time for
		                // each tick instead of just adding hours. This comes at a cost,
		                // so first we find out if it is needed (#4951).
		                variableDayLength = (
		                    // Long range, assume we're crossing over.
		                    max - min > 4 * timeUnits.month ||
		                    // Short range, check if min and max are in different time
		                    // zones.
		                    time.getTimezoneOffset(min) !== time.getTimezoneOffset(max)
		                );
		            }

		            // Iterate and add tick positions at appropriate values
		            var t = minDate.getTime();
		            i = 1;
		            while (t < max) {
		                tickPositions.push(t);

		                // if the interval is years, use Date.UTC to increase years
		                if (interval === timeUnits.year) {
		                    t = time.makeTime(minYear + i * count, 0);

		                // if the interval is months, use Date.UTC to increase months
		                } else if (interval === timeUnits.month) {
		                    t = time.makeTime(minYear, minMonth + i * count);

		                // if we're using global time, the interval is not fixed as it
		                // jumps one hour at the DST crossover
		                } else if (
		                    variableDayLength &&
		                    (interval === timeUnits.day || interval === timeUnits.week)
		                ) {
		                    t = time.makeTime(
		                        minYear,
		                        minMonth,
		                        minDateDate +
		                            i * count * (interval === timeUnits.day ? 1 : 7)
		                    );

		                } else if (
		                    variableDayLength &&
		                    interval === timeUnits.hour &&
		                    count > 1
		                ) {
		                    // make sure higher ranks are preserved across DST (#6797,
		                    // #7621)
		                    t = time.makeTime(
		                        minYear,
		                        minMonth,
		                        minDateDate,
		                        minHours + i * count
		                    );

		                // else, the interval is fixed and we use simple addition
		                } else {
		                    t += interval * count;
		                }

		                i++;
		            }

		            // push the last time
		            tickPositions.push(t);


		            // Handle higher ranks. Mark new days if the time is on midnight
		            // (#950, #1649, #1760, #3349). Use a reasonable dropout threshold
		            // to prevent looping over dense data grouping (#6156).
		            if (interval <= timeUnits.hour && tickPositions.length < 10000) {
		                each(tickPositions, function (t) {
		                    if (
		                        // Speed optimization, no need to run dateFormat unless
		                        // we're on a full or half hour
		                        t % 1800000 === 0 &&
		                        // Check for local or global midnight
		                        time.dateFormat('%H%M%S%L', t) === '000000000'
		                    ) {
		                        higherRanks[t] = 'day';
		                    }
		                });
		            }
		        }


		        // record information on the chosen unit - for dynamic label formatter
		        tickPositions.info = extend(normalizedInterval, {
		            higherRanks: higherRanks,
		            totalRange: interval * count
		        });

		        return tickPositions;
		    }

		}; // end of Time


	}(Highcharts));
	(function (H) {
		/**
		 * (c) 2010-2018 Torstein Honsi
		 *
		 * License: www.highcharts.com/license
		 */

		var color = H.color,
		    isTouchDevice = H.isTouchDevice,
		    merge = H.merge,
		    svg = H.svg;

		/* ****************************************************************************
		 * Handle the options                                                         *
		 *****************************************************************************/
		/**
		 * Global default settings.
		 *
		 * @name Highcharts.defaultOptions
		 * @type {Highcharts.Options}
		 *//**
		 * @optionparent
		 */
		H.defaultOptions = {


		    /**
		     * An array containing the default colors for the chart's series. When
		     * all colors are used, new colors are pulled from the start again.
		     *
		     * Default colors can also be set on a series or series.type basis,
		     * see [column.colors](#plotOptions.column.colors),
		     * [pie.colors](#plotOptions.pie.colors).
		     *
		     * In styled mode, the colors option doesn't exist. Instead, colors
		     * are defined in CSS and applied either through series or point class
		     * names, or through the [chart.colorCount](#chart.colorCount) option.
		     *
		     *
		     * ### Legacy
		     *
		     * In Highcharts 3.x, the default colors were:
		     *
		     * <pre>colors: ['#2f7ed8', '#0d233a', '#8bbc21', '#910000', '#1aadce',
		     *     '#492970', '#f28f43', '#77a1e5', '#c42525', '#a6c96a']</pre>
		     *
		     * In Highcharts 2.x, the default colors were:
		     *
		     * <pre>colors: ['#4572A7', '#AA4643', '#89A54E', '#80699B', '#3D96AE',
		     *    '#DB843D', '#92A8CD', '#A47D7C', '#B5CA92']</pre>
		     *
		     * @sample {highcharts} highcharts/chart/colors/
		     *         Assign a global color theme
		     *
		     * @type    {Array<Highcharts.ColorString>}
		     * @default ["#7cb5ec", "#434348", "#90ed7d", "#f7a35c", "#8085e9",
		     *          "#f15c80", "#e4d354", "#2b908f", "#f45b5b", "#91e8e1"]
		     */
		    colors: '#7cb5ec #434348 #90ed7d #f7a35c #8085e9 #f15c80 #e4d354 #2b908f #f45b5b #91e8e1'.split(' '),



		    /**
		     * Styled mode only. Configuration object for adding SVG definitions for
		     * reusable elements. See [gradients, shadows and
		     * patterns](https://www.highcharts.com/docs/chart-design-and-style/gradients-shadows-and-patterns)
		     * for more information and code examples.
		     *
		     * @type      {*}
		     * @since     5.0.0
		     * @apioption defs
		     */

		    /**
		     * @ignore-option
		     */
		    symbols: ['circle', 'diamond', 'square', 'triangle', 'triangle-down'],

		    /**
		     * The language object is global and it can't be set on each chart
		     * initiation. Instead, use `Highcharts.setOptions` to set it before any
		     * chart is initialized.
		     *
		     * <pre>Highcharts.setOptions({
		     *     lang: {
		     *         months: [
		     *             'Janvier', 'Février', 'Mars', 'Avril',
		     *             'Mai', 'Juin', 'Juillet', 'Août',
		     *             'Septembre', 'Octobre', 'Novembre', 'Décembre'
		     *         ],
		     *         weekdays: [
		     *             'Dimanche', 'Lundi', 'Mardi', 'Mercredi',
		     *             'Jeudi', 'Vendredi', 'Samedi'
		     *         ]
		     *     }
		     * });</pre>
		     */
		    lang: {

		        /**
		         * The loading text that appears when the chart is set into the loading
		         * state following a call to `chart.showLoading`.
		         */
		        loading: 'Loading...',

		        /**
		         * An array containing the months names. Corresponds to the `%B` format
		         * in `Highcharts.dateFormat()`.
		         *
		         * @type    {Array<string>}
		         * @default ["January", "February", "March", "April", "May", "June",
		         *          "July", "August", "September", "October", "November",
		         *          "December"]
		         */
		        months: [
		            'January', 'February', 'March', 'April', 'May', 'June', 'July',
		            'August', 'September', 'October', 'November', 'December'
		        ],

		        /**
		         * An array containing the months names in abbreviated form. Corresponds
		         * to the `%b` format in `Highcharts.dateFormat()`.
		         *
		         * @type    {Array<string>}
		         * @default ["Jan", "Feb", "Mar", "Apr", "May", "Jun",
		         *          "Jul", "Aug", "Sep", "Oct", "Nov", "Dec"]
		         */
		        shortMonths: [
		            'Jan', 'Feb', 'Mar', 'Apr', 'May', 'Jun', 'Jul',
		            'Aug', 'Sep', 'Oct', 'Nov', 'Dec'
		        ],

		        /**
		         * An array containing the weekday names.
		         *
		         * @type    {Array<string>}
		         * @default ["Sunday", "Monday", "Tuesday", "Wednesday", "Thursday",
		         *          "Friday", "Saturday"]
		         */
		        weekdays: [
		            'Sunday', 'Monday', 'Tuesday', 'Wednesday',
		            'Thursday', 'Friday', 'Saturday'
		        ],

		        /**
		         * Short week days, starting Sunday. If not specified, Highcharts uses
		         * the first three letters of the `lang.weekdays` option.
		         *
		         * @sample highcharts/lang/shortweekdays/
		         *         Finnish two-letter abbreviations
		         *
		         * @type      {Array<string>}
		         * @since     4.2.4
		         * @apioption lang.shortWeekdays
		         */

		        /**
		         * What to show in a date field for invalid dates. Defaults to an empty
		         * string.
		         *
		         * @type      {string}
		         * @since     4.1.8
		         * @product   highcharts highstock
		         * @apioption lang.invalidDate
		         */

		        /**
		         * The title appearing on hovering the zoom in button. The text itself
		         * defaults to "+" and can be changed in the button options.
		         *
		         * @type      {string}
		         * @default   Zoom in
		         * @product   highmaps
		         * @apioption lang.zoomIn
		         */

		        /**
		         * The title appearing on hovering the zoom out button. The text itself
		         * defaults to "-" and can be changed in the button options.
		         *
		         * @type      {string}
		         * @default   Zoom out
		         * @product   highmaps
		         * @apioption lang.zoomOut
		         */

		        /**
		         * The default decimal point used in the `Highcharts.numberFormat`
		         * method unless otherwise specified in the function arguments.
		         *
		         * @since 1.2.2
		         */
		        decimalPoint: '.',

		        /**
		         * [Metric prefixes](http://en.wikipedia.org/wiki/Metric_prefix) used
		         * to shorten high numbers in axis labels. Replacing any of the
		         * positions with `null` causes the full number to be written. Setting
		         * `numericSymbols` to `null` disables shortening altogether.
		         *
		         * @sample {highcharts} highcharts/lang/numericsymbols/
		         *         Replacing the symbols with text
		         * @sample {highstock} highcharts/lang/numericsymbols/
		         *         Replacing the symbols with text
		         *
		         * @type    {Array<string>}
		         * @default ["k", "M", "G", "T", "P", "E"]
		         * @since   2.3.0
		         */
		        numericSymbols: ['k', 'M', 'G', 'T', 'P', 'E'],

		        /**
		         * The magnitude of [numericSymbols](#lang.numericSymbol) replacements.
		         * Use 10000 for Japanese, Korean and various Chinese locales, which
		         * use symbols for 10^4, 10^8 and 10^12.
		         *
		         * @sample highcharts/lang/numericsymbolmagnitude/
		         *         10000 magnitude for Japanese
		         *
		         * @type      {number}
		         * @default   1000
		         * @since     5.0.3
		         * @apioption lang.numericSymbolMagnitude
		         */

		        /**
		         * The text for the label appearing when a chart is zoomed.
		         *
		         * @since 1.2.4
		         */
		        resetZoom: 'Reset zoom',

		        /**
		         * The tooltip title for the label appearing when a chart is zoomed.
		         *
		         * @since 1.2.4
		         */
		        resetZoomTitle: 'Reset zoom level 1:1',

		        /**
		         * The default thousands separator used in the `Highcharts.numberFormat`
		         * method unless otherwise specified in the function arguments. Since
		         * Highcharts 4.1 it defaults to a single space character, which is
		         * compatible with ISO and works across Anglo-American and continental
		         * European languages.
		         *
		         * The default is a single space.
		         *
		         * @default \u0020
		         * @since   1.2.2
		         */
		        thousandsSep: ' '
		    },

		    /**
		     * Global options that don't apply to each chart. These options, like
		     * the `lang` options, must be set using the `Highcharts.setOptions`
		     * method.
		     *
		     * <pre>Highcharts.setOptions({
		     *     global: {
		     *         useUTC: false
		     *     }
		     * });</pre>
		     *
		     */

		    /**
		     * _Canvg rendering for Android 2.x is removed as of Highcharts 5.0\.
		     * Use the [libURL](#exporting.libURL) option to configure exporting._
		     *
		     * The URL to the additional file to lazy load for Android 2.x devices.
		     * These devices don't support SVG, so we download a helper file that
		     * contains [canvg](http://code.google.com/p/canvg/), its dependency
		     * rbcolor, and our own CanVG Renderer class. To avoid hotlinking to
		     * our site, you can install canvas-tools.js on your own server and
		     * change this option accordingly.
		     *
		     * @deprecated
		     *
		     * @type      {string}
		     * @default   http://code.highcharts.com/{version}/modules/canvas-tools.js
		     * @product   highcharts highmaps
		     * @apioption global.canvasToolsURL
		     */

		    /**
		     * This option is deprecated since v6.0.5. Instead, use
		     * [time.useUTC](#time.useUTC) that supports individual time settings
		     * per chart.
		     *
		     * @deprecated
		     *
		     * @type      {boolean}
		     * @apioption global.useUTC
		     */

		    /**
		     * This option is deprecated since v6.0.5. Instead, use
		     * [time.Date](#time.Date) that supports individual time settings
		     * per chart.
		     *
		     * @deprecated
		     *
		     * @type      {Function}
		     * @product   highcharts highstock
		     * @apioption global.Date
		     */

		    /**
		     * This option is deprecated since v6.0.5. Instead, use
		     * [time.getTimezoneOffset](#time.getTimezoneOffset) that supports
		     * individual time settings per chart.
		     *
		     * @deprecated
		     *
		     * @type      {Function}
		     * @product   highcharts highstock
		     * @apioption global.getTimezoneOffset
		     */

		    /**
		     * This option is deprecated since v6.0.5. Instead, use
		     * [time.timezone](#time.timezone) that supports individual time
		     * settings per chart.
		     *
		     * @deprecated
		     *
		     * @type      {string}
		     * @product   highcharts highstock
		     * @apioption global.timezone
		     */

		    /**
		     * This option is deprecated since v6.0.5. Instead, use
		     * [time.timezoneOffset](#time.timezoneOffset) that supports individual
		     * time settings per chart.
		     *
		     * @deprecated
		     *
		     * @type      {number}
		     * @product   highcharts highstock
		     * @apioption global.timezoneOffset
		     */

		    global: {},

		    time: H.Time.prototype.defaultOptions,

		    /**
		     * General options for the chart.
		     */
		    chart: {

		        /**
		         * Default `mapData` for all series. If set to a string, it functions
		         * as an index into the `Highcharts.maps` array. Otherwise it is
		         * interpreted s map data.
		         *
		         * @see [mapData](#series.map.mapData)
		         *
		         * @type      {string|Array<*>}
		         * @since     5.0.0
		         * @product   highmaps
		         * @apioption chart.map
		         */

		        /**
		         * Set lat/lon transformation definitions for the chart. If not defined,
		         * these are extracted from the map data.
		         *
		         * @type      {*}
		         * @since     5.0.0
		         * @product   highmaps
		         * @apioption chart.mapTransforms
		         */

		        /**
		         * When using multiple axis, the ticks of two or more opposite axes
		         * will automatically be aligned by adding ticks to the axis or axes
		         * with the least ticks, as if `tickAmount` were specified.
		         *
		         * This can be prevented by setting `alignTicks` to false. If the grid
		         * lines look messy, it's a good idea to hide them for the secondary
		         * axis by setting `gridLineWidth` to 0.
		         *
		         * If `startOnTick` or `endOnTick` in an Axis options are set to false,
		         * then the `alignTicks ` will be disabled for the Axis.
		         *
		         * Disabled for logarithmic axes.
		         *
		         * @sample {highcharts} highcharts/chart/alignticks-true/
		         *         True by default
		         * @sample {highcharts} highcharts/chart/alignticks-false/
		         *         False
		         * @sample {highstock} stock/chart/alignticks-true/
		         *         True by default
		         * @sample {highstock} stock/chart/alignticks-false/
		         *         False
		         *
		         * @type      {boolean}
		         * @default   true
		         * @product   highcharts highstock gantt
		         * @apioption chart.alignTicks
		         */

		        /**
		         * Set the overall animation for all chart updating. Animation can be
		         * disabled throughout the chart by setting it to false here. It can
		         * be overridden for each individual API method as a function parameter.
		         * The only animation not affected by this option is the initial series
		         * animation, see [plotOptions.series.animation](
		         * #plotOptions.series.animation).
		         *
		         * The animation can either be set as a boolean or a configuration
		         * object. If `true`, it will use the 'swing' jQuery easing and a
		         * duration of 500 ms. If used as a configuration object, the following
		         * properties are supported:
		         *
		         * <dl>
		         *
		         * <dt>duration</dt>
		         *
		         * <dd>The duration of the animation in milliseconds.</dd>
		         *
		         * <dt>easing</dt>
		         *
		         * <dd>A string reference to an easing function set on the `Math`
		         * object. See [the easing
		         * demo](https://jsfiddle.net/gh/get/library/pure/highcharts/highcharts/tree/master/samples/highcharts/plotoptions/series-animation-easing/).
		         * </dd>
		         *
		         * </dl>
		         *
		         * @sample {highcharts} highcharts/chart/animation-none/
		         *         Updating with no animation
		         * @sample {highcharts} highcharts/chart/animation-duration/
		         *         With a longer duration
		         * @sample {highcharts} highcharts/chart/animation-easing/
		         *         With a jQuery UI easing
		         * @sample {highmaps} maps/chart/animation-none/
		         *         Updating with no animation
		         * @sample {highmaps} maps/chart/animation-duration/
		         *         With a longer duration
		         *
		         * @type      {boolean|Highcharts.AnimationOptionsObject}
		         * @default   true
		         * @apioption chart.animation
		         */

		        /**
		         * A CSS class name to apply to the charts container `div`, allowing
		         * unique CSS styling for each chart.
		         *
		         * @type      {string}
		         * @apioption chart.className
		         */

		        /**
		         * Event listeners for the chart.
		         *
		         * @apioption chart.events
		         */

		        /**
		         * Fires when a series is added to the chart after load time, using
		         * the `addSeries` method. One parameter, `event`, is passed to the
		         * function, containing common event information.
		         * Through `event.options` you can access the series options that was
		         * passed to the `addSeries` method. Returning false prevents the series
		         * from being added.
		         *
		         * @sample {highcharts} highcharts/chart/events-addseries/
		         *         Alert on add series
		         * @sample {highstock} stock/chart/events-addseries/
		         *         Alert on add series
		         *
		         * @type      {Function}
		         * @since     1.2.0
		         * @context   Highcharts.Chart
		         * @apioption chart.events.addSeries
		         */

		        /**
		         * Fires when clicking on the plot background. One parameter, `event`,
		         * is passed to the function, containing common event information.
		         *
		         * Information on the clicked spot can be found through `event.xAxis`
		         * and `event.yAxis`, which are arrays containing the axes of each
		         * dimension and each axis' value at the clicked spot. The primary axes
		         * are `event.xAxis[0]` and `event.yAxis[0]`. Remember the unit of a
		         * datetime axis is milliseconds since 1970-01-01 00:00:00.
		         *
		         * <pre>click: function(e) {
		         *     console.log(
		         *         Highcharts.dateFormat('%Y-%m-%d %H:%M:%S', e.xAxis[0].value),
		         *         e.yAxis[0].value
		         *     )
		         * }</pre>
		         *
		         * @sample {highcharts} highcharts/chart/events-click/
		         *         Alert coordinates on click
		         * @sample {highcharts} highcharts/chart/events-container/
		         *         Alternatively, attach event to container
		         * @sample {highstock} stock/chart/events-click/
		         *         Alert coordinates on click
		         * @sample {highstock} highcharts/chart/events-container/
		         *         Alternatively, attach event to container
		         * @sample {highmaps} maps/chart/events-click/
		         *         Record coordinates on click
		         * @sample {highmaps} highcharts/chart/events-container/
		         *         Alternatively, attach event to container
		         *
		         * @type      {Function}
		         * @since     1.2.0
		         * @context   Highcharts.Chart
		         * @apioption chart.events.click
		         */


		        /**
		         * Fires when the chart is finished loading. Since v4.2.2, it also waits
		         * for images to be loaded, for example from point markers. One
		         * parameter, `event`, is passed to the function, containing common
		         * event information.
		         *
		         * There is also a second parameter to the chart constructor where a
		         * callback function can be passed to be executed on chart.load.
		         *
		         * @sample {highcharts} highcharts/chart/events-load/
		         *         Alert on chart load
		         * @sample {highstock} stock/chart/events-load/
		         *         Alert on chart load
		         * @sample {highmaps} maps/chart/events-load/
		         *         Add series on chart load
		         *
		         * @type      {Function}
		         * @context   Highcharts.Chart
		         * @apioption chart.events.load
		         */

		        /**
		         * Fires when the chart is redrawn, either after a call to
		         * `chart.redraw()` or after an axis, series or point is modified with
		         * the `redraw` option set to true. One parameter, `event`, is passed to
		         * the function, containing common event information.
		         *
		         * @sample {highcharts} highcharts/chart/events-redraw/
		         *         Alert on chart redraw
		         * @sample {highstock} stock/chart/events-redraw/
		         *         Alert on chart redraw when adding a series or moving the
		         *         zoomed range
		         * @sample {highmaps} maps/chart/events-redraw/
		         *         Set subtitle on chart redraw
		         *
		         * @type      {Function}
		         * @since     1.2.0
		         * @context   Highcharts.Chart
		         * @apioption chart.events.redraw
		         */

		        /**
		         * Fires after initial load of the chart (directly after the `load`
		         * event), and after each redraw (directly after the `redraw` event).
		         *
		         * @type      {Function}
		         * @since     5.0.7
		         * @context   Highcharts.Chart
		         * @apioption chart.events.render
		         */

		        /**
		         * Fires when an area of the chart has been selected. Selection is
		         * enabled by setting the chart's zoomType. One parameter, `event`, is
		         * passed to the function, containing common event information. The
		         * default action for the selection event is to zoom the chart to the
		         * selected area. It can be prevented by calling
		         * `event.preventDefault()`.
		         *
		         * Information on the selected area can be found through `event.xAxis`
		         * and `event.yAxis`, which are arrays containing the axes of each
		         * dimension and each axis' min and max values. The primary axes are
		         * `event.xAxis[0]` and `event.yAxis[0]`. Remember the unit of a
		         * datetime axis is milliseconds since 1970-01-01 00:00:00.
		         *
		         * <pre>selection: function(event) {
		         *     // log the min and max of the primary, datetime x-axis
		         *     console.log(
		         *         Highcharts.dateFormat(
		         *             '%Y-%m-%d %H:%M:%S',
		         *             event.xAxis[0].min
		         *         ),
		         *         Highcharts.dateFormat(
		         *             '%Y-%m-%d %H:%M:%S',
		         *             event.xAxis[0].max
		         *         )
		         *     );
		         *     // log the min and max of the y axis
		         *     console.log(event.yAxis[0].min, event.yAxis[0].max);
		         * }</pre>
		         *
		         * @sample {highcharts} highcharts/chart/events-selection/
		         *         Report on selection and reset
		         * @sample {highcharts} highcharts/chart/events-selection-points/
		         *         Select a range of points through a drag selection
		         * @sample {highstock} stock/chart/events-selection/
		         *         Report on selection and reset
		         * @sample {highstock} highcharts/chart/events-selection-points/
		         *         Select a range of points through a drag selection
		         *         (Highcharts)
		         *
		         * @type      {Function}
		         * @apioption chart.events.selection
		         */

		        /**
		         * The margin between the outer edge of the chart and the plot area.
		         * The numbers in the array designate top, right, bottom and left
		         * respectively. Use the options `marginTop`, `marginRight`,
		         * `marginBottom` and `marginLeft` for shorthand setting of one option.
		         *
		         * By default there is no margin. The actual space is dynamically
		         * calculated from the offset of axis labels, axis title, title,
		         * subtitle and legend in addition to the `spacingTop`, `spacingRight`,
		         * `spacingBottom` and `spacingLeft` options.
		         *
		         * @sample {highcharts} highcharts/chart/margins-zero/
		         *         Zero margins
		         * @sample {highstock} stock/chart/margin-zero/
		         *         Zero margins
		         *
		         * @type      {number|Array<number>}
		         * @apioption chart.margin
		         */

		        /**
		         * The margin between the bottom outer edge of the chart and the plot
		         * area. Use this to set a fixed pixel value for the margin as opposed
		         * to the default dynamic margin. See also `spacingBottom`.
		         *
		         * @sample {highcharts} highcharts/chart/marginbottom/
		         *         100px bottom margin
		         * @sample {highstock} stock/chart/marginbottom/
		         *         100px bottom margin
		         * @sample {highmaps} maps/chart/margin/
		         *         100px margins
		         *
		         * @type      {number}
		         * @since     2.0
		         * @apioption chart.marginBottom
		         */

		        /**
		         * The margin between the left outer edge of the chart and the plot
		         * area. Use this to set a fixed pixel value for the margin as opposed
		         * to the default dynamic margin. See also `spacingLeft`.
		         *
		         * @sample {highcharts} highcharts/chart/marginleft/
		         *         150px left margin
		         * @sample {highstock} stock/chart/marginleft/
		         *         150px left margin
		         * @sample {highmaps} maps/chart/margin/
		         *         100px margins
		         *
		         * @type      {number}
		         * @since     2.0
		         * @apioption chart.marginLeft
		         */

		        /**
		         * The margin between the right outer edge of the chart and the plot
		         * area. Use this to set a fixed pixel value for the margin as opposed
		         * to the default dynamic margin. See also `spacingRight`.
		         *
		         * @sample {highcharts} highcharts/chart/marginright/
		         *         100px right margin
		         * @sample {highstock} stock/chart/marginright/
		         *         100px right margin
		         * @sample {highmaps} maps/chart/margin/
		         *         100px margins
		         *
		         * @type      {number}
		         * @since     2.0
		         * @apioption chart.marginRight
		         */

		        /**
		         * The margin between the top outer edge of the chart and the plot area.
		         * Use this to set a fixed pixel value for the margin as opposed to
		         * the default dynamic margin. See also `spacingTop`.
		         *
		         * @sample {highcharts} highcharts/chart/margintop/ 100px top margin
		         * @sample {highstock} stock/chart/margintop/
		         *         100px top margin
		         * @sample {highmaps} maps/chart/margin/
		         *         100px margins
		         *
		         * @type      {number}
		         * @since     2.0
		         * @apioption chart.marginTop
		         */

		        /**
		         * Allows setting a key to switch between zooming and panning. Can be
		         * one of `alt`, `ctrl`, `meta` (the command key on Mac and Windows
		         * key on Windows) or `shift`. The keys are mapped directly to the key
		         * properties of the click event argument (`event.altKey`,
		         * `event.ctrlKey`, `event.metaKey` and `event.shiftKey`).
		         *
		         * @type       {string}
		         * @since      4.0.3
		         * @product    highcharts gantt
		         * @validvalue ["alt", "ctrl", "meta", "shift"]
		         * @apioption  chart.panKey
		         */

		        /**
		         * Allow panning in a chart. Best used with [panKey](#chart.panKey)
		         * to combine zooming and panning.
		         *
		         * On touch devices, when the [tooltip.followTouchMove](
		         * #tooltip.followTouchMove) option is `true` (default), panning
		         * requires two fingers. To allow panning with one finger, set
		         * `followTouchMove` to `false`.
		         *
		         * @sample {highcharts} highcharts/chart/pankey/ Zooming and panning
		         *
		         * @type      {boolean}
		         * @default   {highcharts} false
		         * @default   {highstock} true
		         * @since     4.0.3
		         * @product   highcharts highstock gantt
		         * @apioption chart.panning
		         */


		        /**
		         * Equivalent to [zoomType](#chart.zoomType), but for multitouch
		         * gestures only. By default, the `pinchType` is the same as the
		         * `zoomType` setting. However, pinching can be enabled separately in
		         * some cases, for example in stock charts where a mouse drag pans the
		         * chart, while pinching is enabled. When [tooltip.followTouchMove](
		         * #tooltip.followTouchMove) is true, pinchType only applies to
		         * two-finger touches.
		         *
		         * @type       {string}
		         * @default    {highcharts} undefined
		         * @default    {highstock} x
		         * @since      3.0
		         * @product    highcharts highstock gantt
		         * @validvalue ["x", "y", "xy"]
		         * @apioption  chart.pinchType
		         */

		        /**
		         * The corner radius of the outer chart border.
		         *
		         * @sample {highcharts} highcharts/chart/borderradius/
		         *         20px radius
		         * @sample {highstock} stock/chart/border/
		         *         10px radius
		         * @sample {highmaps} maps/chart/border/
		         *         Border options
		         *
		         */
		        borderRadius: 0,



		        /**
		         * Alias of `type`.
		         *
		         * @sample {highcharts} highcharts/chart/defaultseriestype/
		         *         Bar
		         *
		         * @deprecated
		         *
		         * @product highcharts
		         */
		        defaultSeriesType: 'line',

		        /**
		         * If true, the axes will scale to the remaining visible series once
		         * one series is hidden. If false, hiding and showing a series will
		         * not affect the axes or the other series. For stacks, once one series
		         * within the stack is hidden, the rest of the stack will close in
		         * around it even if the axis is not affected.
		         *
		         * @sample {highcharts} highcharts/chart/ignorehiddenseries-true/
		         *         True by default
		         * @sample {highcharts} highcharts/chart/ignorehiddenseries-false/
		         *         False
		         * @sample {highcharts} highcharts/chart/ignorehiddenseries-true-stacked/
		         *         True with stack
		         * @sample {highstock} stock/chart/ignorehiddenseries-true/
		         *         True by default
		         * @sample {highstock} stock/chart/ignorehiddenseries-false/
		         *         False
		         *
		         * @since   1.2.0
		         * @product highcharts highstock gantt
		         */
		        ignoreHiddenSeries: true,


		        /**
		         * Whether to invert the axes so that the x axis is vertical and y axis
		         * is horizontal. When `true`, the x axis is [reversed](#xAxis.reversed)
		         * by default.
		         *
		         * @productdesc {highcharts}
		         * If a bar series is present in the chart, it will be inverted
		         * automatically. Inverting the chart doesn't have an effect if there
		         * are no cartesian series in the chart, or if the chart is
		         * [polar](#chart.polar).
		         *
		         * @sample {highcharts} highcharts/chart/inverted/
		         *         Inverted line
		         * @sample {highstock} stock/navigator/inverted/
		         *         Inverted stock chart
		         *
		         * @type      {boolean}
		         * @default   false
		         * @product   highcharts highstock gantt
		         * @apioption chart.inverted
		         */

		        /**
		         * The distance between the outer edge of the chart and the content,
		         * like title or legend, or axis title and labels if present. The
		         * numbers in the array designate top, right, bottom and left
		         * respectively. Use the options spacingTop, spacingRight, spacingBottom
		         * and spacingLeft options for shorthand setting of one option.
		         *
		         * @type    {Array<number>}
		         * @see     [chart.margin](#chart.margin)
		         * @default [10, 10, 15, 10]
		         * @since   3.0.6
		         */
		        spacing: [10, 10, 15, 10],

		        /**
		         * The button that appears after a selection zoom, allowing the user
		         * to reset zoom.
		         */
		        resetZoomButton: {

		            /**
		             * What frame the button should be placed related to. Can be either
		             * `plot` or `chart`
		             *
		             * @sample {highcharts} highcharts/chart/resetzoombutton-relativeto/
		             *         Relative to the chart
		             * @sample {highstock} highcharts/chart/resetzoombutton-relativeto/
		             *         Relative to the chart
		             *
		             * @type       {string}
		             * @default    plot
		             * @since      2.2
		             * @validvalue ["plot", "chart"]
		             * @apioption  chart.resetZoomButton.relativeTo
		             */

		            /**
		             * A collection of attributes for the button. The object takes SVG
		             * attributes like `fill`, `stroke`, `stroke-width` or `r`, the
		             * border radius. The theme also supports `style`, a collection of
		             * CSS properties for the text. Equivalent attributes for the hover
		             * state are given in `theme.states.hover`.
		             *
		             * @sample {highcharts} highcharts/chart/resetzoombutton-theme/
		             *         Theming the button
		             * @sample {highstock} highcharts/chart/resetzoombutton-theme/
		             *         Theming the button
		             *
		             * @since 2.2
		             */
		            theme: {

		                /**
		                 * The Z index for the reset zoom button. The default value
		                 * places it below the tooltip that has Z index 7.
		                 */
		                zIndex: 6
		            },

		            /**
		             * The position of the button.
		             *
		             * @sample {highcharts} highcharts/chart/resetzoombutton-position/
		             *         Above the plot area
		             * @sample {highstock} highcharts/chart/resetzoombutton-position/
		             *         Above the plot area
		             * @sample {highmaps} highcharts/chart/resetzoombutton-position/
		             *         Above the plot area
		             *
		             * @since 2.2
		             */
		            position: {

		                /**
		                 * The horizontal alignment of the button.
		                 */
		                align: 'right',

		                /**
		                 * The horizontal offset of the button.
		                 */
		                x: -10,

		                /**
		                 * The vertical alignment of the button.
		                 *
		                 * @type       {string}
		                 * @default    top
		                 * @validvalue ["top", "middle", "bottom"]
		                 * @apioption  chart.resetZoomButton.position.verticalAlign
		                 */

		                /**
		                 * The vertical offset of the button.
		                 */
		                y: 10
		            }
		        },

		        /**
		         * The pixel width of the plot area border.
		         *
		         * @sample {highcharts} highcharts/chart/plotborderwidth/
		         *         1px border
		         * @sample {highstock} stock/chart/plotborder/
		         *         2px border
		         * @sample {highmaps} maps/chart/plotborder/
		         *         Plot border options
		         *
		         * @type      {number}
		         * @default   0
		         * @apioption chart.plotBorderWidth
		         */

		        /**
		         * Whether to apply a drop shadow to the plot area. Requires that
		         * plotBackgroundColor be set. The shadow can be an object configuration
		         * containing `color`, `offsetX`, `offsetY`, `opacity` and `width`.
		         *
		         * @sample {highcharts} highcharts/chart/plotshadow/
		         *         Plot shadow
		         * @sample {highstock} stock/chart/plotshadow/
		         *         Plot shadow
		         * @sample {highmaps} maps/chart/plotborder/
		         *         Plot border options
		         *
		         * @type      {boolean|Highcharts.CSSObject}
		         * @default   false
		         * @apioption chart.plotShadow
		         */

		        /**
		         * When true, cartesian charts like line, spline, area and column are
		         * transformed into the polar coordinate system. Requires
		         * `highcharts-more.js`.
		         *
		         * @sample {highcharts} highcharts/demo/polar/
		         *         Polar chart
		         * @sample {highcharts} highcharts/demo/polar-wind-rose/
		         *         Wind rose, stacked polar column chart
		         * @sample {highcharts} highcharts/demo/polar-spider/
		         *         Spider web chart
		         * @sample {highcharts} highcharts/parallel-coordinates/polar/
		         *         Star plot, multivariate data in a polar chart
		         *
		         * @type      {boolean}
		         * @default   false
		         * @since     2.3.0
		         * @product   highcharts
		         * @apioption chart.polar
		         */

		        /**
		         * Whether to reflow the chart to fit the width of the container div
		         * on resizing the window.
		         *
		         * @sample {highcharts} highcharts/chart/reflow-true/
		         *         True by default
		         * @sample {highcharts} highcharts/chart/reflow-false/
		         *         False
		         * @sample {highstock} stock/chart/reflow-true/
		         *         True by default
		         * @sample {highstock} stock/chart/reflow-false/
		         *         False
		         * @sample {highmaps} maps/chart/reflow-true/
		         *         True by default
		         * @sample {highmaps} maps/chart/reflow-false/
		         *         False
		         *
		         * @type      {boolean}
		         * @default   true
		         * @since     2.1
		         * @apioption chart.reflow
		         */

		        /**
		         * The HTML element where the chart will be rendered. If it is a string,
		         * the element by that id is used. The HTML element can also be passed
		         * by direct reference, or as the first argument of the chart
		         * constructor, in which case the option is not needed.
		         *
		         * @sample {highcharts} highcharts/chart/reflow-true/
		         *         String
		         * @sample {highcharts} highcharts/chart/renderto-object/
		         *         Object reference
		         * @sample {highcharts} highcharts/chart/renderto-jquery/
		         *         Object reference through jQuery
		         * @sample {highstock} stock/chart/renderto-string/
		         *         String
		         * @sample {highstock} stock/chart/renderto-object/
		         *         Object reference
		         * @sample {highstock} stock/chart/renderto-jquery/
		         *         Object reference through jQuery
		         *
		         * @type      {string|Highcharts.SVGDOMElement}
		         * @apioption chart.renderTo
		         */

		        /**
		         * The background color of the marker square when selecting (zooming
		         * in on) an area of the chart.
		         *
		         * @see In styled mode, the selection marker fill is set with the
		         *      `.highcharts-selection-marker` class.
		         *
		         * @type      {Highcharts.ColorString}
		         * @default   rgba(51,92,173,0.25)
		         * @since     2.1.7
		         * @apioption chart.selectionMarkerFill
		         */

		        /**
		         * Whether to apply a drop shadow to the outer chart area. Requires
		         * that backgroundColor be set. The shadow can be an object
		         * configuration containing `color`, `offsetX`, `offsetY`, `opacity` and
		         * `width`.
		         *
		         * @sample {highcharts} highcharts/chart/shadow/
		         *         Shadow
		         * @sample {highstock} stock/chart/shadow/
		         *         Shadow
		         * @sample {highmaps} maps/chart/border/
		         *         Chart border and shadow
		         *
		         * @type      {boolean|Highcharts.CSSObject}
		         * @default   false
		         * @apioption chart.shadow
		         */

		        /**
		         * Whether to show the axes initially. This only applies to empty charts
		         * where series are added dynamically, as axes are automatically added
		         * to cartesian series.
		         *
		         * @sample {highcharts} highcharts/chart/showaxes-false/
		         *         False by default
		         * @sample {highcharts} highcharts/chart/showaxes-true/
		         *         True
		         *
		         * @type      {boolean}
		         * @since     1.2.5
		         * @product   highcharts gantt
		         * @apioption chart.showAxes
		         */

		        /**
		         * The space between the bottom edge of the chart and the content (plot
		         * area, axis title and labels, title, subtitle or legend in top
		         * position).
		         *
		         * @sample {highcharts} highcharts/chart/spacingbottom/
		         *         Spacing bottom set to 100
		         * @sample {highstock} stock/chart/spacingbottom/
		         *         Spacing bottom set to 100
		         * @sample {highmaps} maps/chart/spacing/
		         *         Spacing 100 all around
		         *
		         * @type      {number}
		         * @default   15
		         * @since     2.1
		         * @apioption chart.spacingBottom
		         */

		        /**
		         * The space between the left edge of the chart and the content (plot
		         * area, axis title and labels, title, subtitle or legend in top
		         * position).
		         *
		         * @sample {highcharts} highcharts/chart/spacingleft/
		         *         Spacing left set to 100
		         * @sample {highstock} stock/chart/spacingleft/
		         *         Spacing left set to 100
		         * @sample {highmaps} maps/chart/spacing/
		         *         Spacing 100 all around
		         *
		         * @type      {number}
		         * @default   10
		         * @since     2.1
		         * @apioption chart.spacingLeft
		         */

		        /**
		         * The space between the right edge of the chart and the content (plot
		         * area, axis title and labels, title, subtitle or legend in top
		         * position).
		         *
		         * @sample {highcharts} highcharts/chart/spacingright-100/
		         *         Spacing set to 100
		         * @sample {highcharts} highcharts/chart/spacingright-legend/
		         *         Legend in right position with default spacing
		         * @sample {highstock} stock/chart/spacingright/
		         *         Spacing set to 100
		         * @sample {highmaps} maps/chart/spacing/
		         *         Spacing 100 all around
		         *
		         * @type      {number}
		         * @default   10
		         * @since     2.1
		         * @apioption chart.spacingRight
		         */

		        /**
		         * The space between the top edge of the chart and the content (plot
		         * area, axis title and labels, title, subtitle or legend in top
		         * position).
		         *
		         * @sample {highcharts} highcharts/chart/spacingtop-100/
		         *         A top spacing of 100
		         * @sample {highcharts} highcharts/chart/spacingtop-10/
		         *         Floating chart title makes the plot area align to the default
		         *         spacingTop of 10.
		         * @sample {highstock} stock/chart/spacingtop/
		         *         A top spacing of 100
		         * @sample {highmaps} maps/chart/spacing/
		         *         Spacing 100 all around
		         *
		         * @type      {number}
		         * @default   10
		         * @since     2.1
		         * @apioption chart.spacingTop
		         */

		        /**
		         * Additional CSS styles to apply inline to the container `div`. Note
		         * that since the default font styles are applied in the renderer, it
		         * is ignorant of the individual chart options and must be set globally.
		         *
		         * @see    In styled mode, general chart styles can be set with the
		         *         `.highcharts-root` class.
		         * @sample {highcharts} highcharts/chart/style-serif-font/
		         *         Using a serif type font
		         * @sample {highcharts} highcharts/css/em/
		         *         Styled mode with relative font sizes
		         * @sample {highstock} stock/chart/style/
		         *         Using a serif type font
		         * @sample {highmaps} maps/chart/style-serif-font/
		         *         Using a serif type font
		         *
		         * @type      {Highcharts.CSSObject}
		         * @default   {"fontFamily": "\"Lucida Grande\", \"Lucida Sans Unicode\", Verdana, Arial, Helvetica, sans-serif","fontSize":"12px"}
		         * @apioption chart.style
		         */

		        /**
		         * The default series type for the chart. Can be any of the chart types
		         * listed under [plotOptions](#plotOptions).
		         *
		         * @sample {highcharts} highcharts/chart/type-bar/
		         *         Bar
		         * @sample {highstock} stock/chart/type/
		         *         Areaspline
		         * @sample {highmaps} maps/chart/type-mapline/
		         *         Mapline
		         *
		         * @type       {string}
		         * @default    {highcharts} line
		         * @default    {highstock} line
		         * @default    {highmaps} map
		         * @since      2.1.0
		         * @validvalue ["line", "spline", "column", "bar", "area", "areaspline",
		         *             "pie", "arearange", "areasplinerange", "boxplot",
		         *             "bubble", "columnrange", "errorbar", "funnel", "gauge",
		         *             "heatmap", "polygon", "pyramid", "scatter", "solidgauge",
		         *             "treemap", "waterfall"]
		         * @apioption  chart.type
		         */

		        /**
		         * Decides in what dimensions the user can zoom by dragging the mouse.
		         * Can be one of `x`, `y` or `xy`.
		         *
		         * @see [panKey](#chart.panKey)
		         *
		         * @sample {highcharts} highcharts/chart/zoomtype-none/
		         *         None by default
		         * @sample {highcharts} highcharts/chart/zoomtype-x/
		         *         X
		         * @sample {highcharts} highcharts/chart/zoomtype-y/
		         *         Y
		         * @sample {highcharts} highcharts/chart/zoomtype-xy/
		         *         Xy
		         * @sample {highstock} stock/demo/basic-line/
		         *         None by default
		         * @sample {highstock} stock/chart/zoomtype-x/
		         *         X
		         * @sample {highstock} stock/chart/zoomtype-y/
		         *         Y
		         * @sample {highstock} stock/chart/zoomtype-xy/
		         *         Xy
		         *
		         * @type       {string}
		         * @product    highcharts highstock gantt
		         * @validvalue ["x", "y", "xy"]
		         * @apioption  chart.zoomType
		         */

		        /**
		         * An explicit width for the chart. By default (when `null`) the width
		         * is calculated from the offset width of the containing element.
		         *
		         * @sample {highcharts} highcharts/chart/width/
		         *         800px wide
		         * @sample {highstock} stock/chart/width/
		         *         800px wide
		         * @sample {highmaps} maps/chart/size/
		         *         Chart with explicit size
		         *
		         * @type {number|null}
		         */
		        width: null,

		        /**
		         * An explicit height for the chart. If a _number_, the height is
		         * given in pixels. If given a _percentage string_ (for example
		         * `'56%'`), the height is given as the percentage of the actual chart
		         * width. This allows for preserving the aspect ratio across responsive
		         * sizes.
		         *
		         * By default (when `null`) the height is calculated from the offset
		         * height of the containing element, or 400 pixels if the containing
		         * element's height is 0.
		         *
		         * @sample {highcharts} highcharts/chart/height/
		         *         500px height
		         * @sample {highstock} stock/chart/height/
		         *         300px height
		         * @sample {highmaps} maps/chart/size/
		         *         Chart with explicit size
		         * @sample highcharts/chart/height-percent/
		         *         Highcharts with percentage height
		         *
		         * @type {number|string|null}
		         */
		        height: null,



		        /**
		         * The color of the outer chart border.
		         *
		         * @see In styled mode, the stroke is set with the
		         *      `.highcharts-background` class.
		         *
		         * @sample {highcharts} highcharts/chart/bordercolor/
		         *         Brown border
		         * @sample {highstock} stock/chart/border/
		         *         Brown border
		         * @sample {highmaps} maps/chart/border/
		         *         Border options
		         *
		         * @type {Highcharts.ColorString}
		         */
		        borderColor: '#335cad',

		        /**
		         * The pixel width of the outer chart border.
		         *
		         * @see In styled mode, the stroke is set with the
		         *      `.highcharts-background` class.
		         *
		         * @sample {highcharts} highcharts/chart/borderwidth/
		         *         5px border
		         * @sample {highstock} stock/chart/border/
		         *         2px border
		         * @sample {highmaps} maps/chart/border/
		         *         Border options
		         *
		         * @type      {number}
		         * @default   0
		         * @apioption chart.borderWidth
		         */

		        /**
		         * The background color or gradient for the outer chart area.
		         *
		         * @see In styled mode, the background is set with the
		         *      `.highcharts-background` class.
		         *
		         * @sample {highcharts} highcharts/chart/backgroundcolor-color/
		         *         Color
		         * @sample {highcharts} highcharts/chart/backgroundcolor-gradient/
		         *         Gradient
		         * @sample {highstock} stock/chart/backgroundcolor-color/
		         *         Color
		         * @sample {highstock} stock/chart/backgroundcolor-gradient/
		         *         Gradient
		         * @sample {highmaps} maps/chart/backgroundcolor-color/
		         *         Color
		         * @sample {highmaps} maps/chart/backgroundcolor-gradient/
		         *         Gradient
		         *
		         * @type {Highcharts.ColorString}
		         */
		        backgroundColor: '#ffffff',

		        /**
		         * The background color or gradient for the plot area.
		         *
		         * @see In styled mode, the plot background is set with the
		         *      `.highcharts-plot-background` class.
		         *
		         * @sample {highcharts} highcharts/chart/plotbackgroundcolor-color/
		         *         Color
		         * @sample {highcharts} highcharts/chart/plotbackgroundcolor-gradient/
		         *         Gradient
		         * @sample {highstock} stock/chart/plotbackgroundcolor-color/
		         *         Color
		         * @sample {highstock} stock/chart/plotbackgroundcolor-gradient/
		         *         Gradient
		         * @sample {highmaps} maps/chart/plotbackgroundcolor-color/
		         *         Color
		         * @sample {highmaps} maps/chart/plotbackgroundcolor-gradient/
		         *         Gradient
		         *
		         * @type      {Highcharts.ColorString}
		         * @apioption chart.plotBackgroundColor
		         */

		        /**
		         * The URL for an image to use as the plot background. To set an image
		         * as the background for the entire chart, set a CSS background image
		         * to the container element. Note that for the image to be applied to
		         * exported charts, its URL needs to be accessible by the export server.
		         *
		         * @see In styled mode, a plot background image can be set with the
		         *      `.highcharts-plot-background` class and a [custom pattern](
		         *      https://www.highcharts.com/docs/chart-design-and-style/
		         *      gradients-shadows-and-patterns).
		         *
		         * @sample {highcharts} highcharts/chart/plotbackgroundimage/
		         *         Skies
		         * @sample {highstock} stock/chart/plotbackgroundimage/
		         *         Skies
		         *
		         * @type      {string}
		         * @apioption chart.plotBackgroundImage
		         */

		        /**
		         * The color of the inner chart or plot area border.
		         *
		         * @see In styled mode, a plot border stroke can be set with the
		         *      `.highcharts-plot-border` class.
		         *
		         * @sample {highcharts} highcharts/chart/plotbordercolor/
		         *         Blue border
		         * @sample {highstock} stock/chart/plotborder/
		         *         Blue border
		         * @sample {highmaps} maps/chart/plotborder/
		         *         Plot border options
		         *
		         * @type {Highcharts.ColorString}
		         */
		        plotBorderColor: '#cccccc'



		    },

		    /**
		     * The chart's main title.
		     *
		     * @sample {highmaps} maps/title/title/
		     *         Title options demonstrated
		     */
		    title: {

		        /**
		         * When the title is floating, the plot area will not move to make space
		         * for it.
		         *
		         * @sample {highcharts} highcharts/chart/zoomtype-none/
		         *         False by default
		         * @sample {highcharts} highcharts/title/floating/
		         *         True - title on top of the plot area
		         * @sample {highstock} stock/chart/title-floating/
		         *         True - title on top of the plot area
		         *
		         * @type      {boolean}
		         * @default   false
		         * @since     2.1
		         * @apioption title.floating
		         */

		        /**
		         * CSS styles for the title. Use this for font styling, but use `align`,
		         * `x` and `y` for text alignment.
		         *
		         * In styled mode, the title style is given in the `.highcharts-title`
		         * class.
		         *
		         * @sample {highcharts} highcharts/title/style/
		         *         Custom color and weight
		         * @sample {highstock} stock/chart/title-style/
		         *         Custom color and weight
		         * @sample highcharts/css/titles/
		         *         Styled mode
		         *
		         * @type      {Highcharts.CSSObject}
		         * @default   {highcharts|highmaps} { "color": "#333333", "fontSize": "18px" }
		         * @default   {highstock} { "color": "#333333", "fontSize": "16px" }
		         * @apioption title.style
		         */

		        /**
		         * Whether to
		         * [use HTML](https://www.highcharts.com/docs/chart-concepts/labels-and-string-formatting#html)
		         * to render the text.
		         *
		         * @type      {boolean}
		         * @default   false
		         * @apioption title.useHTML
		         */

		        /**
		         * The vertical alignment of the title. Can be one of `"top"`,
		         * `"middle"` and `"bottom"`. When a value is given, the title behaves
		         * as if [floating](#title.floating) were `true`.
		         *
		         * @sample {highcharts} highcharts/title/verticalalign/
		         *         Chart title in bottom right corner
		         * @sample {highstock} stock/chart/title-verticalalign/
		         *         Chart title in bottom right corner
		         *
		         * @type       {string}
		         * @since      2.1
		         * @validvalue ["top", "middle", "bottom"]
		         * @apioption  title.verticalAlign
		         */

		        /**
		         * The x position of the title relative to the alignment within
		         * `chart.spacingLeft` and `chart.spacingRight`.
		         *
		         * @sample {highcharts} highcharts/title/align/
		         *         Aligned to the plot area (x = 70px = margin left - spacing
		         *         left)
		         * @sample {highstock} stock/chart/title-align/
		         *         Aligned to the plot area (x = 50px = margin left - spacing
		         *         left)
		         *
		         * @type      {number}
		         * @default   0
		         * @since     2.0
		         * @apioption title.x
		         */

		        /**
		         * The y position of the title relative to the alignment within
		         * [chart.spacingTop](#chart.spacingTop) and [chart.spacingBottom](
		         * #chart.spacingBottom). By default it depends on the font size.
		         *
		         * @sample {highcharts} highcharts/title/y/
		         *         Title inside the plot area
		         * @sample {highstock} stock/chart/title-verticalalign/
		         *         Chart title in bottom right corner
		         *
		         * @type      {number}
		         * @since     2.0
		         * @apioption title.y
		         */

		        /**
		         * The title of the chart. To disable the title, set the `text` to
		         * `undefined`.
		         *
		         * @sample {highcharts} highcharts/title/text/
		         *         Custom title
		         * @sample {highstock} stock/chart/title-text/
		         *         Custom title
		         *
		         * @default {highcharts|highmaps} Chart title
		         * @default {highstock} undefined
		         */
		        text: 'Chart title',

		        /**
		         * The horizontal alignment of the title. Can be one of "left", "center"
		         * and "right".
		         *
		         * @sample {highcharts} highcharts/title/align/
		         *         Aligned to the plot area (x = 70px = margin left - spacing
		         *         left)
		         * @sample {highstock} stock/chart/title-align/
		         *         Aligned to the plot area (x = 50px = margin left - spacing
		         *         left)
		         *
		         * @since      2.0
		         * @validvalue ["left", "center", "right"]
		         */
		        align: 'center',

		        /**
		         * The margin between the title and the plot area, or if a subtitle
		         * is present, the margin between the subtitle and the plot area.
		         *
		         * @sample {highcharts} highcharts/title/margin-50/
		         *         A chart title margin of 50
		         * @sample {highcharts} highcharts/title/margin-subtitle/
		         *         The same margin applied with a subtitle
		         * @sample {highstock} stock/chart/title-margin/
		         *         A chart title margin of 50
		         *
		         * @since 2.1
		         */
		        margin: 15,

		        /**
		         * Adjustment made to the title width, normally to reserve space for
		         * the exporting burger menu.
		         *
		         * @sample highcharts/title/widthadjust/
		         *         Wider menu, greater padding
		         *
		         * @since 4.2.5
		         */
		        widthAdjust: -44

		    },

		    /**
		     * The chart's subtitle. This can be used both to display a subtitle below
		     * the main title, and to display random text anywhere in the chart. The
		     * subtitle can be updated after chart initialization through the
		     * `Chart.setTitle` method.
		     *
		     * @sample {highmaps} maps/title/subtitle/
		     *         Subtitle options demonstrated
		     */
		    subtitle: {

		        /**
		         * When the subtitle is floating, the plot area will not move to make
		         * space for it.
		         *
		         * @sample {highcharts} highcharts/subtitle/floating/
		         *         Floating title and subtitle
		         * @sample {highstock} stock/chart/subtitle-footnote
		         *         Footnote floating at bottom right of plot area
		         *
		         * @type      {boolean}
		         * @default   false
		         * @since     2.1
		         * @apioption subtitle.floating
		         */

		        /**
		         * CSS styles for the title.
		         *
		         * In styled mode, the subtitle style is given in the
		         * `.highcharts-subtitle` class.
		         *
		         * @sample {highcharts} highcharts/subtitle/style/
		         *         Custom color and weight
		         * @sample {highcharts} highcharts/css/titles/
		         *         Styled mode
		         * @sample {highstock} stock/chart/subtitle-style
		         *         Custom color and weight
		         * @sample {highstock} highcharts/css/titles/
		         *         Styled mode
		         * @sample {highmaps} highcharts/css/titles/
		         *         Styled mode
		         *
		         * @type      {Highcharts.CSSObject}
		         * @default   {"color": "#666666"}
		         * @apioption subtitle.style
		         */

		        /**
		         * Whether to
		         * [use HTML](https://www.highcharts.com/docs/chart-concepts/labels-and-string-formatting#html)
		         * to render the text.
		         *
		         * @type      {boolean}
		         * @default   false
		         * @apioption subtitle.useHTML
		         */

		        /**
		         * The vertical alignment of the title. Can be one of "top", "middle"
		         * and "bottom". When a value is given, the title behaves as floating.
		         *
		         * @sample {highcharts} highcharts/subtitle/verticalalign/
		         *         Footnote at the bottom right of plot area
		         * @sample {highstock} stock/chart/subtitle-footnote
		         *         Footnote at the bottom right of plot area
		         *
		         * @type       {string}
		         * @since      2.1
		         * @validvalue ["top", "middle", "bottom"]
		         * @apioption  subtitle.verticalAlign
		         */

		        /**
		         * The x position of the subtitle relative to the alignment within
		         * `chart.spacingLeft` and `chart.spacingRight`.
		         *
		         * @sample {highcharts} highcharts/subtitle/align/
		         *         Footnote at right of plot area
		         * @sample {highstock} stock/chart/subtitle-footnote
		         *         Footnote at the bottom right of plot area
		         *
		         * @type      {number}
		         * @default   0
		         * @since     2.0
		         * @apioption subtitle.x
		         */

		        /**
		         * The y position of the subtitle relative to the alignment within
		         * `chart.spacingTop` and `chart.spacingBottom`. By default the subtitle
		         * is laid out below the title unless the title is floating.
		         *
		         * @sample {highcharts} highcharts/subtitle/verticalalign/
		         *         Footnote at the bottom right of plot area
		         * @sample {highstock} stock/chart/subtitle-footnote
		         *         Footnote at the bottom right of plot area
		         *
		         * @type      {number}
		         * @since     2.0
		         * @apioption subtitle.y
		         */

		        /**
		         * The subtitle of the chart.
		         *
		         * @sample {highcharts|highstock} highcharts/subtitle/text/
		         *         Custom subtitle
		         * @sample {highcharts|highstock} highcharts/subtitle/text-formatted/
		         *         Formatted and linked text.
		         */
		        text: '',

		        /**
		         * The horizontal alignment of the subtitle. Can be one of "left",
		         *  "center" and "right".
		         *
		         * @sample {highcharts} highcharts/subtitle/align/
		         *         Footnote at right of plot area
		         * @sample {highstock} stock/chart/subtitle-footnote
		         *         Footnote at bottom right of plot area
		         *
		         * @since      2.0
		         * @validvalue ["left", "center", "right"]
		         */
		        align: 'center',

		        /**
		         * Adjustment made to the subtitle width, normally to reserve space
		         * for the exporting burger menu.
		         *
		         * @see [title.widthAdjust](#title.widthAdjust)
		         *
		         * @sample highcharts/title/widthadjust/
		         *         Wider menu, greater padding
		         *
		         * @since 4.2.5
		         */
		        widthAdjust: -44
		    },

		    /**
		     * The plotOptions is a wrapper object for config objects for each series
		     * type. The config objects for each series can also be overridden for
		     * each series item as given in the series array.
		     *
		     * Configuration options for the series are given in three levels. Options
		     * for all series in a chart are given in the [plotOptions.series](
		     * #plotOptions.series) object. Then options for all series of a specific
		     * type are given in the plotOptions of that type, for example
		     * `plotOptions.line`. Next, options for one single series are given in
		     * [the series array](#series).
		     */
		    plotOptions: {},

		    /**
		     * HTML labels that can be positioned anywhere in the chart area.
		     */
		    labels: {

		        /**
		         * An HTML label that can be positioned anywhere in the chart area.
		         *
		         * @type      {Array<*>}
		         * @apioption labels.items
		         */

		        /**
		         * Inner HTML or text for the label.
		         *
		         * @type      {string}
		         * @apioption labels.items.html
		         */

		        /**
		         * CSS styles for each label. To position the label, use left and top
		         * like this:
		         *
		         * <pre>style: {
		         *     left: '100px',
		         *     top: '100px'
		         * }</pre>
		         *
		         * @type      {Highcharts.CSSObject}
		         * @apioption labels.items.style
		         */

		        /**
		         * Shared CSS styles for all labels.
		         *
		         * @type    {Highcharts.CSSObject}
		         * @default {"color": "#333333", "position": "absolute"}
		         */
		        style: {
		            /**
		             * @ignore
		             */
		            position: 'absolute',
		            /**
		             * @ignore
		             */
		            color: '#333333'
		        }
		    },

		    /**
		     * The legend is a box containing a symbol and name for each series
		     * item or point item in the chart. Each series (or points in case
		     * of pie charts) is represented by a symbol and its name in the legend.
		     *
		     * It is possible to override the symbol creator function and create
		     * [custom legend symbols](https://jsfiddle.net/gh/get/library/pure/highcharts/highcharts/tree/master/samples/highcharts/studies/legend-custom-symbol/).
		     *
		     * @productdesc {highmaps}
		     * A Highmaps legend by default contains one legend item per series, but if
		     * a `colorAxis` is defined, the axis will be displayed in the legend.
		     * Either as a gradient, or as multiple legend items for `dataClasses`.
		     */
		    legend: {

		        /**
		         * The background color of the legend.
		         *
		         * @see In styled mode, the legend background fill can be applied with
		         *      the `.highcharts-legend-box` class.
		         *
		         * @sample {highcharts} highcharts/legend/backgroundcolor/
		         *         Yellowish background
		         * @sample {highstock} stock/legend/align/
		         *         Various legend options
		         * @sample {highmaps} maps/legend/border-background/
		         *         Border and background options
		         *
		         * @type      {Highcharts.ColorString}
		         * @apioption legend.backgroundColor
		         */

		        /**
		         * The width of the drawn border around the legend.
		         *
		         * @see In styled mode, the legend border stroke width can be applied
		         *      with the `.highcharts-legend-box` class.
		         *
		         * @sample {highcharts} highcharts/legend/borderwidth/
		         *         2px border width
		         * @sample {highstock} stock/legend/align/
		         *         Various legend options
		         * @sample {highmaps} maps/legend/border-background/
		         *         Border and background options
		         *
		         * @type      {number}
		         * @default   0
		         * @apioption legend.borderWidth
		         */

		        /**
		         * Enable or disable the legend. There is also a series-specific option,
		         * [showInLegend](#plotOptions.series.showInLegend), that can hide the
		         * series from the legend. In some series types this is `false` by
		         * default, so it must set to `true` in order to show the legend for the
		         * series.
		         *
		         * @sample {highcharts} highcharts/legend/enabled-false/ Legend disabled
		         * @sample {highstock} stock/legend/align/ Various legend options
		         * @sample {highmaps} maps/legend/enabled-false/ Legend disabled
		         *
		         * @default {highstock} false
		         * @default {highmaps} true
		         * @default {gantt} false
		         */
		        enabled: true,

		        /**
		         * The horizontal alignment of the legend box within the chart area.
		         * Valid values are `left`, `center` and `right`.
		         *
		         * In the case that the legend is aligned in a corner position, the
		         * `layout` option will determine whether to place it above/below
		         * or on the side of the plot area.
		         *
		         * @sample {highcharts} highcharts/legend/align/
		         *         Legend at the right of the chart
		         * @sample {highstock} stock/legend/align/
		         *         Various legend options
		         * @sample {highmaps} maps/legend/alignment/
		         *         Legend alignment
		         *
		         * @since      2.0
		         * @validvalue ["left", "center", "right"]
		         */
		        align: 'center',

		        /**
		         * If the [layout](legend.layout) is `horizontal` and the legend items
		         * span over two lines or more, whether to align the items into vertical
		         * columns. Setting this to `false` makes room for more items, but will
		         * look more messy.
		         *
		         * @since 6.1.0
		         */
		        alignColumns: true,

		        /**
		         * When the legend is floating, the plot area ignores it and is allowed
		         * to be placed below it.
		         *
		         * @sample {highcharts} highcharts/legend/floating-false/
		         *         False by default
		         * @sample {highcharts} highcharts/legend/floating-true/
		         *         True
		         * @sample {highmaps} maps/legend/alignment/
		         *         Floating legend
		         *
		         * @type      {boolean}
		         * @default   false
		         * @since     2.1
		         * @apioption legend.floating
		         */

		        /**
		         * The layout of the legend items. Can be one of `horizontal` or
		         * `vertical` or `proximate`. When `proximate`, the legend items will be
		         * placed as close as possible to the graphs they're representing,
		         * except in inverted charts or when the legend position doesn't allow
		         * it.
		         *
		         * @sample {highcharts} highcharts/legend/layout-horizontal/
		         *         Horizontal by default
		         * @sample {highcharts} highcharts/legend/layout-vertical/
		         *         Vertical
		         * @sample highcharts/legend/layout-proximate
		         *         Labels proximate to the data
		         * @sample {highstock} stock/legend/layout-horizontal/
		         *         Horizontal by default
		         * @sample {highmaps} maps/legend/padding-itemmargin/
		         *         Vertical with data classes
		         * @sample {highmaps} maps/legend/layout-vertical/
		         *         Vertical with color axis gradient
		         *
		         * @validvalue ["horizontal", "vertical", "proximate"]
		         */
		        layout: 'horizontal',

		        /**
		         * In a legend with horizontal layout, the itemDistance defines the
		         * pixel distance between each item.
		         *
		         * @sample {highcharts} highcharts/legend/layout-horizontal/
		         *         50px item distance
		         * @sample {highstock} highcharts/legend/layout-horizontal/
		         *         50px item distance
		         *
		         * @type      {number}
		         * @default   {highcharts} 20
		         * @default   {highstock} 20
		         * @default   {highmaps} 8
		         * @since     3.0.3
		         * @apioption legend.itemDistance
		         */

		        /**
		         * The pixel bottom margin for each legend item.
		         *
		         * @sample {highcharts|highstock} highcharts/legend/padding-itemmargin/
		         *         Padding and item margins demonstrated
		         * @sample {highmaps} maps/legend/padding-itemmargin/
		         *         Padding and item margins demonstrated
		         *
		         * @type      {number}
		         * @default   0
		         * @since     2.2.0
		         * @apioption legend.itemMarginBottom
		         */

		        /**
		         * The pixel top margin for each legend item.
		         *
		         * @sample {highcharts|highstock} highcharts/legend/padding-itemmargin/
		         *         Padding and item margins demonstrated
		         * @sample {highmaps} maps/legend/padding-itemmargin/
		         *         Padding and item margins demonstrated
		         *
		         * @type      {number}
		         * @default   0
		         * @since     2.2.0
		         * @apioption legend.itemMarginTop
		         */

		        /**
		         * The width for each legend item. By default the items are laid out
		         * successively. In a [horizontal layout](legend.layout), if the items
		         * are laid out across two rows or more, they will be vertically aligned
		         * depending on the [legend.alignColumns](legend.alignColumns) option.
		         *
		         * @sample {highcharts} highcharts/legend/itemwidth-default/
		         *         Undefined by default
		         * @sample {highcharts} highcharts/legend/itemwidth-80/
		         *         80 for aligned legend items
		         *
		         * @type      {number}
		         * @since     2.0
		         * @apioption legend.itemWidth
		         */

		        /**
		         * A [format string](https://www.highcharts.com/docs/chart-concepts/
		         * labels-and-string-formatting) for each legend label. Available
		         * variables relates to properties on the series, or the point in case
		         * of pies.
		         *
		         * @type      {string}
		         * @default   {name}
		         * @since     1.3
		         * @apioption legend.labelFormat
		         */

		        /**
		         * Callback function to format each of the series' labels. The `this`
		         * keyword refers to the series object, or the point object in case
		         * of pie charts. By default the series or point name is printed.
		         *
		         * @productdesc {highmaps}
		         * In Highmaps the context can also be a data class in case of a
		         * `colorAxis`.
		         *
		         * @sample {highcharts} highcharts/legend/labelformatter/
		         *         Add text
		         * @sample {highmaps} maps/legend/labelformatter/
		         *         Data classes with label formatter
		         *
		         * @context {Highcharts.Series|Highcharts.Point}
		         */
		        labelFormatter: function () {
		            return this.name;
		        },

		        /**
		         * Line height for the legend items. Deprecated as of 2.1\. Instead,
		         * the line height for each item can be set using itemStyle.lineHeight,
		         * and the padding between items using `itemMarginTop` and
		         * `itemMarginBottom`.
		         *
		         * @sample {highcharts} highcharts/legend/lineheight/
		         *         Setting padding
		         *
		         * @deprecated
		         *
		         * @type      {number}
		         * @default   16
		         * @since     2.0
		         * @product   highcharts gantt
		         * @apioption legend.lineHeight
		         */

		        /**
		         * If the plot area sized is calculated automatically and the legend
		         * is not floating, the legend margin is the space between the legend
		         * and the axis labels or plot area.
		         *
		         * @sample {highcharts} highcharts/legend/margin-default/
		         *         12 pixels by default
		         * @sample {highcharts} highcharts/legend/margin-30/
		         *         30 pixels
		         *
		         * @type      {number}
		         * @default   12
		         * @since     2.1
		         * @apioption legend.margin
		         */

		        /**
		         * Maximum pixel height for the legend. When the maximum height is
		         * extended, navigation will show.
		         *
		         * @type      {number}
		         * @since     2.3.0
		         * @apioption legend.maxHeight
		         */

		        /**
		         * The color of the drawn border around the legend.
		         *
		         * @see In styled mode, the legend border stroke can be applied with the
		         *      `.highcharts-legend-box` class.
		         *
		         * @sample {highcharts} highcharts/legend/bordercolor/
		         *         Brown border
		         * @sample {highstock} stock/legend/align/
		         *         Various legend options
		         * @sample {highmaps} maps/legend/border-background/
		         *         Border and background options
		         *
		         * @type {Highcharts.ColorString}
		         */
		        borderColor: '#999999',

		        /**
		         * The border corner radius of the legend.
		         *
		         * @sample {highcharts} highcharts/legend/borderradius-default/
		         *         Square by default
		         * @sample {highcharts} highcharts/legend/borderradius-round/
		         *         5px rounded
		         * @sample {highmaps} maps/legend/border-background/
		         *         Border and background options
		         */
		        borderRadius: 0,

		        /**
		         * Options for the paging or navigation appearing when the legend
		         * is overflown. Navigation works well on screen, but not in static
		         * exported images. One way of working around that is to
		         * [increase the chart height in
		         * export](https://jsfiddle.net/gh/get/library/pure/highcharts/highcharts/tree/master/samples/highcharts/legend/navigation-enabled-false/).
		         */
		        navigation: {

		            /**
		             * How to animate the pages when navigating up or down. A value of
		             * `true` applies the default navigation given in the
		             * `chart.animation` option. Additional options can be given as an
		             * object containing values for easing and duration.
		             *
		             * @sample {highcharts} highcharts/legend/navigation/
		             *         Legend page navigation demonstrated
		             * @sample {highstock} highcharts/legend/navigation/
		             *         Legend page navigation demonstrated
		             *
		             * @type      {boolean|Highcharts.AnimationObject}
		             * @default   true
		             * @since     2.2.4
		             * @apioption legend.navigation.animation
		             */

		            /**
		             * The pixel size of the up and down arrows in the legend paging
		             * navigation.
		             *
		             * @sample {highcharts} highcharts/legend/navigation/
		             *         Legend page navigation demonstrated
		             * @sample {highstock} highcharts/legend/navigation/
		             *         Legend page navigation demonstrated
		             *
		             * @type      {number}
		             * @default   12
		             * @since     2.2.4
		             * @apioption legend.navigation.arrowSize
		             */

		            /**
		             * Whether to enable the legend navigation. In most cases, disabling
		             * the navigation results in an unwanted overflow.
		             *
		             * See also the [adapt chart to legend](
		             * https://www.highcharts.com/products/plugin-registry/single/8/Adapt-Chart-To-Legend)
		             * plugin for a solution to extend the chart height to make room for
		             * the legend, optionally in exported charts only.
		             *
		             * @type      {boolean}
		             * @default   true
		             * @since     4.2.4
		             * @apioption legend.navigation.enabled
		             */

		            /**
		             * Text styles for the legend page navigation.
		             *
		             * @see In styled mode, the navigation items are styled with the
		             *      `.highcharts-legend-navigation` class.
		             *
		             * @sample {highcharts} highcharts/legend/navigation/
		             *         Legend page navigation demonstrated
		             * @sample {highstock} highcharts/legend/navigation/
		             *         Legend page navigation demonstrated
		             *
		             * @type      {Highcharts.CSSObject}
		             * @since     2.2.4
		             * @apioption legend.navigation.style
		             */



		            /**
		             * The color for the active up or down arrow in the legend page
		             * navigation.
		             *
		             * @see In styled mode, the active arrow be styled with the
		             *      `.highcharts-legend-nav-active` class.
		             *
		             * @sample  {highcharts} highcharts/legend/navigation/
		             *          Legend page navigation demonstrated
		             * @sample  {highstock} highcharts/legend/navigation/
		             *          Legend page navigation demonstrated
		             *
		             * @type  {Highcharts.ColorString}
		             * @since 2.2.4
		             */
		            activeColor: '#003399',

		            /**
		             * The color of the inactive up or down arrow in the legend page
		             * navigation. .
		             *
		             * @see In styled mode, the inactive arrow be styled with the
		             *      `.highcharts-legend-nav-inactive` class.
		             *
		             * @sample {highcharts} highcharts/legend/navigation/
		             *         Legend page navigation demonstrated
		             * @sample {highstock} highcharts/legend/navigation/
		             *         Legend page navigation demonstrated
		             *
		             * @type  {Highcharts.ColorString}
		             * @since 2.2.4
		             */
		            inactiveColor: '#cccccc'

		        },

		        /**
		         * The inner padding of the legend box.
		         *
		         * @sample {highcharts|highstock} highcharts/legend/padding-itemmargin/
		         *         Padding and item margins demonstrated
		         * @sample {highmaps} maps/legend/padding-itemmargin/
		         *         Padding and item margins demonstrated
		         *
		         * @type      {number}
		         * @default   8
		         * @since     2.2.0
		         * @apioption legend.padding
		         */

		        /**
		         * Whether to reverse the order of the legend items compared to the
		         * order of the series or points as defined in the configuration object.
		         *
		         * @see [yAxis.reversedStacks](#yAxis.reversedStacks),
		         *      [series.legendIndex](#series.legendIndex)
		         *
		         * @sample {highcharts} highcharts/legend/reversed/
		         *         Stacked bar with reversed legend
		         *
		         * @type      {boolean}
		         * @default   false
		         * @since     1.2.5
		         * @apioption legend.reversed
		         */

		        /**
		         * Whether to show the symbol on the right side of the text rather than
		         * the left side. This is common in Arabic and Hebraic.
		         *
		         * @sample {highcharts} highcharts/legend/rtl/
		         *         Symbol to the right
		         *
		         * @type      {boolean}
		         * @default   false
		         * @since     2.2
		         * @apioption legend.rtl
		         */

		        /**
		         * CSS styles for the legend area. In the 1.x versions the position
		         * of the legend area was determined by CSS. In 2.x, the position is
		         * determined by properties like `align`, `verticalAlign`, `x` and `y`,
		         * but the styles are still parsed for backwards compatibility.
		         *
		         * @deprecated
		         *
		         * @type      {Highcharts.CSSObject}
		         * @product   highcharts highstock
		         * @apioption legend.style
		         */



		        /**
		         * CSS styles for each legend item. Only a subset of CSS is supported,
		         * notably those options related to text. The default `textOverflow`
		         * property makes long texts truncate. Set it to `undefined` to wrap
		         * text instead. A `width` property can be added to control the text
		         * width.
		         *
		         * @see In styled mode, the legend items can be styled with the
		         *      `.highcharts-legend-item` class.
		         *
		         * @sample {highcharts} highcharts/legend/itemstyle/
		         *         Bold black text
		         * @sample {highmaps} maps/legend/itemstyle/
		         *         Item text styles
		         *
		         * @type    {Highcharts.CSSObject}
		         * @default {"color": "#333333", "cursor": "pointer", "fontSize": "12px", "fontWeight": "bold", "textOverflow": "ellipsis"}
		         */
		        itemStyle: {
		            /**
		             * @ignore
		             */
		            color: '#333333',
		            /**
		             * @ignore
		             */
		            fontSize: '12px',
		            /**
		             * @ignore
		             */
		            fontWeight: 'bold',
		            /**
		             * @ignore
		             */
		            textOverflow: 'ellipsis'
		        },

		        /**
		         * CSS styles for each legend item in hover mode. Only a subset of
		         * CSS is supported, notably those options related to text. Properties
		         * are inherited from `style` unless overridden here.
		         *
		         * @see In styled mode, the hovered legend items can be styled with
		         *      the `.highcharts-legend-item:hover` pesudo-class.
		         *
		         * @sample {highcharts} highcharts/legend/itemhoverstyle/
		         *         Red on hover
		         * @sample {highmaps} maps/legend/itemstyle/
		         *         Item text styles
		         *
		         * @type    {Highcharts.CSSObject}
		         * @default {"color": "#000000"}
		         */
		        itemHoverStyle: {
		            /**
		             * @ignore
		             */
		            color: '#000000'
		        },

		        /**
		         * CSS styles for each legend item when the corresponding series or
		         * point is hidden. Only a subset of CSS is supported, notably those
		         * options related to text. Properties are inherited from `style`
		         * unless overridden here.
		         *
		         * @see In styled mode, the hidden legend items can be styled with
		         *      the `.highcharts-legend-item-hidden` class.
		         *
		         * @sample {highcharts} highcharts/legend/itemhiddenstyle/
		         *         Darker gray color
		         *
		         * @type    {Highcharts.CSSObject}
		         * @default {"color": "#cccccc"}
		         */
		        itemHiddenStyle: {
		            /**
		             * @ignore
		             */
		            color: '#cccccc'
		        },

		        /**
		         * Whether to apply a drop shadow to the legend. A `backgroundColor`
		         * also needs to be applied for this to take effect. The shadow can be
		         * an object configuration containing `color`, `offsetX`, `offsetY`,
		         * `opacity` and `width`.
		         *
		         * @sample {highcharts} highcharts/legend/shadow/
		         *         White background and drop shadow
		         * @sample {highstock} stock/legend/align/
		         *         Various legend options
		         * @sample {highmaps} maps/legend/border-background/
		         *         Border and background options
		         *
		         * @type {boolean|Highcharts.CSSObject}
		         */
		        shadow: false,



		        /**
		         * Default styling for the checkbox next to a legend item when
		         * `showCheckbox` is true.
		         *
		         * @type {Highcharts.CSSObject}
		         * @default {"width": "13px", "height": "13px", "position":"absolute"}
		         */
		        itemCheckboxStyle: {
		            /**
		             * @ignore
		             */
		            position: 'absolute',
		            /**
		             * @ignore
		             */
		            width: '13px', // for IE precision
		            /**
		             * @ignore
		             */
		            height: '13px'
		        },
		        // itemWidth: undefined,

		        /**
		         * When this is true, the legend symbol width will be the same as
		         * the symbol height, which in turn defaults to the font size of the
		         * legend items.
		         *
		         * @since 5.0.0
		         */
		        squareSymbol: true,

		        /**
		         * The pixel height of the symbol for series types that use a rectangle
		         * in the legend. Defaults to the font size of legend items.
		         *
		         * @productdesc {highmaps}
		         * In Highmaps, when the symbol is the gradient of a vertical color
		         * axis, the height defaults to 200.
		         *
		         * @sample {highmaps} maps/legend/layout-vertical-sized/
		         *         Sized vertical gradient
		         * @sample {highmaps} maps/legend/padding-itemmargin/
		         *         No distance between data classes
		         *
		         * @type      {number}
		         * @since     3.0.8
		         * @apioption legend.symbolHeight
		         */

		        /**
		         * The border radius of the symbol for series types that use a rectangle
		         * in the legend. Defaults to half the `symbolHeight`.
		         *
		         * @sample {highcharts} highcharts/legend/symbolradius/
		         *         Round symbols
		         * @sample {highstock} highcharts/legend/symbolradius/
		         *         Round symbols
		         * @sample {highmaps} highcharts/legend/symbolradius/
		         *         Round symbols
		         *
		         * @type      {number}
		         * @since     3.0.8
		         * @apioption legend.symbolRadius
		         */

		        /**
		         * The pixel width of the legend item symbol. When the `squareSymbol`
		         * option is set, this defaults to the `symbolHeight`, otherwise 16.
		         *
		         * @productdesc {highmaps}
		         * In Highmaps, when the symbol is the gradient of a horizontal color
		         * axis, the width defaults to 200.
		         *
		         * @sample {highcharts} highcharts/legend/symbolwidth/
		         *         Greater symbol width and padding
		         * @sample {highmaps} maps/legend/padding-itemmargin/
		         *         Padding and item margins demonstrated
		         * @sample {highmaps} maps/legend/layout-vertical-sized/
		         *         Sized vertical gradient
		         *
		         * @type      {number}
		         * @apioption legend.symbolWidth
		         */

		        /**
		         * Whether to [use HTML](https://www.highcharts.com/docs/chart-concepts/
		         * labels-and-string-formatting#html) to render the legend item texts.
		         *
		         * Prior to 4.1.7, when using HTML, [legend.navigation](
		         * #legend.navigation) was disabled.
		         *
		         * @type      {boolean}
		         * @default   false
		         * @apioption legend.useHTML
		         */

		        /**
		         * The width of the legend box.
		         *
		         * @sample {highcharts} highcharts/legend/width/
		         *         Aligned to the plot area
		         *
		         * @type      {number}
		         * @since     2.0
		         * @apioption legend.width
		         */

		        /**
		         * The pixel padding between the legend item symbol and the legend
		         * item text.
		         *
		         * @sample {highcharts} highcharts/legend/symbolpadding/
		         *         Greater symbol width and padding
		         */
		        symbolPadding: 5,

		        /**
		         * The vertical alignment of the legend box. Can be one of `top`,
		         * `middle` or `bottom`. Vertical position can be further determined
		         * by the `y` option.
		         *
		         * In the case that the legend is aligned in a corner position, the
		         * `layout` option will determine whether to place it above/below
		         * or on the side of the plot area.
		         *
		         * When the [layout](#legend.layout) option is `proximate`, the
		         * `verticalAlign` option doesn't apply.
		         *
		         * @sample {highcharts} highcharts/legend/verticalalign/
		         *         Legend 100px from the top of the chart
		         * @sample {highstock} stock/legend/align/
		         *         Various legend options
		         * @sample {highmaps} maps/legend/alignment/
		         *         Legend alignment
		         *
		         * @since      2.0
		         * @validvalue ["top", "middle", "bottom"]
		         */
		        verticalAlign: 'bottom',

		        // width: undefined,

		        /**
		         * The x offset of the legend relative to its horizontal alignment
		         * `align` within chart.spacingLeft and chart.spacingRight. Negative
		         * x moves it to the left, positive x moves it to the right.
		         *
		         * @sample {highcharts} highcharts/legend/width/
		         *         Aligned to the plot area
		         *
		         * @since 2.0
		         */
		        x: 0,

		        /**
		         * The vertical offset of the legend relative to it's vertical alignment
		         * `verticalAlign` within chart.spacingTop and chart.spacingBottom.
		         *  Negative y moves it up, positive y moves it down.
		         *
		         * @sample {highcharts} highcharts/legend/verticalalign/
		         *         Legend 100px from the top of the chart
		         * @sample {highstock} stock/legend/align/
		         *         Various legend options
		         * @sample {highmaps} maps/legend/alignment/
		         *         Legend alignment
		         *
		         * @since 2.0
		         */
		        y: 0,

		        /**
		         * A title to be added on top of the legend.
		         *
		         * @sample {highcharts} highcharts/legend/title/
		         *         Legend title
		         * @sample {highmaps} maps/legend/alignment/
		         *         Legend with title
		         *
		         * @since 3.0
		         */
		        title: {
		            /**
		             * A text or HTML string for the title.
		             *
		             * @type      {string}
		             * @since     3.0
		             * @apioption legend.title.text
		             */



		            /**
		             * Generic CSS styles for the legend title.
		             *
		             * @see In styled mode, the legend title is styled with the
		             *      `.highcharts-legend-title` class.
		             *
		             * @type    {Highcharts.CSSObject}
		             * @default {"fontWeight": "bold"}
		             * @since   3.0
		             */
		            style: {
		                /**
		                 * @ignore
		                 */
		                fontWeight: 'bold'
		            }



		        }
		    },


		    /**
		     * The loading options control the appearance of the loading screen
		     * that covers the plot area on chart operations. This screen only
		     * appears after an explicit call to `chart.showLoading()`. It is a
		     * utility for developers to communicate to the end user that something
		     * is going on, for example while retrieving new data via an XHR connection.
		     * The "Loading..." text itself is not part of this configuration
		     * object, but part of the `lang` object.
		     */
		    loading: {

		        /**
		         * The duration in milliseconds of the fade out effect.
		         *
		         * @sample highcharts/loading/hideduration/
		         *         Fade in and out over a second
		         *
		         * @type      {number}
		         * @default   100
		         * @since     1.2.0
		         * @apioption loading.hideDuration
		         */

		        /**
		         * The duration in milliseconds of the fade in effect.
		         *
		         * @sample highcharts/loading/hideduration/
		         *         Fade in and out over a second
		         *
		         * @type      {number}
		         * @default   100
		         * @since     1.2.0
		         * @apioption loading.showDuration
		         */



		        /**
		         * CSS styles for the loading label `span`.
		         *
		         * @see In styled mode, the loading label is styled with the
		         *      `.highcharts-loading-inner` class.
		         *
		         * @sample {highcharts|highmaps} highcharts/loading/labelstyle/
		         *         Vertically centered
		         * @sample {highstock} stock/loading/general/
		         *         Label styles
		         *
		         * @type    {Highcharts.CSSObject}
		         * @default {"fontWeight": "bold", "position": "relative", "top": "45%"}
		         * @since   1.2.0
		         */
		        labelStyle: {
		            /**
		             * @ignore
		             */
		            fontWeight: 'bold',
		            /**
		             * @ignore
		             */
		            position: 'relative',
		            /**
		             * @ignore
		             */
		            top: '45%'
		        },

		        /**
		         * CSS styles for the loading screen that covers the plot area.
		         *
		         * In styled mode, the loading label is styled with the
		         * `.highcharts-loading` class.
		         *
		         * @sample  {highcharts|highmaps} highcharts/loading/style/
		         *          Gray plot area, white text
		         * @sample  {highstock} stock/loading/general/
		         *          Gray plot area, white text
		         *
		         * @type    {Highcharts.CSSObject}
		         * @default {"position": "absolute", "backgroundColor": "#ffffff", "opacity": 0.5, "textAlign": "center"}
		         * @since   1.2.0
		         */
		        style: {
		            /**
		             * @ignore
		             */
		            position: 'absolute',
		            /**
		             * @ignore
		             */
		            backgroundColor: '#ffffff',
		            /**
		             * @ignore
		             */
		            opacity: 0.5,
		            /**
		             * @ignore
		             */
		            textAlign: 'center'
		        }

		    },


		    /**
		     * Options for the tooltip that appears when the user hovers over a
		     * series or point.
		     */
		    tooltip: {


		        /**
		         * The color of the tooltip border. When `undefined`, the border takes
		         * the color of the corresponding series or point.
		         *
		         * @sample {highcharts} highcharts/tooltip/bordercolor-default/
		         *         Follow series by default
		         * @sample {highcharts} highcharts/tooltip/bordercolor-black/
		         *         Black border
		         * @sample {highstock} stock/tooltip/general/
		         *         Styled tooltip
		         * @sample {highmaps} maps/tooltip/background-border/
		         *         Background and border demo
		         *
		         * @type      {Highcharts.ColorString}
		         * @apioption tooltip.borderColor
		         */

		        /**
		         * Since 4.1, the crosshair definitions are moved to the Axis object
		         * in order for a better separation from the tooltip. See
		         * [xAxis.crosshair](#xAxis.crosshair)<a>.</a>
		         *
		         * @sample {highcharts} highcharts/tooltip/crosshairs-x/
		         *         Enable a crosshair for the x value
		         *
		         * @deprecated
		         *
		         * @type      {*}
		         * @default   true
		         * @apioption tooltip.crosshairs
		         */

		        /**
		         * Whether the tooltip should follow the mouse as it moves across
		         * columns, pie slices and other point types with an extent. By default
		         * it behaves this way for scatter, bubble and pie series by override
		         * in the `plotOptions` for those series types.
		         *
		         * For touch moves to behave the same way, [followTouchMove](
		         * #tooltip.followTouchMove) must be `true` also.
		         *
		         * @type      {boolean}
		         * @default   {highcharts} false
		         * @default   {highstock} false
		         * @default   {highmaps} true
		         * @since     3.0
		         * @apioption tooltip.followPointer
		         */

		        /**
		         * Whether the tooltip should update as the finger moves on a touch
		         * device. If this is `true` and [chart.panning](#chart.panning) is
		         * set,`followTouchMove` will take over one-finger touches, so the user
		         * needs to use two fingers for zooming and panning.
		         *
		         * Note the difference to [followPointer](#tooltip.followPointer) that
		         * only defines the _position_ of the tooltip. If `followPointer` is
		         * false in for example a column series, the tooltip will show above or
		         * below the column, but as `followTouchMove` is true, the tooltip will
		         * jump from column to column as the user swipes across the plot area.
		         *
		         * @type      {boolean}
		         * @default   {highcharts} true
		         * @default   {highstock} true
		         * @default   {highmaps} false
		         * @since     3.0.1
		         * @apioption tooltip.followTouchMove
		         */

		        /**
		         * Callback function to format the text of the tooltip from scratch.
		         * Return `false` to disable tooltip for a specific point on series.
		         *
		         * A subset of HTML is supported. Unless `useHTML` is true, the HTML of
		         * the tooltip is parsed and converted to SVG, therefore this isn't a
		         * complete HTML renderer. The following tags are supported: `<b>`,
		         * `<strong>`, `<i>`, `<em>`, `<br/>`, `<span>`. Spans can be styled
		         * with a `style` attribute, but only text-related CSS that is shared
		         * with SVG is handled.
		         *
		         * Since version 2.1 the tooltip can be shared between multiple series
		         * through the `shared` option. The available data in the formatter
		         * differ a bit depending on whether the tooltip is shared or not. In
		         * a shared tooltip, all properties except `x`, which is common for
		         * all points, are kept in an array, `this.points`.
		         *
		         * Available data are:
		         *
		         * <dl>
		         *
		         * <dt>this.percentage (not shared) / this.points[i].percentage (shared)
		         * </dt>
		         *
		         * <dd>Stacked series and pies only. The point's percentage of the
		         * total.
		         * </dd>
		         *
		         * <dt>this.point (not shared) / this.points[i].point (shared)</dt>
		         *
		         * <dd>The point object. The point name, if defined, is available
		         * through `this.point.name`.</dd>
		         *
		         * <dt>this.points</dt>
		         *
		         * <dd>In a shared tooltip, this is an array containing all other
		         * properties for each point.</dd>
		         *
		         * <dt>this.series (not shared) / this.points[i].series (shared)</dt>
		         *
		         * <dd>The series object. The series name is available through
		         * `this.series.name`.</dd>
		         *
		         * <dt>this.total (not shared) / this.points[i].total (shared)</dt>
		         *
		         * <dd>Stacked series only. The total value at this point's x value.
		         * </dd>
		         *
		         * <dt>this.x</dt>
		         *
		         * <dd>The x value. This property is the same regardless of the tooltip
		         * being shared or not.</dd>
		         *
		         * <dt>this.y (not shared) / this.points[i].y (shared)</dt>
		         *
		         * <dd>The y value.</dd>
		         *
		         * </dl>
		         *
		         * @sample {highcharts} highcharts/tooltip/formatter-simple/
		         *         Simple string formatting
		         * @sample {highcharts} highcharts/tooltip/formatter-shared/
		         *         Formatting with shared tooltip
		         * @sample {highstock} stock/tooltip/formatter/
		         *         Formatting with shared tooltip
		         * @sample {highmaps} maps/tooltip/formatter/
		         *         String formatting
		         *
		         * @type      {Function}
		         * @apioption tooltip.formatter
		         */

		        /**
		         * The number of milliseconds to wait until the tooltip is hidden when
		         * mouse out from a point or chart.
		         *
		         * @type      {number}
		         * @default   500
		         * @since     3.0
		         * @apioption tooltip.hideDelay
		         */

		        /**
		         * Whether to allow the tooltip to render outside the chart's SVG
		         * element box. By default (`false`), the tooltip is rendered within the
		         * chart's SVG element, which results in the tooltip being aligned
		         * inside the chart area. For small charts, this may result in clipping
		         * or overlapping. When `true`, a separate SVG element is created and
		         * overlaid on the page, allowing the tooltip to be aligned inside the
		         * page itself.
		         *
		         * @sample highcharts/tooltip/outside
		         *         Small charts with tooltips outside
		         *
		         * @type      {boolean}
		         * @default   false
		         * @since     6.1.1
		         * @apioption tooltip.outside
		         */

		        /**
		         * A callback function for formatting the HTML output for a single point
		         * in the tooltip. Like the `pointFormat` string, but with more
		         * flexibility.
		         *
		         * @type      {Function}
		         * @since     4.1.0
		         * @context   Highcharts.Point
		         * @apioption tooltip.pointFormatter
		         */

		        /**
		         * A callback function to place the tooltip in a default position. The
		         * callback receives three parameters: `labelWidth`, `labelHeight` and
		         * `point`, where point contains values for `plotX` and `plotY` telling
		         * where the reference point is in the plot area. Add `chart.plotLeft`
		         * and `chart.plotTop` to get the full coordinates.
		         *
		         * The return should be an object containing x and y values, for example
		         * `{ x: 100, y: 100 }`.
		         *
		         * @sample {highcharts} highcharts/tooltip/positioner/
		         *         A fixed tooltip position
		         * @sample {highstock} stock/tooltip/positioner/
		         *         A fixed tooltip position on top of the chart
		         * @sample {highmaps} maps/tooltip/positioner/
		         *         A fixed tooltip position
		         *
		         * @type      {Function}
		         * @since     2.2.4
		         * @apioption tooltip.positioner
		         */

		        /**
		         * The name of a symbol to use for the border around the tooltip. Can
		         * be one of: `"callout"`, `"circle"` or `"square"`.
		         *
		         * Custom callbacks for symbol path generation can also be added to
		         * `Highcharts.SVGRenderer.prototype.symbols` the same way as for
		         * [series.marker.symbol](plotOptions.line.marker.symbol).
		         *
		         * @type       {string}
		         * @default    callout
		         * @since      4.0
		         * @validvalue ["callout", "square"]
		         * @apioption  tooltip.shape
		         */

		        /**
		         * When the tooltip is shared, the entire plot area will capture mouse
		         * movement or touch events. Tooltip texts for series types with ordered
		         * data (not pie, scatter, flags etc) will be shown in a single bubble.
		         * This is recommended for single series charts and for tablet/mobile
		         * optimized charts.
		         *
		         * See also [tooltip.split](#tooltip.split), that is better suited for
		         * charts with many series, especially line-type series. The
		         * `tooltip.split` option takes precedence over `tooltip.shared`.
		         *
		         * @sample {highcharts} highcharts/tooltip/shared-false/
		         *         False by default
		         * @sample {highcharts} highcharts/tooltip/shared-true/
		         *         True
		         * @sample {highcharts} highcharts/tooltip/shared-x-crosshair/
		         *         True with x axis crosshair
		         * @sample {highcharts} highcharts/tooltip/shared-true-mixed-types/
		         *         True with mixed series types
		         *
		         * @type      {boolean}
		         * @default   false
		         * @since     2.1
		         * @product   highcharts highstock
		         * @apioption tooltip.shared
		         */

		        /**
		         * Split the tooltip into one label per series, with the header close
		         * to the axis. This is recommended over [shared](#tooltip.shared)
		         * tooltips for charts with multiple line series, generally making them
		         * easier to read. This option takes precedence over `tooltip.shared`.
		         *
		         * @productdesc {highstock} In Highstock, tooltips are split by default
		         * since v6.0.0. Stock charts typically contain multi-dimension points
		         * and multiple panes, making split tooltips the preferred layout over
		         * the previous `shared` tooltip.
		         *
		         * @sample highcharts/tooltip/split/
		         *         Split tooltip
		         *
		         * @type      {boolean}
		         * @default   {highcharts} false
		         * @default   {highstock} true
		         * @since     5.0.0
		         * @product   highcharts highstock
		         * @apioption tooltip.split
		         */

		        /**
		         * Use HTML to render the contents of the tooltip instead of SVG. Using
		         * HTML allows advanced formatting like tables and images in the
		         * tooltip. It is also recommended for rtl languages as it works around
		         * rtl bugs in early Firefox.
		         *
		         * @sample {highcharts|highstock} highcharts/tooltip/footerformat/
		         *         A table for value alignment
		         * @sample {highcharts|highstock} highcharts/tooltip/fullhtml/
		         *         Full HTML tooltip
		         * @sample {highmaps} maps/tooltip/usehtml/
		         *         Pure HTML tooltip
		         *
		         * @type      {boolean}
		         * @default   false
		         * @since     2.2
		         * @apioption tooltip.useHTML
		         */

		        /**
		         * How many decimals to show in each series' y value. This is
		         * overridable in each series' tooltip options object. The default is to
		         * preserve all decimals.
		         *
		         * @sample {highcharts|highstock} highcharts/tooltip/valuedecimals/
		         *         Set decimals, prefix and suffix for the value
		         * @sample {highmaps} maps/tooltip/valuedecimals/
		         *         Set decimals, prefix and suffix for the value
		         *
		         * @type      {number}
		         * @since     2.2
		         * @apioption tooltip.valueDecimals
		         */

		        /**
		         * A string to prepend to each series' y value. Overridable in each
		         * series' tooltip options object.
		         *
		         * @sample {highcharts|highstock} highcharts/tooltip/valuedecimals/
		         *         Set decimals, prefix and suffix for the value
		         * @sample {highmaps} maps/tooltip/valuedecimals/
		         *         Set decimals, prefix and suffix for the value
		         *
		         * @type      {string}
		         * @since     2.2
		         * @apioption tooltip.valuePrefix
		         */

		        /**
		         * A string to append to each series' y value. Overridable in each
		         * series' tooltip options object.
		         *
		         * @sample {highcharts|highstock} highcharts/tooltip/valuedecimals/
		         *         Set decimals, prefix and suffix for the value
		         * @sample {highmaps} maps/tooltip/valuedecimals/
		         *         Set decimals, prefix and suffix for the value
		         *
		         * @type      {string}
		         * @since     2.2
		         * @apioption tooltip.valueSuffix
		         */

		        /**
		         * The format for the date in the tooltip header if the X axis is a
		         * datetime axis. The default is a best guess based on the smallest
		         * distance between points in the chart.
		         *
		         * @sample {highcharts} highcharts/tooltip/xdateformat/
		         *         A different format
		         *
		         * @type      {string}
		         * @product   highcharts highstock gantt
		         * @apioption tooltip.xDateFormat
		         */

		        /**
		         * How many decimals to show for the `point.change` value when the
		         * `series.compare` option is set. This is overridable in each series'
		         * tooltip options object. The default is to preserve all decimals.
		         *
		         * @type      {number}
		         * @since     1.0.1
		         * @product   highstock
		         * @apioption tooltip.changeDecimals
		         */

		        /**
		         * Enable or disable the tooltip.
		         *
		         * @sample {highcharts} highcharts/tooltip/enabled/
		         *         Disabled
		         * @sample {highcharts} highcharts/plotoptions/series-point-events-mouseover/
		         *         Disable tooltip and show values on chart instead
		         */
		        enabled: true,

		        /**
		         * Enable or disable animation of the tooltip.
		         *
		         * @type       {boolean}
		         * @default    true
		         * @since      2.3.0
		         */
		        animation: svg,

		        /**
		         * The radius of the rounded border corners.
		         *
		         * @sample {highcharts} highcharts/tooltip/bordercolor-default/
		         *         5px by default
		         * @sample {highcharts} highcharts/tooltip/borderradius-0/
		         *         Square borders
		         * @sample {highmaps} maps/tooltip/background-border/
		         *         Background and border demo
		         */
		        borderRadius: 3,

		        /**
		         * For series on a datetime axes, the date format in the tooltip's
		         * header will by default be guessed based on the closest data points.
		         * This member gives the default string representations used for
		         * each unit. For an overview of the replacement codes, see
		         * [dateFormat](/class-reference/Highcharts#dateFormat).
		         *
		         * @see [xAxis.dateTimeLabelFormats](#xAxis.dateTimeLabelFormats)
		         *
		         * @type    {Highcharts.Dictionary<string>}
		         * @product highcharts highstock gantt
		         */
		        dateTimeLabelFormats: {
		            millisecond: '%A, %b %e, %H:%M:%S.%L',
		            second: '%A, %b %e, %H:%M:%S',
		            minute: '%A, %b %e, %H:%M',
		            hour: '%A, %b %e, %H:%M',
		            day: '%A, %b %e, %Y',
		            week: 'Week from %A, %b %e, %Y',
		            month: '%B %Y',
		            year: '%Y'
		        },

		        /**
		         * A string to append to the tooltip format.
		         *
		         * @sample {highcharts} highcharts/tooltip/footerformat/
		         *         A table for value alignment
		         * @sample {highmaps} maps/tooltip/format/
		         *         Format demo
		         *
		         * @since 2.2
		         */
		        footerFormat: '',

		        /**
		         * Padding inside the tooltip, in pixels.
		         *
		         * @since      5.0.0
		         */
		        padding: 8,

		        /**
		         * Proximity snap for graphs or single points. It defaults to 10 for
		         * mouse-powered devices and 25 for touch devices.
		         *
		         * Note that in most cases the whole plot area captures the mouse
		         * movement, and in these cases `tooltip.snap` doesn't make sense. This
		         * applies when [stickyTracking](#plotOptions.series.stickyTracking)
		         * is `true` (default) and when the tooltip is [shared](#tooltip.shared)
		         * or [split](#tooltip.split).
		         *
		         * @sample {highcharts} highcharts/tooltip/bordercolor-default/
		         *         10 px by default
		         * @sample {highcharts} highcharts/tooltip/snap-50/
		         *         50 px on graph
		         *
		         * @type    {number}
		         * @default 10/25
		         * @since   1.2.0
		         * @product highcharts highstock
		         */
		        snap: isTouchDevice ? 25 : 10,



		        /**
		         * The background color or gradient for the tooltip.
		         *
		         * In styled mode, the stroke width is set in the
		         * `.highcharts-tooltip-box` class.
		         *
		         * @sample {highcharts} highcharts/tooltip/backgroundcolor-solid/
		         *         Yellowish background
		         * @sample {highcharts} highcharts/tooltip/backgroundcolor-gradient/
		         *         Gradient
		         * @sample {highcharts} highcharts/css/tooltip-border-background/
		         *         Tooltip in styled mode
		         * @sample {highstock} stock/tooltip/general/
		         *         Custom tooltip
		         * @sample {highstock} highcharts/css/tooltip-border-background/
		         *         Tooltip in styled mode
		         * @sample {highmaps} maps/tooltip/background-border/
		         *         Background and border demo
		         * @sample {highmaps} highcharts/css/tooltip-border-background/
		         *         Tooltip in styled mode
		         *
		         * @type {Highcharts.ColorString}
		         */
		        backgroundColor: color('#f7f7f7')
		            .setOpacity(0.85).get(),

		        /**
		         * The pixel width of the tooltip border.
		         *
		         * In styled mode, the stroke width is set in the
		         * `.highcharts-tooltip-box` class.
		         *
		         * @sample {highcharts} highcharts/tooltip/bordercolor-default/
		         *         2px by default
		         * @sample {highcharts} highcharts/tooltip/borderwidth/
		         *         No border (shadow only)
		         * @sample {highcharts} highcharts/css/tooltip-border-background/
		         *         Tooltip in styled mode
		         * @sample {highstock} stock/tooltip/general/
		         *         Custom tooltip
		         * @sample {highstock} highcharts/css/tooltip-border-background/
		         *         Tooltip in styled mode
		         * @sample {highmaps} maps/tooltip/background-border/
		         *         Background and border demo
		         * @sample {highmaps} highcharts/css/tooltip-border-background/
		         *         Tooltip in styled mode
		         */
		        borderWidth: 1,

		        /**
		         * The HTML of the tooltip header line. Variables are enclosed by
		         * curly brackets. Available variables are `point.key`, `series.name`,
		         * `series.color` and other members from the `point` and `series`
		         * objects. The `point.key` variable contains the category name, x
		         * value or datetime string depending on the type of axis. For datetime
		         * axes, the `point.key` date format can be set using
		         * `tooltip.xDateFormat`. To access the original point use
		         * `point.point`.
		         *
		         * @sample {highcharts} highcharts/tooltip/footerformat/
		         *         An HTML table in the tooltip
		         * @sample {highstock} highcharts/tooltip/footerformat/
		         *         An HTML table in the tooltip
		         * @sample {highmaps} maps/tooltip/format/
		         *         Format demo
		         */
		        headerFormat: '<span style="font-size: 10px">{point.key}</span><br/>',

		        /**
		         * The HTML of the point's line in the tooltip. Variables are enclosed
		         * by curly brackets. Available variables are point.x, point.y, series.
		         * name and series.color and other properties on the same form.
		         * Furthermore, `point.y` can be extended by the `tooltip.valuePrefix`
		         * and `tooltip.valueSuffix` variables. This can also be overridden for
		         * each series, which makes it a good hook for displaying units.
		         *
		         * In styled mode, the dot is colored by a class name rather
		         * than the point color.
		         *
		         * @sample {highcharts} highcharts/tooltip/pointformat/
		         *         A different point format with value suffix
		         * @sample {highmaps} maps/tooltip/format/
		         *         Format demo
		         *
		         * @since 2.2
		         */
		        pointFormat: '<span style="color:{point.color}">\u25CF</span> {series.name}: <b>{point.y}</b><br/>',

		        /**
		         * Whether to apply a drop shadow to the tooltip.
		         *
		         * @sample {highcharts} highcharts/tooltip/bordercolor-default/
		         *         True by default
		         * @sample {highcharts} highcharts/tooltip/shadow/
		         *         False
		         * @sample {highmaps} maps/tooltip/positioner/
		         *         Fixed tooltip position, border and shadow disabled
		         */
		        shadow: true,

		        /**
		         * CSS styles for the tooltip. The tooltip can also be styled through
		         * the CSS class `.highcharts-tooltip`.
		         *
		         * @sample {highcharts} highcharts/tooltip/style/
		         *         Greater padding, bold text
		         *
		         * @type    {Highcharts.CSSObject}
		         * @default {"color": "#333333", "cursor": "default", "fontSize": "12px", "pointerEvents": "none", "whiteSpace": "nowrap"}
		         */
		        style: {
		            /**
		             * @ignore
		             */
		            color: '#333333',
		            /**
		             * @ignore
		             */
		            cursor: 'default',
		            /**
		             * @ignore
		             */
		            fontSize: '12px',
		            /**
		             * @ignore
		             */
		            pointerEvents: 'none',
		            // #1686 http://caniuse.com/#feat=pointer-events
		            /**
		             * @ignore
		             */
		            whiteSpace: 'nowrap'
		        }

		    },


		    /**
		     * Highchart by default puts a credits label in the lower right corner
		     * of the chart. This can be changed using these options.
		     */
		    credits: {

		        /**
		         * Credits for map source to be concatenated with conventional credit
		         * text. By default this is a format string that collects copyright
		         * information from the map if available.
		         *
		         * @see [mapTextFull](#credits.mapTextFull)
		         * @see [text](#credits.text)
		         *
		         * @type      {string}
		         * @default   \u00a9 <a href="{geojson.copyrightUrl}">{geojson.copyrightShort}</a>
		         * @since     4.2.2
		         * @product   highmaps
		         * @apioption credits.mapText
		         */

		        /**
		         * Detailed credits for map source to be displayed on hover of credits
		         * text. By default this is a format string that collects copyright
		         * information from the map if available.
		         *
		         * @see [mapText](#credits.mapText)
		         * @see [text](#credits.text)
		         *
		         * @type      {string}
		         * @default   {geojson.copyright}
		         * @since     4.2.2
		         * @product   highmaps
		         * @apioption credits.mapTextFull
		         */

		        /**
		         * Whether to show the credits text.
		         *
		         * @sample {highcharts} highcharts/credits/enabled-false/
		         *         Credits disabled
		         * @sample {highstock} stock/credits/enabled/
		         *         Credits disabled
		         * @sample {highmaps} maps/credits/enabled-false/
		         *         Credits disabled
		         */
		        enabled: true,

		        /**
		         * The URL for the credits label.
		         *
		         * @sample {highcharts} highcharts/credits/href/
		         *         Custom URL and text
		         * @sample {highmaps} maps/credits/customized/
		         *         Custom URL and text
		         */
		        href: 'https://www.highcharts.com',

		        /**
		         * Position configuration for the credits label.
		         *
		         * @sample {highcharts} highcharts/credits/position-left/
		         *         Left aligned
		         * @sample {highcharts} highcharts/credits/position-left/
		         *         Left aligned
		         * @sample {highmaps} maps/credits/customized/
		         *         Left aligned
		         * @sample {highmaps} maps/credits/customized/
		         *         Left aligned
		         *
		         * @since 2.1
		         */
		        position: {

		            /**
		             * Horizontal alignment of the credits.
		             *
		             * @validvalue ["left", "center", "right"]
		             */
		            align: 'right',

		            /**
		             * Horizontal pixel offset of the credits.
		             */
		            x: -10,

		            /**
		             * Vertical alignment of the credits.
		             *
		             * @validvalue ["top", "middle", "bottom"]
		             */
		            verticalAlign: 'bottom',

		            /**
		             * Vertical pixel offset of the credits.
		             */
		            y: -5

		        },



		        /**
		         * CSS styles for the credits label.
		         *
		         * @see In styled mode, credits styles can be set with the
		         *      `.highcharts-credits` class.
		         *
		         * @type    {Highcharts.CSSObject}
		         * @default {"cursor": "pointer", "color": "#999999", "fontSize": "10px"}
		         */
		        style: {
		            /**
		             * @ignore
		             */
		            cursor: 'pointer',
		            /**
		             * @ignore
		             */
		            color: '#999999',
		            /**
		             * @ignore
		             */
		            fontSize: '9px'
		        },



		        /**
		         * The text for the credits label.
		         *
		         * @productdesc {highmaps}
		         * If a map is loaded as GeoJSON, the text defaults to
		         * `Highcharts @ {map-credits}`. Otherwise, it defaults to
		         * `Highcharts.com`.
		         *
		         * @sample {highcharts} highcharts/credits/href/
		         *         Custom URL and text
		         * @sample {highmaps} maps/credits/customized/
		         *         Custom URL and text
		         */
		        text: 'Highcharts.com'

		    }
		};

		/**
		 * Merge the default options with custom options and return the new options
		 * structure. Commonly used for defining reusable templates.
		 *
		 * @sample highcharts/global/useutc-false Setting a global option
		 * @sample highcharts/members/setoptions Applying a global theme
		 *
		 * @function Highcharts.setOptions
		 *
		 * @param {Highcharts.Options} options
		 *        The new custom chart options.
		 *
		 * @return {Highcharts.Options}
		 *         Updated options.
		 */
		H.setOptions = function (options) {

		    // Copy in the default options
		    H.defaultOptions = merge(true, H.defaultOptions, options);

		    // Update the time object
		    H.time.update(
		        merge(H.defaultOptions.global, H.defaultOptions.time),
		        false
		    );

		    return H.defaultOptions;
		};

		/**
		 * Get the updated default options. Until 3.0.7, merely exposing defaultOptions
		 * for outside modules wasn't enough because the setOptions method created a new
		 * object.
		 *
		 * @function Highcharts.getOptions
		 *
		 * @return {Highcharts.Options}
		 */
		H.getOptions = function () {
		    return H.defaultOptions;
		};


		// Series defaults
		H.defaultPlotOptions = H.defaultOptions.plotOptions;


		/**
		 * Global `Time` object with default options. Since v6.0.5, time settings can be
		 * applied individually for each chart. If no individual settings apply, this
		 * `Time` object is shared by all instances.
		 *
		 * @name Highcharts.time
		 * @type {Highcharts.Time}
		 */
		H.time = new H.Time(merge(H.defaultOptions.global, H.defaultOptions.time));

		/**
		 * Formats a JavaScript date timestamp (milliseconds since Jan 1st 1970) into a
		 * human readable date string. The format is a subset of the formats for PHP's
		 * [strftime]{@link
		 * http://www.php.net/manual/en/function.strftime.php} function. Additional
		 * formats can be given in the {@link Highcharts.dateFormats} hook.
		 *
		 * Since v6.0.5, all internal dates are formatted through the
		 * [Chart.time](Chart#time) instance to respect chart-level time settings. The
		 * `Highcharts.dateFormat` function only reflects global time settings set with
		 * `setOptions`.
		 *
		 * @function Highcharts.dateFormat
		 *
		 * @param {string} format
		 *        The desired format where various time representations are prefixed
		 *        with `%`.
		 *
		 * @param {number} timestamp
		 *        The JavaScript timestamp.
		 *
		 * @param {boolean} [capitalize=false]
		 *        Upper case first letter in the return.
		 *
		 * @return {string}
		 *         The formatted date.
		 */
		H.dateFormat = function (format, timestamp, capitalize) {
		    return H.time.dateFormat(format, timestamp, capitalize);
		};

	}(Highcharts));
	(function (H) {
		/**
		 * (c) 2010-2018 Torstein Honsi
		 *
		 * License: www.highcharts.com/license
		 */



		var correctFloat = H.correctFloat,
		    defined = H.defined,
		    destroyObjectProperties = H.destroyObjectProperties,
		    fireEvent = H.fireEvent,
		    isNumber = H.isNumber,
		    merge = H.merge,
		    pick = H.pick,
		    deg2rad = H.deg2rad;

		/**
		 * The Tick class.
		 *
		 * @private
		 * @class
		 * @name Highcharts.Tick
		 *
		 * @param {Highcharts.Axis} axis
		 *
		 * @param {number} pos The position of the tick on the axis.
		 *
		 * @param {string} [type] The type of tick.
		 *
		 * @param {boolean} [noLabel=false] Wether to disable the label or not. Defaults to
		 * false.
		 *
		 * @param {object} [parameters] Optional parameters for the tick.
		 *
		 * @param {object} [parameters.tickmarkOffset] Set tickmarkOffset for the tick.
		 *
		 * @param {object} [parameters.category] Set category for the tick.
		 */
		H.Tick = function (axis, pos, type, noLabel, parameters) {
		    this.axis = axis;
		    this.pos = pos;
		    this.type = type || '';
		    this.isNew = true;
		    this.isNewLabel = true;
		    this.parameters = parameters || {};
		    // Usually undefined, numeric for grid axes
		    this.tickmarkOffset = this.parameters.tickmarkOffset;

		    this.options = this.parameters.options;
		    if (!type && !noLabel) {
		        this.addLabel();
		    }
		};

		/** @lends Highcharts.Tick.prototype */
		H.Tick.prototype = {

		    /**
		     * Write the tick label.
		     *
		     * @private
		     * @function Highcharts.Tick#addLabel
		     */
		    addLabel: function () {
		        var tick = this,
		            axis = tick.axis,
		            options = axis.options,
		            chart = axis.chart,
		            categories = axis.categories,
		            names = axis.names,
		            pos = tick.pos,
		            labelOptions = pick(
		                tick.options && tick.options.labels,
		                options.labels
		            ),
		            str,
		            tickPositions = axis.tickPositions,
		            isFirst = pos === tickPositions[0],
		            isLast = pos === tickPositions[tickPositions.length - 1],
		            value = this.parameters.category || (
		                categories ?
		                    pick(categories[pos], names[pos], pos) :
		                    pos
		            ),
		            label = tick.label,
		            tickPositionInfo = tickPositions.info,
		            dateTimeLabelFormat,
		            dateTimeLabelFormats,
		            i,
		            list;

		        // Set the datetime label format. If a higher rank is set for this
		        // position, use that. If not, use the general format.
		        if (axis.isDatetimeAxis && tickPositionInfo) {
		            dateTimeLabelFormats = chart.time.resolveDTLFormat(
		                options.dateTimeLabelFormats[
		                    (
		                        !options.grid &&
		                        tickPositionInfo.higherRanks[pos]
		                    ) ||
		                    tickPositionInfo.unitName
		                ]
		            );
		            dateTimeLabelFormat = dateTimeLabelFormats.main;
		        }

		        // set properties for access in render method
		        tick.isFirst = isFirst;
		        tick.isLast = isLast;

		        // Get the string
		        tick.formatCtx = {
		            axis: axis,
		            chart: chart,
		            isFirst: isFirst,
		            isLast: isLast,
		            dateTimeLabelFormat: dateTimeLabelFormat,
		            tickPositionInfo: tickPositionInfo,
		            value: axis.isLog ? correctFloat(axis.lin2log(value)) : value,
		            pos: pos
		        };
		        str = axis.labelFormatter.call(tick.formatCtx, this.formatCtx);

		        // Set up conditional formatting based on the format list if existing.
		        list = dateTimeLabelFormats && dateTimeLabelFormats.list;
		        if (list) {
		            tick.shortenLabel = function () {
		                for (i = 0; i < list.length; i++) {
		                    label.attr({
		                        text: axis.labelFormatter.call(H.extend(
		                            tick.formatCtx,
		                            { dateTimeLabelFormat: list[i] }
		                        ))
		                    });
		                    if (
		                        label.getBBox().width <
		                        axis.getSlotWidth(tick) - 2 *
		                            pick(labelOptions.padding, 5)
		                    ) {
		                        return;
		                    }
		                }
		                label.attr({
		                    text: ''
		                });
		            };
		        }

		        // first call
		        if (!defined(label)) {

		            tick.label = label =
		                defined(str) && labelOptions.enabled ?
		                    chart.renderer.text(
		                            str,
		                            0,
		                            0,
		                            labelOptions.useHTML
		                        )

		                        // without position absolute, IE export sometimes is
		                        // wrong.
		                        .css(merge(labelOptions.style))

		                        .add(axis.labelGroup) :
		                    null;

		            // Un-rotated length
		            if (label) {
		                label.textPxLength = label.getBBox().width;
		            }


		            // Base value to detect change for new calls to getBBox
		            tick.rotation = 0;

		        // update
		        } else if (label && label.textStr !== str) {
		            // When resetting text, also reset the width if dynamically set
		            // (#8809)
		            if (
		                label.textWidth &&
		                !(labelOptions.style && labelOptions.style.width) &&
		                !label.styles.width
		            ) {
		                label.css({ width: null });
		            }

		            label.attr({ text: str });
		        }
		    },

		    /**
		     * Get the offset height or width of the label
		     *
		     * @private
		     * @function Highcharts.Tick#getLabelSize
		     *
		     * @return {number}
		     */
		    getLabelSize: function () {
		        return this.label ?
		            this.label.getBBox()[this.axis.horiz ? 'height' : 'width'] :
		            0;
		    },

		    /**
		     * Handle the label overflow by adjusting the labels to the left and right
		     * edge, or hide them if they collide into the neighbour label.
		     *
		     * @private
		     * @function Highcharts.Tick#handleOverflow
		     *
		     * @param {Highcharts.PositionObject} xy
		     */
		    handleOverflow: function (xy) {
		        var tick = this,
		            axis = this.axis,
		            labelOptions = axis.options.labels,
		            pxPos = xy.x,
		            chartWidth = axis.chart.chartWidth,
		            spacing = axis.chart.spacing,
		            leftBound = pick(axis.labelLeft, Math.min(axis.pos, spacing[3])),
		            rightBound = pick(
		                axis.labelRight,
		                Math.max(
		                    !axis.isRadial ? axis.pos + axis.len : 0,
		                    chartWidth - spacing[1]
		                )
		            ),
		            label = this.label,
		            rotation = this.rotation,
		            factor = { left: 0, center: 0.5, right: 1 }[
		                axis.labelAlign || label.attr('align')
		            ],
		            labelWidth = label.getBBox().width,
		            slotWidth = axis.getSlotWidth(tick),
		            modifiedSlotWidth = slotWidth,
		            xCorrection = factor,
		            goRight = 1,
		            leftPos,
		            rightPos,
		            textWidth,
		            css = {};

		        // Check if the label overshoots the chart spacing box. If it does, move
		        // it. If it now overshoots the slotWidth, add ellipsis.
		        if (!rotation && pick(labelOptions.overflow, 'justify') === 'justify') {
		            leftPos = pxPos - factor * labelWidth;
		            rightPos = pxPos + (1 - factor) * labelWidth;

		            if (leftPos < leftBound) {
		                modifiedSlotWidth =
		                    xy.x + modifiedSlotWidth * (1 - factor) - leftBound;
		            } else if (rightPos > rightBound) {
		                modifiedSlotWidth =
		                    rightBound - xy.x + modifiedSlotWidth * factor;
		                goRight = -1;
		            }

		            modifiedSlotWidth = Math.min(slotWidth, modifiedSlotWidth); // #4177
		            if (modifiedSlotWidth < slotWidth && axis.labelAlign === 'center') {
		                xy.x += (
		                    goRight *
		                    (
		                        slotWidth -
		                        modifiedSlotWidth -
		                        xCorrection * (
		                            slotWidth - Math.min(labelWidth, modifiedSlotWidth)
		                        )
		                    )
		                );
		            }
		            // If the label width exceeds the available space, set a text width
		            // to be picked up below. Also, if a width has been set before, we
		            // need to set a new one because the reported labelWidth will be
		            // limited by the box (#3938).
		            if (
		                labelWidth > modifiedSlotWidth ||
		                (axis.autoRotation && (label.styles || {}).width)
		            ) {
		                textWidth = modifiedSlotWidth;
		            }

		        // Add ellipsis to prevent rotated labels to be clipped against the edge
		        // of the chart
		        } else if (rotation < 0 && pxPos - factor * labelWidth < leftBound) {
		            textWidth = Math.round(
		                pxPos / Math.cos(rotation * deg2rad) - leftBound
		            );
		        } else if (rotation > 0 && pxPos + factor * labelWidth > rightBound) {
		            textWidth = Math.round(
		                (chartWidth - pxPos) / Math.cos(rotation * deg2rad)
		            );
		        }

		        if (textWidth) {
		            if (tick.shortenLabel) {
		                tick.shortenLabel();
		            } else {
		                css.width = textWidth;
		                if (!(labelOptions.style || {}).textOverflow) {
		                    css.textOverflow = 'ellipsis';
		                }
		                label.css(css);
		            }
		        }
		    },

		    /**
		     * Get the x and y position for ticks and labels
		     *
		     * @private
		     * @function Highcharts.Tick#getPosition
		     *
		     * @param {boolean} horiz
		     *
		     * @param {number} tickPos
		     *
		     * @param {number} tickmarkOffset
		     *
		     * @param {boolean} [old]
		     *
		     * @return {number}
		     *
		     * @fires Highcharts.Tick#event:afterGetPosition
		     */
		    getPosition: function (horiz, tickPos, tickmarkOffset, old) {
		        var axis = this.axis,
		            chart = axis.chart,
		            cHeight = (old && chart.oldChartHeight) || chart.chartHeight,
		            pos;

		        pos = {
		            x: horiz ?
		                H.correctFloat(
		                    axis.translate(tickPos + tickmarkOffset, null, null, old) +
		                    axis.transB
		                ) :
		                (
		                    axis.left +
		                    axis.offset +
		                    (
		                        axis.opposite ?
		                            (
		                                (
		                                    (old && chart.oldChartWidth) ||
		                                    chart.chartWidth
		                                ) -
		                                axis.right -
		                                axis.left
		                            ) :
		                            0
		                    )
		                ),

		            y: horiz ?
		                (
		                    cHeight -
		                    axis.bottom +
		                    axis.offset -
		                    (axis.opposite ? axis.height : 0)
		                ) :
		                H.correctFloat(
		                    cHeight -
		                    axis.translate(tickPos + tickmarkOffset, null, null, old) -
		                    axis.transB
		                )
		        };

		        fireEvent(this, 'afterGetPosition', { pos: pos });

		        return pos;

		    },

		    /**
		     * Get the x, y position of the tick label
		     *
		     * @private
		     *
		     */
		    getLabelPosition: function (
		        x,
		        y,
		        label,
		        horiz,
		        labelOptions,
		        tickmarkOffset,
		        index,
		        step
		    ) {
		        var axis = this.axis,
		            transA = axis.transA,
		            reversed = axis.reversed,
		            staggerLines = axis.staggerLines,
		            rotCorr = axis.tickRotCorr || { x: 0, y: 0 },
		            yOffset = labelOptions.y,

		            // Adjust for label alignment if we use reserveSpace: true (#5286)
		            labelOffsetCorrection = (
		                !horiz && !axis.reserveSpaceDefault ?
		                    -axis.labelOffset * (
		                        axis.labelAlign === 'center' ? 0.5 : 1
		                    ) :
		                    0
		            ),
		            line,
		            pos = {};

		        if (!defined(yOffset)) {
		            if (axis.side === 0) {
		                yOffset = label.rotation ? -8 : -label.getBBox().height;
		            } else if (axis.side === 2) {
		                yOffset = rotCorr.y + 8;
		            } else {
		                // #3140, #3140
		                yOffset = Math.cos(label.rotation * deg2rad) *
		                    (rotCorr.y - label.getBBox(false, 0).height / 2);
		            }
		        }

		        x = x +
		            labelOptions.x +
		            labelOffsetCorrection +
		            rotCorr.x -
		            (
		                tickmarkOffset && horiz ?
		                    tickmarkOffset * transA * (reversed ? -1 : 1) :
		                    0
		            );
		        y = y + yOffset - (tickmarkOffset && !horiz ?
		            tickmarkOffset * transA * (reversed ? 1 : -1) : 0);

		        // Correct for staggered labels
		        if (staggerLines) {
		            line = (index / (step || 1) % staggerLines);
		            if (axis.opposite) {
		                line = staggerLines - line - 1;
		            }
		            y += line * (axis.labelOffset / staggerLines);
		        }

		        pos.x = x;
		        pos.y = Math.round(y);

		        fireEvent(this, 'afterGetLabelPosition', { pos: pos });

		        return pos;
		    },

		    /**
		     * Extendible method to return the path of the marker
		     *
		     * @private
		     *
		     */
		    getMarkPath: function (x, y, tickLength, tickWidth, horiz, renderer) {
		        return renderer.crispLine([
		            'M',
		            x,
		            y,
		            'L',
		            x + (horiz ? 0 : -tickLength),
		            y + (horiz ? tickLength : 0)
		        ], tickWidth);
		    },

		    /**
		     * Renders the gridLine.
		     *
		     * @private
		     *
		     * @param  {Boolean} old         Whether or not the tick is old
		     * @param  {number} opacity      The opacity of the grid line
		     * @param  {number} reverseCrisp Modifier for avoiding overlapping 1 or -1
		     * @return {undefined}
		     */
		    renderGridLine: function (old, opacity, reverseCrisp) {
		        var tick = this,
		            axis = tick.axis,
		            options = axis.options,
		            gridLine = tick.gridLine,
		            gridLinePath,
		            attribs = {},
		            pos = tick.pos,
		            type = tick.type,
		            tickmarkOffset = pick(tick.tickmarkOffset, axis.tickmarkOffset),
		            renderer = axis.chart.renderer;


		        var gridPrefix = type ? type + 'Grid' : 'grid',
		            gridLineWidth = options[gridPrefix + 'LineWidth'],
		            gridLineColor = options[gridPrefix + 'LineColor'],
		            dashStyle = options[gridPrefix + 'LineDashStyle'];


		        if (!gridLine) {

		            attribs.stroke = gridLineColor;
		            attribs['stroke-width'] = gridLineWidth;
		            if (dashStyle) {
		                attribs.dashstyle = dashStyle;
		            }

		            if (!type) {
		                attribs.zIndex = 1;
		            }
		            if (old) {
		                opacity = 0;
		            }
		            tick.gridLine = gridLine = renderer.path()
		                .attr(attribs)
		                .addClass(
		                    'highcharts-' + (type ? type + '-' : '') + 'grid-line'
		                )
		                .add(axis.gridGroup);

		        }

		        if (gridLine) {
		            gridLinePath = axis.getPlotLinePath(
		                pos + tickmarkOffset,
		                gridLine.strokeWidth() * reverseCrisp,
		                old,
		                'pass'
		            );

		            // If the parameter 'old' is set, the current call will be followed
		            // by another call, therefore do not do any animations this time
		            if (gridLinePath) {
		                gridLine[old || tick.isNew ? 'attr' : 'animate']({
		                    d: gridLinePath,
		                    opacity: opacity
		                });
		            }
		        }
		    },

		    /**
		     * Renders the tick mark.
		     *
		     * @private
		     *
		     * @param  {Object} xy           The position vector of the mark
		     * @param  {number} xy.x         The x position of the mark
		     * @param  {number} xy.y         The y position of the mark
		     * @param  {number} opacity      The opacity of the mark
		     * @param  {number} reverseCrisp Modifier for avoiding overlapping 1 or -1
		     * @return {undefined}
		     */
		    renderMark: function (xy, opacity, reverseCrisp) {
		        var tick = this,
		            axis = tick.axis,
		            options = axis.options,
		            renderer = axis.chart.renderer,
		            type = tick.type,
		            tickPrefix = type ? type + 'Tick' : 'tick',
		            tickSize = axis.tickSize(tickPrefix),
		            mark = tick.mark,
		            isNewMark = !mark,
		            x = xy.x,
		            y = xy.y;


		        var tickWidth = pick(
		                options[tickPrefix + 'Width'],
		                !type && axis.isXAxis ? 1 : 0
		            ), // X axis defaults to 1
		            tickColor = options[tickPrefix + 'Color'];


		        if (tickSize) {

		            // negate the length
		            if (axis.opposite) {
		                tickSize[0] = -tickSize[0];
		            }

		            // First time, create it
		            if (isNewMark) {
		                tick.mark = mark = renderer.path()
		                    .addClass('highcharts-' + (type ? type + '-' : '') + 'tick')
		                    .add(axis.axisGroup);


		                mark.attr({
		                    stroke: tickColor,
		                    'stroke-width': tickWidth
		                });

		            }
		            mark[isNewMark ? 'attr' : 'animate']({
		                d: tick.getMarkPath(
		                    x,
		                    y,
		                    tickSize[0],
		                    mark.strokeWidth() * reverseCrisp,
		                    axis.horiz,
		                    renderer),
		                opacity: opacity
		            });

		        }
		    },

		    /**
		     * Renders the tick label.
		     * Note: The label should already be created in init(), so it should only
		     * have to be moved into place.
		     *
		     * @private
		     *
		     * @param  {Object} xy      The position vector of the label
		     * @param  {number} xy.x    The x position of the label
		     * @param  {number} xy.y    The y position of the label
		     * @param  {Boolean} old    Whether or not the tick is old
		     * @param  {number} opacity The opacity of the label
		     * @param  {number} index   The index of the tick
		     * @return {undefined}
		     */
		    renderLabel: function (xy, old, opacity, index) {
		        var tick = this,
		            axis = tick.axis,
		            horiz = axis.horiz,
		            options = axis.options,
		            label = tick.label,
		            labelOptions = options.labels,
		            step = labelOptions.step,
		            tickmarkOffset = pick(tick.tickmarkOffset, axis.tickmarkOffset),
		            show = true,
		            x = xy.x,
		            y = xy.y;
		        if (label && isNumber(x)) {
		            label.xy = xy = tick.getLabelPosition(
		                x,
		                y,
		                label,
		                horiz,
		                labelOptions,
		                tickmarkOffset,
		                index,
		                step
		            );

		            // Apply show first and show last. If the tick is both first and
		            // last, it is a single centered tick, in which case we show the
		            // label anyway (#2100).
		            if (
		                (
		                    tick.isFirst &&
		                    !tick.isLast &&
		                    !pick(options.showFirstLabel, 1)
		                ) ||
		                (
		                    tick.isLast &&
		                    !tick.isFirst &&
		                    !pick(options.showLastLabel, 1)
		                )
		            ) {
		                show = false;

		            // Handle label overflow and show or hide accordingly
		            } else if (
		                horiz &&
		                !labelOptions.step &&
		                !labelOptions.rotation &&
		                !old &&
		                opacity !== 0
		            ) {
		                tick.handleOverflow(xy);
		            }

		            // apply step
		            if (step && index % step) {
		                // show those indices dividable by step
		                show = false;
		            }

		            // Set the new position, and show or hide
		            if (show && isNumber(xy.y)) {
		                xy.opacity = opacity;
		                label[tick.isNewLabel ? 'attr' : 'animate'](xy);
		                tick.isNewLabel = false;
		            } else {
		                label.attr('y', -9999); // #1338
		                tick.isNewLabel = true;
		            }
		        }
		    },

		    /**
		     * Put everything in place
		     *
		     * @private
		     *
		     * @param index {Number}
		     * @param old {Boolean} Use old coordinates to prepare an animation into new
		     *                      position
		     */
		    render: function (index, old, opacity) {
		        var tick = this,
		            axis = tick.axis,
		            horiz = axis.horiz,
		            pos = tick.pos,
		            tickmarkOffset = pick(tick.tickmarkOffset, axis.tickmarkOffset),
		            xy = tick.getPosition(horiz, pos, tickmarkOffset, old),
		            x = xy.x,
		            y = xy.y,
		            reverseCrisp = ((horiz && x === axis.pos + axis.len) ||
		                (!horiz && y === axis.pos)) ? -1 : 1; // #1480, #1687

		        opacity = pick(opacity, 1);
		        this.isActive = true;

		        // Create the grid line
		        this.renderGridLine(old, opacity, reverseCrisp);

		        // create the tick mark
		        this.renderMark(xy, opacity, reverseCrisp);

		        // the label is created on init - now move it into place
		        this.renderLabel(xy, old, opacity, index);

		        tick.isNew = false;

		        H.fireEvent(this, 'afterRender');
		    },

		    /**
		     * Destructor for the tick prototype
		     *
		     * @private
		     * @function Highcharts.Tick#destroy
		     */
		    destroy: function () {
		        destroyObjectProperties(this, this.axis);
		    }
		};

	}(Highcharts));
	var Axis = (function (H) {
		/**
		 * (c) 2010-2018 Torstein Honsi
		 *
		 * License: www.highcharts.com/license
		 */

		/**
		 * Options for crosshairs on axes.
		 *
		 * @typedef {Highcharts.XAxisCrosshairOptions|Highcharts.YAxisCrosshairOptions} Highcharts.AxisCrosshairOptions
		 */

		/**
		 * Options for axes.
		 *
		 * @typedef {Highcharts.XAxisOptions|Highcharts.YAxisOptions|Highcharts.ZAxisOptions} Highcharts.AxisOptions
		 */

		/**
		 * Position of the axis title.
		 *
		 * @typedef Highcharts.AxisTitlePositionObject
		 *
		 * @property {number} x
		 *           X position.
		 *
		 * @property {number} y
		 *           Y position.
		 */

		/**
		 * The returned object literal from the {@link Highcharts.Axis#getExtremes}
		 * function.
		 *
		 * @typedef Highcharts.ExtremesObject
		 *
		 * @property {number} dataMax
		 *           The maximum value of the axis' associated series.
		 *
		 * @property {number} dataMin
		 *           The minimum value of the axis' associated series.
		 *
		 * @property {number} max
		 *           The maximum axis value, either automatic or set manually. If
		 *           the `max` option is not set, `maxPadding` is 0 and `endOnTick`
		 *           is false, this value will be the same as `dataMax`.
		 *
		 * @property {number} min
		 *           The minimum axis value, either automatic or set manually. If
		 *           the `min` option is not set, `minPadding` is 0 and
		 *           `startOnTick` is false, this value will be the same
		 *           as `dataMin`.
		 *
		 * @property {number} userMax
		 *           The user defined maximum, either from the `max` option or from
		 *           a zoom or `setExtremes` action.
		 *
		 * @property {number} userMin
		 *           The user defined minimum, either from the `min` option or from
		 *           a zoom or `setExtremes` action.
		 */



		var addEvent = H.addEvent,
		    animObject = H.animObject,
		    arrayMax = H.arrayMax,
		    arrayMin = H.arrayMin,
		    color = H.color,
		    correctFloat = H.correctFloat,
		    defaultOptions = H.defaultOptions,
		    defined = H.defined,
		    deg2rad = H.deg2rad,
		    destroyObjectProperties = H.destroyObjectProperties,
		    each = H.each,
		    extend = H.extend,
		    fireEvent = H.fireEvent,
		    format = H.format,
		    getMagnitude = H.getMagnitude,
		    grep = H.grep,
		    inArray = H.inArray,
		    isArray = H.isArray,
		    isNumber = H.isNumber,
		    isString = H.isString,
		    merge = H.merge,
		    normalizeTickInterval = H.normalizeTickInterval,
		    objectEach = H.objectEach,
		    pick = H.pick,
		    removeEvent = H.removeEvent,
		    splat = H.splat,
		    syncTimeout = H.syncTimeout,
		    Tick = H.Tick;

		/**
		 * Create a new axis object. Called internally when instanciating a new chart or
		 * adding axes by {@link Highcharts.Chart#addAxis}.
		 *
		 * A chart can have from 0 axes (pie chart) to multiples. In a normal, single
		 * series cartesian chart, there is one X axis and one Y axis.
		 *
		 * The X axis or axes are referenced by {@link Highcharts.Chart.xAxis}, which is
		 * an array of Axis objects. If there is only one axis, it can be referenced
		 * through `chart.xAxis[0]`, and multiple axes have increasing indices. The same
		 * pattern goes for Y axes.
		 *
		 * If you need to get the axes from a series object, use the `series.xAxis` and
		 * `series.yAxis` properties. These are not arrays, as one series can only be
		 * associated to one X and one Y axis.
		 *
		 * A third way to reference the axis programmatically is by `id`. Add an `id` in
		 * the axis configuration options, and get the axis by
		 * {@link Highcharts.Chart#get}.
		 *
		 * Configuration options for the axes are given in options.xAxis and
		 * options.yAxis.
		 *
		 * @class
		 * @name Highcharts.Axis
		 *
		 * @param {Highcharts.Chart} chart
		 *        The Chart instance to apply the axis on.
		 *
		 * @param {Highcharts.AxisOptions} options
		 *        Axis options.
		 */
		var Axis = function () {
		    this.init.apply(this, arguments);
		};

		H.extend(Axis.prototype, /** @lends Highcharts.Axis.prototype */{

		    /**
		     * The X axis or category axis. Normally this is the horizontal axis,
		     * though if the chart is inverted this is the vertical axis. In case of
		     * multiple axes, the xAxis node is an array of configuration objects.
		     *
		     * See [the Axis object](/class-reference/Highcharts.Axis) for
		     * programmatic access to the axis.
		     *
		     * @productdesc {highmaps}
		     * In Highmaps, the axis is hidden, but it is used behind the scenes to
		     * control features like zooming and panning. Zooming is in effect the same
		     * as setting the extremes of one of the exes.
		     *
		     * @optionparent xAxis
		     */
		    defaultOptions: {

		        /**
		         * When using multiple axis, the ticks of two or more opposite axes
		         * will automatically be aligned by adding ticks to the axis or axes
		         * with the least ticks, as if `tickAmount` were specified.
		         *
		         * This can be prevented by setting `alignTicks` to false. If the grid
		         * lines look messy, it's a good idea to hide them for the secondary
		         * axis by setting `gridLineWidth` to 0.
		         *
		         * If `startOnTick` or `endOnTick` in an Axis options are set to false,
		         * then the `alignTicks ` will be disabled for the Axis.
		         *
		         * Disabled for logarithmic axes.
		         *
		         * @type      {boolean}
		         * @default   true
		         * @product   highcharts highstock gantt
		         * @apioption xAxis.alignTicks
		         */

		        /**
		         * Whether to allow decimals in this axis' ticks. When counting
		         * integers, like persons or hits on a web page, decimals should
		         * be avoided in the labels.
		         *
		         * @see [minTickInterval](#xAxis.minTickInterval)
		         *
		         * @sample {highcharts|highstock} highcharts/yaxis/allowdecimals-true/
		         *         True by default
		         * @sample {highcharts|highstock} highcharts/yaxis/allowdecimals-false/
		         *         False
		         *
		         * @type      {boolean}
		         * @default   true
		         * @since     2.0
		         * @apioption xAxis.allowDecimals
		         */

		        /**
		         * When using an alternate grid color, a band is painted across the
		         * plot area between every other grid line.
		         *
		         * @sample {highcharts} highcharts/yaxis/alternategridcolor/
		         *         Alternate grid color on the Y axis
		         * @sample {highstock} stock/xaxis/alternategridcolor/
		         *         Alternate grid color on the Y axis
		         *
		         * @type      {Highcharts.ColorString}
		         * @apioption xAxis.alternateGridColor
		         */

		        /**
		         * An array defining breaks in the axis, the sections defined will be
		         * left out and all the points shifted closer to each other.
		         *
		         * @productdesc {highcharts}
		         * Requires that the broken-axis.js module is loaded.
		         *
		         * @sample {highcharts} highcharts/axisbreak/break-simple/
		         *         Simple break
		         * @sample {highcharts|highstock} highcharts/axisbreak/break-visualized/
		         *         Advanced with callback
		         * @sample {highstock} stock/demo/intraday-breaks/
		         *         Break on nights and weekends
		         *
		         * @type      {Array<*>}
		         * @since     4.1.0
		         * @product   highcharts highstock gantt
		         * @apioption xAxis.breaks
		         */

		        /**
		         * A number indicating how much space should be left between the start
		         * and the end of the break. The break size is given in axis units,
		         * so for instance on a `datetime` axis, a break size of 3600000 would
		         * indicate the equivalent of an hour.
		         *
		         * @type      {number}
		         * @default   0
		         * @since     4.1.0
		         * @product   highcharts highstock gantt
		         * @apioption xAxis.breaks.breakSize
		         */

		        /**
		         * The point where the break starts.
		         *
		         * @type      {number}
		         * @since     4.1.0
		         * @product   highcharts highstock gantt
		         * @apioption xAxis.breaks.from
		         */

		        /**
		         * Defines an interval after which the break appears again. By default
		         * the breaks do not repeat.
		         *
		         * @type      {number}
		         * @default   0
		         * @since     4.1.0
		         * @product   highcharts highstock gantt
		         * @apioption xAxis.breaks.repeat
		         */

		        /**
		         * The point where the break ends.
		         *
		         * @type      {number}
		         * @since     4.1.0
		         * @product   highcharts highstock gantt
		         * @apioption xAxis.breaks.to
		         */

		        /**
		         * If categories are present for the xAxis, names are used instead of
		         * numbers for that axis. Since Highcharts 3.0, categories can also
		         * be extracted by giving each point a [name](#series.data) and setting
		         * axis [type](#xAxis.type) to `category`. However, if you have multiple
		         * series, best practice remains defining the `categories` array.
		         *
		         * Example:
		         *
		         * <pre>categories: ['Apples', 'Bananas', 'Oranges']</pre>
		         *
		         * @sample {highcharts} highcharts/demo/line-labels/
		         *         With
		         * @sample {highcharts} highcharts/xaxis/categories/
		         *         Without
		         *
		         * @type      {Array<string>}
		         * @product   highcharts
		         * @apioption xAxis.categories
		         */

		        /**
		         * The highest allowed value for automatically computed axis extremes.
		         *
		         * @see [floor](#xAxis.floor)
		         *
		         * @sample {highcharts|highstock} highcharts/yaxis/floor-ceiling/
		         *         Floor and ceiling
		         *
		         * @type       {number}
		         * @since      4.0
		         * @product    highcharts highstock gantt
		         * @apioption  xAxis.ceiling
		         */

		        /**
		         * A class name that opens for styling the axis by CSS, especially in
		         * Highcharts styled mode. The class name is applied to group elements
		         * for the grid, axis elements and labels.
		         *
		         * @sample {highcharts|highstock|highmaps} highcharts/css/axis/
		         *         Multiple axes with separate styling
		         *
		         * @type      {string}
		         * @since     5.0.0
		         * @apioption xAxis.className
		         */

		        /**
		         * Configure a crosshair that follows either the mouse pointer or the
		         * hovered point.
		         *
		         * In styled mode, the crosshairs are styled in the
		         * `.highcharts-crosshair`, `.highcharts-crosshair-thin` or
		         * `.highcharts-xaxis-category` classes.
		         *
		         * @productdesc {highstock}
		         * In Highstock, by default, the crosshair is enabled on the X axis and
		         * disabled on the Y axis.
		         *
		         * @sample {highcharts} highcharts/xaxis/crosshair-both/
		         *         Crosshair on both axes
		         * @sample {highstock} stock/xaxis/crosshairs-xy/
		         *         Crosshair on both axes
		         * @sample {highmaps} highcharts/xaxis/crosshair-both/
		         *         Crosshair on both axes
		         *
		         * @type      {boolean|*}
		         * @default   false
		         * @since     4.1
		         * @apioption xAxis.crosshair
		         */

		        /**
		         * A class name for the crosshair, especially as a hook for styling.
		         *
		         * @type      {string}
		         * @since     5.0.0
		         * @apioption xAxis.crosshair.className
		         */

		        /**
		         * The color of the crosshair. Defaults to `#cccccc` for numeric and
		         * datetime axes, and `rgba(204,214,235,0.25)` for category axes, where
		         * the crosshair by default highlights the whole category.
		         *
		         * @sample {highcharts|highstock|highmaps} highcharts/xaxis/crosshair-customized/
		         *         Customized crosshairs
		         *
		         * @type      {Highcharts.ColorString}
		         * @default   #cccccc
		         * @since     4.1
		         * @apioption xAxis.crosshair.color
		         */

		        /**
		         * The dash style for the crosshair. See
		         * [series.dashStyle](#plotOptions.series.dashStyle)
		         * for possible values.
		         *
		         * @sample {highcharts|highmaps} highcharts/xaxis/crosshair-dotted/
		         *         Dotted crosshair
		         * @sample {highstock} stock/xaxis/crosshair-dashed/
		         *         Dashed X axis crosshair
		         *
		         * @type       {string}
		         * @default    Solid
		         * @since      4.1
		         * @validvalue ["Solid", "ShortDash", "ShortDot", "ShortDashDot",
		         *             "ShortDashDotDot", "Dot", "Dash" ,"LongDash", "DashDot",
		         *             "LongDashDot", "LongDashDotDot"]
		         * @apioption  xAxis.crosshair.dashStyle
		         */

		        /**
		         * A label on the axis next to the crosshair.
		         *
		         * In styled mode, the label is styled with the
		         * `.highcharts-crosshair-label` class.
		         *
		         * @sample {highstock} stock/xaxis/crosshair-label/
		         *         Crosshair labels
		         * @sample {highstock} highcharts/css/crosshair-label/
		         *         Style mode
		         *
		         * @since     2.1
		         * @product   highstock
		         * @apioption xAxis.crosshair.label
		         */

		        /**
		         * Alignment of the label compared to the axis. Defaults to `left` for
		         * right-side axes, `right` for left-side axes and `center` for
		         * horizontal axes.
		         *
		         * @type      {string}
		         * @since     2.1
		         * @product   highstock
		         * @apioption xAxis.crosshair.label.align
		         */

		        /**
		         * The background color for the label. Defaults to the related series
		         * color, or `#666666` if that is not available.
		         *
		         * @type      {Highcharts.ColorString}
		         * @since     2.1
		         * @product   highstock
		         * @apioption xAxis.crosshair.label.backgroundColor
		         */

		        /**
		         * The border color for the crosshair label
		         *
		         * @type      {Highcharts.ColorString}
		         * @since     2.1
		         * @product   highstock
		         * @apioption xAxis.crosshair.label.borderColor
		         */

		        /**
		         * The border corner radius of the crosshair label.
		         *
		         * @type      {number}
		         * @default   3
		         * @since     2.1.10
		         * @product   highstock
		         * @apioption xAxis.crosshair.label.borderRadius
		         */

		        /**
		         * The border width for the crosshair label.
		         *
		         * @type      {number}
		         * @default   0
		         * @since     2.1
		         * @product   highstock
		         * @apioption xAxis.crosshair.label.borderWidth
		         */

		        /**
		         * A format string for the crosshair label. Defaults to `{value}` for
		         * numeric axes and `{value:%b %d, %Y}` for datetime axes.
		         *
		         * @type      {string}
		         * @since     2.1
		         * @product   highstock
		         * @apioption xAxis.crosshair.label.format
		         */

		        /**
		         * Formatter function for the label text.
		         *
		         * @type      {Highcharts.FormatterCallbackFunction}
		         * @since     2.1
		         * @product   highstock
		         * @apioption xAxis.crosshair.label.formatter
		         */

		        /**
		         * Padding inside the crosshair label.
		         *
		         * @type      {number}
		         * @default   8
		         * @since     2.1
		         * @product   highstock
		         * @apioption xAxis.crosshair.label.padding
		         */

		        /**
		         * The shape to use for the label box.
		         *
		         * @type      {string}
		         * @default   callout
		         * @since     2.1
		         * @product   highstock
		         * @apioption xAxis.crosshair.label.shape
		         */

		        /**
		         * Text styles for the crosshair label.
		         *
		         * @type      {Highcharts.CSSObject}
		         * @default   {"color": "white", "fontWeight": "normal", "fontSize": "11px", "textAlign": "center"}
		         * @since     2.1
		         * @product   highstock
		         * @apioption xAxis.crosshair.label.style
		         */

		        /**
		         * Whether the crosshair should snap to the point or follow the pointer
		         * independent of points.
		         *
		         * @sample {highcharts|highstock} highcharts/xaxis/crosshair-snap-false/
		         *         True by default
		         * @sample {highmaps} maps/demo/latlon-advanced/
		         *         Snap is false
		         *
		         * @type      {boolean}
		         * @default   true
		         * @since     4.1
		         * @apioption xAxis.crosshair.snap
		         */

		        /**
		         * The pixel width of the crosshair. Defaults to 1 for numeric or
		         * datetime axes, and for one category width for category axes.
		         *
		         * @sample {highcharts} highcharts/xaxis/crosshair-customized/
		         *         Customized crosshairs
		         * @sample {highstock} highcharts/xaxis/crosshair-customized/
		         *         Customized crosshairs
		         * @sample {highmaps} highcharts/xaxis/crosshair-customized/
		         *         Customized crosshairs
		         *
		         * @type      {number}
		         * @default   1
		         * @since     4.1
		         * @apioption xAxis.crosshair.width
		         */

		        /**
		         * The Z index of the crosshair. Higher Z indices allow drawing the
		         * crosshair on top of the series or behind the grid lines.
		         *
		         * @type      {number}
		         * @default   2
		         * @since     4.1
		         * @apioption xAxis.crosshair.zIndex
		         */

		        /**
		         * For a datetime axis, the scale will automatically adjust to the
		         * appropriate unit. This member gives the default string
		         * representations used for each unit. For intermediate values,
		         * different units may be used, for example the `day` unit can be used
		         * on midnight and `hour` unit be used for intermediate values on the
		         * same axis. For an overview of the replacement codes, see
		         * [dateFormat](/class-reference/Highcharts#dateFormat). Defaults to:
		         *
		         * <pre>{
		         *     millisecond: '%H:%M:%S.%L',
		         *     second: '%H:%M:%S',
		         *     minute: '%H:%M',
		         *     hour: '%H:%M',
		         *     day: '%e. %b',
		         *     week: '%e. %b',
		         *     month: '%b \'%y',
		         *     year: '%Y'
		         * }</pre>
		         *
		         * @sample {highcharts} highcharts/xaxis/datetimelabelformats/
		         *         Different day format on X axis
		         * @sample {highstock} stock/xaxis/datetimelabelformats/
		         *         More information in x axis labels
		         *
		         * @product highcharts highstock gantt
		         */
		        dateTimeLabelFormats: {
		            millisecond: {
		                main: '%H:%M:%S.%L',
		                range: false
		            },
		            second: {
		                main: '%H:%M:%S',
		                range: false
		            },
		            minute: {
		                main: '%H:%M',
		                range: false
		            },
		            hour: {
		                main: '%H:%M',
		                range: false
		            },
		            day: {
		                main: '%e. %b'
		            },
		            week: {
		                main: '%e. %b'
		            },
		            month: {
		                main: '%b \'%y'
		            },
		            year: {
		                main: '%Y'
		            }
		        },

		        /**
		         * _Requires Accessibility module_
		         *
		         * Description of the axis to screen reader users.
		         *
		         * @type      {string}
		         * @since     5.0.0
		         * @apioption xAxis.description
		         */

		        /**
		         * Whether to force the axis to end on a tick. Use this option with
		         * the `maxPadding` option to control the axis end.
		         *
		         * @productdesc {highstock}
		         * In Highstock, `endOnTick` is always false when the navigator is
		         * enabled, to prevent jumpy scrolling.
		         *
		         * @sample {highcharts} highcharts/chart/reflow-true/
		         *         True by default
		         * @sample {highcharts} highcharts/yaxis/endontick/
		         *         False
		         * @sample {highstock} stock/demo/basic-line/
		         *         True by default
		         * @sample {highstock} stock/xaxis/endontick/
		         *         False
		         *
		         * @since 1.2.0
		         */
		        endOnTick: false,

		        /**
		         * Event handlers for the axis.
		         *
		         * @type      {*}
		         * @apioption xAxis.events
		         */

		        /**
		         * An event fired after the breaks have rendered.
		         *
		         * @see [breaks](#xAxis.breaks)
		         *
		         * @sample {highcharts} highcharts/axisbreak/break-event/
		         *         AfterBreak Event
		         *
		         * @type      {Function}
		         * @since     4.1.0
		         * @product   highcharts gantt
		         * @apioption xAxis.events.afterBreaks
		         */

		        /**
		         * As opposed to the `setExtremes` event, this event fires after the
		         * final min and max values are computed and corrected for `minRange`.
		         *
		         *
		         * Fires when the minimum and maximum is set for the axis, either by
		         * calling the `.setExtremes()` method or by selecting an area in the
		         * chart. One parameter, `event`, is passed to the function, containing
		         * common event information.
		         *
		         * The new user set minimum and maximum values can be found by
		         * `event.min` and `event.max`. These reflect the axis minimum and
		         * maximum in axis values. The actual data extremes are found in
		         * `event.dataMin` and `event.dataMax`.
		         *
		         * @type      {Function}
		         * @since     2.3
		         * @context   Axis
		         * @apioption xAxis.events.afterSetExtremes
		         */

		        /**
		         * An event fired when a break from this axis occurs on a point.
		         *
		         * @see [breaks](#xAxis.breaks)
		         *
		         * @sample {highcharts} highcharts/axisbreak/break-visualized/
		         *         Visualization of a Break
		         *
		         * @type      {Function}
		         * @since     4.1.0
		         * @product   highcharts gantt
		         * @context   Axis
		         * @apioption xAxis.events.pointBreak
		         */

		        /**
		         * An event fired when a point falls inside a break from this axis.
		         *
		         * @type      {Function}
		         * @product   highcharts highstock gantt
		         * @context   Axis
		         * @apioption xAxis.events.pointInBreak
		         */

		        /**
		         * Fires when the minimum and maximum is set for the axis, either by
		         * calling the `.setExtremes()` method or by selecting an area in the
		         * chart. One parameter, `event`, is passed to the function,
		         * containing common event information.
		         *
		         * The new user set minimum and maximum values can be found by
		         * `event.min` and `event.max`. These reflect the axis minimum and
		         * maximum in data values. When an axis is zoomed all the way out from
		         * the "Reset zoom" button, `event.min` and `event.max` are null, and
		         * the new extremes are set based on `this.dataMin` and `this.dataMax`.
		         *
		         * @sample {highstock} stock/xaxis/events-setextremes/
		         *         Log new extremes on x axis
		         *
		         * @type      {Function}
		         * @since     1.2.0
		         * @context   Axis
		         * @apioption xAxis.events.setExtremes
		         */

		        /**
		         * The lowest allowed value for automatically computed axis extremes.
		         *
		         * @see [ceiling](#yAxis.ceiling)
		         *
		         * @sample {highcharts} highcharts/yaxis/floor-ceiling/
		         *         Floor and ceiling
		         * @sample {highstock} stock/demo/lazy-loading/
		         *         Prevent negative stock price on Y axis
		         *
		         * @type      {number}
		         * @since     4.0
		         * @product   highcharts highstock gantt
		         * @apioption xAxis.floor
		         */

		        /**
		         * The dash or dot style of the grid lines. For possible values, see
		         * [this demonstration](https://jsfiddle.net/gh/get/library/pure/
		         * highcharts/highcharts/tree/master/samples/highcharts/plotoptions/
		         * series-dashstyle-all/).
		         *
		         * @sample {highcharts} highcharts/yaxis/gridlinedashstyle/
		         *         Long dashes
		         * @sample {highstock} stock/xaxis/gridlinedashstyle/
		         *         Long dashes
		         *
		         * @type       {string}
		         * @default    Solid
		         * @since      1.2
		         * @validvalue ["Solid", "ShortDash", "ShortDot", "ShortDashDot",
		         *             "ShortDashDotDot", "Dot", "Dash" ,"LongDash", "DashDot",
		         *             "LongDashDot", "LongDashDotDot"]
		         * @apioption  xAxis.gridLineDashStyle
		         */

		        /**
		         * The Z index of the grid lines.
		         *
		         * @sample {highcharts|highstock} highcharts/xaxis/gridzindex/
		         *         A Z index of 4 renders the grid above the graph
		         *
		         * @type      {number}
		         * @default   1
		         * @product   highcharts highstock gantt
		         * @apioption xAxis.gridZIndex
		         */

		        /**
		         * An id for the axis. This can be used after render time to get
		         * a pointer to the axis object through `chart.get()`.
		         *
		         * @sample {highcharts} highcharts/xaxis/id/
		         *         Get the object
		         * @sample {highstock} stock/xaxis/id/
		         *         Get the object
		         *
		         * @type      {string}
		         * @since     1.2.0
		         * @apioption xAxis.id
		         */

		        /**
		         * The axis labels show the number or category for each tick.
		         *
		         * @productdesc {highmaps}
		         * X and Y axis labels are by default disabled in Highmaps, but the
		         * functionality is inherited from Highcharts and used on `colorAxis`,
		         * and can be enabled on X and Y axes too.
		         */
		        labels: {

		            /**
		             * What part of the string the given position is anchored to.
		             * If `left`, the left side of the string is at the axis position.
		             * Can be one of `"left"`, `"center"` or `"right"`. Defaults to
		             * an intelligent guess based on which side of the chart the axis
		             * is on and the rotation of the label.
		             *
		             * @see [reserveSpace](#xAxis.labels.reserveSpace)
		             *
		             * @sample {highcharts} highcharts/xaxis/labels-align-left/
		             *         Left
		             * @sample {highcharts} highcharts/xaxis/labels-align-right/
		             *         Right
		             * @sample {highcharts} highcharts/xaxis/labels-reservespace-true/
		             *         Left-aligned labels on a vertical category axis
		             *
		             * @type       {string}
		             * @validvalue ["left", "center", "right"]
		             * @apioption  xAxis.labels.align
		             */

		            /**
		             * For horizontal axes, the allowed degrees of label rotation
		             * to prevent overlapping labels. If there is enough space,
		             * labels are not rotated. As the chart gets narrower, it
		             * will start rotating the labels -45 degrees, then remove
		             * every second label and try again with rotations 0 and -45 etc.
		             * Set it to `false` to disable rotation, which will
		             * cause the labels to word-wrap if possible.
		             *
		             * @sample {highcharts|highstock} highcharts/xaxis/labels-autorotation-default/
		             *         Default auto rotation of 0 or -45
		             * @sample {highcharts|highstock} highcharts/xaxis/labels-autorotation-0-90/
		             *         Custom graded auto rotation
		             *
		             * @type      {Array<number>}
		             * @default   [-45]
		             * @since     4.1.0
		             * @product   highcharts highstock gantt
		             * @apioption xAxis.labels.autoRotation
		             */

		            /**
		             * When each category width is more than this many pixels, we don't
		             * apply auto rotation. Instead, we lay out the axis label with word
		             * wrap. A lower limit makes sense when the label contains multiple
		             * short words that don't extend the available horizontal space for
		             * each label.
		             *
		             * @sample {highcharts} highcharts/xaxis/labels-autorotationlimit/
		             *         Lower limit
		             *
		             * @type      {number}
		             * @default   80
		             * @since     4.1.5
		             * @product   highcharts gantt
		             * @apioption xAxis.labels.autoRotationLimit
		             */

		            /**
		             * Polar charts only. The label's pixel distance from the perimeter
		             * of the plot area.
		             *
		             * @type      {number}
		             * @default   15
		             * @product   highcharts gantt
		             * @apioption xAxis.labels.distance
		             */

		            /**
		             * Enable or disable the axis labels.
		             *
		             * @sample {highcharts} highcharts/xaxis/labels-enabled/
		             *         X axis labels disabled
		             * @sample {highstock} stock/xaxis/labels-enabled/
		             *         X axis labels disabled
		             *
		             * @default {highcharts|highstock|gantt} true
		             * @default {highmaps} false
		             */
		            enabled: true,

		            /**
		             * A [format string](https://www.highcharts.com/docs/chart-
		             * concepts/labels-and-string-formatting) for the axis label.
		             *
		             * @sample {highcharts|highstock} highcharts/yaxis/labels-format/
		             *         Add units to Y axis label
		             *
		             * @type      {string}
		             * @default   {value}
		             * @since     3.0
		             * @apioption xAxis.labels.format
		             */

		            /**
		             * Callback JavaScript function to format the label. The value
		             * is given by `this.value`. Additional properties for `this` are
		             * `axis`, `chart`, `isFirst` and `isLast`. The value of the default
		             * label formatter can be retrieved by calling
		             * `this.axis.defaultLabelFormatter.call(this)` within the function.
		             *
		             * Defaults to:
		             *
		             * <pre>function() {
		             *     return this.value;
		             * }</pre>
		             *
		             * @sample {highcharts} highcharts/xaxis/labels-formatter-linked/
		             *         Linked category names
		             * @sample {highcharts} highcharts/xaxis/labels-formatter-extended/
		             *         Modified numeric labels
		             * @sample {highstock} stock/xaxis/labels-formatter/
		             *         Added units on Y axis
		             *
		             * @type      {Function}
		             * @apioption xAxis.labels.formatter
		             */

		            /**
		             * The number of pixels to indent the labels per level in a treegrid
		             * axis.
		             *
		             * @product gantt
		             * @sample  gantt/treegrid-axis/demo
		             *          Indentation 10px by default.
		             * @sample  gantt/treegrid-axis/indentation-0px
		             *          Indentation set to 0px.
		             */
		            indentation: 10,

		            /**
		             * Horizontal axis only. When `staggerLines` is not set,
		             * `maxStaggerLines` defines how many lines the axis is allowed to
		             * add to automatically avoid overlapping X labels. Set to `1` to
		             * disable overlap detection.
		             *
		             * @deprecated
		             * @type      {number}
		             * @default   5
		             * @since     1.3.3
		             * @apioption xAxis.labels.maxStaggerLines
		             */

		            /**
		             * How to handle overflowing labels on horizontal axis. If set to
		             * `"allow"`, it will not be aligned at all. By default it
		             * `"justify"` labels inside the chart area. If there is room to
		             * move it, it will be aligned to the edge, else it will be removed.
		             *
		             * @type       {boolean|string}
		             * @default    justify
		             * @since      2.2.5
		             * @validvalue ["allow", "justify"]
		             * @apioption  xAxis.labels.overflow
		             */

		            /**
		             * The pixel padding for axis labels, to ensure white space between
		             * them.
		             *
		             * @type      {number}
		             * @default   5
		             * @product   highcharts gantt
		             * @apioption xAxis.labels.padding
		             */

		            /**
		             * Whether to reserve space for the labels. By default, space is
		             * reserved for the labels in these cases:
		             *
		             * * On all horizontal axes.
		             * * On vertical axes if `label.align` is `right` on a left-side
		             * axis or `left` on a right-side axis.
		             * * On vertical axes if `label.align` is `center`.
		             *
		             * This can be turned off when for example the labels are rendered
		             * inside the plot area instead of outside.
		             *
		             * @see [labels.align](#xAxis.labels.align)
		             *
		             * @sample {highcharts} highcharts/xaxis/labels-reservespace/
		             *         No reserved space, labels inside plot
		             * @sample {highcharts} highcharts/xaxis/labels-reservespace-true/
		             *         Left-aligned labels on a vertical category axis
		             *
		             * @type      {boolean}
		             * @since     4.1.10
		             * @product   highcharts gantt
		             * @apioption xAxis.labels.reserveSpace
		             */

		            /**
		             * Rotation of the labels in degrees.
		             *
		             * @sample {highcharts} highcharts/xaxis/labels-rotation/
		             *         X axis labels rotated 90°
		             *
		             * @type      {number}
		             * @default   0
		             * @apioption xAxis.labels.rotation
		             */

		            /**
		             * Horizontal axes only. The number of lines to spread the labels
		             * over to make room or tighter labels.
		             *
		             * @sample {highcharts} highcharts/xaxis/labels-staggerlines/
		             *         Show labels over two lines
		             * @sample {highstock} stock/xaxis/labels-staggerlines/
		             *         Show labels over two lines
		             *
		             * @type      {number}
		             * @since     2.1
		             * @apioption xAxis.labels.staggerLines
		             */

		            /**
		             * To show only every _n_'th label on the axis, set the step to _n_.
		             * Setting the step to 2 shows every other label.
		             *
		             * By default, the step is calculated automatically to avoid
		             * overlap. To prevent this, set it to 1\. This usually only
		             * happens on a category axis, and is often a sign that you have
		             * chosen the wrong axis type.
		             *
		             * Read more at
		             * [Axis docs](https://www.highcharts.com/docs/chart-concepts/axes)
		             * => What axis should I use?
		             *
		             * @sample {highcharts} highcharts/xaxis/labels-step/
		             *         Showing only every other axis label on a categorized
		             *         x-axis
		             * @sample {highcharts} highcharts/xaxis/labels-step-auto/
		             *         Auto steps on a category axis
		             *
		             * @type      {number}
		             * @since     2.1
		             * @apioption xAxis.labels.step
		             */

		            /**
		             * Whether to [use HTML](https://www.highcharts.com/docs/chart-
		             * concepts/labels-and-string-formatting#html) to render the labels.
		             *
		             * @type      {boolean}
		             * @default   false
		             * @apioption xAxis.labels.useHTML
		             */

		            /**
		             * The x position offset of the label relative to the tick position
		             * on the axis.
		             *
		             * @sample {highcharts} highcharts/xaxis/labels-x/
		             *         Y axis labels placed on grid lines
		             */
		            x: 0,

		            /**
		             * The y position offset of the label relative to the tick position
		             * on the axis. The default makes it adapt to the font size on
		             * bottom axis.
		             *
		             * @sample {highcharts} highcharts/xaxis/labels-x/
		             *         Y axis labels placed on grid lines
		             *
		             * @type      {number}
		             * @apioption xAxis.labels.y
		             */

		            /**
		             * The Z index for the axis labels.
		             *
		             * @type      {number}
		             * @default   7
		             * @apioption xAxis.labels.zIndex
		             */



		            /**
		             * CSS styles for the label. Use `whiteSpace: 'nowrap'` to prevent
		             * wrapping of category labels. Use `textOverflow: 'none'` to
		             * prevent ellipsis (dots).
		             *
		             * In styled mode, the labels are styled with the
		             * `.highcharts-axis-labels` class.
		             *
		             * @sample {highcharts} highcharts/xaxis/labels-style/
		             *         Red X axis labels
		             *
		             * @type      {Highcharts.CSSObject}
		             * @default   {"color": "#666666", "cursor": "default", "fontSize": "11px"}
		             */
		            style: {
		                /**
		                 * @ignore
		                 */
		                color: '#666666',
		                /**
		                 * @ignore
		                 */
		                cursor: 'default',
		                /**
		                 * @ignore
		                 */
		                fontSize: '11px'
		            }


		        },

		        /**
		         * Index of another axis that this axis is linked to. When an axis is
		         * linked to a master axis, it will take the same extremes as
		         * the master, but as assigned by min or max or by setExtremes.
		         * It can be used to show additional info, or to ease reading the
		         * chart by duplicating the scales.
		         *
		         * @sample {highcharts} highcharts/xaxis/linkedto/
		         *         Different string formats of the same date
		         * @sample {highcharts} highcharts/yaxis/linkedto/
		         *         Y values on both sides
		         *
		         * @type      {number}
		         * @since     2.0.2
		         * @product   highcharts highstock gantt
		         * @apioption xAxis.linkedTo
		         */

		        /**
		         * The maximum value of the axis. If `null`, the max value is
		         * automatically calculated.
		         *
		         * If the [endOnTick](#yAxis.endOnTick) option is true, the `max` value
		         * might be rounded up.
		         *
		         * If a [tickAmount](#yAxis.tickAmount) is set, the axis may be extended
		         * beyond the set max in order to reach the given number of ticks. The
		         * same may happen in a chart with multiple axes, determined by [chart.
		         * alignTicks](#chart), where a `tickAmount` is applied internally.
		         *
		         * @sample {highcharts} highcharts/yaxis/max-200/
		         *         Y axis max of 200
		         * @sample {highcharts} highcharts/yaxis/max-logarithmic/
		         *         Y axis max on logarithmic axis
		         * @sample {highstock} stock/xaxis/min-max/
		         *         Fixed min and max on X axis
		         * @sample {highmaps} maps/axis/min-max/
		         *         Pre-zoomed to a specific area
		         *
		         * @type      {number}
		         * @apioption xAxis.max
		         */

		        /**
		         * Padding of the max value relative to the length of the axis. A
		         * padding of 0.05 will make a 100px axis 5px longer. This is useful
		         * when you don't want the highest data value to appear on the edge
		         * of the plot area. When the axis' `max` option is set or a max extreme
		         * is set using `axis.setExtremes()`, the maxPadding will be ignored.
		         *
		         * @sample {highcharts} highcharts/yaxis/maxpadding/
		         *         Max padding of 0.25 on y axis
		         * @sample {highstock} stock/xaxis/minpadding-maxpadding/
		         *         Greater min- and maxPadding
		         * @sample {highmaps} maps/chart/plotbackgroundcolor-gradient/
		         *         Add some padding
		         *
		         * @default   {highcharts} 0.01
		         * @default   {highstock|highmaps} 0
		         * @since     1.2.0
		         */
		        maxPadding: 0.01,

		        /**
		         * Deprecated. Use `minRange` instead.
		         *
		         * @deprecated
		         * @type      {number}
		         * @product   highcharts highstock
		         * @apioption xAxis.maxZoom
		         */

		        /**
		         * The minimum value of the axis. If `null` the min value is
		         * automatically calculated.
		         *
		         * If the [startOnTick](#yAxis.startOnTick) option is true (default),
		         * the `min` value might be rounded down.
		         *
		         * The automatically calculated minimum value is also affected by
		         * [floor](#yAxis.floor), [softMin](#yAxis.softMin),
		         * [minPadding](#yAxis.minPadding), [minRange](#yAxis.minRange)
		         * as well as [series.threshold](#plotOptions.series.threshold)
		         * and [series.softThreshold](#plotOptions.series.softThreshold).
		         *
		         * @sample {highcharts} highcharts/yaxis/min-startontick-false/
		         *         -50 with startOnTick to false
		         * @sample {highcharts} highcharts/yaxis/min-startontick-true/
		         *         -50 with startOnTick true by default
		         * @sample {highstock} stock/xaxis/min-max/
		         *         Set min and max on X axis
		         * @sample {highmaps} maps/axis/min-max/
		         *         Pre-zoomed to a specific area
		         *
		         * @type      {number}
		         * @apioption xAxis.min
		         */

		        /**
		         * The dash or dot style of the minor grid lines. For possible values,
		         * see [this demonstration](https://jsfiddle.net/gh/get/library/pure/
		         * highcharts/highcharts/tree/master/samples/highcharts/plotoptions/
		         * series-dashstyle-all/).
		         *
		         * @sample {highcharts} highcharts/yaxis/minorgridlinedashstyle/
		         *         Long dashes on minor grid lines
		         * @sample {highstock} stock/xaxis/minorgridlinedashstyle/
		         *         Long dashes on minor grid lines
		         *
		         * @type       {string}
		         * @default    Solid
		         * @since      1.2
		         * @validvalue ["Solid", "ShortDash", "ShortDot", "ShortDashDot",
		         *             "ShortDashDotDot", "Dot", "Dash" ,"LongDash",
		         *             "DashDot", "LongDashDot", "LongDashDotDot"]
		         * @apioption  xAxis.minorGridLineDashStyle
		         */

		        /**
		         * Specific tick interval in axis units for the minor ticks. On a linear
		         * axis, if `"auto"`, the minor tick interval is calculated as a fifth
		         * of the tickInterval. If `null` or `undefined`, minor ticks are not
		         * shown.
		         *
		         * On logarithmic axes, the unit is the power of the value. For example,
		         * setting the minorTickInterval to 1 puts one tick on each of 0.1, 1,
		         * 10, 100 etc. Setting the minorTickInterval to 0.1 produces 9 ticks
		         * between 1 and 10, 10 and 100 etc.
		         *
		         * If user settings dictate minor ticks to become too dense, they don't
		         * make sense, and will be ignored to prevent performance problems.
		         *
		         * @sample {highcharts} highcharts/yaxis/minortickinterval-null/
		         *         Null by default
		         * @sample {highcharts} highcharts/yaxis/minortickinterval-5/
		         *         5 units
		         * @sample {highcharts} highcharts/yaxis/minortickinterval-log-auto/
		         *         "auto"
		         * @sample {highcharts} highcharts/yaxis/minortickinterval-log/
		         *         0.1
		         * @sample {highstock} stock/demo/basic-line/
		         *         Null by default
		         * @sample {highstock} stock/xaxis/minortickinterval-auto/
		         *         "auto"
		         *
		         * @type      {number|string|null}
		         * @apioption xAxis.minorTickInterval
		         */

		        /**
		         * The pixel length of the minor tick marks.
		         *
		         * @sample {highcharts} highcharts/yaxis/minorticklength/
		         *         10px on Y axis
		         * @sample {highstock} stock/xaxis/minorticks/
		         *         10px on Y axis
		         */
		        minorTickLength: 2,

		        /**
		         * The position of the minor tick marks relative to the axis line.
		         *  Can be one of `inside` and `outside`.
		         *
		         * @sample {highcharts} highcharts/yaxis/minortickposition-outside/
		         *         Outside by default
		         * @sample {highcharts} highcharts/yaxis/minortickposition-inside/
		         *         Inside
		         * @sample {highstock} stock/xaxis/minorticks/
		         *         Inside
		         *
		         * @validvalue ["inside", "outside"]
		         */
		        minorTickPosition: 'outside',

		        /**
		         * Enable or disable minor ticks. Unless
		         * [minorTickInterval](#xAxis.minorTickInterval) is set, the tick
		         * interval is calculated as a fifth of the `tickInterval`.
		         *
		         * On a logarithmic axis, minor ticks are laid out based on a best
		         * guess, attempting to enter approximately 5 minor ticks between
		         * each major tick.
		         *
		         * Prior to v6.0.0, ticks were unabled in auto layout by setting
		         * `minorTickInterval` to `"auto"`.
		         *
		         * @productdesc {highcharts}
		         * On axes using [categories](#xAxis.categories), minor ticks are not
		         * supported.
		         *
		         * @sample {highcharts} highcharts/yaxis/minorticks-true/
		         *         Enabled on linear Y axis
		         *
		         * @type      {boolean}
		         * @default   false
		         * @since     6.0.0
		         * @apioption xAxis.minorTicks
		         */

		        /**
		         * The pixel width of the minor tick mark.
		         *
		         * @sample {highcharts} highcharts/yaxis/minortickwidth/
		         *         3px width
		         * @sample {highstock} stock/xaxis/minorticks/
		         *         1px width
		         *
		         * @type      {number}
		         * @default   0
		         * @apioption xAxis.minorTickWidth
		         */

		        /**
		         * Padding of the min value relative to the length of the axis. A
		         * padding of 0.05 will make a 100px axis 5px longer. This is useful
		         * when you don't want the lowest data value to appear on the edge
		         * of the plot area. When the axis' `min` option is set or a min extreme
		         * is set using `axis.setExtremes()`, the minPadding will be ignored.
		         *
		         * @sample {highcharts} highcharts/yaxis/minpadding/
		         *         Min padding of 0.2
		         * @sample {highstock} stock/xaxis/minpadding-maxpadding/
		         *         Greater min- and maxPadding
		         * @sample {highmaps} maps/chart/plotbackgroundcolor-gradient/
		         *         Add some padding
		         *
		         * @default    {highcharts} 0.01
		         * @default    {highstock|highmaps} 0
		         * @since      1.2.0
		         * @product    highcharts highstock gantt
		         */
		        minPadding: 0.01,

		        /**
		         * The minimum range to display on this axis. The entire axis will not
		         * be allowed to span over a smaller interval than this. For example,
		         * for a datetime axis the main unit is milliseconds. If minRange is
		         * set to 3600000, you can't zoom in more than to one hour.
		         *
		         * The default minRange for the x axis is five times the smallest
		         * interval between any of the data points.
		         *
		         * On a logarithmic axis, the unit for the minimum range is the power.
		         * So a minRange of 1 means that the axis can be zoomed to 10-100,
		         * 100-1000, 1000-10000 etc.
		         *
		         * Note that the `minPadding`, `maxPadding`, `startOnTick` and
		         * `endOnTick` settings also affect how the extremes of the axis
		         * are computed.
		         *
		         * @sample {highcharts} highcharts/xaxis/minrange/
		         *         Minimum range of 5
		         * @sample {highstock} stock/xaxis/minrange/
		         *         Max zoom of 6 months overrides user selections
		         * @sample {highmaps} maps/axis/minrange/
		         *         Minimum range of 1000
		         *
		         * @type      {number}
		         * @apioption xAxis.minRange
		         */

		        /**
		         * The minimum tick interval allowed in axis values. For example on
		         * zooming in on an axis with daily data, this can be used to prevent
		         * the axis from showing hours. Defaults to the closest distance between
		         * two points on the axis.
		         *
		         * @type      {number}
		         * @since     2.3.0
		         * @apioption xAxis.minTickInterval
		         */

		        /**
		         * The distance in pixels from the plot area to the axis line.
		         * A positive offset moves the axis with it's line, labels and ticks
		         * away from the plot area. This is typically used when two or more
		         * axes are displayed on the same side of the plot. With multiple
		         * axes the offset is dynamically adjusted to avoid collision, this
		         * can be overridden by setting offset explicitly.
		         *
		         * @sample    {highcharts} highcharts/yaxis/offset/
		         *            Y axis offset of 70
		         * @sample    {highcharts} highcharts/yaxis/offset-centered/
		         *            Axes positioned in the center of the plot
		         * @sample    {highstock} stock/xaxis/offset/
		         *            Y axis offset by 70 px
		         *
		         * @type      {number}
		         * @default   0
		         * @apioption xAxis.offset
		         */

		        /**
		         * Whether to display the axis on the opposite side of the normal. The
		         * normal is on the left side for vertical axes and bottom for
		         * horizontal, so the opposite sides will be right and top respectively.
		         * This is typically used with dual or multiple axes.
		         *
		         * @sample {highcharts} highcharts/yaxis/opposite/
		         *         Secondary Y axis opposite
		         * @sample {highstock} stock/xaxis/opposite/
		         *         Y axis on left side
		         *
		         * @type      {boolean}
		         * @default   false
		         * @apioption xAxis.opposite
		         */

		        /**
		         * In an ordinal axis, the points are equally spaced in the chart
		         * regardless of the actual time or x distance between them. This means
		         * that missing data periods (e.g. nights or weekends for a stock chart)
		         * will not take up space in the chart.
		         * Having `ordinal: false` will show any gaps created by the `gapSize`
		         * setting proportionate to their duration.
		         *
		         * In stock charts the X axis is ordinal by default, unless
		         * the boost module is used and at least one of the series' data length
		         * exceeds the [boostThreshold](#series.line.boostThreshold).
		         *
		         * @sample {highstock} stock/xaxis/ordinal-true/
		         *         True by default
		         * @sample {highstock} stock/xaxis/ordinal-false/
		         *         False
		         *
		         * @type      {boolean}
		         * @default   true
		         * @since     1.1
		         * @product   highstock
		         * @apioption xAxis.ordinal
		         */

		        /**
		         * Additional range on the right side of the xAxis. Works similar to
		         * `xAxis.maxPadding`, but value is set in milliseconds. Can be set for
		         * both main `xAxis` and the navigator's `xAxis`.
		         *
		         * @sample {highstock} stock/xaxis/overscroll/
		         *         One minute overscroll with live data
		         *
		         * @type      {number}
		         * @default   0
		         * @since     6.0.0
		         * @product   highstock
		         * @apioption xAxis.overscroll
		         */

		        /**
		         * Refers to the index in the [panes](#panes) array. Used for circular
		         * gauges and polar charts. When the option is not set then first pane
		         * will be used.
		         *
		         * @sample highcharts/demo/gauge-vu-meter
		         *         Two gauges with different center
		         *
		         * @type      {number}
		         * @product   highcharts
		         * @apioption xAxis.pane
		         */


		        /**
		         * The zoomed range to display when only defining one or none of `min`
		         * or `max`. For example, to show the latest month, a range of one month
		         * can be set.
		         *
		         * @sample {highstock} stock/xaxis/range/
		         *         Setting a zoomed range when the rangeSelector is disabled
		         *
		         * @type      {number}
		         * @product   highstock
		         * @apioption xAxis.range
		         */

		        /**
		         * Whether to reverse the axis so that the highest number is closest
		         * to the origin. If the chart is inverted, the x axis is reversed by
		         * default.
		         *
		         * @sample {highcharts} highcharts/yaxis/reversed/
		         *         Reversed Y axis
		         * @sample {highstock} stock/xaxis/reversed/
		         *         Reversed Y axis
		         *
		         * @type      {boolean}
		         * @default   false
		         * @apioption xAxis.reversed
		         */
		        // reversed: false,

		        /**
		         * This option determines how stacks should be ordered within a group.
		         * For example reversed xAxis also reverses stacks, so first series
		         * comes last in a group. To keep order like for non-reversed xAxis
		         * enable this option.
		         *
		         * @sample {highcharts} highcharts/xaxis/reversedstacks/
		         *         Reversed stacks comparison
		         * @sample {highstock} highcharts/xaxis/reversedstacks/
		         *         Reversed stacks comparison
		         *
		         * @type      {boolean}
		         * @default   false
		         * @since     6.1.1
		         * @product   highcharts highstock
		         * @apioption xAxis.reversedStacks
		         */

		        /**
		         * An optional scrollbar to display on the X axis in response to
		         * limiting the minimum and maximum of the axis values.
		         *
		         * In styled mode, all the presentational options for the scrollbar
		         * are replaced by the classes `.highcharts-scrollbar-thumb`,
		         * `.highcharts-scrollbar-arrow`, `.highcharts-scrollbar-button`,
		         * `.highcharts-scrollbar-rifles` and `.highcharts-scrollbar-track`.
		         *
		         * @sample {highstock} stock/yaxis/heatmap-scrollbars/
		         *         Heatmap with both scrollbars
		         *
		         * @type      {*}
		         * @extends   scrollbar
		         * @since     4.2.6
		         * @product   highstock
		         * @apioption xAxis.scrollbar
		         */

		        /**
		         * Whether to show the axis line and title when the axis has no data.
		         *
		         * @sample {highcharts} highcharts/yaxis/showempty/
		         *         When clicking the legend to hide series, one axis preserves
		         *         line and title, the other doesn't
		         * @sample {highstock} highcharts/yaxis/showempty/
		         *         When clicking the legend to hide series, one axis preserves
		         *         line and title, the other doesn't
		         *
		         * @type      {boolean}
		         * @default   true
		         * @since     1.1
		         * @apioption xAxis.showEmpty
		         */

		        /**
		         * Whether to show the first tick label.
		         *
		         * @sample {highcharts} highcharts/xaxis/showfirstlabel-false/
		         *         Set to false on X axis
		         * @sample {highstock} stock/xaxis/showfirstlabel/
		         *         Labels below plot lines on Y axis
		         *
		         * @type      {boolean}
		         * @default   true
		         * @apioption xAxis.showFirstLabel
		         */

		        /**
		         * Whether to show the last tick label. Defaults to `true` on cartesian
		         * charts, and `false` on polar charts.
		         *
		         * @sample {highcharts} highcharts/xaxis/showlastlabel-true/
		         *         Set to true on X axis
		         * @sample {highstock} stock/xaxis/showfirstlabel/
		         *         Labels below plot lines on Y axis
		         *
		         * @type      {boolean}
		         * @default   true
		         * @product   highcharts highstock gantt
		         * @apioption xAxis.showLastLabel
		         */

		        /**
		         * A soft maximum for the axis. If the series data maximum is less than
		         * this, the axis will stay at this maximum, but if the series data
		         * maximum is higher, the axis will flex to show all data.
		         *
		         * @sample highcharts/yaxis/softmin-softmax/
		         *         Soft min and max
		         *
		         * @type      {number}
		         * @since     5.0.1
		         * @product   highcharts highstock gantt
		         * @apioption xAxis.softMax
		         */

		        /**
		         * A soft minimum for the axis. If the series data minimum is greater
		         * than this, the axis will stay at this minimum, but if the series
		         * data minimum is lower, the axis will flex to show all data.
		         *
		         * @sample highcharts/yaxis/softmin-softmax/
		         *         Soft min and max
		         *
		         * @type      {number}
		         * @since     5.0.1
		         * @product   highcharts highstock gantt
		         * @apioption xAxis.softMin
		         */

		        /**
		         * For datetime axes, this decides where to put the tick between weeks.
		         *  0 = Sunday, 1 = Monday.
		         *
		         * @sample {highcharts} highcharts/xaxis/startofweek-monday/
		         *         Monday by default
		         * @sample {highcharts} highcharts/xaxis/startofweek-sunday/
		         *         Sunday
		         * @sample {highstock} stock/xaxis/startofweek-1
		         *         Monday by default
		         * @sample {highstock} stock/xaxis/startofweek-0
		         *         Sunday
		         *
		         * @product highcharts highstock gantt
		         */
		        startOfWeek: 1,

		        /**
		         * Whether to force the axis to start on a tick. Use this option with
		         * the `minPadding` option to control the axis start.
		         *
		         * @productdesc {highstock}
		         * In Highstock, `startOnTick` is always false when the navigator is
		         * enabled, to prevent jumpy scrolling.
		         *
		         * @sample {highcharts} highcharts/xaxis/startontick-false/
		         *         False by default
		         * @sample {highcharts} highcharts/xaxis/startontick-true/
		         *         True
		         * @sample {highstock} stock/xaxis/endontick/
		         *         False for Y axis
		         *
		         * @since 1.2.0
		         */
		        startOnTick: false,


		        /**
		         * The amount of ticks to draw on the axis. This opens up for aligning
		         * the ticks of multiple charts or panes within a chart. This option
		         * overrides the `tickPixelInterval` option.
		         *
		         * This option only has an effect on linear axes. Datetime, logarithmic
		         * or category axes are not affected.
		         *
		         * @sample {highcharts} highcharts/yaxis/tickamount/
		         *         8 ticks on Y axis
		         * @sample {highstock} highcharts/yaxis/tickamount/
		         *         8 ticks on Y axis
		         *
		         * @type      {number}
		         * @since     4.1.0
		         * @product   highcharts highstock gantt
		         * @apioption xAxis.tickAmount
		         */

		        /**
		         * The interval of the tick marks in axis units. When `undefined`, the
		         * tick interval is computed to approximately follow the
		         * [tickPixelInterval](#xAxis.tickPixelInterval) on linear and datetime
		         * axes. On categorized axes, a `undefined` tickInterval will default to
		         * 1, one category. Note that datetime axes are based on milliseconds,
		         * so for example an interval of one day is expressed as
		         * `24 * 3600 * 1000`.
		         *
		         * On logarithmic axes, the tickInterval is based on powers, so a
		         * tickInterval of 1 means one tick on each of 0.1, 1, 10, 100 etc. A
		         * tickInterval of 2 means a tick of 0.1, 10, 1000 etc. A tickInterval
		         * of 0.2 puts a tick on 0.1, 0.2, 0.4, 0.6, 0.8, 1, 2, 4, 6, 8, 10, 20,
		         * 40 etc.
		         *
		         *
		         * If the tickInterval is too dense for labels to be drawn, Highcharts
		         * may remove ticks.
		         *
		         * If the chart has multiple axes, the [alignTicks](#chart.alignTicks)
		         * option may interfere with the `tickInterval` setting.
		         *
		         * @see [tickPixelInterval](#xAxis.tickPixelInterval)
		         * @see [tickPositions](#xAxis.tickPositions)
		         * @see [tickPositioner](#xAxis.tickPositioner)
		         *
		         * @sample {highcharts} highcharts/xaxis/tickinterval-5/
		         *         Tick interval of 5 on a linear axis
		         * @sample {highstock} stock/xaxis/tickinterval/
		         *         Tick interval of 0.01 on Y axis
		         *
		         * @type      {number}
		         * @apioption xAxis.tickInterval
		         */

		        /**
		         * The pixel length of the main tick marks.
		         *
		         * @sample {highcharts} highcharts/xaxis/ticklength/
		         *         20 px tick length on the X axis
		         * @sample {highstock} stock/xaxis/ticks/
		         *         Formatted ticks on X axis
		         */
		        tickLength: 10,

		        /**
		         * If tickInterval is `null` this option sets the approximate pixel
		         * interval of the tick marks. Not applicable to categorized axis.
		         *
		         * The tick interval is also influenced by the [minTickInterval](
		         * #xAxis.minTickInterval) option, that, by default prevents ticks from
		         * being denser than the data points.
		         *
		         * @see [tickInterval](#xAxis.tickInterval)
		         * @see [tickPositioner](#xAxis.tickPositioner)
		         * @see [tickPositions](#xAxis.tickPositions)
		         *
		         * @sample {highcharts} highcharts/xaxis/tickpixelinterval-50/
		         *         50 px on X axis
		         * @sample {highstock} stock/xaxis/tickpixelinterval/
		         *         200 px on X axis
		         */
		        tickPixelInterval: 100,

		        /**
		         * For categorized axes only. If `on` the tick mark is placed in the
		         * center of the category, if `between` the tick mark is placed between
		         * categories. The default is `between` if the `tickInterval` is 1,
		         *  else `on`.
		         *
		         * @sample {highcharts} highcharts/xaxis/tickmarkplacement-between/
		         *         "between" by default
		         * @sample {highcharts} highcharts/xaxis/tickmarkplacement-on/
		         *         "on"
		         *
		         * @product    highcharts gantt
		         * @validvalue [null, "on", "between"]
		         */
		        tickmarkPlacement: 'between',

		        /**
		         * The position of the major tick marks relative to the axis line.
		         * Can be one of `inside` and `outside`.
		         *
		         * @sample {highcharts} highcharts/xaxis/tickposition-outside/
		         *         "outside" by default
		         * @sample {highcharts} highcharts/xaxis/tickposition-inside/
		         *         "inside"
		         * @sample {highstock} stock/xaxis/ticks/
		         *         Formatted ticks on X axis
		         *
		         * @validvalue ["inside", "outside"]
		         */
		        tickPosition: 'outside',

		        /**
		         * A callback function returning array defining where the ticks are
		         * laid out on the axis. This overrides the default behaviour of
		         * [tickPixelInterval](#xAxis.tickPixelInterval) and [tickInterval](
		         * #xAxis.tickInterval). The automatic tick positions are accessible
		         * through `this.tickPositions` and can be modified by the callback.
		         *
		         * @see [tickPositions](#xAxis.tickPositions)
		         *
		         * @sample {highcharts} highcharts/xaxis/tickpositions-tickpositioner/
		         *         Demo of tickPositions and tickPositioner
		         * @sample {highstock} highcharts/xaxis/tickpositions-tickpositioner/
		         *         Demo of tickPositions and tickPositioner
		         *
		         * @type      {Function}
		         * @apioption xAxis.tickPositioner
		         */

		        /**
		         * An array defining where the ticks are laid out on the axis. This
		         * overrides the default behaviour of [tickPixelInterval](
		         * #xAxis.tickPixelInterval) and [tickInterval](#xAxis.tickInterval).
		         *
		         * @see [tickPositioner](#xAxis.tickPositioner)
		         *
		         * @sample {highcharts} highcharts/xaxis/tickpositions-tickpositioner/
		         *         Demo of tickPositions and tickPositioner
		         * @sample {highstock} highcharts/xaxis/tickpositions-tickpositioner/
		         *         Demo of tickPositions and tickPositioner
		         *
		         * @type      {Array<number>}
		         * @apioption xAxis.tickPositions
		         */

		        /**
		         * The pixel width of the major tick marks.
		         *
		         * In styled mode, the stroke width is given in the `.highcharts-tick`
		         * class.
		         *
		         * @sample {highcharts} highcharts/xaxis/tickwidth/
		         *         10 px width
		         * @sample {highcharts} highcharts/css/axis-grid/
		         *         Styled mode
		         * @sample {highstock} stock/xaxis/ticks/
		         *         Formatted ticks on X axis
		         * @sample {highstock} highcharts/css/axis-grid/
		         *         Styled mode
		         *
		         * @type      {number}
		         * @default   {highcharts} 1
		         * @default   {highstock} 1
		         * @default   {highmaps} 0
		         * @apioption xAxis.tickWidth
		         */

		        /**
		         * The axis title, showing next to the axis line.
		         *
		         * @productdesc {highmaps}
		         * In Highmaps, the axis is hidden by default, but adding an axis title
		         * is still possible. X axis and Y axis titles will appear at the bottom
		         * and left by default.
		         */
		        title: {

		            /**
		             * Deprecated. Set the `text` to `null` to disable the title.
		             *
		             * @deprecated
		             * @type      {string}
		             * @default   middle
		             * @product   highcharts
		             * @apioption xAxis.title.enabled
		             */

		            /**
		             * The pixel distance between the axis labels or line and the title.
		             * Defaults to 0 for horizontal axes, 10 for vertical
		             *
		             * @sample {highcharts} highcharts/xaxis/title-margin/
		             *         Y axis title margin of 60
		             *
		             * @type      {number}
		             * @apioption xAxis.title.margin
		             */

		            /**
		             * The distance of the axis title from the axis line. By default,
		             * this distance is computed from the offset width of the labels,
		             * the labels' distance from the axis and the title's margin.
		             * However when the offset option is set, it overrides all this.
		             *
		             * @sample {highcharts} highcharts/yaxis/title-offset/
		             *         Place the axis title on top of the axis
		             * @sample {highstock} highcharts/yaxis/title-offset/
		             *         Place the axis title on top of the Y axis
		             *
		             * @type      {number}
		             * @since     2.2.0
		             * @apioption xAxis.title.offset
		             */

		            /**
		             * Whether to reserve space for the title when laying out the axis.
		             *
		             * @type      {boolean}
		             * @default   true
		             * @since     5.0.11
		             * @product   highcharts highstock gantt
		             * @apioption xAxis.title.reserveSpace
		             */

		            /**
		             * The rotation of the text in degrees. 0 is horizontal, 270 is
		             * vertical reading from bottom to top.
		             *
		             * @sample {highcharts} highcharts/yaxis/title-offset/
		             *         Horizontal
		             *
		             * @type      {number}
		             * @default   0
		             * @apioption xAxis.title.rotation
		             */

		            /**
		             * The actual text of the axis title. It can contain basic HTML text
		             * markup like <b>, <i> and spans with style.
		             *
		             * @sample {highcharts} highcharts/xaxis/title-text/
		             *         Custom HTML
		             * @sample {highstock} stock/xaxis/title-text/
		             *         Titles for both axes
		             *
		             * @type      {string}
		             * @apioption xAxis.title.text
		             */

		            /**
		             * Alignment of the text, can be `"left"`, `"right"` or `"center"`.
		             * Default alignment depends on the
		             * [title.align](xAxis.title.align):
		             *
		             * Horizontal axes:
		             * - for `align` = `"low"`, `textAlign` is set to `left`
		             * - for `align` = `"middle"`, `textAlign` is set to `center`
		             * - for `align` = `"high"`, `textAlign` is set to `right`
		             *
		             * Vertical axes:
		             * - for `align` = `"low"` and `opposite` = `true`, `textAlign` is
		             *   set to `right`
		             * - for `align` = `"low"` and `opposite` = `false`, `textAlign` is
		             *   set to `left`
		             * - for `align` = `"middle"`, `textAlign` is set to `center`
		             * - for `align` = `"high"` and `opposite` = `true` `textAlign` is
		             *   set to `left`
		             * - for `align` = `"high"` and `opposite` = `false` `textAlign` is
		             *   set to `right`
		             *
		             * @type      {string}
		             * @apioption xAxis.title.textAlign
		             */

		            /**
		             * Whether to [use HTML](https://www.highcharts.com/docs/
		             * chart-concepts/labels-and-string-formatting#html) to render the
		             * axis title.
		             *
		             * @type      {boolean}
		             * @default   false
		             * @product   highcharts highstock gantt
		             * @apioption xAxis.title.useHTML
		             */

		            /**
		             * Horizontal pixel offset of the title position.
		             *
		             * @type      {number}
		             * @default   0
		             * @since     4.1.6
		             * @product   highcharts highstock gantt
		             * @apioption xAxis.title.x
		             */

		            /**
		             * Vertical pixel offset of the title position.
		             *
		             * @type      {number}
		             * @product   highcharts highstock gantt
		             * @apioption xAxis.title.y
		             */

		            /**
		             * Alignment of the title relative to the axis values. Possible
		             * values are "low", "middle" or "high".
		             *
		             * @sample {highcharts} highcharts/xaxis/title-align-low/
		             *         "low"
		             * @sample {highcharts} highcharts/xaxis/title-align-center/
		             *         "middle" by default
		             * @sample {highcharts} highcharts/xaxis/title-align-high/
		             *         "high"
		             * @sample {highcharts} highcharts/yaxis/title-offset/
		             *         Place the Y axis title on top of the axis
		             * @sample {highstock} stock/xaxis/title-align/
		             *         Aligned to "high" value
		             *
		             * @validvalue ["low", "middle", "high"]
		             */
		            align: 'middle',



		            /**
		             * CSS styles for the title. If the title text is longer than the
		             * axis length, it will wrap to multiple lines by default. This can
		             * be customized by setting `textOverflow: 'ellipsis'`, by
		             * setting a specific `width` or by setting `whiteSpace: 'nowrap'`.
		             *
		             * In styled mode, the stroke width is given in the
		             * `.highcharts-axis-title` class.
		             *
		             * @sample {highcharts} highcharts/xaxis/title-style/
		             *         Red
		             * @sample {highcharts} highcharts/css/axis/
		             *         Styled mode
		             *
		             * @type    {Highcharts.CSSObject}
		             * @default {"color": "#666666"}
		             */
		            style: {
		                /**
		                 * @ignore
		                 */
		                color: '#666666'
		            }



		        },

		        /**
		         * The type of axis. Can be one of `linear`, `logarithmic`, `datetime`
		         * or `category`. In a datetime axis, the numbers are given in
		         * milliseconds, and tick marks are placed on appropriate values like
		         * full hours or days. In a category axis, the
		         * [point names](#series.line.data.name) of the chart's series are used
		         * for categories, if not a [categories](#xAxis.categories) array is
		         * defined.
		         *
		         * @sample {highcharts} highcharts/xaxis/type-linear/
		         *         Linear
		         * @sample {highcharts} highcharts/yaxis/type-log/
		         *         Logarithmic
		         * @sample {highcharts} highcharts/yaxis/type-log-minorgrid/
		         *         Logarithmic with minor grid lines
		         * @sample {highcharts} highcharts/xaxis/type-log-both/
		         *         Logarithmic on two axes
		         * @sample {highcharts} highcharts/yaxis/type-log-negative/
		         *         Logarithmic with extension to emulate negative values
		         *
		         * @product    highcharts gantt
		         * @validvalue ["linear", "logarithmic", "datetime", "category"]
		         */
		        type: 'linear',

		        /**
		         * The type of axis. Can be one of `linear`, `logarithmic`, `datetime`,
		         * `category` or `treegrid`. Defaults to `treegrid` for Gantt charts,
		         * `linear` for other chart types.
		         *
		         * In a datetime axis, the numbers are given in milliseconds, and tick
		         * marks are placed on appropriate values, like full hours or days. In a
		         * category or treegrid axis, the [point names](#series.line.data.name)
		         * of the chart's series are used for categories, if a
		         * [categories](#xAxis.categories) array is not defined.
		         *
		         * @sample {highcharts} highcharts/yaxis/type-log-minorgrid/
		         *         Logarithmic with minor grid lines
		         * @sample {highcharts} highcharts/yaxis/type-log-negative/
		         *         Logarithmic with extension to emulate negative values
		         *
		         * @product    highcharts gantt
		         * @validvalue ["linear", "logarithmic", "datetime", "category", "treegrid"]
		         * @default {highcharts} linear
		         * @default {gantt} treegrid
		         * @apioption yAxis.type
		         */

		        /**
		         * Applies only when the axis `type` is `category`. When `uniqueNames`
		         * is true, points are placed on the X axis according to their names.
		         * If the same point name is repeated in the same or another series,
		         * the point is placed on the same X position as other points of the
		         * same name. When `uniqueNames` is false, the points are laid out in
		         * increasing X positions regardless of their names, and the X axis
		         * category will take the name of the last point in each position.
		         *
		         * @sample {highcharts} highcharts/xaxis/uniquenames-true/
		         *         True by default
		         * @sample {highcharts} highcharts/xaxis/uniquenames-false/
		         *         False
		         *
		         * @type      {boolean}
		         * @default   true
		         * @since     4.2.7
		         * @product   highcharts gantt
		         * @apioption xAxis.uniqueNames
		         */

		        /**
		         * Datetime axis only. An array determining what time intervals the
		         * ticks are allowed to fall on. Each array item is an array where the
		         * first value is the time unit and the second value another array of
		         * allowed multiples. Defaults to:
		         *
		         * <pre>units: [[
		         *     'millisecond', // unit name
		         *     [1, 2, 5, 10, 20, 25, 50, 100, 200, 500] // allowed multiples
		         * ], [
		         *     'second',
		         *     [1, 2, 5, 10, 15, 30]
		         * ], [
		         *     'minute',
		         *     [1, 2, 5, 10, 15, 30]
		         * ], [
		         *     'hour',
		         *     [1, 2, 3, 4, 6, 8, 12]
		         * ], [
		         *     'day',
		         *     [1]
		         * ], [
		         *     'week',
		         *     [1]
		         * ], [
		         *     'month',
		         *     [1, 3, 6]
		         * ], [
		         *     'year',
		         *     null
		         * ]]</pre>
		         *
		         * @type      {Array<Array<string|Array<number>>>}
		         * @product   highcharts highstock gantt
		         * @apioption xAxis.units
		         */

		        /**
		         * Whether axis, including axis title, line, ticks and labels, should
		         * be visible.
		         *
		         * @type      {boolean}
		         * @default   true
		         * @since     4.1.9
		         * @product   highcharts highstock gantt
		         * @apioption xAxis.visible
		         */



		        /**
		         * Color of the minor, secondary grid lines.
		         *
		         * In styled mode, the stroke width is given in the
		         * `.highcharts-minor-grid-line` class.
		         *
		         * @sample {highcharts} highcharts/yaxis/minorgridlinecolor/
		         *         Bright grey lines from Y axis
		         * @sample {highcharts|highstock} highcharts/css/axis-grid/
		         *         Styled mode
		         * @sample {highstock} stock/xaxis/minorgridlinecolor/
		         *         Bright grey lines from Y axis
		         *
		         * @type    {Highcharts.ColorString}
		         * @default #f2f2f2
		         */
		        minorGridLineColor: '#f2f2f2',

		        /**
		         * Width of the minor, secondary grid lines.
		         *
		         * In styled mode, the stroke width is given in the
		         * `.highcharts-grid-line` class.
		         *
		         * @sample {highcharts} highcharts/yaxis/minorgridlinewidth/
		         *         2px lines from Y axis
		         * @sample {highcharts|highstock} highcharts/css/axis-grid/
		         *         Styled mode
		         * @sample {highstock} stock/xaxis/minorgridlinewidth/
		         *         2px lines from Y axis
		         */
		        minorGridLineWidth: 1,

		        /**
		         * Color for the minor tick marks.
		         *
		         * @sample {highcharts} highcharts/yaxis/minortickcolor/
		         *         Black tick marks on Y axis
		         * @sample {highstock} stock/xaxis/minorticks/
		         *         Black tick marks on Y axis
		         *
		         * @type    {Highcharts.ColorString}
		         * @default #999999
		         */
		        minorTickColor: '#999999',

		        /**
		         * The color of the line marking the axis itself.
		         *
		         * In styled mode, the line stroke is given in the
		         * `.highcharts-axis-line` or `.highcharts-xaxis-line` class.
		         *
		         * @productdesc {highmaps}
		         * In Highmaps, the axis line is hidden by default, because the axis is
		         * not visible by default.
		         *
		         * @sample {highcharts} highcharts/yaxis/linecolor/
		         *         A red line on Y axis
		         * @sample {highcharts|highstock} highcharts/css/axis/
		         *         Axes in styled mode
		         * @sample {highstock} stock/xaxis/linecolor/
		         *         A red line on X axis
		         *
		         * @type    {Highcharts.ColorString}
		         * @default #ccd6eb
		         */
		        lineColor: '#ccd6eb',

		        /**
		         * The width of the line marking the axis itself.
		         *
		         * In styled mode, the stroke width is given in the
		         * `.highcharts-axis-line` or `.highcharts-xaxis-line` class.
		         *
		         * @sample {highcharts} highcharts/yaxis/linecolor/
		         *         A 1px line on Y axis
		         * @sample {highcharts|highstock} highcharts/css/axis/
		         *         Axes in styled mode
		         * @sample {highstock} stock/xaxis/linewidth/
		         *         A 2px line on X axis
		         *
		         * @default {highcharts|highstock} 1
		         * @default {highmaps} 0
		         */
		        lineWidth: 1,

		        /**
		         * Color of the grid lines extending the ticks across the plot area.
		         *
		         * In styled mode, the stroke is given in the `.highcharts-grid-line`
		         * class.
		         *
		         * @productdesc {highmaps}
		         * In Highmaps, the grid lines are hidden by default.
		         *
		         * @sample {highcharts} highcharts/yaxis/gridlinecolor/
		         *         Green lines
		         * @sample {highcharts|highstock} highcharts/css/axis-grid/
		         *         Styled mode
		         * @sample {highstock} stock/xaxis/gridlinecolor/
		         *         Green lines
		         *
		         * @type    {Highcharts.ColorString}
		         * @default #e6e6e6
		         */
		        gridLineColor: '#e6e6e6',

		        // gridLineDashStyle: 'solid',

		        /**
		         * The width of the grid lines extending the ticks across the plot area.
		         *
		         * In styled mode, the stroke width is given in the
		         * `.highcharts-grid-line` class.
		         *
		         * @sample {highcharts} highcharts/yaxis/gridlinewidth/
		         *         2px lines
		         * @sample {highcharts|highstock} highcharts/css/axis-grid/
		         *         Styled mode
		         * @sample {highstock} stock/xaxis/gridlinewidth/
		         *         2px lines
		         *
		         * @type      {number}
		         * @default   0
		         * @apioption xAxis.gridLineWidth
		         */
		        // gridLineWidth: 0,

		        /**
		         * Color for the main tick marks.
		         *
		         * In styled mode, the stroke is given in the `.highcharts-tick`
		         * class.
		         *
		         * @sample {highcharts} highcharts/xaxis/tickcolor/
		         *         Red ticks on X axis
		         * @sample {highcharts|highstock} highcharts/css/axis-grid/
		         *         Styled mode
		         * @sample {highstock} stock/xaxis/ticks/
		         *         Formatted ticks on X axis
		         *
		         * @type    {Highcharts.ColorString}
		         * @default #ccd6eb
		         */
		        tickColor: '#ccd6eb'

		        // tickWidth: 1



		    },

		    /**
		     * The Y axis or value axis. Normally this is the vertical axis,
		     * though if the chart is inverted this is the horizontal axis.
		     * In case of multiple axes, the yAxis node is an array of
		     * configuration objects.
		     *
		     * See [the Axis object](/class-reference/Highcharts.Axis) for programmatic
		     * access to the axis.
		     *
		     * @extends      xAxis
		     * @excluding    ordinal,overscroll,currentDateIndicator
		     * @optionparent yAxis
		     */
		    defaultYAxisOptions: {

		        /**
		         * In a polar chart, this is the angle of the Y axis in degrees, where
		         * 0 is up and 90 is right. The angle determines the position of the
		         * axis line and the labels, though the coordinate system is unaffected.
		         *
		         * @sample {highcharts} highcharts/yaxis/angle/
		         *         Dual axis polar chart
		         *
		         * @type      {number}
		         * @default   0
		         * @since     4.2.7
		         * @product   highcharts
		         * @apioption yAxis.angle
		         */

		        /**
		         * Polar charts only. Whether the grid lines should draw as a polygon
		         * with straight lines between categories, or as circles. Can be either
		         * `circle` or `polygon`.
		         *
		         * @sample {highcharts} highcharts/demo/polar-spider/
		         *         Polygon grid lines
		         * @sample {highcharts} highcharts/yaxis/gridlineinterpolation/
		         *         Circle and polygon
		         *
		         * @type       {string}
		         * @product    highcharts
		         * @validvalue ["circle", "polygon"]
		         * @apioption  yAxis.gridLineInterpolation
		         */

		        /**
		         * The height of the Y axis. If it's a number, it is interpreted as
		         * pixels.
		         *
		         * Since Highstock 2: If it's a percentage string, it is interpreted
		         * as percentages of the total plot height.
		         *
		         * @see [yAxis.top](#yAxis.top)
		         *
		         * @sample {highstock} stock/demo/candlestick-and-volume/
		         *         Percentage height panes
		         *
		         * @type      {number|string}
		         * @product   highstock
		         * @apioption yAxis.height
		         */

		        /**
		         * Solid gauge only. Unless [stops](#yAxis.stops) are set, the color
		         * to represent the maximum value of the Y axis.
		         *
		         * @sample {highcharts} highcharts/yaxis/mincolor-maxcolor/
		         *         Min and max colors
		         *
		         * @type      {Highcharts.ColorString}
		         * @default   #003399
		         * @since     4.0
		         * @product   highcharts
		         * @apioption yAxis.maxColor
		         */

		        /**
		         * Solid gauge only. Unless [stops](#yAxis.stops) are set, the color
		         * to represent the minimum value of the Y axis.
		         *
		         * @sample {highcharts} highcharts/yaxis/mincolor-maxcolor/
		         *         Min and max color
		         *
		         * @type      {Highcharts.ColorString}
		         * @default   #e6ebf5
		         * @since     4.0
		         * @product   highcharts
		         * @apioption yAxis.minColor
		         */

		        /**
		         * Whether to reverse the axis so that the highest number is closest
		         * to the origin.
		         *
		         * @sample {highcharts} highcharts/yaxis/reversed/
		         *         Reversed Y axis
		         * @sample {highstock} stock/xaxis/reversed/
		         *         Reversed Y axis
		         *
		         * @type      {boolean}
		         * @default   {highcharts} false
		         * @default   {highstock} false
		         * @default   {highmaps} true
		         * @default   {gantt} true
		         * @apioption yAxis.reversed
		         */

		        /**
		         * If `true`, the first series in a stack will be drawn on top in a
		         * positive, non-reversed Y axis. If `false`, the first series is in
		         * the base of the stack.
		         *
		         * @sample {highcharts} highcharts/yaxis/reversedstacks-false/
		         *         Non-reversed stacks
		         * @sample {highstock} highcharts/yaxis/reversedstacks-false/
		         *         Non-reversed stacks
		         *
		         * @type      {boolean}
		         * @default   true
		         * @since     3.0.10
		         * @product   highcharts highstock
		         * @apioption yAxis.reversedStacks
		         */

		        /**
		         * Solid gauge series only. Color stops for the solid gauge. Use this
		         * in cases where a linear gradient between a `minColor` and `maxColor`
		         * is not sufficient. The stops is an array of tuples, where the first
		         * item is a float between 0 and 1 assigning the relative position in
		         * the gradient, and the second item is the color.
		         *
		         * For solid gauges, the Y axis also inherits the concept of [data classes](http://api.
		         * highcharts.com/highmaps#colorAxis.dataClasses) from the Highmaps
		         * color axis.
		         *
		         * @see [minColor](#yAxis.minColor)
		         * @see [maxColor](#yAxis.maxColor)
		         *
		         * @sample {highcharts} highcharts/demo/gauge-solid/
		         *         True by default
		         *
		         * @type      {Array<Array<number, Highcharts.ColorString>>}
		         * @since     4.0
		         * @product   highcharts
		         * @apioption yAxis.stops
		         */

		        /**
		         * The pixel width of the major tick marks.
		         *
		         * @sample {highcharts} highcharts/xaxis/tickwidth/ 10 px width
		         * @sample {highstock} stock/xaxis/ticks/ Formatted ticks on X axis
		         *
		         * @type      {number}
		         * @default   0
		         * @product   highcharts highstock gantt
		         * @apioption yAxis.tickWidth
		         */

		        /**
		         * Angular gauges and solid gauges only. The label's pixel distance
		         * from the perimeter of the plot area.
		         *
		         * @type      {number}
		         * @default   -25
		         * @product   highcharts
		         * @apioption yAxis.labels.distance
		         */

		        /**
		         * The y position offset of the label relative to the tick position
		         * on the axis.
		         *
		         * @sample {highcharts} highcharts/xaxis/labels-x/
		         *         Y axis labels placed on grid lines
		         *
		         * @type      {number}
		         * @default   {highcharts} 3
		         * @default   {highstock} -2
		         * @default   {highmaps} 3
		         * @apioption yAxis.labels.y
		         */

		        /**
		         * @productdesc {highstock}
		         * In Highstock, `endOnTick` is always false when the navigator is
		         * enabled, to prevent jumpy scrolling.
		         */
		        endOnTick: true,

		        /**
		         * Padding of the max value relative to the length of the axis. A
		         * padding of 0.05 will make a 100px axis 5px longer. This is useful
		         * when you don't want the highest data value to appear on the edge
		         * of the plot area. When the axis' `max` option is set or a max extreme
		         * is set using `axis.setExtremes()`, the maxPadding will be ignored.
		         *
		         * @sample {highcharts} highcharts/yaxis/maxpadding-02/
		         *         Max padding of 0.2
		         * @sample {highstock} stock/xaxis/minpadding-maxpadding/
		         *         Greater min- and maxPadding
		         *
		         * @since   1.2.0
		         * @product highcharts highstock gantt
		         */
		        maxPadding: 0.05,

		        /**
		         * Padding of the min value relative to the length of the axis. A
		         * padding of 0.05 will make a 100px axis 5px longer. This is useful
		         * when you don't want the lowest data value to appear on the edge
		         * of the plot area. When the axis' `min` option is set or a max extreme
		         * is set using `axis.setExtremes()`, the maxPadding will be ignored.
		         *
		         * @sample {highcharts} highcharts/yaxis/minpadding/
		         *         Min padding of 0.2
		         * @sample {highstock} stock/xaxis/minpadding-maxpadding/
		         *         Greater min- and maxPadding
		         *
		         * @since   1.2.0
		         * @product highcharts highstock gantt
		         */
		        minPadding: 0.05,

		        /**
		         * @productdesc {highstock}
		         * In Highstock 1.x, the Y axis was placed on the left side by default.
		         *
		         * @sample {highcharts} highcharts/yaxis/opposite/
		         *         Secondary Y axis opposite
		         * @sample {highstock} stock/xaxis/opposite/
		         *         Y axis on left side
		         *
		         * @type      {boolean}
		         * @default   {highstock} true
		         * @default   {highcharts} false
		         * @product   highstock highcharts gantt
		         * @apioption yAxis.opposite
		         */

		        /**
		         * @see [tickInterval](#xAxis.tickInterval)
		         * @see [tickPositioner](#xAxis.tickPositioner)
		         * @see [tickPositions](#xAxis.tickPositions)
		         */
		        tickPixelInterval: 72,

		        showLastLabel: true,

		        /**
		         * @extends    xAxis.labels
		         */
		        labels: {
		            /**
		             * What part of the string the given position is anchored to. Can
		             * be one of `"left"`, `"center"` or `"right"`. The exact position
		             * also depends on the `labels.x` setting.
		             *
		             * Angular gauges and solid gauges defaults to `center`.
		             *
		             * @sample {highcharts} highcharts/yaxis/labels-align-left/
		             *         Left
		             *
		             * @type       {string}
		             * @default    {highcharts|highmaps} right
		             * @default    {highstock} left
		             * @validvalue ["left", "center", "right"]
		             * @apioption  yAxis.labels.align
		             */

		            /**
		             * The x position offset of the label relative to the tick position
		             * on the axis. Defaults to -15 for left axis, 15 for right axis.
		             *
		             * @sample {highcharts} highcharts/xaxis/labels-x/
		             *         Y axis labels placed on grid lines
		             */
		            x: -8
		        },

		        /**
		         * @productdesc {highmaps}
		         * In Highmaps, the axis line is hidden by default, because the axis is
		         * not visible by default.
		         *
		         * @type      {Highcharts.ColorString}
		         * @apioption yAxis.lineColor
		         */

		        /**
		         * @sample {highcharts} highcharts/yaxis/max-200/
		         *         Y axis max of 200
		         * @sample {highcharts} highcharts/yaxis/max-logarithmic/
		         *         Y axis max on logarithmic axis
		         * @sample {highstock} stock/yaxis/min-max/
		         *         Fixed min and max on Y axis
		         * @sample {highmaps} maps/axis/min-max/
		         *         Pre-zoomed to a specific area
		         *
		         * @type      {number}
		         * @apioption yAxis.max
		         */

		        /**
		         * @sample {highcharts} highcharts/yaxis/min-startontick-false/
		         *         -50 with startOnTick to false
		         * @sample {highcharts} highcharts/yaxis/min-startontick-true/
		         *         -50 with startOnTick true by default
		         * @sample {highstock} stock/yaxis/min-max/
		         *         Fixed min and max on Y axis
		         * @sample {highmaps} maps/axis/min-max/
		         *         Pre-zoomed to a specific area
		         *
		         * @type      {number}
		         * @apioption yAxis.min
		         */

		        /**
		         * An optional scrollbar to display on the Y axis in response to
		         * limiting the minimum an maximum of the axis values.
		         *
		         * In styled mode, all the presentational options for the scrollbar
		         * are replaced by the classes `.highcharts-scrollbar-thumb`,
		         * `.highcharts-scrollbar-arrow`, `.highcharts-scrollbar-button`,
		         * `.highcharts-scrollbar-rifles` and `.highcharts-scrollbar-track`.
		         *
		         * @sample {highstock} stock/yaxis/scrollbar/
		         *         Scrollbar on the Y axis
		         *
		         * @extends   scrollbar
		         * @excluding height
		         * @since     4.2.6
		         * @product   highstock
		         * @apioption yAxis.scrollbar
		         */

		        /**
		         * Enable the scrollbar on the Y axis.
		         *
		         * @sample {highstock} stock/yaxis/scrollbar/
		         *         Enabled on Y axis
		         *
		         * @type      {boolean}
		         * @default   false
		         * @since     4.2.6
		         * @product   highstock
		         * @apioption yAxis.scrollbar.enabled
		         */

		        /**
		         * Pixel margin between the scrollbar and the axis elements.
		         *
		         * @type      {number}
		         * @default   10
		         * @since     4.2.6
		         * @product   highstock
		         * @apioption yAxis.scrollbar.margin
		         */

		        /**
		         * Whether to show the scrollbar when it is fully zoomed out at max
		         * range. Setting it to `false` on the Y axis makes the scrollbar stay
		         * hidden until the user zooms in, like common in browsers.
		         *
		         * @type      {boolean}
		         * @default   true
		         * @since     4.2.6
		         * @product   highstock
		         * @apioption yAxis.scrollbar.showFull
		         */

		        /**
		         * The width of a vertical scrollbar or height of a horizontal
		         * scrollbar. Defaults to 20 on touch devices.
		         *
		         * @type      {number}
		         * @default   14
		         * @since     4.2.6
		         * @product   highstock
		         * @apioption yAxis.scrollbar.size
		         */

		        /**
		         * Z index of the scrollbar elements.
		         *
		         * @type      {number}
		         * @default   3
		         * @since     4.2.6
		         * @product   highstock
		         * @apioption yAxis.scrollbar.zIndex
		         */

		        /**
		         * A soft maximum for the axis. If the series data maximum is less
		         * than this, the axis will stay at this maximum, but if the series
		         * data maximum is higher, the axis will flex to show all data.
		         *
		         * **Note**: The [series.softThreshold](
		         * #plotOptions.series.softThreshold) option takes precedence over this
		         * option.
		         *
		         * @sample highcharts/yaxis/softmin-softmax/
		         *         Soft min and max
		         *
		         * @type      {number}
		         * @since     5.0.1
		         * @product   highcharts highstock gantt
		         * @apioption yAxis.softMax
		         */

		        /**
		         * A soft minimum for the axis. If the series data minimum is greater
		         * than this, the axis will stay at this minimum, but if the series
		         * data minimum is lower, the axis will flex to show all data.
		         *
		         * **Note**: The [series.softThreshold](
		         * #plotOptions.series.softThreshold) option takes precedence over this
		         * option.
		         *
		         * @sample highcharts/yaxis/softmin-softmax/
		         *         Soft min and max
		         *
		         * @type      {number}
		         * @since     5.0.1
		         * @product   highcharts highstock gantt
		         * @apioption yAxis.softMin
		         */

		        /**
		         * Defines the horizontal alignment of the stack total label. Can be one
		         * of `"left"`, `"center"` or `"right"`. The default value is calculated
		         * at runtime and depends on orientation and whether the stack is
		         * positive or negative.
		         *
		         * @sample {highcharts} highcharts/yaxis/stacklabels-align-left/
		         *         Aligned to the left
		         * @sample {highcharts} highcharts/yaxis/stacklabels-align-center/
		         *         Aligned in center
		         * @sample {highcharts} highcharts/yaxis/stacklabels-align-right/
		         *         Aligned to the right
		         *
		         * @type       {string}
		         * @since      2.1.5
		         * @product    highcharts
		         * @validvalue ["left", "center", "right"]
		         * @apioption  yAxis.stackLabels.align
		         */

		        /**
		         * A [format string](http://docs.highcharts.com/#formatting) for the
		         * data label. Available variables are the same as for `formatter`.
		         *
		         * @type      {string}
		         * @default   {total}
		         * @since     3.0.2
		         * @product   highcharts highstock
		         * @apioption yAxis.stackLabels.format
		         */

		        /**
		         * Rotation of the labels in degrees.
		         *
		         * @sample {highcharts} highcharts/yaxis/stacklabels-rotation/
		         *         Labels rotated 45°
		         *
		         * @type      {number}
		         * @default   0
		         * @since     2.1.5
		         * @product   highcharts
		         * @apioption yAxis.stackLabels.rotation
		         */

		        /**
		         * The text alignment for the label. While `align` determines where the
		         * texts anchor point is placed with regards to the stack, `textAlign`
		         * determines how the text is aligned against its anchor point. Possible
		         * values are `"left"`, `"center"` and `"right"`. The default value is
		         * calculated at runtime and depends on orientation and whether the
		         * stack is positive or negative.
		         *
		         * @sample {highcharts} highcharts/yaxis/stacklabels-textalign-left/
		         *         Label in center position but text-aligned left
		         *
		         * @type       {string}
		         * @since      2.1.5
		         * @product    highcharts
		         * @validvalue ["left", "center", "right"]
		         * @apioption  yAxis.stackLabels.textAlign
		         */

		        /**
		         * Whether to [use HTML](https://www.highcharts.com/docs/chart-concepts/
		         * labels-and-string-formatting#html) to render the labels.
		         *
		         * @type      {boolean}
		         * @default   false
		         * @since     3.0
		         * @product   highcharts highstock
		         * @apioption yAxis.stackLabels.useHTML
		         */

		        /**
		         * Defines the vertical alignment of the stack total label. Can be one
		         * of `"top"`, `"middle"` or `"bottom"`. The default value is calculated
		         * at runtime and depends on orientation and whether the stack is
		         * positive or negative.
		         *
		         * @sample {highcharts} highcharts/yaxis/stacklabels-verticalalign-top/
		         *         Vertically aligned top
		         * @sample {highcharts} highcharts/yaxis/stacklabels-verticalalign-middle/
		         *         Vertically aligned middle
		         * @sample {highcharts} highcharts/yaxis/stacklabels-verticalalign-bottom/
		         *         Vertically aligned bottom
		         *
		         * @type       {string}
		         * @since      2.1.5
		         * @product    highcharts
		         * @validvalue ["top", "middle", "bottom"]
		         * @apioption  yAxis.stackLabels.verticalAlign
		         */

		        /**
		         * The x position offset of the label relative to the left of the
		         * stacked bar. The default value is calculated at runtime and depends
		         * on orientation and whether the stack is positive or negative.
		         *
		         * @sample {highcharts} highcharts/yaxis/stacklabels-x/
		         *         Stack total labels with x offset
		         *
		         * @type      {number}
		         * @since     2.1.5
		         * @product   highcharts
		         * @apioption yAxis.stackLabels.x
		         */

		        /**
		         * The y position offset of the label relative to the tick position
		         * on the axis. The default value is calculated at runtime and depends
		         * on orientation and whether the stack is positive or negative.
		         *
		         * @sample {highcharts} highcharts/yaxis/stacklabels-y/
		         *         Stack total labels with y offset
		         *
		         * @type      {number}
		         * @since     2.1.5
		         * @product   highcharts
		         * @apioption yAxis.stackLabels.y
		         */

		        /**
		         * Whether to force the axis to start on a tick. Use this option with
		         * the `maxPadding` option to control the axis start.
		         *
		         * @sample  {highcharts} highcharts/xaxis/startontick-false/
		         *          False by default
		         * @sample  {highcharts} highcharts/xaxis/startontick-true/
		         *          True
		         * @sample  {highstock} stock/xaxis/endontick/
		         *          False for Y axis
		         *
		         * @since   1.2.0
		         * @product highcharts highstock gantt
		         */
		        startOnTick: true,

		        title: {

		            /**
		             * The pixel distance between the axis labels and the title.
		             * Positive values are outside the axis line, negative are inside.
		             *
		             * @sample {highcharts} highcharts/xaxis/title-margin/
		             *         Y axis title margin of 60
		             *
		             * @type      {number}
		             * @default   40
		             * @apioption yAxis.title.margin
		             */

		            /**
		             * The rotation of the text in degrees. 0 is horizontal, 270 is
		             * vertical reading from bottom to top.
		             *
		             * @sample {highcharts} highcharts/yaxis/title-offset/
		             *         Horizontal
		             */
		            rotation: 270,

		            /**
		             * The actual text of the axis title. Horizontal texts can contain
		             * HTML, but rotated texts are painted using vector techniques and
		             * must be clean text. The Y axis title is disabled by setting the
		             * `text` option to `undefined`.
		             *
		             * @sample  {highcharts} highcharts/xaxis/title-text/
		             *          Custom HTML
		             *
		             * @default {highcharts} Values
		             * @default {highstock} undefined
		             * @product highcharts highstock gantt
		             */
		            text: 'Values'
		        },

		        /**
		         * The top position of the Y axis. If it's a number, it is interpreted
		         * as pixel position relative to the chart.
		         *
		         * Since Highstock 2: If it's a percentage string, it is interpreted
		         * as percentages of the plot height, offset from plot area top.
		         *
		         * @see [yAxis.height](#yAxis.height)
		         *
		         * @sample {highstock} stock/demo/candlestick-and-volume/
		         *         Percentage height panes
		         *
		         * @type      {number|string}
		         * @product   highstock
		         * @apioption yAxis.top
		         */

		        /**
		         * The stack labels show the total value for each bar in a stacked
		         * column or bar chart. The label will be placed on top of positive
		         * columns and below negative columns. In case of an inverted column
		         * chart or a bar chart the label is placed to the right of positive
		         * bars and to the left of negative bars.
		         *
		         * @product highcharts
		         */
		        stackLabels: {

		            /**
		             * Allow the stack labels to overlap.
		             *
		             * @sample {highcharts} highcharts/yaxis/stacklabels-allowoverlap-false/
		             *         Default false
		             *
		             * @since   5.0.13
		             * @product highcharts
		             */
		            allowOverlap: false,

		            /**
		             * Enable or disable the stack total labels.
		             *
		             * @sample {highcharts} highcharts/yaxis/stacklabels-enabled/
		             *         Enabled stack total labels
		             *
		             * @since   2.1.5
		             * @product highcharts
		             */
		            enabled: false,

		            /**
		             * Callback JavaScript function to format the label. The value is
		             * given by `this.total`.
		             *
		             * @sample {highcharts} highcharts/yaxis/stacklabels-formatter/
		             *         Added units to stack total value
		             *
		             * @type    {Highcharts.FormatterCallbackFunction}
		             * @since   2.1.5
		             * @product highcharts
		             */
		            formatter: function () {
		                return H.numberFormat(this.total, -1);
		            },



		            /**
		             * CSS styles for the label.
		             *
		             * In styled mode, the styles are set in the
		             * `.highcharts-stack-label` class.
		             *
		             * @sample {highcharts} highcharts/yaxis/stacklabels-style/
		             *         Red stack total labels
		             *
		             * @type    {Highcharts.CSSObject}
		             * @default {"color": "#666666", "fontSize": "11px", "fontWeight": "bold", "textOutline": "1px contrast"}
		             * @since   2.1.5
		             * @product highcharts
		             */
		            style: {
		                /**
		                 * @ignore
		                 */
		                color: '#000000',
		                /**
		                 * @ignore
		                 */
		                fontSize: '11px',
		                /**
		                 * @ignore
		                 */
		                fontWeight: 'bold',
		                /**
		                 * @ignore
		                 */
		                textOutline: '1px contrast'
		            }



		        },



		        gridLineWidth: 1,

		        lineWidth: 0

		        // tickWidth: 0



		    },

		    /**
		     * The Z axis or depth axis for 3D plots.
		     *
		     * See [the Axis object](/class-reference/Highcharts.Axis) for programmatic
		     * access to the axis.
		     *
		     * @sample {highcharts} highcharts/3d/scatter-zaxis-categories/
		     *         Z-Axis with Categories
		     * @sample {highcharts} highcharts/3d/scatter-zaxis-grid/
		     *         Z-Axis with styling
		     *
		     * @extends   xAxis
		     * @since     5.0.0
		     * @product   highcharts
		     * @excluding breaks, crosshair, lineColor, lineWidth, nameToX, showEmpty
		     * @apioption zAxis
		     */

		    /**
		     * These options extend the defaultOptions for left axes.
		     *
		     * @private
		     * @name Highcharts.Axis#defaultLeftAxisOptions
		     * @type {*}
		     */
		    defaultLeftAxisOptions: {
		        labels: {
		            x: -15
		        },
		        title: {
		            rotation: 270
		        }
		    },

		    /**
		     * These options extend the defaultOptions for right axes.
		     *
		     * @private
		     * @name Highcharts.Axis#defaultRightAxisOptions
		     * @type {*}
		     */
		    defaultRightAxisOptions: {
		        labels: {
		            x: 15
		        },
		        title: {
		            rotation: 90
		        }
		    },

		    /**
		     * These options extend the defaultOptions for bottom axes.
		     *
		     * @private
		     * @name Highcharts.Axis#defaultBottomAxisOptions
		     * @type {*}
		     */
		    defaultBottomAxisOptions: {
		        labels: {
		            autoRotation: [-45],
		            x: 0
		            // overflow: undefined,
		            // staggerLines: null
		        },
		        title: {
		            rotation: 0
		        }
		    },
		    /**
		     * These options extend the defaultOptions for top axes.
		     *
		     * @private
		     * @name Highcharts.Axis#defaultTopAxisOptions
		     * @type {*}
		     */
		    defaultTopAxisOptions: {
		        labels: {
		            autoRotation: [-45],
		            x: 0
		            // overflow: undefined
		            // staggerLines: null
		        },
		        title: {
		            rotation: 0
		        }
		    },

		    /**
		     * Overrideable function to initialize the axis.
		     *
		     * @see {@link Axis}
		     *
		     * @function Highcharts.Axis#init
		     *
		     * @param {Highcharts.Chart} chart
		     *
		     * @param {Highcharts.Options} userOptions
		     *
		     * @fires Highcharts.Axis#event:afterInit
		     * @fires Highcharts.Axis#event:init
		     */
		    init: function (chart, userOptions) {


		        var isXAxis = userOptions.isX,
		            axis = this;

		        /**
		         * The Chart that the axis belongs to.
		         *
		         * @name Highcharts.Axis#chart
		         * @type {Highcharts.Chart}
		         */
		        axis.chart = chart;

		        /**
		         * Whether the axis is horizontal.
		         *
		         * @name Highcharts.Axis#horiz
		         * @type {boolean}
		         */
		        axis.horiz = chart.inverted && !axis.isZAxis ? !isXAxis : isXAxis;

		        // Flag, isXAxis
		        axis.isXAxis = isXAxis;

		        /**
		         * The collection where the axis belongs, for example `xAxis`, `yAxis`
		         * or `colorAxis`. Corresponds to properties on Chart, for example
		         * {@link Chart.xAxis}.
		         *
		         * @name Highcharts.Axis#coll
		         * @type {string}
		         */
		        axis.coll = axis.coll || (isXAxis ? 'xAxis' : 'yAxis');

		        fireEvent(this, 'init', { userOptions: userOptions });

		        axis.opposite = userOptions.opposite; // needed in setOptions

		        /**
		         * The side on which the axis is rendered. 0 is top, 1 is right, 2 is
		         * bottom and 3 is left.
		         *
		         * @name Highcharts.Axis#side
		         * @type {number}
		         */
		        axis.side = userOptions.side || (axis.horiz ?
		                (axis.opposite ? 0 : 2) : // top : bottom
		                (axis.opposite ? 1 : 3));  // right : left

		        axis.setOptions(userOptions);


		        var options = this.options,
		            type = options.type,
		            isDatetimeAxis = type === 'datetime';

		        axis.labelFormatter = options.labels.formatter ||
		            axis.defaultLabelFormatter; // can be overwritten by dynamic format


		        // Flag, stagger lines or not
		        axis.userOptions = userOptions;

		        axis.minPixelPadding = 0;


		        /**
		         * Whether the axis is reversed. Based on the `axis.reversed`,
		         * option, but inverted charts have reversed xAxis by default.
		         *
		         * @name Highcharts.Axis#reversed
		         * @type {boolean}
		         */
		        axis.reversed = options.reversed;
		        axis.visible = options.visible !== false;
		        axis.zoomEnabled = options.zoomEnabled !== false;

		        // Initial categories
		        axis.hasNames = type === 'category' || options.categories === true;
		        axis.categories = options.categories || axis.hasNames;
		        if (!axis.names) { // Preserve on update (#3830)
		            axis.names = [];
		            axis.names.keys = {};
		        }


		        // Placeholder for plotlines and plotbands groups
		        axis.plotLinesAndBandsGroups = {};

		        // Shorthand types
		        axis.isLog = type === 'logarithmic';
		        axis.isDatetimeAxis = isDatetimeAxis;
		        axis.positiveValuesOnly = axis.isLog && !axis.allowNegativeLog;

		        // Flag, if axis is linked to another axis
		        axis.isLinked = defined(options.linkedTo);

		        /**
		         * List of major ticks mapped by postition on axis.
		         *
		         * @name ticks
		         * @memberOf Axis
		         * @type {Object.<number, Highcharts.Tick>}
		         * @see  Highcharts.Tick
		         */
		        axis.ticks = {};
		        axis.labelEdge = [];
		        /**
		         * List of minor ticks mapped by position on the axis.
		         *
		         * @name minorTicks
		         * @memberOf Axis
		         * @type {Object.<number, Highcharts.Tick>}
		         *
		         * @see  Highcharts.Tick
		         */
		        axis.minorTicks = {};

		        // List of plotLines/Bands
		        axis.plotLinesAndBands = [];

		        // Alternate bands
		        axis.alternateBands = {};

		        // Axis metrics
		        axis.len = 0;
		        axis.minRange = axis.userMinRange = options.minRange || options.maxZoom;
		        axis.range = options.range;
		        axis.offset = options.offset || 0;


		        // Dictionary for stacks
		        axis.stacks = {};
		        axis.oldStacks = {};
		        axis.stacksTouched = 0;


		        /**
		         * The maximum value of the axis. In a logarithmic axis, this is the
		         * logarithm of the real value, and the real value can be obtained from
		         * {@link Axis#getExtremes}.
		         *
		         * @name Highcharts.Axis#max
		         * @type {number}
		         */
		        axis.max = null;
		        /**
		         * The minimum value of the axis. In a logarithmic axis, this is the
		         * logarithm of the real value, and the real value can be obtained from
		         * {@link Axis#getExtremes}.
		         *
		         * @name Highcharts.Axis#min
		         * @type {number}
		         */
		        axis.min = null;


		        /**
		         * The processed crosshair options.
		         *
		         * @name Highcharts.Axis#crosshair
		         * @type {false|Highcharts.AxisCrosshairOptions}
		         */
		        axis.crosshair = pick(
		            options.crosshair,
		            splat(chart.options.tooltip.crosshairs)[isXAxis ? 0 : 1],
		            false
		        );

		        var events = axis.options.events;

		        // Register. Don't add it again on Axis.update().
		        if (inArray(axis, chart.axes) === -1) { //
		            if (isXAxis) { // #2713
		                chart.axes.splice(chart.xAxis.length, 0, axis);
		            } else {
		                chart.axes.push(axis);
		            }

		            chart[axis.coll].push(axis);
		        }

		        /**
		         * All series associated to the axis.
		         *
		         * @name Highcharts.Axis#series
		         * @type {Array<Highcharts.Series>}
		         */
		        axis.series = axis.series || []; // populated by Series

		        // Reversed axis
		        if (
		            chart.inverted &&
		            !axis.isZAxis &&
		            isXAxis &&
		            axis.reversed === undefined
		        ) {
		            axis.reversed = true;
		        }

		        // register event listeners
		        objectEach(events, function (event, eventType) {
		            addEvent(axis, eventType, event);
		        });

		        // extend logarithmic axis
		        axis.lin2log = options.linearToLogConverter || axis.lin2log;
		        if (axis.isLog) {
		            axis.val2lin = axis.log2lin;
		            axis.lin2val = axis.lin2log;
		        }

		        fireEvent(this, 'afterInit');
		    },

		    /**
		     * Merge and set options.
		     *
		     * @private
		     * @function Highcharts.Axis#setOptions
		     *
		     * @param {Highcharts.AxisOptions} userOptions
		     *
		     * @fires Highcharts.Axis#event:afterSetOptions
		     */
		    setOptions: function (userOptions) {
		        this.options = merge(
		            this.defaultOptions,
		            this.coll === 'yAxis' && this.defaultYAxisOptions,
		            [
		                this.defaultTopAxisOptions,
		                this.defaultRightAxisOptions,
		                this.defaultBottomAxisOptions,
		                this.defaultLeftAxisOptions
		            ][this.side],
		            merge(
		                defaultOptions[this.coll], // if set in setOptions (#1053)
		                userOptions
		            )
		        );

		        fireEvent(this, 'afterSetOptions', { userOptions: userOptions });
		    },

		    /**
		     * The default label formatter. The context is a special config object for
		     * the label. In apps, use the {@link
		     * https://api.highcharts.com/highcharts/xAxis.labels.formatter|
		     * labels.formatter} instead except when a modification is needed.
		     *
		     * @private
		     * @function Highcharts.Axis#defaultLabelFormatter
		     *
		     * @return {string}
		     */
		    defaultLabelFormatter: function () {
		        var axis = this.axis,
		            value = this.value,
		            time = axis.chart.time,
		            categories = axis.categories,
		            dateTimeLabelFormat = this.dateTimeLabelFormat,
		            lang = defaultOptions.lang,
		            numericSymbols = lang.numericSymbols,
		            numSymMagnitude = lang.numericSymbolMagnitude || 1000,
		            i = numericSymbols && numericSymbols.length,
		            multi,
		            ret,
		            formatOption = axis.options.labels.format,

		            // make sure the same symbol is added for all labels on a linear
		            // axis
		            numericSymbolDetector = axis.isLog ?
		                Math.abs(value) :
		                axis.tickInterval;

		        if (formatOption) {
		            ret = format(formatOption, this, time);

		        } else if (categories) {
		            ret = value;

		        } else if (dateTimeLabelFormat) { // datetime axis
		            ret = time.dateFormat(dateTimeLabelFormat, value);

		        } else if (i && numericSymbolDetector >= 1000) {
		            // Decide whether we should add a numeric symbol like k (thousands)
		            // or M (millions). If we are to enable this in tooltip or other
		            // places as well, we can move this logic to the numberFormatter and
		            // enable it by a parameter.
		            while (i-- && ret === undefined) {
		                multi = Math.pow(numSymMagnitude, i + 1);
		                if (
		                    // Only accept a numeric symbol when the distance is more
		                    // than a full unit. So for example if the symbol is k, we
		                    // don't accept numbers like 0.5k.
		                    numericSymbolDetector >= multi &&
		                    // Accept one decimal before the symbol. Accepts 0.5k but
		                    // not 0.25k. How does this work with the previous?
		                    (value * 10) % multi === 0 &&
		                    numericSymbols[i] !== null &&
		                    value !== 0
		                ) { // #5480
		                    ret = H.numberFormat(value / multi, -1) + numericSymbols[i];
		                }
		            }
		        }

		        if (ret === undefined) {
		            if (Math.abs(value) >= 10000) { // add thousands separators
		                ret = H.numberFormat(value, -1);
		            } else { // small numbers
		                ret = H.numberFormat(value, -1, undefined, ''); // #2466
		            }
		        }

		        return ret;
		    },

		    /**
		     * Get the minimum and maximum for the series of each axis. The function
		     * analyzes the axis series and updates `this.dataMin` and `this.dataMax`.
		     *
		     * @private
		     * @function Highcharts.Axis#getSeriesExtremes
		     *
		     * @fires Highcharts.Axis#event:afterGetSeriesExtremes
		     * @fires Highcharts.Axis#event:getSeriesExtremes
		     */
		    getSeriesExtremes: function () {
		        var axis = this,
		            chart = axis.chart;

		        fireEvent(this, 'getSeriesExtremes', null, function () {

		            axis.hasVisibleSeries = false;

		            // Reset properties in case we're redrawing (#3353)
		            axis.dataMin = axis.dataMax = axis.threshold = null;
		            axis.softThreshold = !axis.isXAxis;

		            if (axis.buildStacks) {
		                axis.buildStacks();
		            }

		            // loop through this axis' series
		            each(axis.series, function (series) {

		                if (series.visible || !chart.options.chart.ignoreHiddenSeries) {

		                    var seriesOptions = series.options,
		                        xData,
		                        threshold = seriesOptions.threshold,
		                        seriesDataMin,
		                        seriesDataMax;

		                    axis.hasVisibleSeries = true;

		                    // Validate threshold in logarithmic axes
		                    if (axis.positiveValuesOnly && threshold <= 0) {
		                        threshold = null;
		                    }

		                    // Get dataMin and dataMax for X axes
		                    if (axis.isXAxis) {
		                        xData = series.xData;
		                        if (xData.length) {
		                            // If xData contains values which is not numbers,
		                            // then filter them out. To prevent performance hit,
		                            // we only do this after we have already found
		                            // seriesDataMin because in most cases all data is
		                            // valid. #5234.
		                            seriesDataMin = arrayMin(xData);
		                            seriesDataMax = arrayMax(xData);

		                            if (
		                                !isNumber(seriesDataMin) &&
		                                !(seriesDataMin instanceof Date) // #5010
		                            ) {
		                                xData = grep(xData, isNumber);
		                                // Do it again with valid data
		                                seriesDataMin = arrayMin(xData);
		                                seriesDataMax = arrayMax(xData);
		                            }

		                            if (xData.length) {
		                                axis.dataMin = Math.min(
		                                    pick(axis.dataMin, xData[0], seriesDataMin),
		                                    seriesDataMin
		                                );
		                                axis.dataMax = Math.max(
		                                    pick(axis.dataMax, xData[0], seriesDataMax),
		                                    seriesDataMax
		                                );
		                            }
		                        }

		                    // Get dataMin and dataMax for Y axes, as well as handle
		                    // stacking and processed data
		                    } else {

		                        // Get this particular series extremes
		                        series.getExtremes();
		                        seriesDataMax = series.dataMax;
		                        seriesDataMin = series.dataMin;

		                        // Get the dataMin and dataMax so far. If percentage is
		                        // used, the min and max are always 0 and 100. If
		                        // seriesDataMin and seriesDataMax is null, then series
		                        // doesn't have active y data, we continue with nulls
		                        if (defined(seriesDataMin) && defined(seriesDataMax)) {
		                            axis.dataMin = Math.min(
		                                pick(axis.dataMin, seriesDataMin),
		                                seriesDataMin
		                            );
		                            axis.dataMax = Math.max(
		                                pick(axis.dataMax, seriesDataMax),
		                                seriesDataMax
		                            );
		                        }

		                        // Adjust to threshold
		                        if (defined(threshold)) {
		                            axis.threshold = threshold;
		                        }
		                        // If any series has a hard threshold, it takes
		                        // precedence
		                        if (
		                            !seriesOptions.softThreshold ||
		                            axis.positiveValuesOnly
		                        ) {
		                            axis.softThreshold = false;
		                        }
		                    }
		                }
		            });
		        });

		        fireEvent(this, 'afterGetSeriesExtremes');
		    },

		    /**
		     * Translate from axis value to pixel position on the chart, or back. Use
		     * the `toPixels` and `toValue` functions in applications.
		     *
		     * @private
		     * @function Highcharts.Axis#translate
		     *
		     * @param {number} val
		     *
		     * @param {boolean} [backwards]
		     *
		     * @param {boolean} [cvsCoord]
		     *
		     * @param {boolean} [old]
		     *
		     * @param {boolean} [handleLog]
		     *
		     * @param {number} [pointPlacement=0]
		     *
		     * @return {number|undefined}
		     */
		    translate: function (
		        val,
		        backwards,
		        cvsCoord,
		        old,
		        handleLog,
		        pointPlacement
		    ) {
		        var axis = this.linkedParent || this, // #1417
		            sign = 1,
		            cvsOffset = 0,
		            localA = old ? axis.oldTransA : axis.transA,
		            localMin = old ? axis.oldMin : axis.min,
		            returnValue,
		            minPixelPadding = axis.minPixelPadding,
		            doPostTranslate = (
		                axis.isOrdinal ||
		                axis.isBroken ||
		                (axis.isLog && handleLog)
		            ) && axis.lin2val;

		        if (!localA) {
		            localA = axis.transA;
		        }

		        // In vertical axes, the canvas coordinates start from 0 at the top like
		        // in SVG.
		        if (cvsCoord) {
		            sign *= -1; // canvas coordinates inverts the value
		            cvsOffset = axis.len;
		        }

		        // Handle reversed axis
		        if (axis.reversed) {
		            sign *= -1;
		            cvsOffset -= sign * (axis.sector || axis.len);
		        }

		        // From pixels to value
		        if (backwards) { // reverse translation

		            val = val * sign + cvsOffset;
		            val -= minPixelPadding;
		            returnValue = val / localA + localMin; // from chart pixel to value
		            if (doPostTranslate) { // log and ordinal axes
		                returnValue = axis.lin2val(returnValue);
		            }

		        // From value to pixels
		        } else {
		            if (doPostTranslate) { // log and ordinal axes
		                val = axis.val2lin(val);
		            }
		            returnValue = isNumber(localMin) ?
		                (
		                    sign * (val - localMin) * localA +
		                    cvsOffset +
		                    (sign * minPixelPadding) +
		                    (isNumber(pointPlacement) ? localA * pointPlacement : 0)
		                ) :
		                undefined;
		        }

		        return returnValue;
		    },

		    /**
		     * Translate a value in terms of axis units into pixels within the chart.
		     *
		     * @function Highcharts.Axis#toPixels
		     *
		     * @param {number} value
		     *        A value in terms of axis units.
		     *
		     * @param {boolean} paneCoordinates
		     *        Whether to return the pixel coordinate relative to the chart or
		     *        just the axis/pane itself.
		     *
		     * @return {number}
		     *         Pixel position of the value on the chart or axis.
		     */
		    toPixels: function (value, paneCoordinates) {
		        return this.translate(value, false, !this.horiz, null, true) +
		            (paneCoordinates ? 0 : this.pos);
		    },

		    /**
		     * Translate a pixel position along the axis to a value in terms of axis
		     * units.
		     *
		     * @function Highcharts.Axis#toValue
		     *
		     * @param {number} pixel
		     *        The pixel value coordinate.
		     *
		     * @param {boolean} paneCoordiantes
		     *        Whether the input pixel is relative to the chart or just the
		     *        axis/pane itself.
		     *
		     * @return {number}
		     *         The axis value.
		     */
		    toValue: function (pixel, paneCoordinates) {
		        return this.translate(
		            pixel - (paneCoordinates ? 0 : this.pos),
		            true,
		            !this.horiz,
		            null,
		            true
		        );
		    },

		    /**
		     * Create the path for a plot line that goes from the given value on
		     * this axis, across the plot to the opposite side. Also used internally for
		     * grid lines and crosshairs.
		     *
		     * @function Highcharts.Axis#getPlotLinePath
		     *
		     * @param {number} value
		     *        Axis value.
		     *
		     * @param {number} [lineWidth=1]
		     *        Used for calculation crisp line coordinates.
		     *
		     * @param {boolean} [old=false]
		     *        Use old coordinates (for resizing and rescaling).
		     *
		     * @param {boolean|string} [force=false]
		     *        If `false`, the function will return null when it falls outside
		     *        the axis bounds. If `true`, the function will return a path
		     *        aligned to the plot area sides if it falls outside. If `pass`, it
		     *        will return a path outside.
		     *
		     * @param {number} [translatedValue]
		     *        If given, return the plot line path of a pixel position on the
		     *        axis.
		     *
		     * @return {Array<string|number>}
		     *         The SVG path definition for the plot line.
		     */
		    getPlotLinePath: function (value, lineWidth, old, force, translatedValue) {
		        var axis = this,
		            chart = axis.chart,
		            axisLeft = axis.left,
		            axisTop = axis.top,
		            x1,
		            y1,
		            x2,
		            y2,
		            cHeight = (old && chart.oldChartHeight) || chart.chartHeight,
		            cWidth = (old && chart.oldChartWidth) || chart.chartWidth,
		            skip,
		            transB = axis.transB,
		            /**
		             * Check if x is between a and b. If not, either move to a/b
		             * or skip, depending on the force parameter.
		             */
		            between = function (x, a, b) {
		                if (force !== 'pass' && x < a || x > b) {
		                    if (force) {
		                        x = Math.min(Math.max(a, x), b);
		                    } else {
		                        skip = true;
		                    }
		                }
		                return x;
		            };

		        translatedValue = pick(
		            translatedValue,
		            axis.translate(value, null, null, old)
		        );
		        // Keep the translated value within sane bounds, and avoid Infinity to
		        // fail the isNumber test (#7709).
		        translatedValue = Math.min(Math.max(-1e5, translatedValue), 1e5);


		        x1 = x2 = Math.round(translatedValue + transB);
		        y1 = y2 = Math.round(cHeight - translatedValue - transB);
		        if (!isNumber(translatedValue)) { // no min or max
		            skip = true;
		            force = false; // #7175, don't force it when path is invalid
		        } else if (axis.horiz) {
		            y1 = axisTop;
		            y2 = cHeight - axis.bottom;
		            x1 = x2 = between(x1, axisLeft, axisLeft + axis.width);
		        } else {
		            x1 = axisLeft;
		            x2 = cWidth - axis.right;
		            y1 = y2 = between(y1, axisTop, axisTop + axis.height);
		        }
		        return skip && !force ?
		            null :
		            chart.renderer.crispLine(
		                ['M', x1, y1, 'L', x2, y2],
		                lineWidth || 1
		            );
		    },

		    /**
		     * Internal function to et the tick positions of a linear axis to round
		     * values like whole tens or every five.
		     *
		     * @function Highcharts.Axis#getLinearTickPositions
		     *
		     * @param {number} tickInterval
		     *        The normalized tick interval.
		     *
		     * @param {number} min
		     *        Axis minimum.
		     *
		     * @param {number} max
		     *        Axis maximum.
		     *
		     * @return {Array<number>}
		     *         An array of axis values where ticks should be placed.
		     */
		    getLinearTickPositions: function (tickInterval, min, max) {
		        var pos,
		            lastPos,
		            roundedMin =
		                correctFloat(Math.floor(min / tickInterval) * tickInterval),
		            roundedMax =
		                correctFloat(Math.ceil(max / tickInterval) * tickInterval),
		            tickPositions = [],
		            precision;

		        // When the precision is higher than what we filter out in
		        // correctFloat, skip it (#6183).
		        if (correctFloat(roundedMin + tickInterval) === roundedMin) {
		            precision = 20;
		        }

		        // For single points, add a tick regardless of the relative position
		        // (#2662, #6274)
		        if (this.single) {
		            return [min];
		        }

		        // Populate the intermediate values
		        pos = roundedMin;
		        while (pos <= roundedMax) {

		            // Place the tick on the rounded value
		            tickPositions.push(pos);

		            // Always add the raw tickInterval, not the corrected one.
		            pos = correctFloat(
		                pos + tickInterval,
		                precision
		            );

		            // If the interval is not big enough in the current min - max range
		            // to actually increase the loop variable, we need to break out to
		            // prevent endless loop. Issue #619
		            if (pos === lastPos) {
		                break;
		            }

		            // Record the last value
		            lastPos = pos;
		        }
		        return tickPositions;
		    },

		    /**
		     * Resolve the new minorTicks/minorTickInterval options into the legacy
		     * loosely typed minorTickInterval option.
		     *
		     * @function Highcharts.Axis#getMinorTickInterval
		     *
		     * @return {number|'auto'|null}
		     */
		    getMinorTickInterval: function () {
		        var options = this.options;

		        if (options.minorTicks === true) {
		            return pick(options.minorTickInterval, 'auto');
		        }
		        if (options.minorTicks === false) {
		            return null;
		        }
		        return options.minorTickInterval;
		    },

		    /**
		     * Internal function to return the minor tick positions. For logarithmic
		     * axes, the same logic as for major ticks is reused.
		     *
		     * @function Highcharts.Axis#getMinorTickPositions
		     *
		     * @return {Array<number>}
		     *         An array of axis values where ticks should be placed.
		     */
		    getMinorTickPositions: function () {
		        var axis = this,
		            options = axis.options,
		            tickPositions = axis.tickPositions,
		            minorTickInterval = axis.minorTickInterval,
		            minorTickPositions = [],
		            pos,
		            pointRangePadding = axis.pointRangePadding || 0,
		            min = axis.min - pointRangePadding, // #1498
		            max = axis.max + pointRangePadding, // #1498
		            range = max - min;

		        // If minor ticks get too dense, they are hard to read, and may cause
		        // long running script. So we don't draw them.
		        if (range && range / minorTickInterval < axis.len / 3) { // #3875

		            if (axis.isLog) {
		                // For each interval in the major ticks, compute the minor ticks
		                // separately.
		                each(this.paddedTicks, function (pos, i, paddedTicks) {
		                    if (i) {
		                        minorTickPositions.push.apply(
		                            minorTickPositions,
		                            axis.getLogTickPositions(
		                                minorTickInterval,
		                                paddedTicks[i - 1],
		                                paddedTicks[i],
		                                true
		                            )
		                        );
		                    }
		                });

		            } else if (
		                axis.isDatetimeAxis &&
		                this.getMinorTickInterval() === 'auto'
		            ) { // #1314
		                minorTickPositions = minorTickPositions.concat(
		                    axis.getTimeTicks(
		                        axis.normalizeTimeTickInterval(minorTickInterval),
		                        min,
		                        max,
		                        options.startOfWeek
		                    )
		                );
		            } else {
		                for (
		                    pos = min + (tickPositions[0] - min) % minorTickInterval;
		                    pos <= max;
		                    pos += minorTickInterval
		                ) {
		                    // Very, very, tight grid lines (#5771)
		                    if (pos === minorTickPositions[0]) {
		                        break;
		                    }
		                    minorTickPositions.push(pos);
		                }
		            }
		        }

		        if (minorTickPositions.length !== 0) {
		            axis.trimTicks(minorTickPositions); // #3652 #3743 #1498 #6330
		        }
		        return minorTickPositions;
		    },

		    /**
		     * Adjust the min and max for the minimum range. Keep in mind that the
		     * series data is not yet processed, so we don't have information on data
		     * cropping and grouping, or updated axis.pointRange or series.pointRange.
		     * The data can't be processed until we have finally established min and
		     * max.
		     *
		     * @private
		     * @function Highcharts.Axis#adjustForMinRange
		     */
		    adjustForMinRange: function () {
		        var axis = this,
		            options = axis.options,
		            min = axis.min,
		            max = axis.max,
		            zoomOffset,
		            spaceAvailable,
		            closestDataRange,
		            i,
		            distance,
		            xData,
		            loopLength,
		            minArgs,
		            maxArgs,
		            minRange;

		        // Set the automatic minimum range based on the closest point distance
		        if (axis.isXAxis && axis.minRange === undefined && !axis.isLog) {

		            if (defined(options.min) || defined(options.max)) {
		                axis.minRange = null; // don't do this again

		            } else {

		                // Find the closest distance between raw data points, as opposed
		                // to closestPointRange that applies to processed points
		                // (cropped and grouped)
		                each(axis.series, function (series) {
		                    xData = series.xData;
		                    loopLength = series.xIncrement ? 1 : xData.length - 1;
		                    for (i = loopLength; i > 0; i--) {
		                        distance = xData[i] - xData[i - 1];
		                        if (
		                            closestDataRange === undefined ||
		                            distance < closestDataRange
		                        ) {
		                            closestDataRange = distance;
		                        }
		                    }
		                });
		                axis.minRange = Math.min(
		                    closestDataRange * 5,
		                    axis.dataMax - axis.dataMin
		                );
		            }
		        }

		        // if minRange is exceeded, adjust
		        if (max - min < axis.minRange) {

		            spaceAvailable = axis.dataMax - axis.dataMin >= axis.minRange;
		            minRange = axis.minRange;
		            zoomOffset = (minRange - max + min) / 2;

		            // if min and max options have been set, don't go beyond it
		            minArgs = [min - zoomOffset, pick(options.min, min - zoomOffset)];
		            // If space is available, stay within the data range
		            if (spaceAvailable) {
		                minArgs[2] = axis.isLog ?
		                    axis.log2lin(axis.dataMin) :
		                    axis.dataMin;
		            }
		            min = arrayMax(minArgs);

		            maxArgs = [min + minRange, pick(options.max, min + minRange)];
		            // If space is availabe, stay within the data range
		            if (spaceAvailable) {
		                maxArgs[2] = axis.isLog ?
		                    axis.log2lin(axis.dataMax) :
		                    axis.dataMax;
		            }

		            max = arrayMin(maxArgs);

		            // now if the max is adjusted, adjust the min back
		            if (max - min < minRange) {
		                minArgs[0] = max - minRange;
		                minArgs[1] = pick(options.min, max - minRange);
		                min = arrayMax(minArgs);
		            }
		        }

		        // Record modified extremes
		        axis.min = min;
		        axis.max = max;
		    },

		    /**
		     * Find the closestPointRange across all series.
		     *
		     * @private
		     * @function Highcharts.Axis#getClosest
		     *
		     * @return {number}
		     */
		    getClosest: function () {
		        var ret;

		        if (this.categories) {
		            ret = 1;
		        } else {
		            each(this.series, function (series) {
		                var seriesClosest = series.closestPointRange,
		                    visible = series.visible ||
		                        !series.chart.options.chart.ignoreHiddenSeries;

		                if (
		                    !series.noSharedTooltip &&
		                    defined(seriesClosest) &&
		                    visible
		                ) {
		                    ret = defined(ret) ?
		                        Math.min(ret, seriesClosest) :
		                        seriesClosest;
		                }
		            });
		        }
		        return ret;
		    },

		    /**
		     * When a point name is given and no x, search for the name in the existing
		     * categories, or if categories aren't provided, search names or create a
		     * new category (#2522).
		     *
		     * @private
		     * @function Highcharts.Axis#nameToX
		     *
		     * @param {Highcharts.Point} point
		     *        The point to inspect.
		     *
		     * @return {number}
		     *         The X value that the point is given.
		     */
		    nameToX: function (point) {
		        var explicitCategories = isArray(this.categories),
		            names = explicitCategories ? this.categories : this.names,
		            nameX = point.options.x,
		            x;

		        point.series.requireSorting = false;

		        if (!defined(nameX)) {
		            nameX = this.options.uniqueNames === false ?
		                point.series.autoIncrement() :
		                (
		                    explicitCategories ?
		                        inArray(point.name, names) :
		                        pick(names.keys[point.name], -1)

		                );
		        }
		        if (nameX === -1) { // Not found in currenct categories
		            if (!explicitCategories) {
		                x = names.length;
		            }
		        } else {
		            x = nameX;
		        }

		        // Write the last point's name to the names array
		        if (x !== undefined) {
		            this.names[x] = point.name;
		            // Backwards mapping is much faster than array searching (#7725)
		            this.names.keys[point.name] = x;
		        }

		        return x;
		    },

		    /**
		     * When changes have been done to series data, update the axis.names.
		     *
		     * @private
		     * @function Highcharts.Axis#updateNames
		     */
		    updateNames: function () {
		        var axis = this,
		            names = this.names,
		            i = names.length;

		        if (i > 0) {
		            each(H.keys(names.keys), function (key) {
		                delete names.keys[key];
		            });
		            names.length = 0;

		            this.minRange = this.userMinRange; // Reset
		            each(this.series || [], function (series) {

		                // Reset incrementer (#5928)
		                series.xIncrement = null;

		                // When adding a series, points are not yet generated
		                if (!series.points || series.isDirtyData) {
		                    series.processData();
		                    series.generatePoints();
		                }

		                each(series.points, function (point, i) {
		                    var x;
		                    if (point.options) {
		                        x = axis.nameToX(point);
		                        if (x !== undefined && x !== point.x) {
		                            point.x = x;
		                            series.xData[i] = x;
		                        }
		                    }
		                });
		            });
		        }
		    },

		    /**
		     * Update translation information.
		     *
		     * @private
		     * @function Highcharts.Axis#setAxisTranslation
		     *
		     * @param {boolean} saveOld
		     *
		     * @fires Highcharts.Axis#event:afterSetAxisTranslation
		     */
		    setAxisTranslation: function (saveOld) {
		        var axis = this,
		            range = axis.max - axis.min,
		            pointRange = axis.axisPointRange || 0,
		            closestPointRange,
		            minPointOffset = 0,
		            pointRangePadding = 0,
		            linkedParent = axis.linkedParent,
		            ordinalCorrection,
		            hasCategories = !!axis.categories,
		            transA = axis.transA,
		            isXAxis = axis.isXAxis;

		        // Adjust translation for padding. Y axis with categories need to go
		        // through the same (#1784).
		        if (isXAxis || hasCategories || pointRange) {

		            // Get the closest points
		            closestPointRange = axis.getClosest();

		            if (linkedParent) {
		                minPointOffset = linkedParent.minPointOffset;
		                pointRangePadding = linkedParent.pointRangePadding;
		            } else {
		                each(axis.series, function (series) {
		                    var seriesPointRange = hasCategories ?
		                        1 :
		                        (
		                            isXAxis ?
		                                pick(
		                                    series.options.pointRange,
		                                    closestPointRange,
		                                    0
		                                ) :
		                                (axis.axisPointRange || 0)
		                        ), // #2806
		                        pointPlacement = series.options.pointPlacement;

		                    pointRange = Math.max(pointRange, seriesPointRange);

		                    if (!axis.single) {
		                        // minPointOffset is the value padding to the left of
		                        // the axis in order to make room for points with a
		                        // pointRange, typically columns. When the
		                        // pointPlacement option is 'between' or 'on', this
		                        // padding does not apply.
		                        minPointOffset = Math.max(
		                            minPointOffset,
		                            isString(pointPlacement) ? 0 : seriesPointRange / 2
		                        );

		                        // Determine the total padding needed to the length of
		                        // the axis to make room for the pointRange. If the
		                        // series' pointPlacement is 'on', no padding is added.
		                        pointRangePadding = Math.max(
		                            pointRangePadding,
		                            pointPlacement === 'on' ? 0 : seriesPointRange
		                        );
		                    }
		                });
		            }

		            // Record minPointOffset and pointRangePadding
		            ordinalCorrection = axis.ordinalSlope && closestPointRange ?
		                axis.ordinalSlope / closestPointRange :
		                1; // #988, #1853
		            axis.minPointOffset = minPointOffset =
		                minPointOffset * ordinalCorrection;
		            axis.pointRangePadding =
		                pointRangePadding = pointRangePadding * ordinalCorrection;

		            // pointRange means the width reserved for each point, like in a
		            // column chart
		            axis.pointRange = Math.min(pointRange, range);

		            // closestPointRange means the closest distance between points. In
		            // columns it is mostly equal to pointRange, but in lines pointRange
		            // is 0 while closestPointRange is some other value
		            if (isXAxis) {
		                axis.closestPointRange = closestPointRange;
		            }
		        }

		        // Secondary values
		        if (saveOld) {
		            axis.oldTransA = transA;
		        }
		        axis.translationSlope = axis.transA = transA =
		            axis.staticScale ||
		            axis.len / ((range + pointRangePadding) || 1);

		        // Translation addend
		        axis.transB = axis.horiz ? axis.left : axis.bottom;
		        axis.minPixelPadding = transA * minPointOffset;

		        fireEvent(this, 'afterSetAxisTranslation');
		    },

		    /**
		     * @private
		     * @function Highcharts.Axis#minFromRange
		     *
		     * @return {number}
		     */
		    minFromRange: function () {
		        return this.max - this.range;
		    },

		    /**
		     * Set the tick positions to round values and optionally extend the extremes
		     * to the nearest tick.
		     *
		     * @private
		     * @function Highcharts.Axis#setTickInterval
		     *
		     * @param {boolean} secondPass
		     *
		     * @fires Highcharts.Axis#event:foundExtremes
		     */
		    setTickInterval: function (secondPass) {
		        var axis = this,
		            chart = axis.chart,
		            options = axis.options,
		            isLog = axis.isLog,
		            isDatetimeAxis = axis.isDatetimeAxis,
		            isXAxis = axis.isXAxis,
		            isLinked = axis.isLinked,
		            maxPadding = options.maxPadding,
		            minPadding = options.minPadding,
		            length,
		            linkedParentExtremes,
		            tickIntervalOption = options.tickInterval,
		            minTickInterval,
		            tickPixelIntervalOption = options.tickPixelInterval,
		            categories = axis.categories,
		            threshold = isNumber(axis.threshold) ? axis.threshold : null,
		            softThreshold = axis.softThreshold,
		            thresholdMin,
		            thresholdMax,
		            hardMin,
		            hardMax;

		        if (!isDatetimeAxis && !categories && !isLinked) {
		            this.getTickAmount();
		        }

		        // Min or max set either by zooming/setExtremes or initial options
		        hardMin = pick(axis.userMin, options.min);
		        hardMax = pick(axis.userMax, options.max);

		        // Linked axis gets the extremes from the parent axis
		        if (isLinked) {
		            axis.linkedParent = chart[axis.coll][options.linkedTo];
		            linkedParentExtremes = axis.linkedParent.getExtremes();
		            axis.min = pick(
		                linkedParentExtremes.min,
		                linkedParentExtremes.dataMin
		            );
		            axis.max = pick(
		                linkedParentExtremes.max,
		                linkedParentExtremes.dataMax
		            );
		            if (options.type !== axis.linkedParent.options.type) {
		                H.error(11, 1); // Can't link axes of different type
		            }

		        // Initial min and max from the extreme data values
		        } else {

		            // Adjust to hard threshold
		            if (!softThreshold && defined(threshold)) {
		                if (axis.dataMin >= threshold) {
		                    thresholdMin = threshold;
		                    minPadding = 0;
		                } else if (axis.dataMax <= threshold) {
		                    thresholdMax = threshold;
		                    maxPadding = 0;
		                }
		            }

		            axis.min = pick(hardMin, thresholdMin, axis.dataMin);
		            axis.max = pick(hardMax, thresholdMax, axis.dataMax);

		        }

		        if (isLog) {
		            if (
		                axis.positiveValuesOnly &&
		                !secondPass &&
		                Math.min(axis.min, pick(axis.dataMin, axis.min)) <= 0
		            ) { // #978
		                H.error(10, 1); // Can't plot negative values on log axis
		            }
		            // The correctFloat cures #934, float errors on full tens. But it
		            // was too aggressive for #4360 because of conversion back to lin,
		            // therefore use precision 15.
		            axis.min = correctFloat(axis.log2lin(axis.min), 15);
		            axis.max = correctFloat(axis.log2lin(axis.max), 15);
		        }

		        // handle zoomed range
		        if (axis.range && defined(axis.max)) {
		            axis.userMin = axis.min = hardMin =
		                Math.max(axis.dataMin, axis.minFromRange()); // #618, #6773
		            axis.userMax = hardMax = axis.max;

		            axis.range = null;  // don't use it when running setExtremes
		        }

		        // Hook for Highstock Scroller. Consider combining with beforePadding.
		        fireEvent(axis, 'foundExtremes');

		        // Hook for adjusting this.min and this.max. Used by bubble series.
		        if (axis.beforePadding) {
		            axis.beforePadding();
		        }

		        // adjust min and max for the minimum range
		        axis.adjustForMinRange();

		        // Pad the values to get clear of the chart's edges. To avoid
		        // tickInterval taking the padding into account, we do this after
		        // computing tick interval (#1337).
		        if (
		            !categories &&
		            !axis.axisPointRange &&
		            !axis.usePercentage &&
		            !isLinked &&
		            defined(axis.min) &&
		            defined(axis.max)
		        ) {
		            length = axis.max - axis.min;
		            if (length) {
		                if (!defined(hardMin) && minPadding) {
		                    axis.min -= length * minPadding;
		                }
		                if (!defined(hardMax) && maxPadding) {
		                    axis.max += length * maxPadding;
		                }
		            }
		        }

		        // Handle options for floor, ceiling, softMin and softMax (#6359)
		        if (isNumber(options.softMin) && !isNumber(axis.userMin)) {
		            axis.min = Math.min(axis.min, options.softMin);
		        }
		        if (isNumber(options.softMax) && !isNumber(axis.userMax)) {
		            axis.max = Math.max(axis.max, options.softMax);
		        }
		        if (isNumber(options.floor)) {
		            axis.min = Math.max(axis.min, options.floor);
		        }
		        if (isNumber(options.ceiling)) {
		            axis.max = Math.min(axis.max, options.ceiling);
		        }


		        // When the threshold is soft, adjust the extreme value only if the data
		        // extreme and the padded extreme land on either side of the threshold.
		        // For example, a series of [0, 1, 2, 3] would make the yAxis add a tick
		        // for -1 because of the default minPadding and startOnTick options.
		        // This is prevented by the softThreshold option.
		        if (softThreshold && defined(axis.dataMin)) {
		            threshold = threshold || 0;
		            if (
		                !defined(hardMin) &&
		                axis.min < threshold &&
		                axis.dataMin >= threshold
		            ) {
		                axis.min = threshold;

		            } else if (
		                !defined(hardMax) &&
		                axis.max > threshold &&
		                axis.dataMax <= threshold
		            ) {
		                axis.max = threshold;
		            }
		        }


		        // get tickInterval
		        if (
		            axis.min === axis.max ||
		            axis.min === undefined ||
		            axis.max === undefined
		        ) {
		            axis.tickInterval = 1;

		        } else if (
		            isLinked &&
		            !tickIntervalOption &&
		            tickPixelIntervalOption ===
		                axis.linkedParent.options.tickPixelInterval
		        ) {
		            axis.tickInterval = tickIntervalOption =
		                axis.linkedParent.tickInterval;

		        } else {
		            axis.tickInterval = pick(
		                tickIntervalOption,
		                this.tickAmount ?
		                    ((axis.max - axis.min) / Math.max(this.tickAmount - 1, 1)) :
		                    undefined,
		                // For categoried axis, 1 is default, for linear axis use
		                // tickPix
		                categories ?
		                    1 :
		                    // don't let it be more than the data range
		                    (axis.max - axis.min) * tickPixelIntervalOption /
		                        Math.max(axis.len, tickPixelIntervalOption)
		            );
		        }

		        /**
		         * Now we're finished detecting min and max, crop and group series data.
		         * This is in turn needed in order to find tick positions in
		         * ordinal axes.
		         */
		        if (isXAxis && !secondPass) {
		            each(axis.series, function (series) {
		                series.processData(
		                    axis.min !== axis.oldMin || axis.max !== axis.oldMax
		                );
		            });
		        }

		        // set the translation factor used in translate function
		        axis.setAxisTranslation(true);

		        // hook for ordinal axes and radial axes
		        if (axis.beforeSetTickPositions) {
		            axis.beforeSetTickPositions();
		        }

		        // hook for extensions, used in Highstock ordinal axes
		        if (axis.postProcessTickInterval) {
		            axis.tickInterval = axis.postProcessTickInterval(axis.tickInterval);
		        }

		        // In column-like charts, don't cramp in more ticks than there are
		        // points (#1943, #4184)
		        if (axis.pointRange && !tickIntervalOption) {
		            axis.tickInterval = Math.max(axis.pointRange, axis.tickInterval);
		        }

		        // Before normalizing the tick interval, handle minimum tick interval.
		        // This applies only if tickInterval is not defined.
		        minTickInterval = pick(
		            options.minTickInterval,
		            axis.isDatetimeAxis && axis.closestPointRange
		        );
		        if (!tickIntervalOption && axis.tickInterval < minTickInterval) {
		            axis.tickInterval = minTickInterval;
		        }

		        // for linear axes, get magnitude and normalize the interval
		        if (!isDatetimeAxis && !isLog && !tickIntervalOption) {
		            axis.tickInterval = normalizeTickInterval(
		                axis.tickInterval,
		                null,
		                getMagnitude(axis.tickInterval),
		                // If the tick interval is between 0.5 and 5 and the axis max is
		                // in the order of thousands, chances are we are dealing with
		                // years. Don't allow decimals. #3363.
		                pick(
		                    options.allowDecimals,
		                    !(
		                        axis.tickInterval > 0.5 &&
		                        axis.tickInterval < 5 &&
		                        axis.max > 1000 &&
		                        axis.max < 9999
		                    )
		                ),
		                !!this.tickAmount
		            );
		        }

		        // Prevent ticks from getting so close that we can't draw the labels
		        if (!this.tickAmount) {
		            axis.tickInterval = axis.unsquish();
		        }

		        this.setTickPositions();
		    },

		    /**
		     * Now we have computed the normalized tickInterval, get the tick positions
		     *
		     * @function Highcharts.Axis#setTickPositions
		     *
		     * @fires Highcharts.Axis#event:afterSetTickPositions
		     */
		    setTickPositions: function () {

		        var options = this.options,
		            tickPositions,
		            tickPositionsOption = options.tickPositions,
		            minorTickIntervalOption = this.getMinorTickInterval(),
		            tickPositioner = options.tickPositioner,
		            startOnTick = options.startOnTick,
		            endOnTick = options.endOnTick;

		        // Set the tickmarkOffset
		        this.tickmarkOffset = (
		            this.categories &&
		            options.tickmarkPlacement === 'between' &&
		            this.tickInterval === 1
		        ) ? 0.5 : 0; // #3202


		        // get minorTickInterval
		        this.minorTickInterval =
		            minorTickIntervalOption === 'auto' &&
		            this.tickInterval ?
		                this.tickInterval / 5 :
		                minorTickIntervalOption;

		        // When there is only one point, or all points have the same value on
		        // this axis, then min and max are equal and tickPositions.length is 0
		        // or 1. In this case, add some padding in order to center the point,
		        // but leave it with one tick. #1337.
		        this.single =
		            this.min === this.max &&
		            defined(this.min) &&
		            !this.tickAmount &&
		            (
		                // Data is on integer (#6563)
		                parseInt(this.min, 10) === this.min ||

		                // Between integers and decimals are not allowed (#6274)
		                options.allowDecimals !== false
		            );

		        // Find the tick positions. Work on a copy (#1565)
		        this.tickPositions = tickPositions =
		            tickPositionsOption && tickPositionsOption.slice();
		        if (!tickPositions) {

		            // Too many ticks (#6405). Create a friendly warning and provide two
		            // ticks so at least we can show the data series.
		            if (
		                !this.ordinalPositions &&
		                (
		                    (this.max - this.min) / this.tickInterval >
		                    Math.max(2 * this.len, 200)
		                )
		            ) {
		                tickPositions = [this.min, this.max];
		                H.error(19);

		            } else if (this.isDatetimeAxis) {
		                tickPositions = this.getTimeTicks(
		                    this.normalizeTimeTickInterval(
		                        this.tickInterval,
		                        options.units
		                    ),
		                    this.min,
		                    this.max,
		                    options.startOfWeek,
		                    this.ordinalPositions,
		                    this.closestPointRange,
		                    true
		                );
		            } else if (this.isLog) {
		                tickPositions = this.getLogTickPositions(
		                    this.tickInterval,
		                    this.min,
		                    this.max
		                );
		            } else {
		                tickPositions = this.getLinearTickPositions(
		                    this.tickInterval,
		                    this.min,
		                    this.max
		                );
		            }

		            // Too dense ticks, keep only the first and last (#4477)
		            if (tickPositions.length > this.len) {
		                tickPositions = [tickPositions[0], tickPositions.pop()];
		                // Reduce doubled value (#7339)
		                if (tickPositions[0] === tickPositions[1]) {
		                    tickPositions.length = 1;
		                }
		            }

		            this.tickPositions = tickPositions;

		            // Run the tick positioner callback, that allows modifying auto tick
		            // positions.
		            if (tickPositioner) {
		                tickPositioner = tickPositioner.apply(
		                    this,
		                    [this.min, this.max]
		                );
		                if (tickPositioner) {
		                    this.tickPositions = tickPositions = tickPositioner;
		                }
		            }

		        }

		        // Reset min/max or remove extremes based on start/end on tick
		        this.paddedTicks = tickPositions.slice(0); // Used for logarithmic minor
		        this.trimTicks(tickPositions, startOnTick, endOnTick);
		        if (!this.isLinked) {

		            // Substract half a unit (#2619, #2846, #2515, #3390),
		            // but not in case of multiple ticks (#6897)
		            if (this.single && tickPositions.length < 2) {
		                this.min -= 0.5;
		                this.max += 0.5;
		            }
		            if (!tickPositionsOption && !tickPositioner) {
		                this.adjustTickAmount();
		            }
		        }

		        fireEvent(this, 'afterSetTickPositions');
		    },

		    /**
		     * Handle startOnTick and endOnTick by either adapting to padding min/max or
		     * rounded min/max. Also handle single data points.
		     *
		     * @private
		     * @function Highcharts.Axis#trimTicks
		     *
		     * @param {Array<number>} tickPositions
		     *
		     * @param {boolean} startOnTicl
		     *
		     * @param {boolean} endOnTick
		     */
		    trimTicks: function (tickPositions, startOnTick, endOnTick) {
		        var roundedMin = tickPositions[0],
		            roundedMax = tickPositions[tickPositions.length - 1],
		            minPointOffset = this.minPointOffset || 0;

		        if (!this.isLinked) {
		            if (startOnTick && roundedMin !== -Infinity) { // #6502
		                this.min = roundedMin;
		            } else {
		                while (this.min - minPointOffset > tickPositions[0]) {
		                    tickPositions.shift();
		                }
		            }

		            if (endOnTick) {
		                this.max = roundedMax;
		            } else {
		                while (this.max + minPointOffset <
		                        tickPositions[tickPositions.length - 1]) {
		                    tickPositions.pop();
		                }
		            }

		            // If no tick are left, set one tick in the middle (#3195)
		            if (
		                tickPositions.length === 0 &&
		                defined(roundedMin) &&
		                !this.options.tickPositions
		            ) {
		                tickPositions.push((roundedMax + roundedMin) / 2);
		            }
		        }
		    },

		    /**
		     * Check if there are multiple axes in the same pane.
		     *
		     * @private
		     * @function Highcharts.Axis#alignToOthers
		     *
		     * @return {boolean}
		     *         True if there are other axes.
		     */
		    alignToOthers: function () {
		        var others = {}, // Whether there is another axis to pair with this one
		            hasOther,
		            options = this.options;

		        if (
		            // Only if alignTicks is true
		            this.chart.options.chart.alignTicks !== false &&
		            options.alignTicks !== false &&

		            // Disabled when startOnTick or endOnTick are false (#7604)
		            options.startOnTick !== false &&
		            options.endOnTick !== false &&

		            // Don't try to align ticks on a log axis, they are not evenly
		            // spaced (#6021)
		            !this.isLog
		        ) {
		            each(this.chart[this.coll], function (axis) {
		                var otherOptions = axis.options,
		                    horiz = axis.horiz,
		                    key = [
		                        horiz ? otherOptions.left : otherOptions.top,
		                        otherOptions.width,
		                        otherOptions.height,
		                        otherOptions.pane
		                    ].join(',');


		                if (axis.series.length) { // #4442
		                    if (others[key]) {
		                        hasOther = true; // #4201
		                    } else {
		                        others[key] = 1;
		                    }
		                }
		            });
		        }
		        return hasOther;
		    },

		    /**
		     * Find the max ticks of either the x and y axis collection, and record it
		     * in `this.tickAmount`.
		     *
		     * @private
		     * @function Highcharts.Axis#getTickAmount
		     */
		    getTickAmount: function () {
		        var options = this.options,
		            tickAmount = options.tickAmount,
		            tickPixelInterval = options.tickPixelInterval;

		        if (
		            !defined(options.tickInterval) &&
		            this.len < tickPixelInterval &&
		            !this.isRadial &&
		            !this.isLog &&
		            options.startOnTick &&
		            options.endOnTick
		        ) {
		            tickAmount = 2;
		        }

		        if (!tickAmount && this.alignToOthers()) {
		            // Add 1 because 4 tick intervals require 5 ticks (including first
		            // and last)
		            tickAmount = Math.ceil(this.len / tickPixelInterval) + 1;
		        }

		        // For tick amounts of 2 and 3, compute five ticks and remove the
		        // intermediate ones. This prevents the axis from adding ticks that are
		        // too far away from the data extremes.
		        if (tickAmount < 4) {
		            this.finalTickAmt = tickAmount;
		            tickAmount = 5;
		        }

		        this.tickAmount = tickAmount;
		    },

		    /**
		     * When using multiple axes, adjust the number of ticks to match the highest
		     * number of ticks in that group.
		     *
		     * @private
		     * @function Highcharts.Axis#adjustTickAmount
		     */
		    adjustTickAmount: function () {
		        var tickInterval = this.tickInterval,
		            tickPositions = this.tickPositions,
		            tickAmount = this.tickAmount,
		            finalTickAmt = this.finalTickAmt,
		            currentTickAmount = tickPositions && tickPositions.length,
		            threshold = pick(this.threshold, this.softThreshold ? 0 : null),
		            i,
		            len;

		        if (this.hasData()) {
		            if (currentTickAmount < tickAmount) {
		                while (tickPositions.length < tickAmount) {

		                    // Extend evenly for both sides unless we're on the
		                    // threshold (#3965)
		                    if (
		                        tickPositions.length % 2 ||
		                        this.min === threshold
		                    ) {
		                        // to the end
		                        tickPositions.push(correctFloat(
		                            tickPositions[tickPositions.length - 1] +
		                            tickInterval
		                        ));
		                    } else {
		                        // to the start
		                        tickPositions.unshift(correctFloat(
		                            tickPositions[0] - tickInterval
		                        ));
		                    }
		                }
		                this.transA *= (currentTickAmount - 1) / (tickAmount - 1);
		                this.min = tickPositions[0];
		                this.max = tickPositions[tickPositions.length - 1];

		            // We have too many ticks, run second pass to try to reduce ticks
		            } else if (currentTickAmount > tickAmount) {
		                this.tickInterval *= 2;
		                this.setTickPositions();
		            }

		            // The finalTickAmt property is set in getTickAmount
		            if (defined(finalTickAmt)) {
		                i = len = tickPositions.length;
		                while (i--) {
		                    if (
		                        // Remove every other tick
		                        (finalTickAmt === 3 && i % 2 === 1) ||
		                        // Remove all but first and last
		                        (finalTickAmt <= 2 && i > 0 && i < len - 1)
		                    ) {
		                        tickPositions.splice(i, 1);
		                    }
		                }
		                this.finalTickAmt = undefined;
		            }
		        }
		    },

		    /**
		     * Set the scale based on data min and max, user set min and max or options.
		     *
		     * @private
		     * @function Highcharts.Axis#setScale
		     *
		     * @fires Highcharts.Axis#event:afterSetScale
		     */
		    setScale: function () {
		        var axis = this,
		            isDirtyData,
		            isDirtyAxisLength;

		        axis.oldMin = axis.min;
		        axis.oldMax = axis.max;
		        axis.oldAxisLength = axis.len;

		        // set the new axisLength
		        axis.setAxisSize();
		        isDirtyAxisLength = axis.len !== axis.oldAxisLength;

		        // is there new data?
		        each(axis.series, function (series) {
		            if (
		                series.isDirtyData ||
		                series.isDirty ||
		                // When x axis is dirty, we need new data extremes for y as well
		                series.xAxis.isDirty
		            ) {
		                isDirtyData = true;
		            }
		        });

		        // do we really need to go through all this?
		        if (
		            isDirtyAxisLength ||
		            isDirtyData ||
		            axis.isLinked ||
		            axis.forceRedraw ||
		            axis.userMin !== axis.oldUserMin ||
		            axis.userMax !== axis.oldUserMax ||
		            axis.alignToOthers()
		        ) {

		            if (axis.resetStacks) {
		                axis.resetStacks();
		            }

		            axis.forceRedraw = false;

		            // get data extremes if needed
		            axis.getSeriesExtremes();

		            // get fixed positions based on tickInterval
		            axis.setTickInterval();

		            // record old values to decide whether a rescale is necessary later
		            // on (#540)
		            axis.oldUserMin = axis.userMin;
		            axis.oldUserMax = axis.userMax;

		            // Mark as dirty if it is not already set to dirty and extremes have
		            // changed. #595.
		            if (!axis.isDirty) {
		                axis.isDirty =
		                    isDirtyAxisLength ||
		                    axis.min !== axis.oldMin ||
		                    axis.max !== axis.oldMax;
		            }
		        } else if (axis.cleanStacks) {
		            axis.cleanStacks();
		        }

		        fireEvent(this, 'afterSetScale');
		    },

		    /**
		     * Set the minimum and maximum of the axes after render time. If the
		     * `startOnTick` and `endOnTick` options are true, the minimum and maximum
		     * values are rounded off to the nearest tick. To prevent this, these
		     * options can be set to false before calling setExtremes. Also, setExtremes
		     * will not allow a range lower than the `minRange` option, which by default
		     * is the range of five points.
		     *
		     * @sample highcharts/members/axis-setextremes/
		     *         Set extremes from a button
		     * @sample highcharts/members/axis-setextremes-datetime/
		     *         Set extremes on a datetime axis
		     * @sample highcharts/members/axis-setextremes-off-ticks/
		     *         Set extremes off ticks
		     * @sample stock/members/axis-setextremes/
		     *         Set extremes in Highstock
		     * @sample maps/members/axis-setextremes/
		     *         Set extremes in Highmaps
		     *
		     * @function Highcharts.Axis#setExtremes
		     *
		     * @param {number} [newMin]
		     *        The new minimum value.
		     *
		     * @param {number} [newMax]
		     *        The new maximum value.
		     *
		     * @param {boolean} [redraw=true]
		     *        Whether to redraw the chart or wait for an explicit call to
		     *        {@link Highcharts.Chart#redraw}
		     *
		     * @param {boolean|Highcharts.AnimationOptionsObject} [animation=true]
		     *        Enable or modify animations.
		     *
		     * @param {*} [eventArguments]
		     *        Arguments to be accessed in event handler.
		     *
		     * @fires Highcharts.Axis#event:setExtremes
		     */
		    setExtremes: function (newMin, newMax, redraw, animation, eventArguments) {
		        var axis = this,
		            chart = axis.chart;

		        redraw = pick(redraw, true); // defaults to true

		        each(axis.series, function (serie) {
		            delete serie.kdTree;
		        });

		        // Extend the arguments with min and max
		        eventArguments = extend(eventArguments, {
		            min: newMin,
		            max: newMax
		        });

		        // Fire the event
		        fireEvent(axis, 'setExtremes', eventArguments, function () {

		            axis.userMin = newMin;
		            axis.userMax = newMax;
		            axis.eventArgs = eventArguments;

		            if (redraw) {
		                chart.redraw(animation);
		            }
		        });
		    },

		    /**
		     * Overridable method for zooming chart. Pulled out in a separate method to
		     * allow overriding in stock charts.
		     *
		     * @private
		     * @function Highcharts.Axis#zoom
		     *
		     * @param {number} newMin
		     *
		     * @param {number} newMax
		     *
		     * @return {boolean}
		     */
		    zoom: function (newMin, newMax) {
		        var dataMin = this.dataMin,
		            dataMax = this.dataMax,
		            options = this.options,
		            min = Math.min(dataMin, pick(options.min, dataMin)),
		            max = Math.max(dataMax, pick(options.max, dataMax));

		        if (newMin !== this.min || newMax !== this.max) { // #5790

		            // Prevent pinch zooming out of range. Check for defined is for
		            // #1946. #1734.
		            if (!this.allowZoomOutside) {
		                // #6014, sometimes newMax will be smaller than min (or newMin
		                // will be larger than max).
		                if (defined(dataMin)) {
		                    if (newMin < min) {
		                        newMin = min;
		                    }
		                    if (newMin > max) {
		                        newMin = max;
		                    }
		                }
		                if (defined(dataMax)) {
		                    if (newMax < min) {
		                        newMax = min;
		                    }
		                    if (newMax > max) {
		                        newMax = max;
		                    }
		                }
		            }

		            // In full view, displaying the reset zoom button is not required
		            this.displayBtn = newMin !== undefined || newMax !== undefined;

		            // Do it
		            this.setExtremes(
		                newMin,
		                newMax,
		                false,
		                undefined,
		                { trigger: 'zoom' }
		            );
		        }

		        return true;
		    },

		    /**
		     * Update the axis metrics.
		     *
		     * @private
		     * @function Highcharts.Axis#setAxisSize
		     */
		    setAxisSize: function () {
		        var chart = this.chart,
		            options = this.options,
		            // [top, right, bottom, left]
		            offsets = options.offsets || [0, 0, 0, 0],
		            horiz = this.horiz,

		            // Check for percentage based input values. Rounding fixes problems
		            // with column overflow and plot line filtering (#4898, #4899)
		            width = this.width = Math.round(H.relativeLength(
		                pick(
		                    options.width,
		                    chart.plotWidth - offsets[3] + offsets[1]
		                ),
		                chart.plotWidth
		            )),
		            height = this.height = Math.round(H.relativeLength(
		                pick(
		                    options.height,
		                    chart.plotHeight - offsets[0] + offsets[2]
		                ),
		                chart.plotHeight
		            )),
		            top = this.top = Math.round(H.relativeLength(
		                pick(options.top, chart.plotTop + offsets[0]),
		                chart.plotHeight,
		                chart.plotTop
		            )),
		            left = this.left = Math.round(H.relativeLength(
		                pick(options.left, chart.plotLeft + offsets[3]),
		                chart.plotWidth,
		                chart.plotLeft
		            ));

		        // Expose basic values to use in Series object and navigator
		        this.bottom = chart.chartHeight - height - top;
		        this.right = chart.chartWidth - width - left;

		        // Direction agnostic properties
		        this.len = Math.max(horiz ? width : height, 0); // Math.max fixes #905
		        this.pos = horiz ? left : top; // distance from SVG origin
		    },

		    /**
		     * Get the current extremes for the axis.
		     *
		     * @sample highcharts/members/axis-getextremes/
		     *         Report extremes by click on a button
		     * @sample maps/members/axis-getextremes/
		     *         Get extremes in Highmaps
		     *
		     * @function Highcharts.Axis#getExtremes
		     *
		     * @returns {Highcharts.ExtremesObject}
		     *          An object containing extremes information.
		     */
		    getExtremes: function () {
		        var axis = this,
		            isLog = axis.isLog;

		        return {
		            min: isLog ? correctFloat(axis.lin2log(axis.min)) : axis.min,
		            max: isLog ? correctFloat(axis.lin2log(axis.max)) : axis.max,
		            dataMin: axis.dataMin,
		            dataMax: axis.dataMax,
		            userMin: axis.userMin,
		            userMax: axis.userMax
		        };
		    },

		    /**
		     * Get the zero plane either based on zero or on the min or max value.
		     * Used in bar and area plots.
		     *
		     * @function Highcharts.Axis#getThreshold
		     *
		     * @param {number} threshold
		     *        The threshold in axis values.
		     *
		     * @return {number}
		     *         The translated threshold position in terms of pixels, and
		     *         corrected to stay within the axis bounds.
		     */
		    getThreshold: function (threshold) {
		        var axis = this,
		            isLog = axis.isLog,
		            realMin = isLog ? axis.lin2log(axis.min) : axis.min,
		            realMax = isLog ? axis.lin2log(axis.max) : axis.max;

		        if (threshold === null || threshold === -Infinity) {
		            threshold = realMin;
		        } else if (threshold === Infinity) {
		            threshold = realMax;
		        } else if (realMin > threshold) {
		            threshold = realMin;
		        } else if (realMax < threshold) {
		            threshold = realMax;
		        }

		        return axis.translate(threshold, 0, 1, 0, 1);
		    },

		    /**
		     * Compute auto alignment for the axis label based on which side the axis is
		     * on and the given rotation for the label.
		     *
		     * @private
		     * @function Highcharts.Axis#autoLabelAlign
		     *
		     * @param {number} rotation
		     *        The rotation in degrees as set by either the `rotation` or
		     *        `autoRotation` options.
		     *
		     * @return {string}
		     *         Can be `center`, `left` or `right`.
		     */
		    autoLabelAlign: function (rotation) {
		        var ret,
		            angle = (pick(rotation, 0) - (this.side * 90) + 720) % 360;

		        if (angle > 15 && angle < 165) {
		            ret = 'right';
		        } else if (angle > 195 && angle < 345) {
		            ret = 'left';
		        } else {
		            ret = 'center';
		        }
		        return ret;
		    },

		    /**
		     * Get the tick length and width for the axis based on axis options.
		     *
		     * @private
		     * @function Highcharts.Axis#tickSize
		     *
		     * @param {string} prefix
		     *        'tick' or 'minorTick'
		     *
		     * @return {Array<number>}
		     *         An array of tickLength and tickWidth
		     */
		    tickSize: function (prefix) {
		        var options = this.options,
		            tickLength = options[prefix + 'Length'],
		            tickWidth = pick(
		                options[prefix + 'Width'],
		                prefix === 'tick' && this.isXAxis ? 1 : 0 // X axis default 1
		            );

		        if (tickWidth && tickLength) {
		            // Negate the length
		            if (options[prefix + 'Position'] === 'inside') {
		                tickLength = -tickLength;
		            }
		            return [tickLength, tickWidth];
		        }

		    },

		    /**
		     * Return the size of the labels.
		     *
		     * @private
		     * @function Highcharts.Axis#labelMetrics
		     *
		     * @return {Highcharts.FontMetricsObject}
		     */
		    labelMetrics: function () {
		        var index = this.tickPositions && this.tickPositions[0] || 0;
		        return this.chart.renderer.fontMetrics(
		            this.options.labels.style && this.options.labels.style.fontSize,
		            this.ticks[index] && this.ticks[index].label
		        );
		    },

		    /**
		     * Prevent the ticks from getting so close we can't draw the labels. On a
		     * horizontal axis, this is handled by rotating the labels, removing ticks
		     * and adding ellipsis. On a vertical axis remove ticks and add ellipsis.
		     *
		     * @private
		     * @function Highcharts.Axis#unsquish
		     *
		     * @return {number}
		     */
		    unsquish: function () {
		        var labelOptions = this.options.labels,
		            horiz = this.horiz,
		            tickInterval = this.tickInterval,
		            newTickInterval = tickInterval,
		            slotSize = this.len / (
		                ((this.categories ? 1 : 0) + this.max - this.min) / tickInterval
		            ),
		            rotation,
		            rotationOption = labelOptions.rotation,
		            labelMetrics = this.labelMetrics(),
		            step,
		            bestScore = Number.MAX_VALUE,
		            autoRotation,
		            // Return the multiple of tickInterval that is needed to avoid
		            // collision
		            getStep = function (spaceNeeded) {
		                var step = spaceNeeded / (slotSize || 1);
		                step = step > 1 ? Math.ceil(step) : 1;
		                return correctFloat(step * tickInterval);
		            };

		        if (horiz) {
		            autoRotation = !labelOptions.staggerLines &&
		                !labelOptions.step &&
		                ( // #3971
		                    defined(rotationOption) ?
		                        [rotationOption] :
		                        slotSize < pick(labelOptions.autoRotationLimit, 80) &&
		                            labelOptions.autoRotation
		                );

		            if (autoRotation) {

		                // Loop over the given autoRotation options, and determine
		                // which gives the best score. The best score is that with
		                // the lowest number of steps and a rotation closest
		                // to horizontal.
		                each(autoRotation, function (rot) {
		                    var score;

		                    if (
		                        rot === rotationOption ||
		                        (rot && rot >= -90 && rot <= 90)
		                    ) { // #3891

		                        step = getStep(
		                            Math.abs(labelMetrics.h / Math.sin(deg2rad * rot))
		                        );

		                        score = step + Math.abs(rot / 360);

		                        if (score < bestScore) {
		                            bestScore = score;
		                            rotation = rot;
		                            newTickInterval = step;
		                        }
		                    }
		                });
		            }

		        } else if (!labelOptions.step) { // #4411
		            newTickInterval = getStep(labelMetrics.h);
		        }

		        this.autoRotation = autoRotation;
		        this.labelRotation = pick(rotation, rotationOption);

		        return newTickInterval;
		    },

		    /**
		     * Get the general slot width for labels/categories on this axis. This may
		     * change between the pre-render (from Axis.getOffset) and the final tick
		     * rendering and placement.
		     *
		     * @private
		     * @function Highcharts.Axis#getSlotWidth
		     *
		     * @param {*} [tick]
		     *        Optionally, calculate the slot width basing on tick label. It is
		     *        used in highcharts-3d module, where the slots has different widths
		     *        depending on perspective angles.
		     *
		     * @return {number}
		     *         The pixel width allocated to each axis label.
		     */
		    getSlotWidth: function (tick) {
		        // #5086, #1580, #1931
		        var chart = this.chart,
		            horiz = this.horiz,
		            labelOptions = this.options.labels,
		            slotCount = Math.max(
		                this.tickPositions.length - (this.categories ? 0 : 1),
		                1
		            ),
		            marginLeft = chart.margin[3];

		        return (
		            tick &&
		            tick.slotWidth // Used by grid axis
		        ) || (
		            horiz &&
		            (labelOptions.step || 0) < 2 &&
		            !labelOptions.rotation && // #4415
		            ((this.staggerLines || 1) * this.len) / slotCount
		        ) || (
		            !horiz && (
		                // #7028
		                (
		                    labelOptions.style &&
		                    parseInt(labelOptions.style.width, 10)
		                ) ||
		                (
		                    marginLeft &&
		                    (marginLeft - chart.spacing[3])
		                ) ||
		                chart.chartWidth * 0.33
		            )
		        );

		    },

		    /**
		     * Render the axis labels and determine whether ellipsis or rotation need
		     * to be applied.
		     *
		     * @private
		     * @function Highcharts.Axis#renderUnsquish
		     */
		    renderUnsquish: function () {
		        var chart = this.chart,
		            renderer = chart.renderer,
		            tickPositions = this.tickPositions,
		            ticks = this.ticks,
		            labelOptions = this.options.labels,
		            labelStyleOptions = (labelOptions && labelOptions.style || {}),
		            horiz = this.horiz,
		            slotWidth = this.getSlotWidth(),
		            innerWidth = Math.max(
		                1,
		                Math.round(slotWidth - 2 * (labelOptions.padding || 5))
		            ),
		            attr = {},
		            labelMetrics = this.labelMetrics(),
		            textOverflowOption = labelOptions.style &&
		                labelOptions.style.textOverflow,
		            commonWidth,
		            commonTextOverflow,
		            maxLabelLength = 0,
		            label,
		            i,
		            pos;

		        // Set rotation option unless it is "auto", like in gauges
		        if (!isString(labelOptions.rotation)) {
		            attr.rotation = labelOptions.rotation || 0; // #4443
		        }

		        // Get the longest label length
		        each(tickPositions, function (tick) {
		            tick = ticks[tick];
		            if (
		                tick &&
		                tick.label &&
		                tick.label.textPxLength > maxLabelLength
		            ) {
		                maxLabelLength = tick.label.textPxLength;
		            }
		        });
		        this.maxLabelLength = maxLabelLength;


		        // Handle auto rotation on horizontal axis
		        if (this.autoRotation) {

		            // Apply rotation only if the label is too wide for the slot, and
		            // the label is wider than its height.
		            if (
		                maxLabelLength > innerWidth &&
		                maxLabelLength > labelMetrics.h
		            ) {
		                attr.rotation = this.labelRotation;
		            } else {
		                this.labelRotation = 0;
		            }

		        // Handle word-wrap or ellipsis on vertical axis
		        } else if (slotWidth) {
		            // For word-wrap or ellipsis
		            commonWidth = innerWidth;

		            if (!textOverflowOption) {
		                commonTextOverflow = 'clip';

		                // On vertical axis, only allow word wrap if there is room
		                // for more lines.
		                i = tickPositions.length;
		                while (!horiz && i--) {
		                    pos = tickPositions[i];
		                    label = ticks[pos].label;
		                    if (label) {
		                        // Reset ellipsis in order to get the correct
		                        // bounding box (#4070)
		                        if (
		                            label.styles &&
		                            label.styles.textOverflow === 'ellipsis'
		                        ) {
		                            label.css({ textOverflow: 'clip' });

		                        // Set the correct width in order to read
		                        // the bounding box height (#4678, #5034)
		                        } else if (label.textPxLength > slotWidth) {
		                            label.css({ width: slotWidth + 'px' });
		                        }

		                        if (
		                            label.getBBox().height > (
		                                this.len / tickPositions.length -
		                                (labelMetrics.h - labelMetrics.f)
		                            )
		                        ) {
		                            label.specificTextOverflow = 'ellipsis';
		                        }
		                    }
		                }
		            }
		        }


		        // Add ellipsis if the label length is significantly longer than ideal
		        if (attr.rotation) {
		            commonWidth = (
		                maxLabelLength > chart.chartHeight * 0.5 ?
		                    chart.chartHeight * 0.33 :
		                    maxLabelLength
		            );
		            if (!textOverflowOption) {
		                commonTextOverflow = 'ellipsis';
		            }
		        }

		        // Set the explicit or automatic label alignment
		        this.labelAlign = labelOptions.align ||
		            this.autoLabelAlign(this.labelRotation);
		        if (this.labelAlign) {
		            attr.align = this.labelAlign;
		        }

		        // Apply general and specific CSS
		        each(tickPositions, function (pos) {
		            var tick = ticks[pos],
		                label = tick && tick.label,
		                widthOption = labelStyleOptions.width,
		                css = {};

		            if (label) {
		                // This needs to go before the CSS in old IE (#4502)
		                label.attr(attr);

		                if (tick.shortenLabel) {
		                    tick.shortenLabel();
		                } else if (
		                    commonWidth &&
		                    !widthOption &&
		                    // Setting width in this case messes with the bounding box
		                    // (#7975)
		                    labelStyleOptions.whiteSpace !== 'nowrap' &&
		                    (
		                        // Speed optimizing, #7656
		                        commonWidth < label.textPxLength ||
		                        // Resetting CSS, #4928
		                        label.element.tagName === 'SPAN'
		                    )
		                ) {
		                    css.width = commonWidth;
		                    if (!textOverflowOption) {
		                        css.textOverflow = (
		                            label.specificTextOverflow ||
		                            commonTextOverflow
		                        );
		                    }
		                    label.css(css);

		                // Reset previously shortened label (#8210)
		                } else if (
		                    label.styles &&
		                    label.styles.width &&
		                    !css.width &&
		                    !widthOption
		                ) {
		                    label.css({ width: null });
		                }

		                delete label.specificTextOverflow;
		                tick.rotation = attr.rotation;
		            }
		        }, this);

		        // Note: Why is this not part of getLabelPosition?
		        this.tickRotCorr = renderer.rotCorr(
		            labelMetrics.b,
		            this.labelRotation || 0,
		            this.side !== 0
		        );
		    },

		    /**
		     * Return true if the axis has associated data.
		     *
		     * @function Highcharts.Axis#hasData
		     *
		     * @return {boolean}
		     *         True if the axis has associated visible series and those series
		     *         have either valid data points or explicit `min` and `max`
		     *         settings.
		     */
		    hasData: function () {
		        return (
		            this.hasVisibleSeries ||
		            (
		                defined(this.min) &&
		                defined(this.max) &&
		                this.tickPositions &&
		                this.tickPositions.length > 0
		            )
		        );
		    },

		    /**
		     * Adds the title defined in axis.options.title.
		     *
		     * @function Highcharts.Axis#addTitle
		     *
		     * @param {boolean} display
		     *        Whether or not to display the title.
		     */
		    addTitle: function (display) {
		        var axis = this,
		            renderer = axis.chart.renderer,
		            horiz = axis.horiz,
		            opposite = axis.opposite,
		            options = axis.options,
		            axisTitleOptions = options.title,
		            textAlign;

		        if (!axis.axisTitle) {
		            textAlign = axisTitleOptions.textAlign;
		            if (!textAlign) {
		                textAlign = (horiz ? {
		                    low: 'left',
		                    middle: 'center',
		                    high: 'right'
		                } : {
		                    low: opposite ? 'right' : 'left',
		                    middle: 'center',
		                    high: opposite ? 'left' : 'right'
		                })[axisTitleOptions.align];
		            }
		            axis.axisTitle = renderer.text(
		                axisTitleOptions.text,
		                0,
		                0,
		                axisTitleOptions.useHTML
		            )
		            .attr({
		                zIndex: 7,
		                rotation: axisTitleOptions.rotation || 0,
		                align: textAlign
		            })
		            .addClass('highcharts-axis-title')

		            // #7814, don't mutate style option
		            .css(merge(axisTitleOptions.style))

		            .add(axis.axisGroup);
		            axis.axisTitle.isNew = true;
		        }

		        // Max width defaults to the length of the axis

		        if (!axisTitleOptions.style.width && !axis.isRadial) {

		            axis.axisTitle.css({
		                width: axis.len
		            });

		        }


		        // hide or show the title depending on whether showEmpty is set
		        axis.axisTitle[display ? 'show' : 'hide'](true);
		    },

		    /**
		     * Generates a tick for initial positioning.
		     *
		     * @private
		     * @function Highcharts.Axis#generateTick
		     *
		     * @param {number} pos
		     *        The tick position in axis values.
		     *
		     * @param {number} i
		     *        The index of the tick in {@link Axis.tickPositions}.
		     */
		    generateTick: function (pos) {
		        var ticks = this.ticks;

		        if (!ticks[pos]) {
		            ticks[pos] = new Tick(this, pos);
		        } else {
		            ticks[pos].addLabel(); // update labels depending on tick interval
		        }
		    },

		    /**
		    /**
		     * Render the tick labels to a preliminary position to get their sizes
		     *
		     * @private
		     * @function Highcharts.Axis#getOffset
		     *
		     * @fires Highcharts.Axis#event:afterGetOffset
		     */
		    getOffset: function () {
		        var axis = this,
		            chart = axis.chart,
		            renderer = chart.renderer,
		            options = axis.options,
		            tickPositions = axis.tickPositions,
		            ticks = axis.ticks,
		            horiz = axis.horiz,
		            side = axis.side,
		            invertedSide = chart.inverted &&
		                !axis.isZAxis ? [1, 0, 3, 2][side] : side,
		            hasData,
		            showAxis,
		            titleOffset = 0,
		            titleOffsetOption,
		            titleMargin = 0,
		            axisTitleOptions = options.title,
		            labelOptions = options.labels,
		            labelOffset = 0, // reset
		            labelOffsetPadded,
		            axisOffset = chart.axisOffset,
		            clipOffset = chart.clipOffset,
		            clip,
		            directionFactor = [-1, 1, 1, -1][side],
		            className = options.className,
		            axisParent = axis.axisParent, // Used in color axis
		            lineHeightCorrection,
		            tickSize;

		        // For reuse in Axis.render
		        hasData = axis.hasData();
		        axis.showAxis = showAxis = hasData || pick(options.showEmpty, true);

		        // Set/reset staggerLines
		        axis.staggerLines = axis.horiz && labelOptions.staggerLines;

		        // Create the axisGroup and gridGroup elements on first iteration
		        if (!axis.axisGroup) {
		            axis.gridGroup = renderer.g('grid')
		                .attr({ zIndex: options.gridZIndex || 1 })
		                .addClass(
		                    'highcharts-' + this.coll.toLowerCase() + '-grid ' +
		                    (className || '')
		                )
		                .add(axisParent);
		            axis.axisGroup = renderer.g('axis')
		                .attr({ zIndex: options.zIndex || 2 })
		                .addClass(
		                    'highcharts-' + this.coll.toLowerCase() + ' ' +
		                    (className || '')
		                )
		                .add(axisParent);
		            axis.labelGroup = renderer.g('axis-labels')
		                .attr({ zIndex: labelOptions.zIndex || 7 })
		                .addClass(
		                    'highcharts-' + axis.coll.toLowerCase() + '-labels ' +
		                    (className || '')
		                )
		                .add(axisParent);
		        }

		        if (hasData || axis.isLinked) {

		            // Generate ticks
		            each(tickPositions, function (pos, i) {
		                // i is not used here, but may be used in overrides
		                axis.generateTick(pos, i);
		            });

		            axis.renderUnsquish();


		            // Left side must be align: right and right side must
		            // have align: left for labels
		            axis.reserveSpaceDefault = (
		                side === 0 ||
		                side === 2 ||
		                { 1: 'left', 3: 'right' }[side] === axis.labelAlign
		            );
		            if (pick(
		                labelOptions.reserveSpace,
		                axis.labelAlign === 'center' ? true : null,
		                axis.reserveSpaceDefault)
		            ) {
		                each(tickPositions, function (pos) {
		                    // get the highest offset
		                    labelOffset = Math.max(
		                        ticks[pos].getLabelSize(),
		                        labelOffset
		                    );
		                });
		            }

		            if (axis.staggerLines) {
		                labelOffset *= axis.staggerLines;
		            }
		            axis.labelOffset = labelOffset * (axis.opposite ? -1 : 1);

		        } else { // doesn't have data
		            objectEach(ticks, function (tick, n) {
		                tick.destroy();
		                delete ticks[n];
		            });
		        }

		        if (
		            axisTitleOptions &&
		            axisTitleOptions.text &&
		            axisTitleOptions.enabled !== false
		        ) {
		            axis.addTitle(showAxis);

		            if (showAxis && axisTitleOptions.reserveSpace !== false) {
		                axis.titleOffset = titleOffset =
		                    axis.axisTitle.getBBox()[horiz ? 'height' : 'width'];
		                titleOffsetOption = axisTitleOptions.offset;
		                titleMargin = defined(titleOffsetOption) ?
		                    0 :
		                    pick(axisTitleOptions.margin, horiz ? 5 : 10);
		            }
		        }

		        // Render the axis line
		        axis.renderLine();

		        // handle automatic or user set offset
		        axis.offset = directionFactor * pick(options.offset, axisOffset[side]);

		        axis.tickRotCorr = axis.tickRotCorr || { x: 0, y: 0 }; // polar
		        if (side === 0) {
		            lineHeightCorrection = -axis.labelMetrics().h;
		        } else if (side === 2) {
		            lineHeightCorrection = axis.tickRotCorr.y;
		        } else {
		            lineHeightCorrection = 0;
		        }

		        // Find the padded label offset
		        labelOffsetPadded = Math.abs(labelOffset) + titleMargin;
		        if (labelOffset) {
		            labelOffsetPadded -= lineHeightCorrection;
		            labelOffsetPadded += directionFactor * (
		                horiz ?
		                    pick(
		                        labelOptions.y,
		                        axis.tickRotCorr.y + directionFactor * 8
		                    ) :
		                    labelOptions.x
		            );
		        }

		        axis.axisTitleMargin = pick(titleOffsetOption, labelOffsetPadded);

		        if (axis.getMaxLabelDimensions) {
		            axis.maxLabelDimensions = axis.getMaxLabelDimensions(
		                ticks,
		                tickPositions
		            );
		        }

		        // Due to GridAxis.tickSize, tickSize should be calculated after ticks
		        // has rendered.
		        tickSize = this.tickSize('tick');

		        axisOffset[side] = Math.max(
		            axisOffset[side],
		            axis.axisTitleMargin + titleOffset + directionFactor * axis.offset,
		            labelOffsetPadded, // #3027
		            hasData && tickPositions.length && tickSize ?
		                tickSize[0] + directionFactor * axis.offset :
		                0 // #4866
		        );

		        // Decide the clipping needed to keep the graph inside
		        // the plot area and axis lines
		        clip = options.offset ?
		            0 :
		            Math.floor(axis.axisLine.strokeWidth() / 2) * 2; // #4308, #4371
		        clipOffset[invertedSide] = Math.max(clipOffset[invertedSide], clip);

		        fireEvent(this, 'afterGetOffset');
		    },

		    /**
		     * Internal function to get the path for the axis line. Extended for polar
		     * charts.
		     *
		     * @function Highcharts.Axis#getLinePath
		     *
		     * @param {number} lineWidth
		     *        The line width in pixels.
		     *
		     * @return {Highcharts.SVGPathArray}
		     *         The SVG path definition in array form.
		     */
		    getLinePath: function (lineWidth) {
		        var chart = this.chart,
		            opposite = this.opposite,
		            offset = this.offset,
		            horiz = this.horiz,
		            lineLeft = this.left + (opposite ? this.width : 0) + offset,
		            lineTop = chart.chartHeight - this.bottom -
		                (opposite ? this.height : 0) + offset;

		        if (opposite) {
		            lineWidth *= -1; // crispify the other way - #1480, #1687
		        }

		        return chart.renderer
		            .crispLine([
		                'M',
		                horiz ?
		                    this.left :
		                    lineLeft,
		                horiz ?
		                    lineTop :
		                    this.top,
		                'L',
		                horiz ?
		                    chart.chartWidth - this.right :
		                    lineLeft,
		                horiz ?
		                    lineTop :
		                    chart.chartHeight - this.bottom
		            ], lineWidth);
		    },

		    /**
		     * Render the axis line. Called internally when rendering and redrawing the
		     * axis.
		     *
		     * @function Highcharts.Axis#renderLine
		     */
		    renderLine: function () {
		        if (!this.axisLine) {
		            this.axisLine = this.chart.renderer.path()
		                .addClass('highcharts-axis-line')
		                .add(this.axisGroup);


		            this.axisLine.attr({
		                stroke: this.options.lineColor,
		                'stroke-width': this.options.lineWidth,
		                zIndex: 7
		            });

		        }
		    },

		    /**
		     * Position the axis title.
		     *
		     * @private
		     * @function Highcharts.Axis#getTitlePosition
		     *
		     * @return {Highcharts.AxisTitlePositionObject}
		     *         X and Y positions for the title.
		     */
		    getTitlePosition: function () {
		        // compute anchor points for each of the title align options
		        var horiz = this.horiz,
		            axisLeft = this.left,
		            axisTop = this.top,
		            axisLength = this.len,
		            axisTitleOptions = this.options.title,
		            margin = horiz ? axisLeft : axisTop,
		            opposite = this.opposite,
		            offset = this.offset,
		            xOption = axisTitleOptions.x || 0,
		            yOption = axisTitleOptions.y || 0,
		            axisTitle = this.axisTitle,
		            fontMetrics = this.chart.renderer.fontMetrics(
		                axisTitleOptions.style && axisTitleOptions.style.fontSize,
		                axisTitle
		            ),
		            // The part of a multiline text that is below the baseline of the
		            // first line. Subtract 1 to preserve pixel-perfectness from the
		            // old behaviour (v5.0.12), where only one line was allowed.
		            textHeightOvershoot = Math.max(
		                axisTitle.getBBox(null, 0).height - fontMetrics.h - 1,
		                0
		            ),

		            // the position in the length direction of the axis
		            alongAxis = {
		                low: margin + (horiz ? 0 : axisLength),
		                middle: margin + axisLength / 2,
		                high: margin + (horiz ? axisLength : 0)
		            }[axisTitleOptions.align],

		            // the position in the perpendicular direction of the axis
		            offAxis = (horiz ? axisTop + this.height : axisLeft) +
		                (horiz ? 1 : -1) * // horizontal axis reverses the margin
		                (opposite ? -1 : 1) * // so does opposite axes
		                this.axisTitleMargin +
		                [
		                    -textHeightOvershoot, // top
		                    textHeightOvershoot, // right
		                    fontMetrics.f, // bottom
		                    -textHeightOvershoot // left
		                ][this.side];


		        return {
		            x: horiz ?
		                alongAxis + xOption :
		                offAxis + (opposite ? this.width : 0) + offset + xOption,
		            y: horiz ?
		                offAxis + yOption - (opposite ? this.height : 0) + offset :
		                alongAxis + yOption
		        };
		    },

		    /**
		     * Render a minor tick into the given position. If a minor tick already
		     * exists in this position, move it.
		     *
		     * @function Highcharts.Axis#renderMinorTick
		     *
		     * @param {number} pos
		     *        The position in axis values.
		     */
		    renderMinorTick: function (pos) {
		        var slideInTicks = this.chart.hasRendered && isNumber(this.oldMin),
		            minorTicks = this.minorTicks;

		        if (!minorTicks[pos]) {
		            minorTicks[pos] = new Tick(this, pos, 'minor');
		        }

		        // Render new ticks in old position
		        if (slideInTicks && minorTicks[pos].isNew) {
		            minorTicks[pos].render(null, true);
		        }

		        minorTicks[pos].render(null, false, 1);
		    },

		    /**
		     * Render a major tick into the given position. If a tick already exists
		     * in this position, move it.
		     *
		     * @function Highcharts.Axis#renderTick
		     *
		     * @param {number} pos
		     *        The position in axis values.
		     *
		     * @param {number} i
		     *        The tick index.
		     */
		    renderTick: function (pos, i) {
		        var isLinked = this.isLinked,
		            ticks = this.ticks,
		            slideInTicks = this.chart.hasRendered && isNumber(this.oldMin);

		        // Linked axes need an extra check to find out if
		        if (!isLinked || (pos >= this.min && pos <= this.max)) {

		            if (!ticks[pos]) {
		                ticks[pos] = new Tick(this, pos);
		            }
		            // NOTE this seems like overkill. Could be handled in tick.render by
		            // setting old position in attr, then set new position in animate.
		            // render new ticks in old position
		            if (slideInTicks && ticks[pos].isNew) {
		                // Start with negative opacity so that it is visible from
		                // halfway into the animation
		                ticks[pos].render(i, true, -1);
		            }

		            ticks[pos].render(i);
		        }
		    },

		    /**
		     * Render the axis.
		     *
		     * @private
		     * @function Highcharts.Axis#render
		     *
		     * @fires Highcharts.Axis#event:afterRender
		     */
		    render: function () {
		        var axis = this,
		            chart = axis.chart,
		            renderer = chart.renderer,
		            options = axis.options,
		            isLog = axis.isLog,
		            isLinked = axis.isLinked,
		            tickPositions = axis.tickPositions,
		            axisTitle = axis.axisTitle,
		            ticks = axis.ticks,
		            minorTicks = axis.minorTicks,
		            alternateBands = axis.alternateBands,
		            stackLabelOptions = options.stackLabels,
		            alternateGridColor = options.alternateGridColor,
		            tickmarkOffset = axis.tickmarkOffset,
		            axisLine = axis.axisLine,
		            showAxis = axis.showAxis,
		            animation = animObject(renderer.globalAnimation),
		            from,
		            to;

		        // Reset
		        axis.labelEdge.length = 0;
		        axis.overlap = false;

		        // Mark all elements inActive before we go over and mark the active ones
		        each([ticks, minorTicks, alternateBands], function (coll) {
		            objectEach(coll, function (tick) {
		                tick.isActive = false;
		            });
		        });

		        // If the series has data draw the ticks. Else only the line and title
		        if (axis.hasData() || isLinked) {

		            // minor ticks
		            if (axis.minorTickInterval && !axis.categories) {
		                each(axis.getMinorTickPositions(), function (pos) {
		                    axis.renderMinorTick(pos);
		                });
		            }

		            // Major ticks. Pull out the first item and render it last so that
		            // we can get the position of the neighbour label. #808.
		            if (tickPositions.length) { // #1300
		                each(tickPositions, function (pos, i) {
		                    axis.renderTick(pos, i);
		                });
		                // In a categorized axis, the tick marks are displayed
		                // between labels. So we need to add a tick mark and
		                // grid line at the left edge of the X axis.
		                if (tickmarkOffset && (axis.min === 0 || axis.single)) {
		                    if (!ticks[-1]) {
		                        ticks[-1] = new Tick(axis, -1, null, true);
		                    }
		                    ticks[-1].render(-1);
		                }

		            }

		            // alternate grid color
		            if (alternateGridColor) {
		                each(tickPositions, function (pos, i) {
		                    to = tickPositions[i + 1] !== undefined ?
		                        tickPositions[i + 1] + tickmarkOffset :
		                        axis.max - tickmarkOffset;

		                    if (
		                        i % 2 === 0 &&
		                        pos < axis.max &&
		                        to <= axis.max + (
		                            chart.polar ?
		                                -tickmarkOffset :
		                                tickmarkOffset
		                        )
		                    ) { // #2248, #4660
		                        if (!alternateBands[pos]) {
		                            alternateBands[pos] = new H.PlotLineOrBand(axis);
		                        }
		                        from = pos + tickmarkOffset; // #949
		                        alternateBands[pos].options = {
		                            from: isLog ? axis.lin2log(from) : from,
		                            to: isLog ? axis.lin2log(to) : to,
		                            color: alternateGridColor
		                        };
		                        alternateBands[pos].render();
		                        alternateBands[pos].isActive = true;
		                    }
		                });
		            }

		            // custom plot lines and bands
		            if (!axis._addedPlotLB) { // only first time
		                each(
		                    (options.plotLines || []).concat(options.plotBands || []),
		                    function (plotLineOptions) {
		                        axis.addPlotBandOrLine(plotLineOptions);
		                    }
		                );
		                axis._addedPlotLB = true;
		            }

		        } // end if hasData

		        // Remove inactive ticks
		        each([ticks, minorTicks, alternateBands], function (coll) {
		            var i,
		                forDestruction = [],
		                delay = animation.duration,
		                destroyInactiveItems = function () {
		                    i = forDestruction.length;
		                    while (i--) {
		                        // When resizing rapidly, the same items
		                        // may be destroyed in different timeouts,
		                        // or the may be reactivated
		                        if (
		                            coll[forDestruction[i]] &&
		                            !coll[forDestruction[i]].isActive
		                        ) {
		                            coll[forDestruction[i]].destroy();
		                            delete coll[forDestruction[i]];
		                        }
		                    }

		                };

		            objectEach(coll, function (tick, pos) {
		                if (!tick.isActive) {
		                    // Render to zero opacity
		                    tick.render(pos, false, 0);
		                    tick.isActive = false;
		                    forDestruction.push(pos);
		                }
		            });

		            // When the objects are finished fading out, destroy them
		            syncTimeout(
		                destroyInactiveItems,
		                coll === alternateBands ||
		                    !chart.hasRendered ||
		                    !delay ?
		                        0 :
		                        delay
		            );
		        });

		        // Set the axis line path
		        if (axisLine) {
		            axisLine[axisLine.isPlaced ? 'animate' : 'attr']({
		                d: this.getLinePath(axisLine.strokeWidth())
		            });
		            axisLine.isPlaced = true;

		            // Show or hide the line depending on options.showEmpty
		            axisLine[showAxis ? 'show' : 'hide'](true);
		        }

		        if (axisTitle && showAxis) {
		            var titleXy = axis.getTitlePosition();
		            if (isNumber(titleXy.y)) {
		                axisTitle[axisTitle.isNew ? 'attr' : 'animate'](titleXy);
		                axisTitle.isNew = false;
		            } else {
		                axisTitle.attr('y', -9999);
		                axisTitle.isNew = true;
		            }
		        }

		        // Stacked totals:
		        if (stackLabelOptions && stackLabelOptions.enabled) {
		            axis.renderStackTotals();
		        }
		        // End stacked totals

		        axis.isDirty = false;

		        fireEvent(this, 'afterRender');
		    },

		    /**
		     * Redraw the axis to reflect changes in the data or axis extremes. Called
		     * internally from {@link Chart#redraw}.
		     *
		     * @private
		     * @function Highcharts.Axis#redraw
		     */
		    redraw: function () {

		        if (this.visible) {
		            // render the axis
		            this.render();

		            // move plot lines and bands
		            each(this.plotLinesAndBands, function (plotLine) {
		                plotLine.render();
		            });
		        }

		        // mark associated series as dirty and ready for redraw
		        each(this.series, function (series) {
		            series.isDirty = true;
		        });

		    },

		    // Properties to survive after destroy, needed for Axis.update (#4317,
		    // #5773, #5881).
		    keepProps: ['extKey', 'hcEvents', 'names', 'series', 'userMax', 'userMin'],

		    /**
		     * Destroys an Axis instance. See {@link Axis#remove} for the API endpoint
		     * to fully remove the axis.
		     *
		     * @private
		     * @function Highcharts.Axis#destroy
		     *
		     * @param {boolean} keepEvents
		     *        Whether to preserve events, used internally in Axis.update.
		     */
		    destroy: function (keepEvents) {
		        var axis = this,
		            stacks = axis.stacks,
		            plotLinesAndBands = axis.plotLinesAndBands,
		            plotGroup,
		            i;

		        fireEvent(this, 'destroy', { keepEvents: keepEvents });

		        // Remove the events
		        if (!keepEvents) {
		            removeEvent(axis);
		        }

		        // Destroy each stack total
		        objectEach(stacks, function (stack, stackKey) {
		            destroyObjectProperties(stack);

		            stacks[stackKey] = null;
		        });

		        // Destroy collections
		        each(
		            [axis.ticks, axis.minorTicks, axis.alternateBands],
		            function (coll) {
		                destroyObjectProperties(coll);
		            }
		        );
		        if (plotLinesAndBands) {
		            i = plotLinesAndBands.length;
		            while (i--) { // #1975
		                plotLinesAndBands[i].destroy();
		            }
		        }

		        // Destroy elements
		        each(
		            ['stackTotalGroup', 'axisLine', 'axisTitle', 'axisGroup',
		                'gridGroup', 'labelGroup', 'cross', 'scrollbar'],
		            function (prop) {
		                if (axis[prop]) {
		                    axis[prop] = axis[prop].destroy();
		                }
		            }
		        );

		        // Destroy each generated group for plotlines and plotbands
		        for (plotGroup in axis.plotLinesAndBandsGroups) {
		            axis.plotLinesAndBandsGroups[plotGroup] =
		                axis.plotLinesAndBandsGroups[plotGroup].destroy();
		        }

		        // Delete all properties and fall back to the prototype.
		        objectEach(axis, function (val, key) {
		            if (inArray(key, axis.keepProps) === -1) {
		                delete axis[key];
		            }
		        });
		    },

		    /**
		     * Internal function to draw a crosshair.
		     *
		     * @function Highcharts.Axis#drawCrosshair
		     *
		     * @param {Highcharts.PointerEventObject} [e]
		     *        The event arguments from the modified pointer event, extended with
		     *        `chartX` and `chartY`
		     *
		     * @param {Highcharts.Point} [point]
		     *        The Point object if the crosshair snaps to points.
		     *
		     * @fires Highcharts.Axis#event:afterDrawCrosshair
		     * @fires Highcharts.Axis#event:drawCrosshair
		     */
		    drawCrosshair: function (e, point) {

		        var path,
		            options = this.crosshair,
		            snap = pick(options.snap, true),
		            pos,
		            categorized,
		            graphic = this.cross;

		        fireEvent(this, 'drawCrosshair', { e: e, point: point });

		        // Use last available event when updating non-snapped crosshairs without
		        // mouse interaction (#5287)
		        if (!e) {
		            e = this.cross && this.cross.e;
		        }

		        if (
		            // Disabled in options
		            !this.crosshair ||
		            // Snap
		            ((defined(point) || !snap) === false)
		        ) {
		            this.hideCrosshair();
		        } else {

		            // Get the path
		            if (!snap) {
		                pos = e &&
		                    (
		                        this.horiz ?
		                            e.chartX - this.pos :
		                            this.len - e.chartY + this.pos
		                    );
		            } else if (defined(point)) {
		                // #3834
		                pos = pick(
		                    point.crosshairPos, // 3D axis extension
		                    this.isXAxis ? point.plotX : this.len - point.plotY
		                );
		            }

		            if (defined(pos)) {
		                path = this.getPlotLinePath(
		                    // First argument, value, only used on radial
		                    point && (this.isXAxis ?
		                        point.x :
		                        pick(point.stackY, point.y)
		                    ),
		                    null,
		                    null,
		                    null,
		                    pos // Translated position
		                ) || null; // #3189
		            }

		            if (!defined(path)) {
		                this.hideCrosshair();
		                return;
		            }

		            categorized = this.categories && !this.isRadial;

		            // Draw the cross
		            if (!graphic) {
		                this.cross = graphic = this.chart.renderer
		                    .path()
		                    .addClass(
		                        'highcharts-crosshair highcharts-crosshair-' +
		                        (categorized ? 'category ' : 'thin ') +
		                        options.className
		                    )
		                    .attr({
		                        zIndex: pick(options.zIndex, 2)
		                    })
		                    .add();


		                // Presentational attributes
		                graphic.attr({
		                    'stroke': options.color ||
		                        (
		                            categorized ?
		                                color('#ccd6eb')
		                                    .setOpacity(0.25).get() :
		                                '#cccccc'
		                        ),
		                    'stroke-width': pick(options.width, 1)
		                }).css({
		                    'pointer-events': 'none'
		                });
		                if (options.dashStyle) {
		                    graphic.attr({
		                        dashstyle: options.dashStyle
		                    });
		                }


		            }

		            graphic.show().attr({
		                d: path
		            });

		            if (categorized && !options.width) {
		                graphic.attr({
		                    'stroke-width': this.transA
		                });
		            }
		            this.cross.e = e;
		        }

		        fireEvent(this, 'afterDrawCrosshair', { e: e, point: point });
		    },

		    /**
		     * Hide the crosshair if visible.
		     *
		     * @function Highcharts.Axis#hideCrosshair
		     */
		    hideCrosshair: function () {
		        if (this.cross) {
		            this.cross.hide();
		        }
		    }
		}); // end Axis

		H.Axis = Axis;

		return Axis;
	}(Highcharts));
	(function (H) {
		/**
		 * (c) 2010-2018 Torstein Honsi
		 *
		 * License: www.highcharts.com/license
		 */



		var Axis = H.Axis,
		    getMagnitude = H.getMagnitude,
		    normalizeTickInterval = H.normalizeTickInterval,
		    timeUnits = H.timeUnits;

		/**
		 * Set the tick positions to a time unit that makes sense, for example
		 * on the first of each month or on every Monday. Return an array
		 * with the time positions. Used in datetime axes as well as for grouping
		 * data on a datetime axis.
		 *
		 * @private
		 * @function Highcharts.Axis#getTimeTicks
		 *
		 * @param {*} normalizedInterval
		 *        The interval in axis values (ms) and thecount
		 *
		 * @param {number} min
		 *        The minimum in axis values
		 *
		 * @param {number} max
		 *        The maximum in axis values
		 *
		 * @param {number} startOfWeek
		 *
		 * @return {number}
		 */
		Axis.prototype.getTimeTicks = function () {
		    return this.chart.time.getTimeTicks.apply(this.chart.time, arguments);
		};

		/**
		 * Get a normalized tick interval for dates. Returns a configuration object with
		 * unit range (interval), count and name. Used to prepare data for getTimeTicks.
		 * Previously this logic was part of getTimeTicks, but as getTimeTicks now runs
		 * of segments in stock charts, the normalizing logic was extracted in order to
		 * prevent it for running over again for each segment having the same interval.
		 * #662, #697.
		 *
		 * @private
		 * @function Highcharts.Axis#normalizeTimeTickInterval
		 *
		 * @param {number} tickInterval
		 *
		 * @param {Array<Array<number|string>>} [unitsOption]
		 *
		 * @return {*}
		 */
		Axis.prototype.normalizeTimeTickInterval = function (
		    tickInterval,
		    unitsOption
		) {
		    var units = unitsOption || [[
		            'millisecond', // unit name
		            [1, 2, 5, 10, 20, 25, 50, 100, 200, 500] // allowed multiples
		        ], [
		            'second',
		            [1, 2, 5, 10, 15, 30]
		        ], [
		            'minute',
		            [1, 2, 5, 10, 15, 30]
		        ], [
		            'hour',
		            [1, 2, 3, 4, 6, 8, 12]
		        ], [
		            'day',
		            [1, 2]
		        ], [
		            'week',
		            [1, 2]
		        ], [
		            'month',
		            [1, 2, 3, 4, 6]
		        ], [
		            'year',
		            null
		        ]],
		        unit = units[units.length - 1], // default unit is years
		        interval = timeUnits[unit[0]],
		        multiples = unit[1],
		        count,
		        i;

		    // loop through the units to find the one that best fits the tickInterval
		    for (i = 0; i < units.length; i++) {
		        unit = units[i];
		        interval = timeUnits[unit[0]];
		        multiples = unit[1];


		        if (units[i + 1]) {
		            // lessThan is in the middle between the highest multiple and the
		            // next unit.
		            var lessThan = (interval * multiples[multiples.length - 1] +
		                        timeUnits[units[i + 1][0]]) / 2;

		            // break and keep the current unit
		            if (tickInterval <= lessThan) {
		                break;
		            }
		        }
		    }

		    // prevent 2.5 years intervals, though 25, 250 etc. are allowed
		    if (interval === timeUnits.year && tickInterval < 5 * interval) {
		        multiples = [1, 2, 5];
		    }

		    // get the count
		    count = normalizeTickInterval(
		        tickInterval / interval,
		        multiples,
		        unit[0] === 'year' ?
		            Math.max(getMagnitude(tickInterval / interval), 1) : // #1913, #2360
		            1
		    );

		    return {
		        unitRange: interval,
		        count: count,
		        unitName: unit[0]
		    };
		};

	}(Highcharts));
	(function (H) {
		/**
		 * (c) 2010-2018 Torstein Honsi
		 *
		 * License: www.highcharts.com/license
		 */



		var Axis = H.Axis,
		    getMagnitude = H.getMagnitude,
		    map = H.map,
		    normalizeTickInterval = H.normalizeTickInterval,
		    pick = H.pick;

		/*
		 * Methods defined on the Axis prototype
		 */

		/**
		 * Set the tick positions of a logarithmic axis.
		 *
		 * @private
		 * @function Highcharts.Axis#getLogTickPositions
		 *
		 * @param {number} interval
		 *
		 * @param {number} min
		 *
		 * @param {number} max
		 *
		 * @param {number} minor
		 *
		 * @return {Array<number>}
		 */
		Axis.prototype.getLogTickPositions = function (interval, min, max, minor) {
		    var axis = this,
		        options = axis.options,
		        axisLength = axis.len,
		        // Since we use this method for both major and minor ticks,
		        // use a local variable and return the result
		        positions = [];

		    // Reset
		    if (!minor) {
		        axis._minorAutoInterval = null;
		    }

		    // First case: All ticks fall on whole logarithms: 1, 10, 100 etc.
		    if (interval >= 0.5) {
		        interval = Math.round(interval);
		        positions = axis.getLinearTickPositions(interval, min, max);

		    // Second case: We need intermediary ticks. For example
		    // 1, 2, 4, 6, 8, 10, 20, 40 etc.
		    } else if (interval >= 0.08) {
		        var roundedMin = Math.floor(min),
		            intermediate,
		            i,
		            j,
		            len,
		            pos,
		            lastPos,
		            break2;

		        if (interval > 0.3) {
		            intermediate = [1, 2, 4];

		        // 0.2 equals five minor ticks per 1, 10, 100 etc
		        } else if (interval > 0.15) {
		            intermediate = [1, 2, 4, 6, 8];
		        } else { // 0.1 equals ten minor ticks per 1, 10, 100 etc
		            intermediate = [1, 2, 3, 4, 5, 6, 7, 8, 9];
		        }

		        for (i = roundedMin; i < max + 1 && !break2; i++) {
		            len = intermediate.length;
		            for (j = 0; j < len && !break2; j++) {
		                pos = axis.log2lin(axis.lin2log(i) * intermediate[j]);
		                // #1670, lastPos is #3113
		                if (
		                    pos > min &&
		                    (!minor || lastPos <= max) &&
		                    lastPos !== undefined
		                ) {
		                    positions.push(lastPos);
		                }

		                if (lastPos > max) {
		                    break2 = true;
		                }
		                lastPos = pos;
		            }
		        }

		    // Third case: We are so deep in between whole logarithmic values that
		    // we might as well handle the tick positions like a linear axis. For
		    // example 1.01, 1.02, 1.03, 1.04.
		    } else {
		        var realMin = axis.lin2log(min),
		            realMax = axis.lin2log(max),
		            tickIntervalOption = minor ?
		                this.getMinorTickInterval() :
		                options.tickInterval,
		            filteredTickIntervalOption = tickIntervalOption === 'auto' ?
		                null :
		                tickIntervalOption,
		            tickPixelIntervalOption =
		                options.tickPixelInterval / (minor ? 5 : 1),
		            totalPixelLength = minor ?
		                axisLength / axis.tickPositions.length :
		                axisLength;

		        interval = pick(
		            filteredTickIntervalOption,
		            axis._minorAutoInterval,
		            (realMax - realMin) *
		                tickPixelIntervalOption / (totalPixelLength || 1)
		        );

		        interval = normalizeTickInterval(
		            interval,
		            null,
		            getMagnitude(interval)
		        );

		        positions = map(axis.getLinearTickPositions(
		            interval,
		            realMin,
		            realMax
		        ), axis.log2lin);

		        if (!minor) {
		            axis._minorAutoInterval = interval / 5;
		        }
		    }

		    // Set the axis-level tickInterval variable
		    if (!minor) {
		        axis.tickInterval = interval;
		    }
		    return positions;
		};

		/**
		 * @private
		 * @function Highcharts.Axis#log2lin
		 *
		 * @param {number} num
		 *
		 * @return {number}
		 */
		Axis.prototype.log2lin = function (num) {
		    return Math.log(num) / Math.LN10;
		};

		/**
		 * @private
		 * @function Highcharts.Axis#lin2log
		 *
		 * @param {number} num
		 *
		 * @return {number}
		 */
		Axis.prototype.lin2log = function (num) {
		    return Math.pow(10, num);
		};

	}(Highcharts));
	(function (H, Axis) {
		/**
		 * (c) 2010-2018 Torstein Honsi
		 *
		 * License: www.highcharts.com/license
		 */

		/**
		 * Options for plot bands on axes.
		 *
		 * @typedef {Highcharts.XAxisPlotBandsOptions|Highcharts.YAxisPlotBandsOptions|Highcharts.ZAxisPlotBandsOptions} Highcharts.AxisPlotBandsOptions
		 */

		/**
		 * Options for plot band labels on axes.
		 *
		 * @typedef {Highcharts.XAxisPlotBandsLabelOptions|Highcharts.YAxisPlotBandsLabelOptions|Highcharts.ZAxisPlotBandsLabelOptions} Highcharts.AxisPlotBandsLabelOptions
		 */

		/**
		 * Options for plot lines on axes.
		 *
		 * @typedef {Highcharts.XAxisPlotLinesOptions|Highcharts.YAxisPlotLinesOptions|Highcharts.ZAxisPlotLinesOptions} Highcharts.AxisPlotLinesOptions
		 */

		/**
		 * Options for plot line labels on axes.
		 *
		 * @typedef {Highcharts.XAxisPlotLinesLabelOptions|Highcharts.YAxisPlotLinesLabelOptions|Highcharts.ZAxisPlotLinesLabelOptions} Highcharts.AxisPlotLinesLabelOptions
		 */



		var arrayMax = H.arrayMax,
		    arrayMin = H.arrayMin,
		    defined = H.defined,
		    destroyObjectProperties = H.destroyObjectProperties,
		    each = H.each,
		    erase = H.erase,
		    merge = H.merge,
		    pick = H.pick;

		/**
		 * The object wrapper for plot lines and plot bands
		 *
		 * @class
		 * @name Highcharts.PlotLineOrBand
		 *
		 * @param {Highcharts.Axis} axis
		 *
		 * @param {Highcharts.AxisPlotLinesOptions|Highcharts.AxisPlotBandsOptions} options
		 */
		H.PlotLineOrBand = function (axis, options) {
		    this.axis = axis;

		    if (options) {
		        this.options = options;
		        this.id = options.id;
		    }
		};

		H.PlotLineOrBand.prototype = {

		    /**
		     * Render the plot line or plot band. If it is already existing,
		     * move it.
		     *
		     * @private
		     * @function Highcharts.PlotLineOrBand#render
		     *
		     * @return {Highcharts.PlotLineOrBand|undefined}
		     */
		    render: function () {

		        H.fireEvent(this, 'render');

		        var plotLine = this,
		            axis = plotLine.axis,
		            horiz = axis.horiz,
		            options = plotLine.options,
		            optionsLabel = options.label,
		            label = plotLine.label,
		            to = options.to,
		            from = options.from,
		            value = options.value,
		            isBand = defined(from) && defined(to),
		            isLine = defined(value),
		            svgElem = plotLine.svgElem,
		            isNew = !svgElem,
		            path = [],
		            color = options.color,
		            zIndex = pick(options.zIndex, 0),
		            events = options.events,
		            attribs = {
		                'class': 'highcharts-plot-' + (isBand ? 'band ' : 'line ') +
		                    (options.className || '')
		            },
		            groupAttribs = {},
		            renderer = axis.chart.renderer,
		            groupName = isBand ? 'bands' : 'lines',
		            group;

		        // logarithmic conversion
		        if (axis.isLog) {
		            from = axis.log2lin(from);
		            to = axis.log2lin(to);
		            value = axis.log2lin(value);
		        }


		        // Set the presentational attributes
		        if (isLine) {
		            attribs.stroke = color;
		            attribs['stroke-width'] = options.width;
		            if (options.dashStyle) {
		                attribs.dashstyle = options.dashStyle;
		            }

		        } else if (isBand) { // plot band
		            if (color) {
		                attribs.fill = color;
		            }
		            if (options.borderWidth) {
		                attribs.stroke = options.borderColor;
		                attribs['stroke-width'] = options.borderWidth;
		            }
		        }


		        // Grouping and zIndex
		        groupAttribs.zIndex = zIndex;
		        groupName += '-' + zIndex;

		        group = axis.plotLinesAndBandsGroups[groupName];
		        if (!group) {
		            axis.plotLinesAndBandsGroups[groupName] = group =
		                renderer.g('plot-' + groupName)
		                    .attr(groupAttribs).add();
		        }

		        // Create the path
		        if (isNew) {
		            /**
		             * SVG element of the plot line or band.
		             *
		             * @name Highcharts.PlotLineOrBand#svgElement
		             * @type {Highcharts.SVGElement}
		             */
		            plotLine.svgElem = svgElem =
		                renderer
		                    .path()
		                    .attr(attribs).add(group);
		        }


		        // Set the path or return
		        if (isLine) {
		            path = axis.getPlotLinePath(value, svgElem.strokeWidth());
		        } else if (isBand) { // plot band
		            path = axis.getPlotBandPath(from, to, options);
		        } else {
		            return;
		        }


		        // common for lines and bands
		        if (isNew && path && path.length) {
		            svgElem.attr({ d: path });

		            // events
		            if (events) {
		                H.objectEach(events, function (event, eventType) {
		                    svgElem.on(eventType, function (e) {
		                        events[eventType].apply(plotLine, [e]);
		                    });
		                });
		            }
		        } else if (svgElem) {
		            if (path) {
		                svgElem.show();
		                svgElem.animate({ d: path });
		            } else {
		                svgElem.hide();
		                if (label) {
		                    plotLine.label = label = label.destroy();
		                }
		            }
		        }

		        // the plot band/line label
		        if (
		            optionsLabel &&
		            defined(optionsLabel.text) &&
		            path &&
		            path.length &&
		            axis.width > 0 &&
		            axis.height > 0 &&
		            !path.isFlat
		        ) {
		            // apply defaults
		            optionsLabel = merge({
		                align: horiz && isBand && 'center',
		                x: horiz ? !isBand && 4 : 10,
		                verticalAlign: !horiz && isBand && 'middle',
		                y: horiz ? isBand ? 16 : 10 : isBand ? 6 : -4,
		                rotation: horiz && !isBand && 90
		            }, optionsLabel);

		            this.renderLabel(optionsLabel, path, isBand, zIndex);

		        } else if (label) { // move out of sight
		            label.hide();
		        }

		        // chainable
		        return plotLine;
		    },

		    /**
		     * Render and align label for plot line or band.
		     *
		     * @private
		     * @function Highcharts.PlotLineOrBand#renderLabel
		     *
		     * @param {Highcharts.AxisPlotLinesLabelOptions|Highcharts.AxisPlotBandsLabelOptions} optionsLabel
		     *
		     * @param {Highcharts.SVGPathArray} path
		     *
		     * @param {boolean} [isBand]
		     *
		     * @param {number} [zIndex]
		     */
		    renderLabel: function (optionsLabel, path, isBand, zIndex) {
		        var plotLine = this,
		            label = plotLine.label,
		            renderer = plotLine.axis.chart.renderer,
		            attribs,
		            xBounds,
		            yBounds,
		            x,
		            y;

		        // add the SVG element
		        if (!label) {
		            attribs = {
		                align: optionsLabel.textAlign || optionsLabel.align,
		                rotation: optionsLabel.rotation,
		                'class': 'highcharts-plot-' + (isBand ? 'band' : 'line') +
		                    '-label ' + (optionsLabel.className || '')
		            };

		            attribs.zIndex = zIndex;

		            /**
		             * SVG element of the label.
		             *
		             * @name Highcharts.PlotLineOrBand#label
		             * @type {Highcharts.SVGElement}
		             */
		            plotLine.label = label = renderer.text(
		                    optionsLabel.text,
		                    0,
		                    0,
		                    optionsLabel.useHTML
		                )
		                .attr(attribs)
		                .add();


		            label.css(optionsLabel.style);

		        }

		        // get the bounding box and align the label
		        // #3000 changed to better handle choice between plotband or plotline
		        xBounds = path.xBounds ||
		            [path[1], path[4], (isBand ? path[6] : path[1])];
		        yBounds = path.yBounds ||
		            [path[2], path[5], (isBand ? path[7] : path[2])];

		        x = arrayMin(xBounds);
		        y = arrayMin(yBounds);

		        label.align(optionsLabel, false, {
		            x: x,
		            y: y,
		            width: arrayMax(xBounds) - x,
		            height: arrayMax(yBounds) - y
		        });
		        label.show();
		    },

		    /**
		     * Remove the plot line or band.
		     *
		     * @function Highcharts.PlotLineOrBand#destroy
		     */
		    destroy: function () {
		        // remove it from the lookup
		        erase(this.axis.plotLinesAndBands, this);

		        delete this.axis;
		        destroyObjectProperties(this);
		    }
		};

		// Object with members for extending the Axis prototype
		H.extend(Axis.prototype, /** @lends Highcharts.Axis.prototype */ {

		    /**
		     * An array of colored bands stretching across the plot area marking an
		     * interval on the axis.
		     *
		     * In styled mode, the plot bands are styled by the `.highcharts-plot-band`
		     * class in addition to the `className` option.
		     *
		     * @productdesc {highcharts}
		     * In a gauge, a plot band on the Y axis (value axis) will stretch along the
		     * perimeter of the gauge.
		     *
		     * @type      {Array<*>}
		     * @product   highcharts highstock gantt
		     * @apioption xAxis.plotBands
		     */

		    /**
		     * Border color for the plot band. Also requires `borderWidth` to be set.
		     *
		     * @type      {Highcharts.ColorString}
		     * @apioption xAxis.plotBands.borderColor
		     */

		    /**
		     * Border width for the plot band. Also requires `borderColor` to be set.
		     *
		     * @type      {number}
		     * @default   0
		     * @apioption xAxis.plotBands.borderWidth
		     */

		    /**
		     * A custom class name, in addition to the default `highcharts-plot-band`,
		     * to apply to each individual band.
		     *
		     * @type      {string}
		     * @since     5.0.0
		     * @apioption xAxis.plotBands.className
		     */

		    /**
		     * The color of the plot band.
		     *
		     * @sample {highcharts} highcharts/xaxis/plotbands-color/
		     *         Color band
		     * @sample {highstock} stock/xaxis/plotbands/
		     *         Plot band on Y axis
		     *
		     * @type      {Highcharts.ColorString}
		     * @apioption xAxis.plotBands.color
		     */

		    /**
		     * An object defining mouse events for the plot band. Supported properties
		     * are `click`, `mouseover`, `mouseout`, `mousemove`.
		     *
		     * @sample {highcharts} highcharts/xaxis/plotbands-events/
		     *         Mouse events demonstrated
		     *
		     * @since     1.2
		     * @context   PlotLineOrBand
		     * @apioption xAxis.plotBands.events
		     */

		    /**
		     * The start position of the plot band in axis units.
		     *
		     * @sample {highcharts} highcharts/xaxis/plotbands-color/
		     *         Datetime axis
		     * @sample {highcharts} highcharts/xaxis/plotbands-from/
		     *         Categorized axis
		     * @sample {highstock} stock/xaxis/plotbands/
		     *         Plot band on Y axis
		     *
		     * @type      {number}
		     * @apioption xAxis.plotBands.from
		     */

		    /**
		     * An id used for identifying the plot band in Axis.removePlotBand.
		     *
		     * @sample {highcharts} highcharts/xaxis/plotbands-id/
		     *         Remove plot band by id
		     * @sample {highstock} highcharts/xaxis/plotbands-id/
		     *         Remove plot band by id
		     *
		     * @type      {string}
		     * @apioption xAxis.plotBands.id
		     */

		    /**
		     * The end position of the plot band in axis units.
		     *
		     * @sample {highcharts} highcharts/xaxis/plotbands-color/
		     *         Datetime axis
		     * @sample {highcharts} highcharts/xaxis/plotbands-from/
		     *         Categorized axis
		     * @sample {highstock} stock/xaxis/plotbands/
		     *         Plot band on Y axis
		     *
		     * @type      {number}
		     * @apioption xAxis.plotBands.to
		     */

		    /**
		     * The z index of the plot band within the chart, relative to other
		     * elements. Using the same z index as another element may give
		     * unpredictable results, as the last rendered element will be on top.
		     * Values from 0 to 20 make sense.
		     *
		     * @sample {highcharts} highcharts/xaxis/plotbands-color/
		     *         Behind plot lines by default
		     * @sample {highcharts} highcharts/xaxis/plotbands-zindex/
		     *         Above plot lines
		     * @sample {highcharts} highcharts/xaxis/plotbands-zindex-above-series/
		     *         Above plot lines and series
		     *
		     * @type      {number}
		     * @since     1.2
		     * @apioption xAxis.plotBands.zIndex
		     */

		    /**
		     * Text labels for the plot bands
		     *
		     * @product   highcharts highstock gantt
		     * @apioption xAxis.plotBands.label
		     */

		    /**
		     * Horizontal alignment of the label. Can be one of "left", "center" or
		     * "right".
		     *
		     * @sample {highcharts} highcharts/xaxis/plotbands-label-align/
		     *         Aligned to the right
		     * @sample {highstock} stock/xaxis/plotbands-label/
		     *         Plot band with labels
		     *
		     * @type      {string}
		     * @default   center
		     * @since     2.1
		     * @apioption xAxis.plotBands.label.align
		     */

		    /**
		     * Rotation of the text label in degrees .
		     *
		     * @sample {highcharts} highcharts/xaxis/plotbands-label-rotation/
		     *         Vertical text
		     *
		     * @type      {number}
		     * @default   0
		     * @since     2.1
		     * @apioption xAxis.plotBands.label.rotation
		     */

		    /**
		     * CSS styles for the text label.
		     *
		     * In styled mode, the labels are styled by the
		     * `.highcharts-plot-band-label` class.
		     *
		     * @sample {highcharts} highcharts/xaxis/plotbands-label-style/
		     *         Blue and bold label
		     *
		     * @type      {Highcharts.CSSObject}
		     * @since     2.1
		     * @apioption xAxis.plotBands.label.style
		     */

		    /**
		     * The string text itself. A subset of HTML is supported.
		     *
		     * @type      {string}
		     * @since     2.1
		     * @apioption xAxis.plotBands.label.text
		     */

		    /**
		     * The text alignment for the label. While `align` determines where the
		     * texts anchor point is placed within the plot band, `textAlign` determines
		     * how the text is aligned against its anchor point. Possible values are
		     * "left", "center" and "right". Defaults to the same as the `align` option.
		     *
		     * @sample {highcharts} highcharts/xaxis/plotbands-label-rotation/
		     *         Vertical text in center position but text-aligned left
		     *
		     * @type       {string}
		     * @since      2.1
		     * @validvalue ["center", "left", "right"]
		     * @apioption  xAxis.plotBands.label.textAlign
		     */

		    /**
		     * Whether to [use HTML](https://www.highcharts.com/docs/chart-concepts
		     * /labels-and-string-formatting#html) to render the labels.
		     *
		     * @type      {boolean}
		     * @default   false
		     * @since     3.0.3
		     * @apioption xAxis.plotBands.label.useHTML
		     */

		    /**
		     * Vertical alignment of the label relative to the plot band. Can be one of
		     * "top", "middle" or "bottom".
		     *
		     * @sample {highcharts} highcharts/xaxis/plotbands-label-verticalalign/
		     *         Vertically centered label
		     * @sample {highstock} stock/xaxis/plotbands-label/
		     *         Plot band with labels
		     *
		     * @type       {string}
		     * @default    top
		     * @since      2.1
		     * @validvalue ["bottom", "middle",  "top"]
		     * @apioption  xAxis.plotBands.label.verticalAlign
		     */

		    /**
		     * Horizontal position relative the alignment. Default varies by
		     * orientation.
		     *
		     * @sample {highcharts} highcharts/xaxis/plotbands-label-align/
		     *         Aligned 10px from the right edge
		     * @sample {highstock} stock/xaxis/plotbands-label/
		     *         Plot band with labels
		     *
		     * @type      {number}
		     * @since     2.1
		     * @apioption xAxis.plotBands.label.x
		     */

		    /**
		     * Vertical position of the text baseline relative to the alignment. Default
		     * varies by orientation.
		     *
		     * @sample {highcharts} highcharts/xaxis/plotbands-label-y/
		     *         Label on x axis
		     * @sample {highstock} stock/xaxis/plotbands-label/
		     *         Plot band with labels
		     *
		     * @type      {number}
		     * @since     2.1
		     * @apioption xAxis.plotBands.label.y
		     */

		    /**
		     * An array of lines stretching across the plot area, marking a specific
		     * value on one of the axes.
		     *
		     * In styled mode, the plot lines are styled by the
		     * `.highcharts-plot-line` class in addition to the `className` option.
		     *
		     * @type      {Array<*>}
		     * @product   highcharts highstock gantt
		     * @apioption xAxis.plotLines
		     */

		    /**
		     * A custom class name, in addition to the default `highcharts-plot-line`,
		     * to apply to each individual line.
		     *
		     * @type      {string}
		     * @since     5.0.0
		     * @apioption xAxis.plotLines.className
		     */

		    /**
		     * The color of the line.
		     *
		     * @sample {highcharts} highcharts/xaxis/plotlines-color/
		     *         A red line from X axis
		     * @sample {highstock} stock/xaxis/plotlines/
		     *         Plot line on Y axis
		     *
		     * @type      {Highcharts.ColorString}
		     * @apioption xAxis.plotLines.color
		     */

		    /**
		     * The dashing or dot style for the plot line. For possible values see
		     * [this overview](https://jsfiddle.net/gh/get/library/pure/highcharts
		     * /highcharts/tree/master/samples/highcharts/plotoptions/series-
		     * dashstyle-all/).
		     *
		     * @sample {highcharts} highcharts/xaxis/plotlines-dashstyle/
		     *         Dash and dot pattern
		     * @sample {highstock} stock/xaxis/plotlines/
		     *         Plot line on Y axis
		     *
		     * @type       {string}
		     * @default    Solid
		     * @since      1.2
		     * @validvalue ["Solid", "ShortDash", "ShortDot", "ShortDashDot",
		     *             "ShortDashDotDot", "Dot", "Dash" ,"LongDash", "DashDot",
		     *             "LongDashDot", "LongDashDotDot"]
		     * @apioption  xAxis.plotLines.dashStyle
		     */

		    /**
		     * An object defining mouse events for the plot line. Supported
		     * properties are `click`, `mouseover`, `mouseout`, `mousemove`.
		     *
		     * @sample {highcharts} highcharts/xaxis/plotlines-events/
		     *         Mouse events demonstrated
		     *
		     * @type      {*}
		     * @since     1.2
		     * @context   PlotLineOrBand
		     * @apioption xAxis.plotLines.events
		     */

		    /**
		     * An id used for identifying the plot line in Axis.removePlotLine.
		     *
		     * @sample {highcharts} highcharts/xaxis/plotlines-id/
		     *         Remove plot line by id
		     *
		     * @type      {string}
		     * @apioption xAxis.plotLines.id
		     */

		    /**
		     * The position of the line in axis units.
		     *
		     * @sample {highcharts} highcharts/xaxis/plotlines-color/
		     *         Between two categories on X axis
		     * @sample {highstock} stock/xaxis/plotlines/
		     *         Plot line on Y axis
		     *
		     * @type      {number}
		     * @apioption xAxis.plotLines.value
		     */

		    /**
		     * The width or thickness of the plot line.
		     *
		     * @sample {highcharts} highcharts/xaxis/plotlines-color/
		     *         2px wide line from X axis
		     * @sample {highstock} stock/xaxis/plotlines/
		     *         Plot line on Y axis
		     *
		     * @type      {number}
		     * @apioption xAxis.plotLines.width
		     */

		    /**
		     * The z index of the plot line within the chart.
		     *
		     * @sample {highcharts} highcharts/xaxis/plotlines-zindex-behind/
		     *         Behind plot lines by default
		     * @sample {highcharts} highcharts/xaxis/plotlines-zindex-above/
		     *         Above plot lines
		     * @sample {highcharts} highcharts/xaxis/plotlines-zindex-above-all/
		     *         Above plot lines and series
		     *
		     * @type      {number}
		     * @since     1.2
		     * @apioption xAxis.plotLines.zIndex
		     */

		    /**
		     * Text labels for the plot bands
		     *
		     * @apioption xAxis.plotLines.label
		     */

		    /**
		     * Horizontal alignment of the label. Can be one of "left", "center" or
		     * "right".
		     *
		     * @sample {highcharts} highcharts/xaxis/plotlines-label-align-right/
		     *         Aligned to the right
		     * @sample {highstock} stock/xaxis/plotlines/
		     *         Plot line on Y axis
		     *
		     * @type       {string}
		     * @default    left
		     * @since      2.1
		     * @validvalue ["center", "left", "right"]
		     * @apioption  xAxis.plotLines.label.align
		     */

		    /**
		     * Rotation of the text label in degrees. Defaults to 0 for horizontal plot
		     * lines and 90 for vertical lines.
		     *
		     * @sample {highcharts} highcharts/xaxis/plotlines-label-verticalalign-middle/
		     *         Slanted text
		     *
		     * @type      {number}
		     * @since     2.1
		     * @apioption xAxis.plotLines.label.rotation
		     */

		    /**
		     * CSS styles for the text label.
		     *
		     * In styled mode, the labels are styled by the
		     * `.highcharts-plot-line-label` class.
		     *
		     * @sample {highcharts} highcharts/xaxis/plotlines-label-style/
		     *         Blue and bold label
		     *
		     * @type      {Highcharts.CSSObject}
		     * @since     2.1
		     * @apioption xAxis.plotLines.label.style
		     */

		    /**
		     * The text itself. A subset of HTML is supported.
		     *
		     * @type      {string}
		     * @since     2.1
		     * @apioption xAxis.plotLines.label.text
		     */

		    /**
		     * The text alignment for the label. While `align` determines where the
		     * texts anchor point is placed within the plot band, `textAlign` determines
		     * how the text is aligned against its anchor point. Possible values are
		     * "left", "center" and "right". Defaults to the same as the `align` option.
		     *
		     * @sample {highcharts} highcharts/xaxis/plotlines-label-textalign/
		     *         Text label in bottom position
		     *
		     * @type      {string}
		     * @since     2.1
		     * @apioption xAxis.plotLines.label.textAlign
		     */

		    /**
		     * Whether to [use HTML](https://www.highcharts.com/docs/chart-concepts
		     * /labels-and-string-formatting#html) to render the labels.
		     *
		     * @type      {boolean}
		     * @default   false
		     * @since     3.0.3
		     * @apioption xAxis.plotLines.label.useHTML
		     */

		    /**
		     * Vertical alignment of the label relative to the plot line. Can be
		     * one of "top", "middle" or "bottom".
		     *
		     * @sample {highcharts} highcharts/xaxis/plotlines-label-verticalalign-middle/
		     *         Vertically centered label
		     *
		     * @type       {string}
		     * @default    {highcharts} top
		     * @default    {highstock} top
		     * @since      2.1
		     * @validvalue ["top", "middle", "bottom"]
		     * @apioption  xAxis.plotLines.label.verticalAlign
		     */

		    /**
		     * Horizontal position relative the alignment. Default varies by
		     * orientation.
		     *
		     * @sample {highcharts} highcharts/xaxis/plotlines-label-align-right/
		     *         Aligned 10px from the right edge
		     * @sample {highstock} stock/xaxis/plotlines/
		     *         Plot line on Y axis
		     *
		     * @type      {number}
		     * @since     2.1
		     * @apioption xAxis.plotLines.label.x
		     */

		    /**
		     * Vertical position of the text baseline relative to the alignment. Default
		     * varies by orientation.
		     *
		     * @sample {highcharts} highcharts/xaxis/plotlines-label-y/
		     *         Label below the plot line
		     * @sample {highstock} stock/xaxis/plotlines/
		     *         Plot line on Y axis
		     *
		     * @type      {number}
		     * @since     2.1
		     * @apioption xAxis.plotLines.label.y
		     */

		    /**
		     * An array of objects defining plot bands on the Y axis.
		     *
		     * @type      {Array<*>}
		     * @extends   xAxis.plotBands
		     * @apioption yAxis.plotBands
		     */

		    /**
		     * In a gauge chart, this option determines the inner radius of the
		     * plot band that stretches along the perimeter. It can be given as
		     * a percentage string, like `"100%"`, or as a pixel number, like `100`.
		     * By default, the inner radius is controlled by the [thickness](
		     * #yAxis.plotBands.thickness) option.
		     *
		     * @sample {highcharts} highcharts/xaxis/plotbands-gauge
		     *         Gauge plot band
		     *
		     * @type      {number|string}
		     * @since     2.3
		     * @product   highcharts
		     * @apioption yAxis.plotBands.innerRadius
		     */

		    /**
		     * In a gauge chart, this option determines the outer radius of the
		     * plot band that stretches along the perimeter. It can be given as
		     * a percentage string, like `"100%"`, or as a pixel number, like `100`.
		     *
		     * @sample {highcharts} highcharts/xaxis/plotbands-gauge
		     *         Gauge plot band
		     *
		     * @type      {number|string}
		     * @default   100%
		     * @since     2.3
		     * @product   highcharts
		     * @apioption yAxis.plotBands.outerRadius
		     */

		    /**
		     * In a gauge chart, this option sets the width of the plot band
		     * stretching along the perimeter. It can be given as a percentage
		     * string, like `"10%"`, or as a pixel number, like `10`. The default
		     * value 10 is the same as the default [tickLength](#yAxis.tickLength),
		     * thus making the plot band act as a background for the tick markers.
		     *
		     * @sample {highcharts} highcharts/xaxis/plotbands-gauge
		     *         Gauge plot band
		     *
		     * @type      {number|string}
		     * @default   10
		     * @since     2.3
		     * @product   highcharts
		     * @apioption yAxis.plotBands.thickness
		     */

		    /**
		     * An array of objects representing plot lines on the X axis
		     *
		     * @type      {Array<*>}
		     * @extends   xAxis.plotLines
		     * @apioption yAxis.plotLines
		     */

		    /**
		     * Internal function to create the SVG path definition for a plot band.
		     *
		     * @function Highcharts.Axis#getPlotBandPath
		     *
		     * @param {number} from
		     *        The axis value to start from.
		     *
		     * @param {number} to
		     *        The axis value to end on.
		     *
		     * @return {Highcharts.SVGPathArray}
		     *         The SVG path definition in array form.
		     */
		    getPlotBandPath: function (from, to) {
		        var toPath = this.getPlotLinePath(to, null, null, true),
		            path = this.getPlotLinePath(from, null, null, true),
		            result = [],
		            i,
		            // #4964 check if chart is inverted or plotband is on yAxis
		            horiz = this.horiz,
		            plus = 1,
		            isFlat,
		            outside =
		                (from < this.min && to < this.min) ||
		                (from > this.max && to > this.max);

		        if (path && toPath) {

		            // Flat paths don't need labels (#3836)
		            if (outside) {
		                isFlat = path.toString() === toPath.toString();
		                plus = 0;
		            }

		            // Go over each subpath - for panes in Highstock
		            for (i = 0; i < path.length; i += 6) {

		                // Add 1 pixel when coordinates are the same
		                if (horiz && toPath[i + 1] === path[i + 1]) {
		                    toPath[i + 1] += plus;
		                    toPath[i + 4] += plus;
		                } else if (!horiz && toPath[i + 2] === path[i + 2]) {
		                    toPath[i + 2] += plus;
		                    toPath[i + 5] += plus;
		                }

		                result.push(
		                    'M',
		                    path[i + 1],
		                    path[i + 2],
		                    'L',
		                    path[i + 4],
		                    path[i + 5],
		                    toPath[i + 4],
		                    toPath[i + 5],
		                    toPath[i + 1],
		                    toPath[i + 2],
		                    'z'
		                );
		                result.isFlat = isFlat;
		            }

		        } else { // outside the axis area
		            path = null;
		        }

		        return result;
		    },

		    /**
		     * Add a plot band after render time.
		     *
		     * @sample highcharts/members/axis-addplotband/
		     *         Toggle the plot band from a button
		     *
		     * @function Highcharts.Axis#addPlotBand
		     *
		     * @param {Highcharts.AxisPlotBandsOptions} options
		     *        A configuration object for the plot band, as defined in
		     *        {@link  https://api.highcharts.com/highcharts/xAxis.plotBands|xAxis.plotBands}.
		     *
		     * @return {Highcharts.PlotLineOrBand|undefined}
		     *         The added plot band.
		     */
		    addPlotBand: function (options) {
		        return this.addPlotBandOrLine(options, 'plotBands');
		    },

		    /**
		     * Add a plot line after render time.
		     *
		     * @sample highcharts/members/axis-addplotline/
		     *         Toggle the plot line from a button
		     *
		     * @function Highcharts.Axis#addPlotLine
		     *
		     * @param {Highcharts.AxisPlotLinesOptions} options
		     *        A configuration object for the plot line, as defined in
		     *        {@link https://api.highcharts.com/highcharts/xAxis.plotLines|xAxis.plotLines}.
		     *
		     * @return {Highcharts.PlotLineOrBand|undefined}
		     *         The added plot line.
		     */
		    addPlotLine: function (options) {
		        return this.addPlotBandOrLine(options, 'plotLines');
		    },

		    /**
		     * Add a plot band or plot line after render time. Called from addPlotBand
		     * and addPlotLine internally.
		     *
		     * @private
		     * @function Highcharts.Axis#addPlotBandOrLine
		     *
		     * @param {Highcharts.AxisPlotLinesOptions|Highcharts.AxisPlotBandsOptions} options
		     *        The plotBand or plotLine configuration object.
		     *
		     * @param {"plotBands"|"plotLines"} [coll]
		     *
		     * @return {Highcharts.PlotLineOrBand|undefined}
		     */
		    addPlotBandOrLine: function (options, coll) {
		        var obj = new H.PlotLineOrBand(this, options).render(),
		            userOptions = this.userOptions;

		        if (obj) { // #2189
		            // Add it to the user options for exporting and Axis.update
		            if (coll) {
		                userOptions[coll] = userOptions[coll] || [];
		                userOptions[coll].push(options);
		            }
		            this.plotLinesAndBands.push(obj);
		        }

		        return obj;
		    },

		    /**
		     * Remove a plot band or plot line from the chart by id. Called internally
		     * from `removePlotBand` and `removePlotLine`.
		     *
		     * @private
		     * @function Highcharts.Axis#removePlotBandOrLine
		     *
		     * @param {string} id
		     */
		    removePlotBandOrLine: function (id) {
		        var plotLinesAndBands = this.plotLinesAndBands,
		            options = this.options,
		            userOptions = this.userOptions,
		            i = plotLinesAndBands.length;
		        while (i--) {
		            if (plotLinesAndBands[i].id === id) {
		                plotLinesAndBands[i].destroy();
		            }
		        }
		        each([
		            options.plotLines || [],
		            userOptions.plotLines || [],
		            options.plotBands || [],
		            userOptions.plotBands || []
		        ], function (arr) {
		            i = arr.length;
		            while (i--) {
		                if (arr[i].id === id) {
		                    erase(arr, arr[i]);
		                }
		            }
		        });
		    },

		    /**
		     * Remove a plot band by its id.
		     *
		     * @sample highcharts/members/axis-removeplotband/
		     *         Remove plot band by id
		     * @sample highcharts/members/axis-addplotband/
		     *         Toggle the plot band from a button
		     *
		     * @function Highcharts.Axis#removePlotBand
		     *
		     * @param {string} id
		     *        The plot band's `id` as given in the original configuration
		     *        object or in the `addPlotBand` option.
		     */
		    removePlotBand: function (id) {
		        this.removePlotBandOrLine(id);
		    },

		    /**
		     * Remove a plot line by its id.
		     *
		     * @sample highcharts/xaxis/plotlines-id/
		     *         Remove plot line by id
		     * @sample highcharts/members/axis-addplotline/
		     *         Toggle the plot line from a button
		     *
		     * @function Highcharts.Axis#removePlotLine
		     *
		     * @param {string} id
		     *        The plot line's `id` as given in the original configuration
		     *        object or in the `addPlotLine` option.
		     */
		    removePlotLine: function (id) {
		        this.removePlotBandOrLine(id);
		    }
		});

	}(Highcharts, Axis));
	(function (H) {
		/**
		 * (c) 2010-2018 Torstein Honsi
		 *
		 * License: www.highcharts.com/license
		 */



		var doc = H.doc,
		    each = H.each,
		    extend = H.extend,
		    format = H.format,
		    isNumber = H.isNumber,
		    map = H.map,
		    merge = H.merge,
		    pick = H.pick,
		    splat = H.splat,
		    syncTimeout = H.syncTimeout,
		    timeUnits = H.timeUnits;

		/**
		 * Tooltip of a chart.
		 *
		 * @class
		 * @name Highcharts.Tooltip
		 *
		 * @param {Highcharts.Chart} chart
		 *        The chart instance.
		 *
		 * @param {Highcharts.TooltipOptions} options
		 *        Tooltip options.
		 */
		H.Tooltip = function () {
		    this.init.apply(this, arguments);
		};

		H.Tooltip.prototype = {

		    /**
		     * @private
		     * @function Highcharts.Tooltip#init
		     *
		     * @param {Highcharts.Chart} chart
		     *        The chart instance.
		     *
		     * @param {Highcharts.TooltipOptions} options
		     *        Tooltip options.
		     */
		    init: function (chart, options) {

		        /**
		         * Chart of the tooltip.
		         *
		         * @readonly
		         * @name Highcharts.Tooltip#chart
		         * @type {Highcharts.Chart}
		         */
		        this.chart = chart;

		        /**
		         * Used tooltip options.
		         *
		         * @readonly
		         * @name Highcharts.Tooltip#options
		         * @type {Highcharts.TooltipOptions}
		         */
		        this.options = options;

		        /**
		         * List of crosshairs.
		         *
		         * @private
		         * @readonly
		         * @name Highcharts.Tooltip#crosshairs
		         * @type {Array<*>}
		         */
		        this.crosshairs = [];

		        /**
		         * Current values of x and y when animating.
		         *
		         * @private
		         * @readonly
		         * @name Highcharts.Tooltip#now
		         * @type {*}
		         */
		        this.now = { x: 0, y: 0 };

		        /**
		         * Tooltips are initially hidden.
		         *
		         * @readonly
		         * @name Highcharts.Tooltip#isHidden
		         * @type {boolean}
		         */
		        this.isHidden = true;

		        /**
		         * True, if the tooltip is splitted into one label per series, with the
		         * header close to the axis.
		         *
		         * @readonly
		         * @name Highcharts.Tooltip#split
		         * @type {boolean}
		         */
		        this.split = options.split && !chart.inverted;

		        /**
		         * When the tooltip is shared, the entire plot area will capture mouse
		         * movement or touch events.
		         *
		         * @readonly
		         * @name Highcharts.Tooltip#shared
		         * @type {boolean}
		         */
		        this.shared = options.shared || this.split;

		        /**
		         * Whether to allow the tooltip to render outside the chart's SVG
		         * element box. By default (false), the tooltip is rendered within the
		         * chart's SVG element, which results in the tooltip being aligned
		         * inside the chart area.
		         *
		         * @readonly
		         * @name Highcharts.Tooltip#outside
		         * @type {boolean}
		         *
		         * @todo
		         * Split tooltip does not support outside in the first iteration. Should
		         * not be too complicated to implement.
		         */
		        this.outside = options.outside && !this.split;

		    },

		    /**
		     * Destroy the single tooltips in a split tooltip.
		     * If the tooltip is active then it is not destroyed, unless forced to.
		     *
		     * @private
		     * @function Highcharts.Tooltip#cleanSplit
		     *
		     * @param {boolean} force
		     *        Force destroy all tooltips.
		     */
		    cleanSplit: function (force) {
		        each(this.chart.series, function (series) {
		            var tt = series && series.tt;
		            if (tt) {
		                if (!tt.isActive || force) {
		                    series.tt = tt.destroy();
		                } else {
		                    tt.isActive = false;
		                }
		            }
		        });
		    },




		    /**
		     * Creates the Tooltip label element if it does not exist, then returns it.
		     *
		     * @function Highcharts.Tooltip#getLabel
		     *
		     * @return {Highcharts.SVGElement}
		     */
		    getLabel: function () {

		        var renderer = this.chart.renderer,
		            options = this.options,
		            container;

		        if (!this.label) {

		            if (this.outside) {
		                this.container = container = H.doc.createElement('div');
		                container.className = 'highcharts-tooltip-container';
		                H.css(container, {
		                    position: 'absolute',
		                    top: '1px',
		                    pointerEvents: options.style && options.style.pointerEvents
		                });
		                H.doc.body.appendChild(container);

		                this.renderer = renderer = new H.Renderer(container, 0, 0);
		            }


		            // Create the label
		            if (this.split) {
		                this.label = renderer.g('tooltip');
		            } else {
		                this.label = renderer.label(
		                        '',
		                        0,
		                        0,
		                        options.shape || 'callout',
		                        null,
		                        null,
		                        options.useHTML,
		                        null,
		                        'tooltip'
		                    )
		                    .attr({
		                        padding: options.padding,
		                        r: options.borderRadius
		                    });


		                this.label
		                    .attr({
		                        'fill': options.backgroundColor,
		                        'stroke-width': options.borderWidth
		                    })
		                    // #2301, #2657
		                    .css(options.style)
		                    .shadow(options.shadow);

		            }



		            if (this.outside) {
		                this.label.attr({
		                    x: this.distance,
		                    y: this.distance
		                });
		                this.label.xSetter = function (value) {
		                    container.style.left = value + 'px';
		                };
		                this.label.ySetter = function (value) {
		                    container.style.top = value + 'px';
		                };
		            }

		            this.label
		                .attr({
		                    zIndex: 8
		                })
		                .add();
		        }
		        return this.label;
		    },

		    /**
		     * Updates the tooltip with the provided tooltip options.
		     *
		     * @function Highcharts.Tooltip#update
		     *
		     * @param {Highcharts.TooltipOptions} options
		     */
		    update: function (options) {
		        this.destroy();
		        // Update user options (#6218)
		        merge(true, this.chart.options.tooltip.userOptions, options);
		        this.init(this.chart, merge(true, this.options, options));
		    },

		    /**
		     * Removes and destroys the tooltip and its elements.
		     *
		     * @function Highcharts.Tooltip#destroy
		     */
		    destroy: function () {
		        // Destroy and clear local variables
		        if (this.label) {
		            this.label = this.label.destroy();
		        }
		        if (this.split && this.tt) {
		            this.cleanSplit(this.chart, true);
		            this.tt = this.tt.destroy();
		        }
		        if (this.renderer) {
		            this.renderer = this.renderer.destroy();
		            H.discardElement(this.container);
		        }
		        H.clearTimeout(this.hideTimer);
		        H.clearTimeout(this.tooltipTimeout);
		    },

		    /**
		     * Moves the tooltip with a soft animation to a new position.
		     *
		     * @function Highcharts.Tooltip#move
		     *
		     * @param {number} x
		     *
		     * @param {number} y
		     *
		     * @param {number} anchorX
		     *
		     * @param {number} anchorY
		     */
		    move: function (x, y, anchorX, anchorY) {
		        var tooltip = this,
		            now = tooltip.now,
		            animate = tooltip.options.animation !== false &&
		                !tooltip.isHidden &&
		                // When we get close to the target position, abort animation and
		                // land on the right place (#3056)
		                (Math.abs(x - now.x) > 1 || Math.abs(y - now.y) > 1),
		            skipAnchor = tooltip.followPointer || tooltip.len > 1;

		        // Get intermediate values for animation
		        extend(now, {
		            x: animate ? (2 * now.x + x) / 3 : x,
		            y: animate ? (now.y + y) / 2 : y,
		            anchorX: skipAnchor ?
		                undefined :
		                animate ? (2 * now.anchorX + anchorX) / 3 : anchorX,
		            anchorY: skipAnchor ?
		                undefined :
		                animate ? (now.anchorY + anchorY) / 2 : anchorY
		        });

		        // Move to the intermediate value
		        tooltip.getLabel().attr(now);


		        // Run on next tick of the mouse tracker
		        if (animate) {

		            // Never allow two timeouts
		            H.clearTimeout(this.tooltipTimeout);

		            // Set the fixed interval ticking for the smooth tooltip
		            this.tooltipTimeout = setTimeout(function () {
		                // The interval function may still be running during destroy,
		                // so check that the chart is really there before calling.
		                if (tooltip) {
		                    tooltip.move(x, y, anchorX, anchorY);
		                }
		            }, 32);

		        }
		    },

		    /**
		     * Hides the tooltip with a fade out animation.
		     *
		     * @function Highcharts.Tooltip#hide
		     *
		     * @param {number} [delay]
		     *        The fade out in milliseconds. If no value is provided the value
		     *        of the tooltip.hideDelay option is used. A value of 0 disables
		     *        the fade out animation.
		     */
		    hide: function (delay) {
		        var tooltip = this;
		        // disallow duplicate timers (#1728, #1766)
		        H.clearTimeout(this.hideTimer);
		        delay = pick(delay, this.options.hideDelay, 500);
		        if (!this.isHidden) {
		            this.hideTimer = syncTimeout(function () {
		                tooltip.getLabel()[delay ? 'fadeOut' : 'hide']();
		                tooltip.isHidden = true;
		            }, delay);
		        }
		    },

		    /**
		     * Extendable method to get the anchor position of the tooltip
		     * from a point or set of points
		     *
		     * @private
		     * @function Highcharts.Tooltip#getAnchor
		     *
		     * @param {Array<Highchart.Points>} points
		     *
		     * @param {global.Event} [mouseEvent]
		     */
		    getAnchor: function (points, mouseEvent) {
		        var ret,
		            chart = this.chart,
		            pointer = chart.pointer,
		            inverted = chart.inverted,
		            plotTop = chart.plotTop,
		            plotLeft = chart.plotLeft,
		            plotX = 0,
		            plotY = 0,
		            yAxis,
		            xAxis;

		        points = splat(points);

		        // When tooltip follows mouse, relate the position to the mouse
		        if (this.followPointer && mouseEvent) {
		            if (mouseEvent.chartX === undefined) {
		                mouseEvent = pointer.normalize(mouseEvent);
		            }
		            ret = [
		                mouseEvent.chartX - chart.plotLeft,
		                mouseEvent.chartY - plotTop
		            ];
		        // Pie uses a special tooltipPos
		        } else if (points[0].tooltipPos) {
		            ret = points[0].tooltipPos;
		        // When shared, use the average position
		        } else {
		            each(points, function (point) {
		                yAxis = point.series.yAxis;
		                xAxis = point.series.xAxis;
		                plotX += point.plotX +
		                    (!inverted && xAxis ? xAxis.left - plotLeft : 0);
		                plotY +=
		                    (
		                        point.plotLow ?
		                            (point.plotLow + point.plotHigh) / 2 :
		                            point.plotY
		                    ) +
		                    (!inverted && yAxis ? yAxis.top - plotTop : 0); // #1151
		            });

		            plotX /= points.length;
		            plotY /= points.length;

		            ret = [
		                inverted ? chart.plotWidth - plotY : plotX,
		                this.shared && !inverted && points.length > 1 && mouseEvent ?
		                    // place shared tooltip next to the mouse (#424)
		                    mouseEvent.chartY - plotTop :
		                    inverted ? chart.plotHeight - plotX : plotY
		            ];
		        }

		        return map(ret, Math.round);
		    },

		    /**
		     * Place the tooltip in a chart without spilling over
		     * and not covering the point it self.
		     *
		     * @private
		     * @function Highcharts.Tooltip#getPosition
		     *
		     * @param {number} boxWidth
		     *
		     * @param {number} boxHeight
		     *
		     * @param {Highcharts.Point} point
		     *
		     * @return {*}
		     */
		    getPosition: function (boxWidth, boxHeight, point) {

		        var chart = this.chart,
		            distance = this.distance,
		            ret = {},
		            // Don't use h if chart isn't inverted (#7242)
		            h = (chart.inverted && point.h) || 0, // #4117
		            swapped,
		            outside = this.outside,
		            outerWidth = outside ?
		                // substract distance to prevent scrollbars
		                doc.documentElement.clientWidth - 2 * distance :
		                chart.chartWidth,
		            outerHeight = outside ?
		                Math.max(
		                    doc.body.scrollHeight,
		                    doc.documentElement.scrollHeight,
		                    doc.body.offsetHeight,
		                    doc.documentElement.offsetHeight,
		                    doc.documentElement.clientHeight
		                ) :
		                chart.chartHeight,
		            chartPosition = chart.pointer.chartPosition,
		            first = [
		                'y',
		                outerHeight,
		                boxHeight,
		                (outside ? chartPosition.top - distance : 0) +
		                    point.plotY + chart.plotTop,
		                outside ? 0 : chart.plotTop,
		                outside ? outerHeight : chart.plotTop + chart.plotHeight
		            ],
		            second = [
		                'x',
		                outerWidth,
		                boxWidth,
		                (outside ? chartPosition.left - distance : 0) +
		                    point.plotX + chart.plotLeft,
		                outside ? 0 : chart.plotLeft,
		                outside ? outerWidth : chart.plotLeft + chart.plotWidth
		            ],
		            // The far side is right or bottom
		            preferFarSide = !this.followPointer && pick(
		                point.ttBelow,
		                !chart.inverted === !!point.negative
		            ), // #4984

		            /*
		             * Handle the preferred dimension. When the preferred dimension is
		             * tooltip on top or bottom of the point, it will look for space
		             * there.
		             *
		             * @private
		             */
		            firstDimension = function (
		                dim,
		                outerSize,
		                innerSize,
		                point,
		                min,
		                max
		            ) {
		                var roomLeft = innerSize < point - distance,
		                    roomRight = point + distance + innerSize < outerSize,
		                    alignedLeft = point - distance - innerSize,
		                    alignedRight = point + distance;

		                if (preferFarSide && roomRight) {
		                    ret[dim] = alignedRight;
		                } else if (!preferFarSide && roomLeft) {
		                    ret[dim] = alignedLeft;
		                } else if (roomLeft) {
		                    ret[dim] = Math.min(
		                        max - innerSize,
		                        alignedLeft - h < 0 ? alignedLeft : alignedLeft - h
		                    );
		                } else if (roomRight) {
		                    ret[dim] = Math.max(
		                        min,
		                        alignedRight + h + innerSize > outerSize ?
		                            alignedRight :
		                            alignedRight + h
		                    );
		                } else {
		                    return false;
		                }
		            },

		            /*
		             * Handle the secondary dimension. If the preferred dimension is
		             * tooltip on top or bottom of the point, the second dimension is to
		             * align the tooltip above the point, trying to align center but
		             * allowing left or right align within the chart box.
		             *
		             * @private
		             */
		            secondDimension = function (dim, outerSize, innerSize, point) {
		                var retVal;

		                // Too close to the edge, return false and swap dimensions
		                if (point < distance || point > outerSize - distance) {
		                    retVal = false;
		                // Align left/top
		                } else if (point < innerSize / 2) {
		                    ret[dim] = 1;
		                // Align right/bottom
		                } else if (point > outerSize - innerSize / 2) {
		                    ret[dim] = outerSize - innerSize - 2;
		                // Align center
		                } else {
		                    ret[dim] = point - innerSize / 2;
		                }
		                return retVal;
		            },

		            /*
		             * Swap the dimensions
		             */
		            swap = function (count) {
		                var temp = first;
		                first = second;
		                second = temp;
		                swapped = count;
		            },
		            run = function () {
		                if (firstDimension.apply(0, first) !== false) {
		                    if (
		                        secondDimension.apply(0, second) === false &&
		                        !swapped
		                    ) {
		                        swap(true);
		                        run();
		                    }
		                } else if (!swapped) {
		                    swap(true);
		                    run();
		                } else {
		                    ret.x = ret.y = 0;
		                }
		            };

		        // Under these conditions, prefer the tooltip on the side of the point
		        if (chart.inverted || this.len > 1) {
		            swap();
		        }
		        run();

		        return ret;

		    },

		    /**
		     * In case no user defined formatter is given, this will be used. Note that
		     * the context here is an object holding point, series, x, y etc.
		     *
		     * @private
		     * @function Highcharts.Tooltip#defaultFormatter
		     *
		     * @param {Highcharts.Tooltip} tooltip
		     *
		     * @return {Array<string>}
		     */
		    defaultFormatter: function (tooltip) {
		        var items = this.points || splat(this),
		            s;

		        // Build the header
		        s = [tooltip.tooltipFooterHeaderFormatter(items[0])];

		        // build the values
		        s = s.concat(tooltip.bodyFormatter(items));

		        // footer
		        s.push(tooltip.tooltipFooterHeaderFormatter(items[0], true));

		        return s;
		    },

		    /**
		     * Refresh the tooltip's text and position.
		     *
		     * @function Highcharts.Tooltip#refresh
		     *
		     * @param {Highcharts.Point|Array<Highcharts.Point>} pointOrPoints
		     *        Either a point or an array of points.
		     *
		     * @param {global.Event} [mouseEvent]
		     *        Mouse event, that is responsible for the refresh and should be
		     *        used for the tooltip update.
		     */
		    refresh: function (pointOrPoints, mouseEvent) {
		        var tooltip = this,
		            label,
		            options = tooltip.options,
		            x,
		            y,
		            point = pointOrPoints,
		            anchor,
		            textConfig = {},
		            text,
		            pointConfig = [],
		            formatter = options.formatter || tooltip.defaultFormatter,
		            shared = tooltip.shared,
		            currentSeries;

		        if (!options.enabled) {
		            return;
		        }

		        H.clearTimeout(this.hideTimer);

		        // get the reference point coordinates (pie charts use tooltipPos)
		        tooltip.followPointer = splat(point)[0].series.tooltipOptions
		            .followPointer;
		        anchor = tooltip.getAnchor(point, mouseEvent);
		        x = anchor[0];
		        y = anchor[1];

		        // shared tooltip, array is sent over
		        if (shared && !(point.series && point.series.noSharedTooltip)) {
		            each(point, function (item) {
		                item.setState('hover');

		                pointConfig.push(item.getLabelConfig());
		            });

		            textConfig = {
		                x: point[0].category,
		                y: point[0].y
		            };
		            textConfig.points = pointConfig;
		            point = point[0];

		        // single point tooltip
		        } else {
		            textConfig = point.getLabelConfig();
		        }
		        this.len = pointConfig.length; // #6128
		        text = formatter.call(textConfig, tooltip);

		        // register the current series
		        currentSeries = point.series;
		        this.distance = pick(currentSeries.tooltipOptions.distance, 16);

		        // update the inner HTML
		        if (text === false) {
		            this.hide();
		        } else {

		            label = tooltip.getLabel();

		            // show it
		            if (tooltip.isHidden) {
		                label.attr({
		                    opacity: 1
		                }).show();
		            }

		            // update text
		            if (tooltip.split) {
		                this.renderSplit(text, splat(pointOrPoints));
		            } else {

		                // Prevent the tooltip from flowing over the chart box (#6659)

		                if (!options.style.width) {

		                    label.css({
		                        width: this.chart.spacingBox.width
		                    });

		                }


		                label.attr({
		                    text: text && text.join ? text.join('') : text
		                });

		                // Set the stroke color of the box to reflect the point
		                label.removeClass(/highcharts-color-[\d]+/g)
		                    .addClass(
		                        'highcharts-color-' +
		                        pick(point.colorIndex, currentSeries.colorIndex)
		                    );


		                label.attr({
		                    stroke: (
		                        options.borderColor ||
		                        point.color ||
		                        currentSeries.color ||
		                        '#666666'
		                    )
		                });


		                tooltip.updatePosition({
		                    plotX: x,
		                    plotY: y,
		                    negative: point.negative,
		                    ttBelow: point.ttBelow,
		                    h: anchor[2] || 0
		                });
		            }

		            this.isHidden = false;
		        }
		    },

		    /**
		     * Render the split tooltip. Loops over each point's text and adds
		     * a label next to the point, then uses the distribute function to
		     * find best non-overlapping positions.
		     *
		     * @private
		     * @function Highcharts.Tooltip#renderSplit
		     *
		     * @param {Array<Highcharts.Label>} labels
		     *
		     * @param {Array<Highcharts.Point>} points
		     */
		    renderSplit: function (labels, points) {
		        var tooltip = this,
		            boxes = [],
		            chart = this.chart,
		            ren = chart.renderer,
		            rightAligned = true,
		            options = this.options,
		            headerHeight = 0,
		            headerTop,
		            tooltipLabel = this.getLabel(),
		            distributionBoxTop = chart.plotTop;

		        // Graceful degradation for legacy formatters
		        if (H.isString(labels)) {
		            labels = [false, labels];
		        }
		        // Create the individual labels for header and points, ignore footer
		        each(labels.slice(0, points.length + 1), function (str, i) {
		            if (str !== false) {
		                var point = points[i - 1] ||
		                        // Item 0 is the header. Instead of this, we could also
		                        // use the crosshair label
		                        { isHeader: true, plotX: points[0].plotX },
		                    owner = point.series || tooltip,
		                    tt = owner.tt,
		                    series = point.series || {},
		                    colorClass = 'highcharts-color-' + pick(
		                        point.colorIndex,
		                        series.colorIndex,
		                        'none'
		                    ),
		                    target,
		                    x,
		                    bBox,
		                    boxWidth;

		                // Store the tooltip referance on the series
		                if (!tt) {
		                    owner.tt = tt = ren.label(
		                            null,
		                            null,
		                            null,
		                            'callout',
		                            null,
		                            null,
		                            options.useHTML
		                        )
		                        .addClass(
		                            'highcharts-tooltip-box ' + colorClass +
		                            (point.isHeader ? ' highcharts-tooltip-header' : '')
		                        )
		                        .attr({
		                            'padding': options.padding,
		                            'r': options.borderRadius,

		                            'fill': options.backgroundColor,
		                            'stroke': (
		                                options.borderColor ||
		                                point.color ||
		                                series.color ||
		                                '#333333'
		                            ),
		                            'stroke-width': options.borderWidth

		                        })
		                        .add(tooltipLabel);
		                }

		                tt.isActive = true;
		                tt.attr({
		                    text: str
		                });

		                tt.css(options.style)
		                    .shadow(options.shadow);


		                // Get X position now, so we can move all to the other side in
		                // case of overflow
		                bBox = tt.getBBox();
		                boxWidth = bBox.width + tt.strokeWidth();
		                if (point.isHeader) {
		                    headerHeight = bBox.height;
		                    if (chart.xAxis[0].opposite) {
		                        headerTop = true;
		                        distributionBoxTop -= headerHeight;
		                    }
		                    x = Math.max(
		                        0, // No left overflow
		                        Math.min(
		                            point.plotX + chart.plotLeft - boxWidth / 2,
		                            // No right overflow (#5794)
		                            chart.chartWidth +
		                            (
		                                // Scrollable plot area
		                                chart.scrollablePixels ?
		                                    chart.scrollablePixels - chart.marginRight :
		                                    0
		                            ) -
		                            boxWidth
		                        )
		                    );
		                } else {
		                    x = point.plotX + chart.plotLeft -
		                        pick(options.distance, 16) - boxWidth;
		                }


		                // If overflow left, we don't use this x in the next loop
		                if (x < 0) {
		                    rightAligned = false;
		                }

		                // Prepare for distribution
		                target = (point.series && point.series.yAxis &&
		                    point.series.yAxis.pos) + (point.plotY || 0);
		                target -= distributionBoxTop;

		                if (point.isHeader) {
		                    target = headerTop ?
		                        -headerHeight :
		                        chart.plotHeight + headerHeight;
		                }
		                boxes.push({
		                    target: target,
		                    rank: point.isHeader ? 1 : 0,
		                    size: owner.tt.getBBox().height + 1,
		                    point: point,
		                    x: x,
		                    tt: tt
		                });
		            }
		        });

		        // Clean previous run (for missing points)
		        this.cleanSplit();

		        // Distribute and put in place
		        H.distribute(boxes, chart.plotHeight + headerHeight);
		        each(boxes, function (box) {
		            var point = box.point,
		                series = point.series;

		            // Put the label in place
		            box.tt.attr({
		                visibility: box.pos === undefined ? 'hidden' : 'inherit',
		                x: (rightAligned || point.isHeader ?
		                    box.x :
		                    point.plotX + chart.plotLeft + pick(options.distance, 16)),
		                y: box.pos + distributionBoxTop,
		                anchorX: point.isHeader ?
		                    point.plotX + chart.plotLeft :
		                    point.plotX + series.xAxis.pos,
		                anchorY: point.isHeader ?
		                    chart.plotTop + chart.plotHeight / 2 :
		                    point.plotY + series.yAxis.pos
		            });
		        });
		    },

		    /**
		     * Find the new position and perform the move
		     *
		     * @private
		     * @function Highcharts.Tooltip#updatePosition
		     *
		     * @param {Highcharts.Point} point
		     */
		    updatePosition: function (point) {
		        var chart = this.chart,
		            label = this.getLabel(),
		            pos = (this.options.positioner || this.getPosition).call(
		                this,
		                label.width,
		                label.height,
		                point
		            ),
		            anchorX = point.plotX + chart.plotLeft,
		            anchorY = point.plotY + chart.plotTop,
		            pad;

		        // Set the renderer size dynamically to prevent document size to change
		        if (this.outside) {
		            pad = (this.options.borderWidth || 0) + 2 * this.distance;
		            this.renderer.setSize(
		                label.width + pad,
		                label.height + pad,
		                false
		            );
		            anchorX += chart.pointer.chartPosition.left - pos.x;
		            anchorY += chart.pointer.chartPosition.top - pos.y;
		        }

		        // do the move
		        this.move(
		            Math.round(pos.x),
		            Math.round(pos.y || 0), // can be undefined (#3977)
		            anchorX,
		            anchorY
		        );
		    },

		    /**
		     * Get the optimal date format for a point, based on a range.
		     *
		     * @private
		     * @function Highcharts.Tooltip#getDateFormat
		     *
		     * @param {number} range
		     *        The time range
		     *
		     * @param {number|Date} date
		     *        The date of the point in question
		     *
		     * @param {number} startOfWeek
		     *        An integer representing the first day of the week, where 0 is
		     *        Sunday.
		     *
		     * @param {Highcharts.Dictionary<string>} dateTimeLabelFormats
		     *        A map of time units to formats.
		     *
		     * @return {string}
		     *         The optimal date format for a point.
		     */
		    getDateFormat: function (range, date, startOfWeek, dateTimeLabelFormats) {
		        var time = this.chart.time,
		            dateStr = time.dateFormat('%m-%d %H:%M:%S.%L', date),
		            format,
		            n,
		            blank = '01-01 00:00:00.000',
		            strpos = {
		                millisecond: 15,
		                second: 12,
		                minute: 9,
		                hour: 6,
		                day: 3
		            },
		            lastN = 'millisecond'; // for sub-millisecond data, #4223
		        for (n in timeUnits) {

		            // If the range is exactly one week and we're looking at a
		            // Sunday/Monday, go for the week format
		            if (
		                range === timeUnits.week &&
		                +time.dateFormat('%w', date) === startOfWeek &&
		                dateStr.substr(6) === blank.substr(6)
		            ) {
		                n = 'week';
		                break;
		            }

		            // The first format that is too great for the range
		            if (timeUnits[n] > range) {
		                n = lastN;
		                break;
		            }

		            // If the point is placed every day at 23:59, we need to show
		            // the minutes as well. #2637.
		            if (
		                strpos[n] &&
		                dateStr.substr(strpos[n]) !== blank.substr(strpos[n])
		            ) {
		                break;
		            }

		            // Weeks are outside the hierarchy, only apply them on
		            // Mondays/Sundays like in the first condition
		            if (n !== 'week') {
		                lastN = n;
		            }
		        }

		        if (n) {
		            format = time.resolveDTLFormat(dateTimeLabelFormats[n]).main;
		        }

		        return format;
		    },

		    /**
		     * Get the best X date format based on the closest point range on the axis.
		     *
		     * @private
		     * @function Highcharts.Tooltip#getXDateFormat
		     *
		     * @param {Highcharts.Point} point
		     *
		     * @param {Highcharts.TooltipOptions} options
		     *
		     * @param {Highcharts.Axis} xAxis
		     *
		     * @return {string}
		     */
		    getXDateFormat: function (point, options, xAxis) {
		        var xDateFormat,
		            dateTimeLabelFormats = options.dateTimeLabelFormats,
		            closestPointRange = xAxis && xAxis.closestPointRange;

		        if (closestPointRange) {
		            xDateFormat = this.getDateFormat(
		                closestPointRange,
		                point.x,
		                xAxis.options.startOfWeek,
		                dateTimeLabelFormats
		            );
		        } else {
		            xDateFormat = dateTimeLabelFormats.day;
		        }

		        return xDateFormat || dateTimeLabelFormats.year; // #2546, 2581
		    },

		    /**
		     * Format the footer/header of the tooltip
		     * #3397: abstraction to enable formatting of footer and header
		     *
		     * @private
		     * @function Highcharts.Tooltip#tooltipFooterHeaderFormatter
		     *
		     * @param {*} labelConfig
		     *
		     * @param {boolean} isFooter
		     *
		     * @return {string}
		     */
		    tooltipFooterHeaderFormatter: function (labelConfig, isFooter) {
		        var footOrHead = isFooter ? 'footer' : 'header',
		            series = labelConfig.series,
		            tooltipOptions = series.tooltipOptions,
		            xDateFormat = tooltipOptions.xDateFormat,
		            xAxis = series.xAxis,
		            isDateTime = (
		                xAxis &&
		                xAxis.options.type === 'datetime' &&
		                isNumber(labelConfig.key)
		            ),
		            formatString = tooltipOptions[footOrHead + 'Format'];

		        // Guess the best date format based on the closest point distance (#568,
		        // #3418)
		        if (isDateTime && !xDateFormat) {
		            xDateFormat = this.getXDateFormat(
		                labelConfig,
		                tooltipOptions,
		                xAxis
		            );
		        }

		        // Insert the footer date format if any
		        if (isDateTime && xDateFormat) {
		            each(
		                (labelConfig.point && labelConfig.point.tooltipDateKeys) ||
		                    ['key'],
		                function (key) {
		                    formatString = formatString.replace(
		                        '{point.' + key + '}',
		                        '{point.' + key + ':' + xDateFormat + '}'
		                    );
		                }
		            );
		        }

		        return format(formatString, {
		            point: labelConfig,
		            series: series
		        }, this.chart.time);
		    },

		    /**
		     * Build the body (lines) of the tooltip by iterating over the items and
		     * returning one entry for each item, abstracting this functionality allows
		     * to easily overwrite and extend it.
		     *
		     * @private
		     * @function Highcharts.Tooltip#bodyFormatter
		     *
		     * @param {Array<Highcharts.Point>} items
		     *
		     * @return {string}
		     */
		    bodyFormatter: function (items) {
		        return map(items, function (item) {
		            var tooltipOptions = item.series.tooltipOptions;
		            return (
		                tooltipOptions[
		                    (item.point.formatPrefix || 'point') + 'Formatter'
		                ] ||
		                item.point.tooltipFormatter
		            ).call(
		                item.point,
		                tooltipOptions[(item.point.formatPrefix || 'point') + 'Format']
		            );
		        });
		    }

		};

	}(Highcharts));
	(function (Highcharts) {
		/**
		 * (c) 2010-2018 Torstein Honsi
		 *
		 * License: www.highcharts.com/license
		 */

		/**
		 * One position in relation to an axis.
		 *
		 * @typedef Highcharts.PointerAxisCoordinateObject
		 *
		 * @property {Highcharts.Axis} axis
		 *           Related axis.
		 *
		 * @property {number} value
		 *           Axis value.
		 */

		/**
		 * Positions in terms of axis values.
		 *
		 * @typedef Highcharts.PointerAxisCoordinatesObject
		 *
		 * @property {Array<Highcharts.PointerAxisCoordinateObject>} xAxis
		 *           Positions on the x-axis.
		 *
		 * @property {Array<Highcharts.PointerAxisCoordinateObject>} yAxis
		 *           Positions on the y-axis.
		 */

		/**
		 * Pointer coordinates.
		 *
		 * @typedef Highcharts.PointerCoordinatesObject
		 *
		 * @property {number} chartX
		 *
		 * @property {number} chartY
		 */

		/**
		 * A native browser mouse or touch event, extended with position information
		 * relative to the {@link Chart.container}.
		 *
		 * @typedef {global.PointerEvent} Highcharts.PointerEventObject
		 *
		 * @property {number} chartX
		 *           The X coordinate of the pointer interaction relative to the
		 *           chart.
		 *
		 * @property {number} chartY
		 *           The Y coordinate of the pointer interaction relative to the
		 *           chart.
		 */

		/**
		 * Axis-specific data of a selection.
		 *
		 * @typedef Highcharts.SelectDataObject
		 *
		 * @property {Highcharts.Axis} axis
		 *
		 * @property {number} min
		 *
		 * @property {number} max
		 */

		/**
		 * Object for select events.
		 *
		 * @typedef Highcharts.SelectEventObject
		 *
		 * @property {global.Event} originalEvent
		 *
		 * @property {Array<Highcharts.SelectDataObject>} xAxis
		 *
		 * @property {Array<Highcharts.SelectDataObject>} yAxis
		 */



		var H = Highcharts,
		    addEvent = H.addEvent,
		    attr = H.attr,
		    charts = H.charts,
		    color = H.color,
		    css = H.css,
		    defined = H.defined,
		    each = H.each,
		    extend = H.extend,
		    find = H.find,
		    fireEvent = H.fireEvent,
		    isNumber = H.isNumber,
		    isObject = H.isObject,
		    offset = H.offset,
		    pick = H.pick,
		    splat = H.splat,
		    Tooltip = H.Tooltip;

		/**
		 * The mouse and touch tracker object. Each {@link Chart} item has one
		 * assosiated Pointer item that can be accessed from the  {@link Chart.pointer}
		 * property.
		 *
		 * @class
		 * @name Highcharts.Pointer
		 *
		 * @param {Highcharts.Chart} chart
		 *        The Chart instance.
		 *
		 * @param {Highcharts.Options} options
		 *        The root options object. The pointer uses options from the chart and
		 *        tooltip structures.
		 */
		Highcharts.Pointer = function (chart, options) {
		    this.init(chart, options);
		};

		Highcharts.Pointer.prototype = {
		    /**
		     * Initialize the Pointer.
		     *
		     * @private
		     * @function Highcharts.Pointer#init
		     *
		     * @param {Highcharts.Chart} chart
		     *        The Chart instance.
		     *
		     * @param {Highcharts.Options} options
		     *        The root options object. The pointer uses options from the chart
		     *        and tooltip structures.
		     */
		    init: function (chart, options) {

		        // Store references
		        this.options = options;
		        this.chart = chart;

		        // Do we need to handle click on a touch device?
		        this.runChartClick =
		            options.chart.events && !!options.chart.events.click;

		        this.pinchDown = [];
		        this.lastValidTouch = {};

		        if (Tooltip) {
		            /**
		             * Tooltip object for points of series.
		             *
		             * @name Highcharts.Chart#tooltip
		             * @type {Highcharts.Tooltip}
		             */
		            chart.tooltip = new Tooltip(chart, options.tooltip);
		            this.followTouchMove = pick(options.tooltip.followTouchMove, true);
		        }

		        this.setDOMEvents();
		    },

		    /**
		     * Resolve the zoomType option, this is reset on all touch start and mouse
		     * down events.
		     *
		     * @private
		     * @function Highcharts.Pointer#zoomOption
		     *
		     * @param {global.Event} e
		     *        Event object.
		     */
		    zoomOption: function (e) {
		        var chart = this.chart,
		            options = chart.options.chart,
		            zoomType = options.zoomType || '',
		            inverted = chart.inverted,
		            zoomX,
		            zoomY;

		        // Look for the pinchType option
		        if (/touch/.test(e.type)) {
		            zoomType = pick(options.pinchType, zoomType);
		        }

		        this.zoomX = zoomX = /x/.test(zoomType);
		        this.zoomY = zoomY = /y/.test(zoomType);
		        this.zoomHor = (zoomX && !inverted) || (zoomY && inverted);
		        this.zoomVert = (zoomY && !inverted) || (zoomX && inverted);
		        this.hasZoom = zoomX || zoomY;
		    },

		    /**
		     * Takes a browser event object and extends it with custom Highcharts
		     * properties `chartX` and `chartY` in order to work on the internal
		     * coordinate system.
		     *
		     * @function Highcharts.Pointer#normalize
		     *
		     * @param {global.Event} e
		     *        Event object in standard browsers.
		     *
		     * @return {Highcharts.PointerEventObject}
		     *         A browser event with extended properties `chartX` and `chartY`.
		     */
		    normalize: function (e, chartPosition) {
		        var ePos;

		        // iOS (#2757)
		        ePos = e.touches ?
		            (e.touches.length ? e.touches.item(0) : e.changedTouches[0]) :
		            e;

		        // Get mouse position
		        if (!chartPosition) {
		            this.chartPosition = chartPosition = offset(this.chart.container);
		        }

		        return extend(e, {
		            chartX: Math.round(ePos.pageX - chartPosition.left),
		            chartY: Math.round(ePos.pageY - chartPosition.top)
		        });
		    },

		    /**
		     * Get the click position in terms of axis values.
		     *
		     * @function Highcharts.Pointer#getCoordinates
		     *
		     * @param {Highcharts.PointerEventObject} e
		     *        Pointer event, extended with `chartX` and `chartY` properties.
		     *
		     * @return {Highcharts.PointerAxisCoordinatesObject}
		     */
		    getCoordinates: function (e) {

		        var coordinates = {
		            xAxis: [],
		            yAxis: []
		        };

		        each(this.chart.axes, function (axis) {
		            coordinates[axis.isXAxis ? 'xAxis' : 'yAxis'].push({
		                axis: axis,
		                value: axis.toValue(e[axis.horiz ? 'chartX' : 'chartY'])
		            });
		        });

		        return coordinates;
		    },

		    /**
		     * Finds the closest point to a set of coordinates, using the k-d-tree
		     * algorithm.
		     *
		     * @function Highcharts.Pointer#findNearestKDPoints
		     *
		     * @param {Array<Highcharts.Series>} series
		     *        All the series to search in.
		     *
		     * @param {boolean} shared
		     *        Whether it is a shared tooltip or not.
		     *
		     * @param {Highcharts.PointerCoordinatesObject} coordinates
		     *        Chart coordinates of the pointer.
		     *
		     * @return {Point|undefined}
		     *         The point closest to given coordinates.
		     */
		    findNearestKDPoint: function (series, shared, coordinates) {
		        var closest,
		            sort = function (p1, p2) {
		                var isCloserX = p1.distX - p2.distX,
		                    isCloser = p1.dist - p2.dist,
		                    isAbove =
		                        (p2.series.group && p2.series.group.zIndex) -
		                        (p1.series.group && p1.series.group.zIndex),
		                    result;

		                // We have two points which are not in the same place on xAxis
		                // and shared tooltip:
		                if (isCloserX !== 0 && shared) { // #5721
		                    result = isCloserX;
		                // Points are not exactly in the same place on x/yAxis:
		                } else if (isCloser !== 0) {
		                    result = isCloser;
		                // The same xAxis and yAxis position, sort by z-index:
		                } else if (isAbove !== 0) {
		                    result = isAbove;
		                // The same zIndex, sort by array index:
		                } else {
		                    result = p1.series.index > p2.series.index ? -1 : 1;
		                }
		                return result;
		            };
		        each(series, function (s) {
		            var noSharedTooltip = s.noSharedTooltip && shared,
		                compareX = (
		                    !noSharedTooltip &&
		                    s.options.findNearestPointBy.indexOf('y') < 0
		                ),
		                point = s.searchPoint(
		                    coordinates,
		                    compareX
		                );
		            if (
		                // Check that we actually found a point on the series.
		                isObject(point, true) &&
		                // Use the new point if it is closer.
		                (!isObject(closest, true) || (sort(closest, point) > 0))
		            ) {
		                closest = point;
		            }
		        });
		        return closest;
		    },

		    /**
		     * @private
		     * @function Highcharts.Pointer#getPointFromEvent
		     *
		     * @param {global.Event} e
		     *
		     * @return {Highcharts.Point|undefined}
		     */
		    getPointFromEvent: function (e) {
		        var target = e.target,
		            point;

		        while (target && !point) {
		            point = target.point;
		            target = target.parentNode;
		        }
		        return point;
		    },

		    /**
		     * @private
		     * @function Highcharts.Pointer#getChartCoordinatesFromPoint
		     *
		     * @param {Highcharts.Point} point
		     *
		     * @param {boolean} inverted
		     *
		     * @return {Highcharts.PointerCoordinatesObject}
		     */
		    getChartCoordinatesFromPoint: function (point, inverted) {
		        var series = point.series,
		            xAxis = series.xAxis,
		            yAxis = series.yAxis,
		            plotX = pick(point.clientX, point.plotX),
		            shapeArgs = point.shapeArgs;

		        if (xAxis && yAxis) {
		            return inverted ? {
		                chartX: xAxis.len + xAxis.pos - plotX,
		                chartY: yAxis.len + yAxis.pos - point.plotY
		            } : {
		                chartX: plotX + xAxis.pos,
		                chartY: point.plotY + yAxis.pos
		            };
		        } else if (shapeArgs && shapeArgs.x && shapeArgs.y) {
		            // E.g. pies do not have axes
		            return {
		                chartX: shapeArgs.x,
		                chartY: shapeArgs.y
		            };
		        }
		    },

		    /**
		     * Calculates what is the current hovered point/points and series.
		     *
		     * @private
		     * @function Highcharts.Pointer#getHoverData
		     *
		     * @param {Highcharts.Point|undefined} existingHoverPoint
		     *        The point currrently beeing hovered.
		     *
		     * @param {Highcharts.Series|undefined} existingHoverSeries
		     *        The series currently beeing hovered.
		     *
		     * @param {Array<Highcharts.Series>} series
		     *        All the series in the chart.
		     *
		     * @param {boolean} isDirectTouch
		     *        Is the pointer directly hovering the point.
		     *
		     * @param {boolean} shared
		     *        Whether it is a shared tooltip or not.
		     *
		     * @param {Highcharts.PointerCoordinatesObject} coordinates
		     *        Chart coordinates of the pointer.
		     *
		     * @return {*}
		     *         Object containing resulting hover data: hoverPoint, hoverSeries,
		     *         and hoverPoints.
		     */
		    getHoverData: function (
		        existingHoverPoint,
		        existingHoverSeries,
		        series,
		        isDirectTouch,
		        shared,
		        coordinates,
		        params
		    ) {
		        var hoverPoint,
		            hoverPoints = [],
		            hoverSeries = existingHoverSeries,
		            isBoosting = params && params.isBoosting,
		            useExisting = !!(isDirectTouch && existingHoverPoint),
		            notSticky = hoverSeries && !hoverSeries.stickyTracking,
		            filter = function (s) {
		                return (
		                    s.visible &&
		                    !(!shared && s.directTouch) && // #3821
		                    pick(s.options.enableMouseTracking, true)
		                );
		            },
		            // Which series to look in for the hover point
		            searchSeries = notSticky ?
		                // Only search on hovered series if it has stickyTracking false
		                [hoverSeries] :
		                // Filter what series to look in.
		                H.grep(series, function (s) {
		                    return filter(s) && s.stickyTracking;
		                });

		        // Use existing hovered point or find the one closest to coordinates.
		        hoverPoint = useExisting ?
		            existingHoverPoint :
		            this.findNearestKDPoint(searchSeries, shared, coordinates);

		        // Assign hover series
		        hoverSeries = hoverPoint && hoverPoint.series;

		        // If we have a hoverPoint, assign hoverPoints.
		        if (hoverPoint) {
		            // When tooltip is shared, it displays more than one point
		            if (shared && !hoverSeries.noSharedTooltip) {
		                searchSeries = H.grep(series, function (s) {
		                    return filter(s) && !s.noSharedTooltip;
		                });

		                // Get all points with the same x value as the hoverPoint
		                each(searchSeries, function (s) {
		                    var point = find(s.points, function (p) {
		                        return p.x === hoverPoint.x && !p.isNull;
		                    });
		                    if (isObject(point)) {
		                        /*
		                        * Boost returns a minimal point. Convert it to a usable
		                        * point for tooltip and states.
		                        */
		                        if (isBoosting) {
		                            point = s.getPoint(point);
		                        }
		                        hoverPoints.push(point);
		                    }
		                });
		            } else {
		                hoverPoints.push(hoverPoint);
		            }
		        }
		        return {
		            hoverPoint: hoverPoint,
		            hoverSeries: hoverSeries,
		            hoverPoints: hoverPoints
		        };
		    },

		    /**
		     * With line type charts with a single tracker, get the point closest to the
		     * mouse. Run Point.onMouseOver and display tooltip for the point or points.
		     *
		     * @private
		     * @function Highcharts.Pointer#runPointActions
		     *
		     * @param {global.Event} e
		     *
		     * @param {Highcharts.Point} p
		     *
		     * @fires Highcharts.Point#event:mouseOut
		     * @fires Highcharts.Point#event:mouseOver
		     */
		    runPointActions: function (e, p) {
		        var pointer = this,
		            chart = pointer.chart,
		            series = chart.series,
		            tooltip = chart.tooltip && chart.tooltip.options.enabled ?
		                chart.tooltip :
		                undefined,
		            shared = tooltip ? tooltip.shared : false,
		            hoverPoint = p || chart.hoverPoint,
		            hoverSeries = hoverPoint && hoverPoint.series || chart.hoverSeries,
		            // onMouseOver or already hovering a series with directTouch
		            isDirectTouch = e.type !== 'touchmove' && (
		                !!p || (
		                    (hoverSeries && hoverSeries.directTouch) &&
		                    pointer.isDirectTouch
		                )
		            ),
		            hoverData = this.getHoverData(
		                hoverPoint,
		                hoverSeries,
		                series,
		                isDirectTouch,
		                shared,
		                e,
		                { isBoosting: chart.isBoosting }
		            ),
		            useSharedTooltip,
		            followPointer,
		            anchor,
		            points;

		        // Update variables from hoverData.
		        hoverPoint = hoverData.hoverPoint;
		        points = hoverData.hoverPoints;
		        hoverSeries = hoverData.hoverSeries;
		        followPointer = hoverSeries && hoverSeries.tooltipOptions.followPointer;
		        useSharedTooltip = (
		            shared &&
		            hoverSeries &&
		            !hoverSeries.noSharedTooltip
		        );

		        // Refresh tooltip for kdpoint if new hover point or tooltip was hidden
		        // #3926, #4200
		        if (
		            hoverPoint &&
		            // !(hoverSeries && hoverSeries.directTouch) &&
		            (hoverPoint !== chart.hoverPoint || (tooltip && tooltip.isHidden))
		        ) {
		            each(chart.hoverPoints || [], function (p) {
		                if (H.inArray(p, points) === -1) {
		                    p.setState();
		                }
		            });
		            // Do mouseover on all points (#3919, #3985, #4410, #5622)
		            each(points || [], function (p) {
		                p.setState('hover');
		            });
		            // set normal state to previous series
		            if (chart.hoverSeries !== hoverSeries) {
		                hoverSeries.onMouseOver();
		            }

		            // If tracking is on series in stead of on each point,
		            // fire mouseOver on hover point. // #4448
		            if (chart.hoverPoint) {
		                chart.hoverPoint.firePointEvent('mouseOut');
		            }

		            // Hover point may have been destroyed in the event handlers (#7127)
		            if (!hoverPoint.series) {
		                return;
		            }

		            hoverPoint.firePointEvent('mouseOver');
		            chart.hoverPoints = points;
		            chart.hoverPoint = hoverPoint;
		            // Draw tooltip if necessary
		            if (tooltip) {
		                tooltip.refresh(useSharedTooltip ? points : hoverPoint, e);
		            }
		        // Update positions (regardless of kdpoint or hoverPoint)
		        } else if (followPointer && tooltip && !tooltip.isHidden) {
		            anchor = tooltip.getAnchor([{}], e);
		            tooltip.updatePosition({ plotX: anchor[0], plotY: anchor[1] });
		        }

		        // Start the event listener to pick up the tooltip and crosshairs
		        if (!pointer.unDocMouseMove) {
		            pointer.unDocMouseMove = addEvent(
		                chart.container.ownerDocument,
		                'mousemove',
		                function (e) {
		                    var chart = charts[H.hoverChartIndex];
		                    if (chart) {
		                        chart.pointer.onDocumentMouseMove(e);
		                    }
		                }
		            );
		        }

		        // Issues related to crosshair #4927, #5269 #5066, #5658
		        each(chart.axes, function drawAxisCrosshair(axis) {
		            var snap = pick(axis.crosshair.snap, true),
		                point = !snap ?
		                    undefined :
		                    H.find(points, function (p) {
		                        return p.series[axis.coll] === axis;
		                    });

		            // Axis has snapping crosshairs, and one of the hover points belongs
		            // to axis. Always call drawCrosshair when it is not snap.
		            if (point || !snap) {
		                axis.drawCrosshair(e, point);
		            // Axis has snapping crosshairs, but no hover point belongs to axis
		            } else {
		                axis.hideCrosshair();
		            }
		        });
		    },

		    /**
		     * Reset the tracking by hiding the tooltip, the hover series state and the
		     * hover point
		     *
		     * @function Highcharts.Pointer#reset
		     *
		     * @param {boolean} allowMove
		     *        Instead of destroying the tooltip altogether, allow moving it if
		     *        possible.
		     *
		     * @param {number} delay
		     */
		    reset: function (allowMove, delay) {
		        var pointer = this,
		            chart = pointer.chart,
		            hoverSeries = chart.hoverSeries,
		            hoverPoint = chart.hoverPoint,
		            hoverPoints = chart.hoverPoints,
		            tooltip = chart.tooltip,
		            tooltipPoints = tooltip && tooltip.shared ?
		                hoverPoints :
		                hoverPoint;

		        // Check if the points have moved outside the plot area (#1003, #4736,
		        // #5101)
		        if (allowMove && tooltipPoints) {
		            each(splat(tooltipPoints), function (point) {
		                if (point.series.isCartesian && point.plotX === undefined) {
		                    allowMove = false;
		                }
		            });
		        }

		        // Just move the tooltip, #349
		        if (allowMove) {
		            if (tooltip && tooltipPoints) {
		                tooltip.refresh(tooltipPoints);
		                if (tooltip.shared && hoverPoints) { // #8284
		                    each(hoverPoints, function (point) {
		                        point.setState(point.state, true);
		                        if (point.series.isCartesian) {
		                            if (point.series.xAxis.crosshair) {
		                                point.series.xAxis.drawCrosshair(null, point);
		                            }
		                            if (point.series.yAxis.crosshair) {
		                                point.series.yAxis.drawCrosshair(null, point);
		                            }
		                        }
		                    });
		                } else if (hoverPoint) { // #2500
		                    hoverPoint.setState(hoverPoint.state, true);
		                    each(chart.axes, function (axis) {
		                        if (axis.crosshair) {
		                            axis.drawCrosshair(null, hoverPoint);
		                        }
		                    });
		                }
		            }

		        // Full reset
		        } else {

		            if (hoverPoint) {
		                hoverPoint.onMouseOut();
		            }

		            if (hoverPoints) {
		                each(hoverPoints, function (point) {
		                    point.setState();
		                });
		            }

		            if (hoverSeries) {
		                hoverSeries.onMouseOut();
		            }

		            if (tooltip) {
		                tooltip.hide(delay);
		            }

		            if (pointer.unDocMouseMove) {
		                pointer.unDocMouseMove = pointer.unDocMouseMove();
		            }

		            // Remove crosshairs
		            each(chart.axes, function (axis) {
		                axis.hideCrosshair();
		            });

		            pointer.hoverX = chart.hoverPoints = chart.hoverPoint = null;
		        }
		    },

		    /**
		     * Scale series groups to a certain scale and translation.
		     *
		     * @private
		     * @function Highcharts.Pointer#scaleGroups
		     *
		     * @param {Highcharts.SeriesPlotBoxObject} attribs
		     *
		     * @param {boolean} clip
		     */
		    scaleGroups: function (attribs, clip) {

		        var chart = this.chart,
		            seriesAttribs;

		        // Scale each series
		        each(chart.series, function (series) {
		            seriesAttribs = attribs || series.getPlotBox(); // #1701
		            if (series.xAxis && series.xAxis.zoomEnabled && series.group) {
		                series.group.attr(seriesAttribs);
		                if (series.markerGroup) {
		                    series.markerGroup.attr(seriesAttribs);
		                    series.markerGroup.clip(clip ? chart.clipRect : null);
		                }
		                if (series.dataLabelsGroup) {
		                    series.dataLabelsGroup.attr(seriesAttribs);
		                }
		            }
		        });

		        // Clip
		        chart.clipRect.attr(clip || chart.clipBox);
		    },

		    /**
		     * Start a drag operation.
		     *
		     * @private
		     * @function Highcharts.Pointer#dragStart
		     *
		     * @param {Highcharts.PointerEventObject} e
		     */
		    dragStart: function (e) {
		        var chart = this.chart;

		        // Record the start position
		        chart.mouseIsDown = e.type;
		        chart.cancelClick = false;
		        chart.mouseDownX = this.mouseDownX = e.chartX;
		        chart.mouseDownY = this.mouseDownY = e.chartY;
		    },

		    /**
		     * Perform a drag operation in response to a mousemove event while the mouse
		     * is down.
		     *
		     * @private
		     * @function Highcharts.Pointer#drag
		     *
		     * @param {Highcharts.PointerEventObject} e
		     */
		    drag: function (e) {

		        var chart = this.chart,
		            chartOptions = chart.options.chart,
		            chartX = e.chartX,
		            chartY = e.chartY,
		            zoomHor = this.zoomHor,
		            zoomVert = this.zoomVert,
		            plotLeft = chart.plotLeft,
		            plotTop = chart.plotTop,
		            plotWidth = chart.plotWidth,
		            plotHeight = chart.plotHeight,
		            clickedInside,
		            size,
		            selectionMarker = this.selectionMarker,
		            mouseDownX = this.mouseDownX,
		            mouseDownY = this.mouseDownY,
		            panKey = chartOptions.panKey && e[chartOptions.panKey + 'Key'];

		        // If the device supports both touch and mouse (like IE11), and we are
		        // touch-dragging inside the plot area, don't handle the mouse event.
		        // #4339.
		        if (selectionMarker && selectionMarker.touch) {
		            return;
		        }

		        // If the mouse is outside the plot area, adjust to cooordinates
		        // inside to prevent the selection marker from going outside
		        if (chartX < plotLeft) {
		            chartX = plotLeft;
		        } else if (chartX > plotLeft + plotWidth) {
		            chartX = plotLeft + plotWidth;
		        }

		        if (chartY < plotTop) {
		            chartY = plotTop;
		        } else if (chartY > plotTop + plotHeight) {
		            chartY = plotTop + plotHeight;
		        }

		        // determine if the mouse has moved more than 10px
		        this.hasDragged = Math.sqrt(
		            Math.pow(mouseDownX - chartX, 2) +
		            Math.pow(mouseDownY - chartY, 2)
		        );

		        if (this.hasDragged > 10) {
		            clickedInside = chart.isInsidePlot(
		                mouseDownX - plotLeft,
		                mouseDownY - plotTop
		            );

		            // make a selection
		            if (
		                chart.hasCartesianSeries &&
		                (this.zoomX || this.zoomY) &&
		                clickedInside &&
		                !panKey
		            ) {
		                if (!selectionMarker) {
		                    this.selectionMarker = selectionMarker =
		                        chart.renderer.rect(
		                            plotLeft,
		                            plotTop,
		                            zoomHor ? 1 : plotWidth,
		                            zoomVert ? 1 : plotHeight,
		                            0
		                        )
		                        .attr({

		                            fill: (
		                                chartOptions.selectionMarkerFill ||
		                                color('#335cad')
		                                    .setOpacity(0.25).get()
		                            ),

		                            'class': 'highcharts-selection-marker',
		                            'zIndex': 7
		                        })
		                        .add();
		                }
		            }

		            // adjust the width of the selection marker
		            if (selectionMarker && zoomHor) {
		                size = chartX - mouseDownX;
		                selectionMarker.attr({
		                    width: Math.abs(size),
		                    x: (size > 0 ? 0 : size) + mouseDownX
		                });
		            }
		            // adjust the height of the selection marker
		            if (selectionMarker && zoomVert) {
		                size = chartY - mouseDownY;
		                selectionMarker.attr({
		                    height: Math.abs(size),
		                    y: (size > 0 ? 0 : size) + mouseDownY
		                });
		            }

		            // panning
		            if (clickedInside && !selectionMarker && chartOptions.panning) {
		                chart.pan(e, chartOptions.panning);
		            }
		        }
		    },

		    /**
		     * On mouse up or touch end across the entire document, drop the selection.
		     *
		     * @private
		     * @function Highcharts.Pointer#drop
		     *
		     * @param {global.Event} e
		     */
		    drop: function (e) {
		        var pointer = this,
		            chart = this.chart,
		            hasPinched = this.hasPinched;

		        if (this.selectionMarker) {
		            var selectionData = {
		                    originalEvent: e, // #4890
		                    xAxis: [],
		                    yAxis: []
		                },
		                selectionBox = this.selectionMarker,
		                selectionLeft = selectionBox.attr ?
		                    selectionBox.attr('x') :
		                    selectionBox.x,
		                selectionTop = selectionBox.attr ?
		                    selectionBox.attr('y') :
		                    selectionBox.y,
		                selectionWidth = selectionBox.attr ?
		                    selectionBox.attr('width') :
		                    selectionBox.width,
		                selectionHeight = selectionBox.attr ?
		                    selectionBox.attr('height') :
		                    selectionBox.height,
		                runZoom;

		            // a selection has been made
		            if (this.hasDragged || hasPinched) {

		                // record each axis' min and max
		                each(chart.axes, function (axis) {
		                    if (
		                        axis.zoomEnabled &&
		                        defined(axis.min) &&
		                        (
		                            hasPinched ||
		                            pointer[{
		                                xAxis: 'zoomX',
		                                yAxis: 'zoomY'
		                            }[axis.coll]]
		                        )
		                    ) { // #859, #3569
		                        var horiz = axis.horiz,
		                            minPixelPadding = e.type === 'touchend' ?
		                                axis.minPixelPadding :
		                                0, // #1207, #3075
		                            selectionMin = axis.toValue(
		                                (horiz ? selectionLeft : selectionTop) +
		                                minPixelPadding
		                            ),
		                            selectionMax = axis.toValue(
		                                (
		                                    horiz ?
		                                        selectionLeft + selectionWidth :
		                                        selectionTop + selectionHeight
		                                ) - minPixelPadding
		                                );

		                        selectionData[axis.coll].push({
		                            axis: axis,
		                            // Min/max for reversed axes
		                            min: Math.min(selectionMin, selectionMax),
		                            max: Math.max(selectionMin, selectionMax)
		                        });
		                        runZoom = true;
		                    }
		                });
		                if (runZoom) {
		                    fireEvent(
		                        chart,
		                        'selection',
		                        selectionData,
		                        function (args) {
		                            chart.zoom(
		                                extend(
		                                    args,
		                                    hasPinched ? { animation: false } : null
		                                )
		                            );
		                        }
		                    );
		                }

		            }

		            if (isNumber(chart.index)) {
		                this.selectionMarker = this.selectionMarker.destroy();
		            }

		            // Reset scaling preview
		            if (hasPinched) {
		                this.scaleGroups();
		            }
		        }

		        // Reset all. Check isNumber because it may be destroyed on mouse up
		        // (#877)
		        if (chart && isNumber(chart.index)) {
		            css(chart.container, { cursor: chart._cursor });
		            chart.cancelClick = this.hasDragged > 10; // #370
		            chart.mouseIsDown = this.hasDragged = this.hasPinched = false;
		            this.pinchDown = [];
		        }
		    },

		    /**
		     * @private
		     * @function Highcharts.Pointer#onContainerMouseDown
		     *
		     * @param {global.Event} e
		     */
		    onContainerMouseDown: function (e) {
		        // Normalize before the 'if' for the legacy IE (#7850)
		        e = this.normalize(e);

		        if (e.button !== 2) {

		            this.zoomOption(e);

		            // issue #295, dragging not always working in Firefox
		            if (e.preventDefault) {
		                e.preventDefault();
		            }

		            this.dragStart(e);
		        }
		    },

		    /**
		     * @private
		     * @function Highcharts.Pointer#onDocumentMouseUp
		     *
		     * @param {global.Event} e
		     */
		    onDocumentMouseUp: function (e) {
		        if (charts[H.hoverChartIndex]) {
		            charts[H.hoverChartIndex].pointer.drop(e);
		        }
		    },

		    /**
		     * Special handler for mouse move that will hide the tooltip when the mouse
		     * leaves the plotarea. Issue #149 workaround. The mouseleave event does not
		     * always fire.
		     *
		     * @private
		     * @function Highcharts.Pointer#onDocumentMouseMove
		     *
		     * @param {Highcharts.PointerEventObject} e
		     */
		    onDocumentMouseMove: function (e) {
		        var chart = this.chart,
		            chartPosition = this.chartPosition;

		        e = this.normalize(e, chartPosition);

		        // If we're outside, hide the tooltip
		        if (
		            chartPosition &&
		            !this.inClass(e.target, 'highcharts-tracker') &&
		            !chart.isInsidePlot(
		                e.chartX - chart.plotLeft,
		                e.chartY - chart.plotTop
		            )
		        ) {
		            this.reset();
		        }
		    },

		    /**
		     * When mouse leaves the container, hide the tooltip.
		     *
		     * @private
		     * @function Highcharts.Pointer#onContainerMouseLeave
		     *
		     * @param {global.Event} e
		     */
		    onContainerMouseLeave: function (e) {
		        var chart = charts[H.hoverChartIndex];
		        // #4886, MS Touch end fires mouseleave but with no related target
		        if (chart && (e.relatedTarget || e.toElement)) {
		            chart.pointer.reset();
		            // Also reset the chart position, used in #149 fix
		            chart.pointer.chartPosition = null;
		        }
		    },

		    /**
		     * The mousemove, touchmove and touchstart event handler
		     *
		     * @private
		     * @function Highcharts.Pointer#onContainerMouseMove
		     *
		     * @param {Highcharts.PointerEventObject} e
		     */
		    onContainerMouseMove: function (e) {

		        var chart = this.chart;

		        if (
		            !defined(H.hoverChartIndex) ||
		            !charts[H.hoverChartIndex] ||
		            !charts[H.hoverChartIndex].mouseIsDown
		        ) {
		            H.hoverChartIndex = chart.index;
		        }

		        e = this.normalize(e);
		        e.returnValue = false; // #2251, #3224

		        if (chart.mouseIsDown === 'mousedown') {
		            this.drag(e);
		        }

		        // Show the tooltip and run mouse over events (#977)
		        if (
		            (
		                this.inClass(e.target, 'highcharts-tracker') ||
		                chart.isInsidePlot(
		                    e.chartX - chart.plotLeft,
		                    e.chartY - chart.plotTop
		                )
		            ) &&
		            !chart.openMenu
		        ) {
		            this.runPointActions(e);
		        }
		    },

		    /**
		     * Utility to detect whether an element has, or has a parent with, a
		     * specificclass name. Used on detection of tracker objects and on deciding
		     * whether hovering the tooltip should cause the active series to mouse out.
		     *
		     * @function Highcharts.Pointer#inClass
		     *
		     * @param {Highcharts.SVGDOMElement|Highcharts.HTMLDOMElement} element
		     *        The element to investigate.
		     *
		     * @param {string} className
		     *        The class name to look for.
		     *
		     * @return {boolean}
		     *         True if either the element or one of its parents has the given
		     *         class name.
		     */
		    inClass: function (element, className) {
		        var elemClassName;
		        while (element) {
		            elemClassName = attr(element, 'class');
		            if (elemClassName) {
		                if (elemClassName.indexOf(className) !== -1) {
		                    return true;
		                }
		                if (elemClassName.indexOf('highcharts-container') !== -1) {
		                    return false;
		                }
		            }
		            element = element.parentNode;
		        }
		    },

		    /**
		     * @private
		     * @function Highcharts.Pointer#onTrackerMouseOut
		     *
		     * @param {global.Event} e
		     */
		    onTrackerMouseOut: function (e) {
		        var series = this.chart.hoverSeries,
		            relatedTarget = e.relatedTarget || e.toElement;

		        this.isDirectTouch = false;

		        if (
		            series &&
		            relatedTarget &&
		            !series.stickyTracking &&
		            !this.inClass(relatedTarget, 'highcharts-tooltip') &&
		            (
		                !this.inClass(
		                    relatedTarget,
		                    'highcharts-series-' + series.index
		                ) || // #2499, #4465
		                !this.inClass(relatedTarget, 'highcharts-tracker') // #5553
		            )
		        ) {
		            series.onMouseOut();
		        }
		    },

		    /**
		     * @private
		     * @function Highcharts.Pointer#onContainerClick
		     *
		     * @param {Highcharts.PointerEventObject} e
		     */
		    onContainerClick: function (e) {
		        var chart = this.chart,
		            hoverPoint = chart.hoverPoint,
		            plotLeft = chart.plotLeft,
		            plotTop = chart.plotTop;

		        e = this.normalize(e);

		        if (!chart.cancelClick) {

		            // On tracker click, fire the series and point events. #783, #1583
		            if (hoverPoint && this.inClass(e.target, 'highcharts-tracker')) {

		                // the series click event
		                fireEvent(hoverPoint.series, 'click', extend(e, {
		                    point: hoverPoint
		                }));

		                // the point click event
		                if (chart.hoverPoint) { // it may be destroyed (#1844)
		                    hoverPoint.firePointEvent('click', e);
		                }

		            // When clicking outside a tracker, fire a chart event
		            } else {
		                extend(e, this.getCoordinates(e));

		                // fire a click event in the chart
		                if (
		                    chart.isInsidePlot(e.chartX - plotLeft, e.chartY - plotTop)
		                ) {
		                    fireEvent(chart, 'click', e);
		                }
		            }


		        }
		    },

		    /**
		     * Set the JS DOM events on the container and document. This method should
		     * contain a one-to-one assignment between methods and their handlers. Any
		     * advanced logic should be moved to the handler reflecting the event's
		     * name.
		     *
		     * @private
		     * @function Highcharts.Pointer#setDOMEvents
		     */
		    setDOMEvents: function () {

		        var pointer = this,
		            container = pointer.chart.container,
		            ownerDoc = container.ownerDocument;

		        container.onmousedown = function (e) {
		            pointer.onContainerMouseDown(e);
		        };
		        container.onmousemove = function (e) {
		            pointer.onContainerMouseMove(e);
		        };
		        container.onclick = function (e) {
		            pointer.onContainerClick(e);
		        };
		        this.unbindContainerMouseLeave = addEvent(
		            container,
		            'mouseleave',
		            pointer.onContainerMouseLeave
		        );
		        if (!H.unbindDocumentMouseUp) {
		            H.unbindDocumentMouseUp = addEvent(
		                ownerDoc,
		                'mouseup',
		                pointer.onDocumentMouseUp
		            );
		        }
		        if (H.hasTouch) {
		            container.ontouchstart = function (e) {
		                pointer.onContainerTouchStart(e);
		            };
		            container.ontouchmove = function (e) {
		                pointer.onContainerTouchMove(e);
		            };
		            if (!H.unbindDocumentTouchEnd) {
		                H.unbindDocumentTouchEnd = addEvent(
		                    ownerDoc,
		                    'touchend',
		                    pointer.onDocumentTouchEnd
		                );
		            }
		        }

		    },

		    /**
		     * Destroys the Pointer object and disconnects DOM events.
		     *
		     * @function Highcharts.Pointer#destroy
		     */
		    destroy: function () {
		        var pointer = this;

		        if (pointer.unDocMouseMove) {
		            pointer.unDocMouseMove();
		        }

		        this.unbindContainerMouseLeave();

		        if (!H.chartCount) {
		            if (H.unbindDocumentMouseUp) {
		                H.unbindDocumentMouseUp = H.unbindDocumentMouseUp();
		            }
		            if (H.unbindDocumentTouchEnd) {
		                H.unbindDocumentTouchEnd = H.unbindDocumentTouchEnd();
		            }
		        }

		        // memory and CPU leak
		        clearInterval(pointer.tooltipTimeout);

		        H.objectEach(pointer, function (val, prop) {
		            pointer[prop] = null;
		        });
		    }
		};

	}(Highcharts));
	(function (H) {
		/**
		 * (c) 2010-2018 Torstein Honsi
		 *
		 * License: www.highcharts.com/license
		 */



		var charts = H.charts,
		    each = H.each,
		    extend = H.extend,
		    map = H.map,
		    noop = H.noop,
		    pick = H.pick,
		    Pointer = H.Pointer;

		// Support for touch devices
		extend(Pointer.prototype, /** @lends Pointer.prototype */ {

		    /**
		     * Run translation operations
		     *
		     * @private
		     * @function Highcharts.Pointer#pinchTranslate
		     *
		     * @param {Array<*>} pinchDown
		     *
		     * @param {Array<*>} touches
		     *
		     * @param {*} transform
		     *
		     * @param {*} selectionMarker
		     *
		     * @param {*} clip
		     *
		     * @param {*} lastValidTouch
		     */
		    pinchTranslate: function (
		        pinchDown,
		        touches,
		        transform,
		        selectionMarker,
		        clip,
		        lastValidTouch
		    ) {
		        if (this.zoomHor) {
		            this.pinchTranslateDirection(
		                true,
		                pinchDown,
		                touches,
		                transform,
		                selectionMarker,
		                clip,
		                lastValidTouch
		            );
		        }
		        if (this.zoomVert) {
		            this.pinchTranslateDirection(
		                false,
		                pinchDown,
		                touches,
		                transform,
		                selectionMarker,
		                clip,
		                lastValidTouch
		            );
		        }
		    },

		    /**
		     * Run translation operations for each direction (horizontal and vertical)
		     * independently.
		     *
		     * @private
		     * @function Highcharts.Pointer#pinchTranslateDirection
		     *
		     * @param {boolean} horiz
		     *
		     * @param {Array<*>} pinchDown
		     *
		     * @param {Array<*>} touches
		     *
		     * @param {*} transform
		     *
		     * @param {*} selectionMarker
		     *
		     * @param {*} clip
		     *
		     * @param {*} lastValidTouch
		     *
		     * @param {number|undefined} [forcedScale=1]
		     */
		    pinchTranslateDirection: function (horiz, pinchDown, touches, transform,
		            selectionMarker, clip, lastValidTouch, forcedScale) {
		        var chart = this.chart,
		            xy = horiz ? 'x' : 'y',
		            XY = horiz ? 'X' : 'Y',
		            sChartXY = 'chart' + XY,
		            wh = horiz ? 'width' : 'height',
		            plotLeftTop = chart['plot' + (horiz ? 'Left' : 'Top')],
		            selectionWH,
		            selectionXY,
		            clipXY,
		            scale = forcedScale || 1,
		            inverted = chart.inverted,
		            bounds = chart.bounds[horiz ? 'h' : 'v'],
		            singleTouch = pinchDown.length === 1,
		            touch0Start = pinchDown[0][sChartXY],
		            touch0Now = touches[0][sChartXY],
		            touch1Start = !singleTouch && pinchDown[1][sChartXY],
		            touch1Now = !singleTouch && touches[1][sChartXY],
		            outOfBounds,
		            transformScale,
		            scaleKey,
		            setScale = function () {
		                // Don't zoom if fingers are too close on this axis
		                if (!singleTouch && Math.abs(touch0Start - touch1Start) > 20) {
		                    scale = forcedScale ||
		                        Math.abs(touch0Now - touch1Now) /
		                        Math.abs(touch0Start - touch1Start);
		                }

		                clipXY = ((plotLeftTop - touch0Now) / scale) + touch0Start;
		                selectionWH = chart['plot' + (horiz ? 'Width' : 'Height')] /
		                    scale;
		            };

		        // Set the scale, first pass
		        setScale();

		        // The clip position (x or y) is altered if out of bounds, the selection
		        // position is not
		        selectionXY = clipXY;

		        // Out of bounds
		        if (selectionXY < bounds.min) {
		            selectionXY = bounds.min;
		            outOfBounds = true;
		        } else if (selectionXY + selectionWH > bounds.max) {
		            selectionXY = bounds.max - selectionWH;
		            outOfBounds = true;
		        }

		        // Is the chart dragged off its bounds, determined by dataMin and
		        // dataMax?
		        if (outOfBounds) {

		            // Modify the touchNow position in order to create an elastic drag
		            // movement. This indicates to the user that the chart is responsive
		            // but can't be dragged further.
		            touch0Now -= 0.8 * (touch0Now - lastValidTouch[xy][0]);
		            if (!singleTouch) {
		                touch1Now -= 0.8 * (touch1Now - lastValidTouch[xy][1]);
		            }

		            // Set the scale, second pass to adapt to the modified touchNow
		            // positions
		            setScale();

		        } else {
		            lastValidTouch[xy] = [touch0Now, touch1Now];
		        }

		        // Set geometry for clipping, selection and transformation
		        if (!inverted) {
		            clip[xy] = clipXY - plotLeftTop;
		            clip[wh] = selectionWH;
		        }
		        scaleKey = inverted ? (horiz ? 'scaleY' : 'scaleX') : 'scale' + XY;
		        transformScale = inverted ? 1 / scale : scale;

		        selectionMarker[wh] = selectionWH;
		        selectionMarker[xy] = selectionXY;
		        transform[scaleKey] = scale;
		        transform['translate' + XY] = (transformScale * plotLeftTop) +
		            (touch0Now - (transformScale * touch0Start));
		    },

		    /**
		     * Handle touch events with two touches
		     *
		     * @private
		     * @function Highcharts.Pointer#pinch
		     *
		     * @param {Highcharts.PointerEvent} e
		     */
		    pinch: function (e) {

		        var self = this,
		            chart = self.chart,
		            pinchDown = self.pinchDown,
		            touches = e.touches,
		            touchesLength = touches.length,
		            lastValidTouch = self.lastValidTouch,
		            hasZoom = self.hasZoom,
		            selectionMarker = self.selectionMarker,
		            transform = {},
		            fireClickEvent = touchesLength === 1 && (
		                (
		                    self.inClass(e.target, 'highcharts-tracker') &&
		                    chart.runTrackerClick
		                ) ||
		                self.runChartClick
		            ),
		            clip = {};

		        // Don't initiate panning until the user has pinched. This prevents us
		        // from blocking page scrolling as users scroll down a long page
		        // (#4210).
		        if (touchesLength > 1) {
		            self.initiated = true;
		        }

		        // On touch devices, only proceed to trigger click if a handler is
		        // defined
		        if (hasZoom && self.initiated && !fireClickEvent) {
		            e.preventDefault();
		        }

		        // Normalize each touch
		        map(touches, function (e) {
		            return self.normalize(e);
		        });

		        // Register the touch start position
		        if (e.type === 'touchstart') {
		            each(touches, function (e, i) {
		                pinchDown[i] = { chartX: e.chartX, chartY: e.chartY };
		            });
		            lastValidTouch.x = [pinchDown[0].chartX, pinchDown[1] &&
		                pinchDown[1].chartX];
		            lastValidTouch.y = [pinchDown[0].chartY, pinchDown[1] &&
		                pinchDown[1].chartY];

		            // Identify the data bounds in pixels
		            each(chart.axes, function (axis) {
		                if (axis.zoomEnabled) {
		                    var bounds = chart.bounds[axis.horiz ? 'h' : 'v'],
		                        minPixelPadding = axis.minPixelPadding,
		                        min = axis.toPixels(
		                            pick(axis.options.min, axis.dataMin)
		                        ),
		                        max = axis.toPixels(
		                            pick(axis.options.max, axis.dataMax)
		                        ),
		                        absMin = Math.min(min, max),
		                        absMax = Math.max(min, max);

		                    // Store the bounds for use in the touchmove handler
		                    bounds.min = Math.min(axis.pos, absMin - minPixelPadding);
		                    bounds.max = Math.max(
		                        axis.pos + axis.len,
		                        absMax + minPixelPadding
		                    );
		                }
		            });
		            self.res = true; // reset on next move

		        // Optionally move the tooltip on touchmove
		        } else if (self.followTouchMove && touchesLength === 1) {
		            this.runPointActions(self.normalize(e));

		        // Event type is touchmove, handle panning and pinching
		        } else if (pinchDown.length) { // can be 0 when releasing, if touchend
		                // fires first


		            // Set the marker
		            if (!selectionMarker) {
		                self.selectionMarker = selectionMarker = extend({
		                    destroy: noop,
		                    touch: true
		                }, chart.plotBox);
		            }

		            self.pinchTranslate(
		                pinchDown,
		                touches,
		                transform,
		                selectionMarker,
		                clip,
		                lastValidTouch
		            );

		            self.hasPinched = hasZoom;

		            // Scale and translate the groups to provide visual feedback during
		            // pinching
		            self.scaleGroups(transform, clip);

		            if (self.res) {
		                self.res = false;
		                this.reset(false, 0);
		            }
		        }
		    },

		    /**
		     * General touch handler shared by touchstart and touchmove.
		     *
		     * @private
		     * @function Highcharts.Pointer#touch
		     *
		     * @param {Highcharts.PointerEvent} e
		     *
		     * @param {boolean} start
		     */
		    touch: function (e, start) {
		        var chart = this.chart,
		            hasMoved,
		            pinchDown,
		            isInside;

		        if (chart.index !== H.hoverChartIndex) {
		            this.onContainerMouseLeave({ relatedTarget: true });
		        }
		        H.hoverChartIndex = chart.index;

		        if (e.touches.length === 1) {

		            e = this.normalize(e);

		            isInside = chart.isInsidePlot(
		                e.chartX - chart.plotLeft,
		                e.chartY - chart.plotTop
		            );
		            if (isInside && !chart.openMenu) {

		                // Run mouse events and display tooltip etc
		                if (start) {
		                    this.runPointActions(e);
		                }

		                // Android fires touchmove events after the touchstart even if
		                // the finger hasn't moved, or moved only a pixel or two. In iOS
		                // however, the touchmove doesn't fire unless the finger moves
		                // more than ~4px. So we emulate this behaviour in Android by
		                // checking how much it moved, and cancelling on small
		                // distances. #3450.
		                if (e.type === 'touchmove') {
		                    pinchDown = this.pinchDown;
		                    hasMoved = pinchDown[0] ? Math.sqrt( // #5266
		                        Math.pow(pinchDown[0].chartX - e.chartX, 2) +
		                        Math.pow(pinchDown[0].chartY - e.chartY, 2)
		                    ) >= 4 : false;
		                }

		                if (pick(hasMoved, true)) {
		                    this.pinch(e);
		                }

		            } else if (start) {
		                // Hide the tooltip on touching outside the plot area (#1203)
		                this.reset();
		            }

		        } else if (e.touches.length === 2) {
		            this.pinch(e);
		        }
		    },

		    /**
		     * @private
		     * @function Highcharts.Pointer#onContainerTouchStart
		     *
		     * @param {Highcharts.PointerEvent} e
		     */
		    onContainerTouchStart: function (e) {
		        this.zoomOption(e);
		        this.touch(e, true);
		    },

		    /**
		     * @private
		     * @function Highcharts.Pointer#onContainerTouchMove
		     *
		     * @param {Highcharts.PointerEvent} e
		     */
		    onContainerTouchMove: function (e) {
		        this.touch(e);
		    },

		    /**
		     * @private
		     * @function Highcharts.Pointer#onDocumentTouchEnd
		     *
		     * @param {Highcharts.PointerEvent} e
		     */
		    onDocumentTouchEnd: function (e) {
		        if (charts[H.hoverChartIndex]) {
		            charts[H.hoverChartIndex].pointer.drop(e);
		        }
		    }

		});

	}(Highcharts));
	(function (H) {
		/**
		 * (c) 2010-2018 Torstein Honsi
		 *
		 * License: www.highcharts.com/license
		 */



		var addEvent = H.addEvent,
		    charts = H.charts,
		    css = H.css,
		    doc = H.doc,
		    extend = H.extend,
		    hasTouch = H.hasTouch,
		    noop = H.noop,
		    Pointer = H.Pointer,
		    removeEvent = H.removeEvent,
		    win = H.win,
		    wrap = H.wrap;

		if (!hasTouch && (win.PointerEvent || win.MSPointerEvent)) {

		    // The touches object keeps track of the points being touched at all times
		    var touches = {},
		        hasPointerEvent = !!win.PointerEvent,
		        getWebkitTouches = function () {
		            var fake = [];
		            fake.item = function (i) {
		                return this[i];
		            };
		            H.objectEach(touches, function (touch) {
		                fake.push({
		                    pageX: touch.pageX,
		                    pageY: touch.pageY,
		                    target: touch.target
		                });
		            });
		            return fake;
		        },
		        translateMSPointer = function (e, method, wktype, func) {
		            var p;
		            if (
		                (
		                    e.pointerType === 'touch' ||
		                    e.pointerType === e.MSPOINTER_TYPE_TOUCH
		                ) && charts[H.hoverChartIndex]
		            ) {
		                func(e);
		                p = charts[H.hoverChartIndex].pointer;
		                p[method]({
		                    type: wktype,
		                    target: e.currentTarget,
		                    preventDefault: noop,
		                    touches: getWebkitTouches()
		                });
		            }
		        };

		    // Extend the Pointer prototype with methods for each event handler and more
		    extend(Pointer.prototype, /** @lends Pointer.prototype */ {

		        /**
		         * @private
		         * @function Highcharts.Pointer#onContainerPointerDown
		         *
		         * @param {Highcharts.PointerEventObject} e
		         */
		        onContainerPointerDown: function (e) {
		            translateMSPointer(
		                e,
		                'onContainerTouchStart',
		                'touchstart',
		                function (e) {
		                    touches[e.pointerId] = {
		                        pageX: e.pageX,
		                        pageY: e.pageY,
		                        target: e.currentTarget
		                    };
		                }
		            );
		        },

		        /**
		         * @private
		         * @function Highcharts.Pointer#onContainerPointerMove
		         *
		         * @param {Highcharts.PointerEventObject} e
		         */
		        onContainerPointerMove: function (e) {
		            translateMSPointer(
		                e,
		                'onContainerTouchMove',
		                'touchmove',
		                function (e) {
		                    touches[e.pointerId] = { pageX: e.pageX, pageY: e.pageY };
		                    if (!touches[e.pointerId].target) {
		                        touches[e.pointerId].target = e.currentTarget;
		                    }
		                }
		            );
		        },

		        /**
		         * @private
		         * @function Highcharts.Pointer#onDocumentPointerUp
		         *
		         * @param {Highcharts.PointerEventObject} e
		         */
		        onDocumentPointerUp: function (e) {
		            translateMSPointer(
		                e,
		                'onDocumentTouchEnd',
		                'touchend',
		                function (e) {
		                    delete touches[e.pointerId];
		                }
		            );
		        },

		        /**
		         * Add or remove the MS Pointer specific events
		         *
		         * @private
		         * @function Highcharts.Pointer#batchMSEvents
		         *
		         * @param {Function} fn
		         */
		        batchMSEvents: function (fn) {
		            fn(
		                this.chart.container,
		                hasPointerEvent ? 'pointerdown' : 'MSPointerDown',
		                this.onContainerPointerDown
		            );
		            fn(
		                this.chart.container,
		                hasPointerEvent ? 'pointermove' : 'MSPointerMove',
		                this.onContainerPointerMove
		            );
		            fn(
		                doc,
		                hasPointerEvent ? 'pointerup' : 'MSPointerUp',
		                this.onDocumentPointerUp
		            );
		        }
		    });

		    // Disable default IE actions for pinch and such on chart element
		    wrap(Pointer.prototype, 'init', function (proceed, chart, options) {
		        proceed.call(this, chart, options);
		        if (this.hasZoom) { // #4014
		            css(chart.container, {
		                '-ms-touch-action': 'none',
		                'touch-action': 'none'
		            });
		        }
		    });

		    // Add IE specific touch events to chart
		    wrap(Pointer.prototype, 'setDOMEvents', function (proceed) {
		        proceed.apply(this);
		        if (this.hasZoom || this.followTouchMove) {
		            this.batchMSEvents(addEvent);
		        }
		    });
		    // Destroy MS events also
		    wrap(Pointer.prototype, 'destroy', function (proceed) {
		        this.batchMSEvents(removeEvent);
		        proceed.call(this);
		    });
		}

	}(Highcharts));
	(function (Highcharts) {
		/**
		 * (c) 2010-2018 Torstein Honsi
		 *
		 * License: www.highcharts.com/license
		 */



		var H = Highcharts,

		    addEvent = H.addEvent,
		    css = H.css,
		    discardElement = H.discardElement,
		    defined = H.defined,
		    each = H.each,
		    fireEvent = H.fireEvent,
		    isFirefox = H.isFirefox,
		    marginNames = H.marginNames,
		    merge = H.merge,
		    pick = H.pick,
		    setAnimation = H.setAnimation,
		    stableSort = H.stableSort,
		    win = H.win,
		    wrap = H.wrap;

		/**
		 * The overview of the chart's series. The legend object is instanciated
		 * internally in the chart constructor, and is available from the `chart.legend`
		 * property. Each chart has only one legend.
		 *
		 * @class
		 * @name Highcharts.Legend
		 *
		 * @param {Highcharts.Chart} chart
		 *        The chart instance.
		 *
		 * @param {Highcharts.LegendOptions} options
		 *        Legend options.
		 */
		Highcharts.Legend = function (chart, options) {
		    this.init(chart, options);
		};

		Highcharts.Legend.prototype = {

		    /**
		     * Initialize the legend.
		     *
		     * @private
		     * @function Highcharts.Legend#init
		     *
		     * @param {Highcharts.Chart} chart
		     *        The chart instance.
		     *
		     * @param {Highcharts.LegendOptions} options
		     *        Legend options.
		     */
		    init: function (chart, options) {

		        /**
		         * Chart of this legend.
		         *
		         * @readonly
		         * @name Highcharts.Legend#chart
		         * @type {Highcharts.Chart}
		         */
		        this.chart = chart;

		        this.setOptions(options);

		        if (options.enabled) {

		            // Render it
		            this.render();

		            // move checkboxes
		            addEvent(this.chart, 'endResize', function () {
		                this.legend.positionCheckboxes();
		            });

		            if (this.proximate) {
		                this.unchartrender = addEvent(
		                    this.chart,
		                    'render',
		                    function () {
		                        this.legend.proximatePositions();
		                        this.legend.positionItems();
		                    }
		                );
		            } else if (this.unchartrender) {
		                this.unchartrender();
		            }
		        }
		    },

		    /**
		     * @private
		     * @function Highcharts.Legend#setOptions
		     *
		     * @param {Highcharts.LegendOptions} options
		     */
		    setOptions: function (options) {

		        var padding = pick(options.padding, 8);

		        /**
		         * Legend options.
		         *
		         * @readonly
		         * @name Highcharts.Legend#options
		         * @type {Highcharts.LegendOptions}
		         */
		        this.options = options;


		        this.itemStyle = options.itemStyle;
		        this.itemHiddenStyle = merge(this.itemStyle, options.itemHiddenStyle);

		        this.itemMarginTop = options.itemMarginTop || 0;
		        this.padding = padding;
		        this.initialItemY = padding - 5; // 5 is pixels above the text
		        this.symbolWidth = pick(options.symbolWidth, 16);
		        this.pages = [];
		        this.proximate = options.layout === 'proximate' && !this.chart.inverted;

		    },

		    /**
		     * Update the legend with new options. Equivalent to running `chart.update`
		     * with a legend configuration option.
		     *
		     * @sample highcharts/legend/legend-update/
		     *         Legend update
		     *
		     * @function Highcharts.Legend#update
		     *
		     * @param {Highcharts.LegendOptions} options
		     *        Legend options.
		     *
		     * @param {boolean} [redraw=true]
		     *        Whether to redraw the chart.
		     *
		     * @todo
		     * Make events official: Fires the event `afterUpdate`.
		     */
		    update: function (options, redraw) {
		        var chart = this.chart;

		        this.setOptions(merge(true, this.options, options));
		        this.destroy();
		        chart.isDirtyLegend = chart.isDirtyBox = true;
		        if (pick(redraw, true)) {
		            chart.redraw();
		        }

		        fireEvent(this, 'afterUpdate');
		    },

		    /**
		     * Set the colors for the legend item.
		     *
		     * @private
		     * @function Highcharts.Legend#colorizeItem
		     *
		     * @param {Highcharts.Point|Highcharts.Series} item
		     *        A Series or Point instance
		     *
		     * @param {boolean} [visible=false]
		     *        Dimmed or colored
		     *
		     * @todo
		     * Make events official: Fires the event `afterColorizeItem`.
		     */
		    colorizeItem: function (item, visible) {
		        item.legendGroup[visible ? 'removeClass' : 'addClass'](
		            'highcharts-legend-item-hidden'
		        );


		        var legend = this,
		            options = legend.options,
		            legendItem = item.legendItem,
		            legendLine = item.legendLine,
		            legendSymbol = item.legendSymbol,
		            hiddenColor = legend.itemHiddenStyle.color,
		            textColor = visible ? options.itemStyle.color : hiddenColor,
		            symbolColor = visible ? (item.color || hiddenColor) : hiddenColor,
		            markerOptions = item.options && item.options.marker,
		            symbolAttr = { fill: symbolColor };

		        if (legendItem) {
		            legendItem.css({
		                fill: textColor,
		                color: textColor // #1553, oldIE
		            });
		        }
		        if (legendLine) {
		            legendLine.attr({ stroke: symbolColor });
		        }

		        if (legendSymbol) {

		            // Apply marker options
		            if (markerOptions && legendSymbol.isMarker) { // #585
		                symbolAttr = item.pointAttribs();
		                if (!visible) {
		                    symbolAttr.stroke = symbolAttr.fill = hiddenColor; // #6769
		                }
		            }

		            legendSymbol.attr(symbolAttr);
		        }


		        fireEvent(this, 'afterColorizeItem', { item: item, visible: visible });
		    },

		    /**
		     * @private
		     * @function Highcharts.Legend#positionItems
		     */
		    positionItems: function () {

		        // Now that the legend width and height are established, put the items
		        // in the final position
		        each(this.allItems, this.positionItem, this);

		        if (!this.chart.isResizing) {
		            this.positionCheckboxes();
		        }
		    },

		    /**
		     * Position the legend item.
		     *
		     * @private
		     * @function Highcharts.Legend#positionItem
		     *
		     * @param {Highcharts.Point|Highcharts.Series} item
		     *        The item to position
		     */
		    positionItem: function (item) {
		        var legend = this,
		            options = legend.options,
		            symbolPadding = options.symbolPadding,
		            ltr = !options.rtl,
		            legendItemPos = item._legendItemPos,
		            itemX = legendItemPos[0],
		            itemY = legendItemPos[1],
		            checkbox = item.checkbox,
		            legendGroup = item.legendGroup;

		        if (legendGroup && legendGroup.element) {
		            legendGroup[defined(legendGroup.translateY) ? 'animate' : 'attr']({
		                translateX: ltr ?
		                    itemX :
		                    legend.legendWidth - itemX - 2 * symbolPadding - 4,
		                translateY: itemY
		            });
		        }

		        if (checkbox) {
		            checkbox.x = itemX;
		            checkbox.y = itemY;
		        }
		    },

		    /**
		     * Destroy a single legend item, used internally on removing series items.
		     *
		     * @private
		     * @function Highcharts.Legend#destroyItem
		     *
		     * @param {Highcharts.Point|Highcharts.Series} item
		     *        The item to remove
		     */
		    destroyItem: function (item) {
		        var checkbox = item.checkbox;

		        // destroy SVG elements
		        each(
		            ['legendItem', 'legendLine', 'legendSymbol', 'legendGroup'],
		            function (key) {
		                if (item[key]) {
		                    item[key] = item[key].destroy();
		                }
		            }
		        );

		        if (checkbox) {
		            discardElement(item.checkbox);
		        }
		    },

		    /**
		     * Destroy the legend. Used internally. To reflow objects, `chart.redraw`
		     * must be called after destruction.
		     *
		     * @private
		     * @function Highcharts.Legend#destroy
		     */
		    destroy: function () {
		        function destroyItems(key) {
		            if (this[key]) {
		                this[key] = this[key].destroy();
		            }
		        }

		        // Destroy items
		        each(this.getAllItems(), function (item) {
		            each(['legendItem', 'legendGroup'], destroyItems, item);
		        });

		        // Destroy legend elements
		        each([
		            'clipRect',
		            'up',
		            'down',
		            'pager',
		            'nav',
		            'box',
		            'title',
		            'group'
		        ], destroyItems, this);
		        this.display = null; // Reset in .render on update.
		    },

		    /**
		     * Position the checkboxes after the width is determined.
		     *
		     * @private
		     * @function Highcharts.Legend#positionCheckboxes
		     */
		    positionCheckboxes: function () {
		        var alignAttr = this.group && this.group.alignAttr,
		            translateY,
		            clipHeight = this.clipHeight || this.legendHeight,
		            titleHeight = this.titleHeight;

		        if (alignAttr) {
		            translateY = alignAttr.translateY;
		            each(this.allItems, function (item) {
		                var checkbox = item.checkbox,
		                    top;

		                if (checkbox) {
		                    top = translateY + titleHeight + checkbox.y +
		                        (this.scrollOffset || 0) + 3;
		                    css(checkbox, {
		                        left: (alignAttr.translateX + item.checkboxOffset +
		                            checkbox.x - 20) + 'px',
		                        top: top + 'px',
		                        display: this.proximate || (
		                            top > translateY - 6 &&
		                            top < translateY + clipHeight - 6
		                        ) ?
		                            '' :
		                            'none'
		                    });
		                }
		            }, this);
		        }
		    },

		    /**
		     * Render the legend title on top of the legend.
		     *
		     * @private
		     * @function Highcharts.Legend#renderTitle
		     */
		    renderTitle: function () {
		        var options = this.options,
		            padding = this.padding,
		            titleOptions = options.title,
		            titleHeight = 0,
		            bBox;

		        if (titleOptions.text) {
		            if (!this.title) {
		                /**
		                 * SVG element of the legend title.
		                 *
		                 * @readonly
		                 * @name Highcharts.Legend#title
		                 * @type {Highcharts.SVGElement}
		                 */
		                this.title = this.chart.renderer.label(
		                        titleOptions.text,
		                        padding - 3,
		                        padding - 4,
		                        null,
		                        null,
		                        null,
		                        options.useHTML,
		                        null,
		                        'legend-title'
		                    )
		                    .attr({ zIndex: 1 })

		                    .css(titleOptions.style)

		                    .add(this.group);
		            }
		            bBox = this.title.getBBox();
		            titleHeight = bBox.height;
		            this.offsetWidth = bBox.width; // #1717
		            this.contentGroup.attr({ translateY: titleHeight });
		        }
		        this.titleHeight = titleHeight;
		    },

		    /**
		     * Set the legend item text.
		     *
		     * @function Highcharts.Legend#setText
		     *
		     * @param {Highcharts.Point|Highcharts.Series} item
		     *        The item for which to update the text in the legend.
		     */
		    setText: function (item) {
		        var options = this.options;
		        item.legendItem.attr({
		            text: options.labelFormat ?
		                H.format(options.labelFormat, item, this.chart.time) :
		                options.labelFormatter.call(item)
		        });
		    },

		    /**
		     * Render a single specific legend item. Called internally from the `render`
		     * function.
		     *
		     * @private
		     * @function Highcharts.Legend#renderItem
		     *
		     * @param {Highcharts.Point|Highcharts.Series} item
		     *        The item to render.
		     */
		    renderItem: function (item) {
		        var legend = this,
		            chart = legend.chart,
		            renderer = chart.renderer,
		            options = legend.options,
		            horizontal = options.layout === 'horizontal',
		            symbolWidth = legend.symbolWidth,
		            symbolPadding = options.symbolPadding,

		            itemStyle = legend.itemStyle,
		            itemHiddenStyle = legend.itemHiddenStyle,

		            itemDistance = horizontal ? pick(options.itemDistance, 20) : 0,
		            ltr = !options.rtl,
		            bBox,
		            li = item.legendItem,
		            isSeries = !item.series,
		            series = !isSeries && item.series.drawLegendSymbol ?
		                item.series :
		                item,
		            seriesOptions = series.options,
		            showCheckbox = legend.createCheckboxForItem &&
		                seriesOptions &&
		                seriesOptions.showCheckbox,
		            // full width minus text width
		            itemExtraWidth = symbolWidth + symbolPadding + itemDistance +
		                (showCheckbox ? 20 : 0),
		            useHTML = options.useHTML,
		            fontSize = 12,
		            itemClassName = item.options.className;

		        if (!li) { // generate it once, later move it

		            // Generate the group box, a group to hold the symbol and text. Text
		            // is to be appended in Legend class.
		            item.legendGroup = renderer.g('legend-item')
		                .addClass(
		                    'highcharts-' + series.type + '-series ' +
		                    'highcharts-color-' + item.colorIndex +
		                    (itemClassName ? ' ' + itemClassName : '') +
		                    (isSeries ? ' highcharts-series-' + item.index : '')
		                )
		                .attr({ zIndex: 1 })
		                .add(legend.scrollGroup);

		            // Generate the list item text and add it to the group
		            item.legendItem = li = renderer.text(
		                    '',
		                    ltr ? symbolWidth + symbolPadding : -symbolPadding,
		                    legend.baseline || 0,
		                    useHTML
		                )

		                // merge to prevent modifying original (#1021)
		                .css(merge(item.visible ? itemStyle : itemHiddenStyle))

		                .attr({
		                    align: ltr ? 'left' : 'right',
		                    zIndex: 2
		                })
		                .add(item.legendGroup);

		            // Get the baseline for the first item - the font size is equal for
		            // all
		            if (!legend.baseline) {

		                fontSize = itemStyle.fontSize;

		                legend.fontMetrics = renderer.fontMetrics(
		                    fontSize,
		                    li
		                );
		                legend.baseline =
		                    legend.fontMetrics.f + 3 + legend.itemMarginTop;
		                li.attr('y', legend.baseline);
		            }

		            // Draw the legend symbol inside the group box
		            legend.symbolHeight = options.symbolHeight || legend.fontMetrics.f;
		            series.drawLegendSymbol(legend, item);

		            if (legend.setItemEvents) {
		                legend.setItemEvents(item, li, useHTML);
		            }

		            // add the HTML checkbox on top
		            if (showCheckbox) {
		                legend.createCheckboxForItem(item);
		            }
		        }

		        // Colorize the items
		        legend.colorizeItem(item, item.visible);

		        // Take care of max width and text overflow (#6659)

		        if (!itemStyle.width) {

		            li.css({
		                width: (
		                    options.itemWidth ||
		                    options.width ||
		                    chart.spacingBox.width
		                ) - itemExtraWidth
		            });

		        }


		        // Always update the text
		        legend.setText(item);

		        // calculate the positions for the next line
		        bBox = li.getBBox();

		        item.itemWidth = item.checkboxOffset =
		            options.itemWidth ||
		            item.legendItemWidth ||
		            bBox.width + itemExtraWidth;
		        legend.maxItemWidth = Math.max(legend.maxItemWidth, item.itemWidth);
		        legend.totalItemWidth += item.itemWidth;
		        legend.itemHeight = item.itemHeight = Math.round(
		            item.legendItemHeight || bBox.height || legend.symbolHeight
		        );
		    },

		    /**
		     * Get the position of the item in the layout. We now know the
		     * maxItemWidth from the previous loop.
		     *
		     * @private
		     * @function Highcharts.Legend#layoutItem
		     *
		     * @param {Highcharts.Point|Highcharts.Series} item
		     */
		    layoutItem: function (item) {

		        var options = this.options,
		            padding = this.padding,
		            horizontal = options.layout === 'horizontal',
		            itemHeight = item.itemHeight,
		            itemMarginBottom = options.itemMarginBottom || 0,
		            itemMarginTop = this.itemMarginTop,
		            itemDistance = horizontal ? pick(options.itemDistance, 20) : 0,
		            widthOption = options.width,
		            maxLegendWidth = widthOption || (
		                this.chart.spacingBox.width - 2 * padding - options.x
		            ),
		            itemWidth = (
		                    options.alignColumns &&
		                    this.totalItemWidth > maxLegendWidth
		                ) ?
		                this.maxItemWidth :
		                item.itemWidth;

		        // If the item exceeds the width, start a new line
		        if (
		            horizontal &&
		            this.itemX - padding + itemWidth > maxLegendWidth
		        ) {
		            this.itemX = padding;
		            this.itemY += itemMarginTop + this.lastLineHeight +
		                itemMarginBottom;
		            this.lastLineHeight = 0; // reset for next line (#915, #3976)
		        }

		        // Set the edge positions
		        this.lastItemY = itemMarginTop + this.itemY + itemMarginBottom;
		        this.lastLineHeight = Math.max( // #915
		            itemHeight,
		            this.lastLineHeight
		        );

		        // cache the position of the newly generated or reordered items
		        item._legendItemPos = [this.itemX, this.itemY];

		        // advance
		        if (horizontal) {
		            this.itemX += itemWidth;

		        } else {
		            this.itemY += itemMarginTop + itemHeight + itemMarginBottom;
		            this.lastLineHeight = itemHeight;
		        }

		        // the width of the widest item
		        this.offsetWidth = widthOption || Math.max(
		            (
		                horizontal ? this.itemX - padding - (item.checkbox ?
		                    // decrease by itemDistance only when no checkbox #4853
		                    0 :
		                    itemDistance
		                ) : itemWidth
		            ) + padding,
		            this.offsetWidth
		        );
		    },

		    /**
		     * Get all items, which is one item per series for most series and one
		     * item per point for pie series and its derivatives.
		     *
		     * @private
		     * @function Highcharts.Legend#getAllItems
		     *
		     * @return {Array<Highcharts.Point|Highcharts.Series>}
		     *         The current items in the legend.
		     *
		     * @fires Highcharts.Legend#event:afterGetAllItems
		     *
		     * @todo
		     * Make events official: Fires the event `afterGetAllItems`.
		     */
		    getAllItems: function () {
		        var allItems = [];
		        each(this.chart.series, function (series) {
		            var seriesOptions = series && series.options;

		            // Handle showInLegend. If the series is linked to another series,
		            // defaults to false.
		            if (series && pick(
		                seriesOptions.showInLegend,
		                !defined(seriesOptions.linkedTo) ? undefined : false, true
		            )) {

		                // Use points or series for the legend item depending on
		                // legendType
		                allItems = allItems.concat(
		                    series.legendItems ||
		                    (
		                        seriesOptions.legendType === 'point' ?
		                            series.data :
		                            series
		                    )
		                );
		            }
		        });

		        fireEvent(this, 'afterGetAllItems', { allItems: allItems });

		        return allItems;
		    },

		    /**
		     * Get a short, three letter string reflecting the alignment and layout.
		     *
		     * @private
		     * @function Highcharts.Legend#getAlignment
		     *
		     * @return {string}
		     *         The alignment, empty string if floating
		     */
		    getAlignment: function () {
		        var options = this.options;

		        // Use the first letter of each alignment option in order to detect
		        // the side. (#4189 - use charAt(x) notation instead of [x] for IE7)
		        if (this.proximate) {
		            return options.align.charAt(0) + 'tv';
		        }
		        return options.floating ? '' : (
		            options.align.charAt(0) +
		            options.verticalAlign.charAt(0) +
		            options.layout.charAt(0)
		        );
		    },

		    /**
		     * Adjust the chart margins by reserving space for the legend on only one
		     * side of the chart. If the position is set to a corner, top or bottom is
		     * reserved for horizontal legends and left or right for vertical ones.
		     *
		     * @private
		     * @function Highcharts.Legend#adjustMargins
		     *
		     * @param {Array<number>} margin
		     *
		     * @param {number} spacing
		     */
		    adjustMargins: function (margin, spacing) {
		        var chart = this.chart,
		            options = this.options,
		            alignment = this.getAlignment();

		        if (alignment) {

		            each([
		                /(lth|ct|rth)/,
		                /(rtv|rm|rbv)/,
		                /(rbh|cb|lbh)/,
		                /(lbv|lm|ltv)/
		            ], function (alignments, side) {
		                if (alignments.test(alignment) && !defined(margin[side])) {

		                    // Now we have detected on which side of the chart we should
		                    // reserve space for the legend
		                    chart[marginNames[side]] = Math.max(
		                        chart[marginNames[side]],
		                        (
		                            chart.legend[
		                                (side + 1) % 2 ? 'legendHeight' : 'legendWidth'
		                            ] +
		                            [1, -1, -1, 1][side] * options[
		                                (side % 2) ? 'x' : 'y'
		                            ] +
		                            pick(options.margin, 12) +
		                            spacing[side] +
		                            (
		                                side === 0 &&
		                                chart.options.title.margin !== undefined ?
		                                    chart.titleOffset +
		                                        chart.options.title.margin :
		                                    0
		                            ) // #7428, #7894
		                        )
		                    );
		                }
		            });
		        }
		    },

		    /**
		     * @private
		     * @function Highcharts.Legend#proximatePositions
		     */
		    proximatePositions: function () {
		        var chart = this.chart,
		            boxes = [],
		            alignLeft = this.options.align === 'left';

		        each(this.allItems, function (item) {
		            var lastPoint,
		                height,
		                useFirstPoint = alignLeft;

		            if (item.xAxis && item.points) {

		                if (item.xAxis.options.reversed) {
		                    useFirstPoint = !useFirstPoint;
		                }
		                lastPoint = H.find(
		                    useFirstPoint ?
		                        item.points :
		                        item.points.slice(0).reverse(),
		                    function (item) {
		                        return H.isNumber(item.plotY);
		                    }
		                );
		                height = item.legendGroup.getBBox().height;
		                boxes.push({
		                    target: item.visible ?
		                        (lastPoint ? lastPoint.plotY : item.xAxis.height) -
		                            0.3 * height :
		                        chart.plotHeight,
		                    size: height,
		                    item: item
		                });
		            }
		        }, this);
		        H.distribute(boxes, chart.plotHeight);
		        each(boxes, function (box) {
		            box.item._legendItemPos[1] =
		                chart.plotTop - chart.spacing[0] + box.pos;
		        });

		    },

		    /**
		     * Render the legend. This method can be called both before and after
		     * `chart.render`. If called after, it will only rearrange items instead
		     * of creating new ones. Called internally on initial render and after
		     * redraws.
		     *
		     * @private
		     * @function Highcharts.Legend#render
		     */
		    render: function () {
		        var legend = this,
		            chart = legend.chart,
		            renderer = chart.renderer,
		            legendGroup = legend.group,
		            allItems,
		            display,
		            legendWidth,
		            legendHeight,
		            box = legend.box,
		            options = legend.options,
		            padding = legend.padding,
		            alignTo;

		        legend.itemX = padding;
		        legend.itemY = legend.initialItemY;
		        legend.offsetWidth = 0;
		        legend.lastItemY = 0;

		        if (!legendGroup) {
		            /**
		             * SVG group of the legend.
		             *
		             * @readonly
		             * @name Highcharts.Legend#group
		             * @type {Highcharts.SVGElement}
		             */
		            legend.group = legendGroup = renderer.g('legend')
		                .attr({ zIndex: 7 })
		                .add();
		            legend.contentGroup = renderer.g()
		                .attr({ zIndex: 1 }) // above background
		                .add(legendGroup);
		            legend.scrollGroup = renderer.g()
		                .add(legend.contentGroup);
		        }

		        legend.renderTitle();

		        // add each series or point
		        allItems = legend.getAllItems();

		        // sort by legendIndex
		        stableSort(allItems, function (a, b) {
		            return ((a.options && a.options.legendIndex) || 0) -
		                ((b.options && b.options.legendIndex) || 0);
		        });

		        // reversed legend
		        if (options.reversed) {
		            allItems.reverse();
		        }

		        /**
		         * All items for the legend, which is an array of series for most series
		         * and an array of points for pie series and its derivatives.
		         *
		         * @readonly
		         * @name Highcharts.Legend#allItems
		         * @type {Array<Highcharts.Point|Highcharts.Series>}
		         */
		        legend.allItems = allItems;
		        legend.display = display = !!allItems.length;

		        // Render the items. First we run a loop to set the text and properties
		        // and read all the bounding boxes. The next loop computes the item
		        // positions based on the bounding boxes.
		        legend.lastLineHeight = 0;
		        legend.maxItemWidth = 0;
		        legend.totalItemWidth = 0;
		        legend.itemHeight = 0;
		        each(allItems, legend.renderItem, legend);
		        each(allItems, legend.layoutItem, legend);

		        // Get the box
		        legendWidth = (options.width || legend.offsetWidth) + padding;
		        legendHeight = legend.lastItemY + legend.lastLineHeight +
		            legend.titleHeight;
		        legendHeight = legend.handleOverflow(legendHeight);
		        legendHeight += padding;

		        // Draw the border and/or background
		        if (!box) {
		            /**
		             * SVG element of the legend box.
		             *
		             * @readonly
		             * @name Highcharts.Legend#box
		             * @type {Highcharts.SVGElement}
		             */
		            legend.box = box = renderer.rect()
		                .addClass('highcharts-legend-box')
		                .attr({
		                    r: options.borderRadius
		                })
		                .add(legendGroup);
		            box.isNew = true;
		        }


		        // Presentational
		        box
		            .attr({
		                stroke: options.borderColor,
		                'stroke-width': options.borderWidth || 0,
		                fill: options.backgroundColor || 'none'
		            })
		            .shadow(options.shadow);


		        if (legendWidth > 0 && legendHeight > 0) {
		            box[box.isNew ? 'attr' : 'animate'](
		                box.crisp.call({}, { // #7260
		                    x: 0,
		                    y: 0,
		                    width: legendWidth,
		                    height: legendHeight
		                }, box.strokeWidth())
		            );
		            box.isNew = false;
		        }

		        // hide the border if no items
		        box[display ? 'show' : 'hide']();



		        legend.legendWidth = legendWidth;
		        legend.legendHeight = legendHeight;

		        if (display) {
		            // If aligning to the top and the layout is horizontal, adjust for
		            // the title (#7428)
		            alignTo = chart.spacingBox;
		            if (/(lth|ct|rth)/.test(legend.getAlignment())) {
		                alignTo = merge(alignTo, {
		                    y: alignTo.y + chart.titleOffset +
		                        chart.options.title.margin
		                });
		            }

		            legendGroup.align(merge(options, {
		                width: legendWidth,
		                height: legendHeight,
		                verticalAlign: this.proximate ? 'top' : options.verticalAlign
		            }), true, alignTo);
		        }

		        if (!this.proximate) {
		            this.positionItems();
		        }
		    },

		    /**
		     * Set up the overflow handling by adding navigation with up and down arrows
		     * below the legend.
		     *
		     * @private
		     * @function Highcharts.Legend#handleOverflow
		     *
		     * @param {number} legendHeight
		     *
		     * @return {number}
		     */
		    handleOverflow: function (legendHeight) {
		        var legend = this,
		            chart = this.chart,
		            renderer = chart.renderer,
		            options = this.options,
		            optionsY = options.y,
		            alignTop = options.verticalAlign === 'top',
		            padding = this.padding,
		            spaceHeight = chart.spacingBox.height +
		                (alignTop ? -optionsY : optionsY) - padding,
		            maxHeight = options.maxHeight,
		            clipHeight,
		            clipRect = this.clipRect,
		            navOptions = options.navigation,
		            animation = pick(navOptions.animation, true),
		            arrowSize = navOptions.arrowSize || 12,
		            nav = this.nav,
		            pages = this.pages,
		            lastY,
		            allItems = this.allItems,
		            clipToHeight = function (height) {
		                if (typeof height === 'number') {
		                    clipRect.attr({
		                        height: height
		                    });
		                } else if (clipRect) { // Reset (#5912)
		                    legend.clipRect = clipRect.destroy();
		                    legend.contentGroup.clip();
		                }

		                // useHTML
		                if (legend.contentGroup.div) {
		                    legend.contentGroup.div.style.clip = height ?
		                        'rect(' + padding + 'px,9999px,' +
		                            (padding + height) + 'px,0)' :
		                        'auto';
		                }
		            };


		        // Adjust the height
		        if (
		            options.layout === 'horizontal' &&
		            options.verticalAlign !== 'middle' &&
		            !options.floating
		        ) {
		            spaceHeight /= 2;
		        }
		        if (maxHeight) {
		            spaceHeight = Math.min(spaceHeight, maxHeight);
		        }

		        // Reset the legend height and adjust the clipping rectangle
		        pages.length = 0;
		        if (legendHeight > spaceHeight && navOptions.enabled !== false) {

		            this.clipHeight = clipHeight =
		                Math.max(spaceHeight - 20 - this.titleHeight - padding, 0);
		            this.currentPage = pick(this.currentPage, 1);
		            this.fullHeight = legendHeight;

		            // Fill pages with Y positions so that the top of each a legend item
		            // defines the scroll top for each page (#2098)
		            each(allItems, function (item, i) {
		                var y = item._legendItemPos[1],
		                    h = Math.round(item.legendItem.getBBox().height),
		                    len = pages.length;

		                if (!len || (y - pages[len - 1] > clipHeight &&
		                        (lastY || y) !== pages[len - 1])) {
		                    pages.push(lastY || y);
		                    len++;
		                }

		                // Keep track of which page each item is on
		                item.pageIx = len - 1;
		                if (lastY) {
		                    allItems[i - 1].pageIx = len - 1;
		                }

		                if (i === allItems.length - 1 &&
		                        y + h - pages[len - 1] > clipHeight) {
		                    pages.push(y);
		                    item.pageIx = len;
		                }
		                if (y !== lastY) {
		                    lastY = y;
		                }
		            });

		            // Only apply clipping if needed. Clipping causes blurred legend in
		            // PDF export (#1787)
		            if (!clipRect) {
		                clipRect = legend.clipRect =
		                    renderer.clipRect(0, padding, 9999, 0);
		                legend.contentGroup.clip(clipRect);
		            }

		            clipToHeight(clipHeight);

		            // Add navigation elements
		            if (!nav) {
		                this.nav = nav = renderer.g()
		                    .attr({ zIndex: 1 })
		                    .add(this.group);

		                this.up = renderer
		                    .symbol(
		                        'triangle',
		                        0,
		                        0,
		                        arrowSize,
		                        arrowSize
		                    )
		                    .on('click', function () {
		                        legend.scroll(-1, animation);
		                    })
		                    .add(nav);

		                this.pager = renderer.text('', 15, 10)
		                    .addClass('highcharts-legend-navigation')

		                    .css(navOptions.style)

		                    .add(nav);

		                this.down = renderer
		                    .symbol(
		                        'triangle-down',
		                        0,
		                        0,
		                        arrowSize,
		                        arrowSize
		                    )
		                    .on('click', function () {
		                        legend.scroll(1, animation);
		                    })
		                    .add(nav);
		            }

		            // Set initial position
		            legend.scroll(0);

		            legendHeight = spaceHeight;

		        // Reset
		        } else if (nav) {
		            clipToHeight();
		            this.nav = nav.destroy(); // #6322
		            this.scrollGroup.attr({
		                translateY: 1
		            });
		            this.clipHeight = 0; // #1379
		        }

		        return legendHeight;
		    },

		    /**
		     * Scroll the legend by a number of pages.
		     *
		     * @private
		     * @function Highcharts.Legend#scroll
		     *
		     * @param {number} scrollBy
		     *        The number of pages to scroll.
		     *
		     * @param {Highcharts.AnimationOptionsObject} animation
		     *        Whether and how to apply animation.
		     */
		    scroll: function (scrollBy, animation) {
		        var pages = this.pages,
		            pageCount = pages.length,
		            currentPage = this.currentPage + scrollBy,
		            clipHeight = this.clipHeight,
		            navOptions = this.options.navigation,
		            pager = this.pager,
		            padding = this.padding;

		        // When resizing while looking at the last page
		        if (currentPage > pageCount) {
		            currentPage = pageCount;
		        }

		        if (currentPage > 0) {

		            if (animation !== undefined) {
		                setAnimation(animation, this.chart);
		            }

		            this.nav.attr({
		                translateX: padding,
		                translateY: clipHeight + this.padding + 7 + this.titleHeight,
		                visibility: 'visible'
		            });
		            this.up.attr({
		                'class': currentPage === 1 ?
		                    'highcharts-legend-nav-inactive' :
		                    'highcharts-legend-nav-active'
		            });
		            pager.attr({
		                text: currentPage + '/' + pageCount
		            });
		            this.down.attr({
		                'x': 18 + this.pager.getBBox().width, // adjust to text width
		                'class': currentPage === pageCount ?
		                    'highcharts-legend-nav-inactive' :
		                    'highcharts-legend-nav-active'
		            });


		            this.up
		                .attr({
		                    fill: currentPage === 1 ?
		                        navOptions.inactiveColor :
		                        navOptions.activeColor
		                })
		                .css({
		                    cursor: currentPage === 1 ? 'default' : 'pointer'
		                });
		            this.down
		                .attr({
		                    fill: currentPage === pageCount ?
		                        navOptions.inactiveColor :
		                        navOptions.activeColor
		                })
		                .css({
		                    cursor: currentPage === pageCount ? 'default' : 'pointer'
		                });


		            this.scrollOffset = -pages[currentPage - 1] + this.initialItemY;

		            this.scrollGroup.animate({
		                translateY: this.scrollOffset
		            });

		            this.currentPage = currentPage;
		            this.positionCheckboxes();
		        }

		    }

		};

		/**
		 * Legend symbol mixin.
		 *
		 * @private
		 * @mixin Highcharts.LegendSymbolMixin
		 */
		H.LegendSymbolMixin = {

		    /**
		     * Get the series' symbol in the legend
		     *
		     * @private
		     * @function Highcharts.LegendSymbolMixin.drawRectangle
		     *
		     * @param {Highcharts.Legend} legend
		     *        The legend object
		     *
		     * @param {Highcharts.Point|Highcharts.Series} item
		     *        The series (this) or point
		     */
		    drawRectangle: function (legend, item) {
		        var options = legend.options,
		            symbolHeight = legend.symbolHeight,
		            square = options.squareSymbol,
		            symbolWidth = square ? symbolHeight : legend.symbolWidth;

		        item.legendSymbol = this.chart.renderer.rect(
		            square ? (legend.symbolWidth - symbolHeight) / 2 : 0,
		            legend.baseline - symbolHeight + 1, // #3988
		            symbolWidth,
		            symbolHeight,
		            pick(legend.options.symbolRadius, symbolHeight / 2)
		        )
		        .addClass('highcharts-point')
		        .attr({
		            zIndex: 3
		        }).add(item.legendGroup);

		    },

		    /**
		     * Get the series' symbol in the legend. This method should be overridable
		     * to create custom symbols through
		     * Highcharts.seriesTypes[type].prototype.drawLegendSymbols.
		     *
		     * @private
		     * @function Highcharts.LegendSymbolMixin.drawLineMarker
		     *
		     * @param {Highcharts.Legend} legend
		     *        The legend object.
		     */
		    drawLineMarker: function (legend) {

		        var options = this.options,
		            markerOptions = options.marker,
		            radius,
		            legendSymbol,
		            symbolWidth = legend.symbolWidth,
		            symbolHeight = legend.symbolHeight,
		            generalRadius = symbolHeight / 2,
		            renderer = this.chart.renderer,
		            legendItemGroup = this.legendGroup,
		            verticalCenter = legend.baseline -
		                Math.round(legend.fontMetrics.b * 0.3),
		            attr = {};

		        // Draw the line

		        attr = {
		            'stroke-width': options.lineWidth || 0
		        };
		        if (options.dashStyle) {
		            attr.dashstyle = options.dashStyle;
		        }


		        this.legendLine = renderer.path([
		            'M',
		            0,
		            verticalCenter,
		            'L',
		            symbolWidth,
		            verticalCenter
		        ])
		        .addClass('highcharts-graph')
		        .attr(attr)
		        .add(legendItemGroup);

		        // Draw the marker
		        if (markerOptions && markerOptions.enabled !== false && symbolWidth) {

		            // Do not allow the marker to be larger than the symbolHeight
		            radius = Math.min(
		                pick(markerOptions.radius, generalRadius),
		                generalRadius
		            );

		            // Restrict symbol markers size
		            if (this.symbol.indexOf('url') === 0) {
		                markerOptions = merge(markerOptions, {
		                    width: symbolHeight,
		                    height: symbolHeight
		                });
		                radius = 0;
		            }

		            this.legendSymbol = legendSymbol = renderer.symbol(
		                this.symbol,
		                (symbolWidth / 2) - radius,
		                verticalCenter - radius,
		                2 * radius,
		                2 * radius,
		                markerOptions
		            )
		            .addClass('highcharts-point')
		            .add(legendItemGroup);
		            legendSymbol.isMarker = true;
		        }
		    }
		};

		// Workaround for #2030, horizontal legend items not displaying in IE11 Preview,
		// and for #2580, a similar drawing flaw in Firefox 26.
		// Explore if there's a general cause for this. The problem may be related
		// to nested group elements, as the legend item texts are within 4 group
		// elements.
		if (/Trident\/7\.0/.test(win.navigator.userAgent) || isFirefox) {
		    wrap(Highcharts.Legend.prototype, 'positionItem', function (proceed, item) {
		        var legend = this,
		            // If chart destroyed in sync, this is undefined (#2030)
		            runPositionItem = function () {
		                if (item._legendItemPos) {
		                    proceed.call(legend, item);
		                }
		            };

		        // Do it now, for export and to get checkbox placement
		        runPositionItem();

		        // Do it after to work around the core issue
		        setTimeout(runPositionItem);
		    });
		}

	}(Highcharts));
	(function (H) {
		/**
		 * (c) 2010-2018 Torstein Honsi
		 *
		 * License: www.highcharts.com/license
		 */

		/**
		 * Callback for chart constructors.
		 *
		 * @callback Highcharts.ChartCallbackFunction
		 *
		 * @param {Highcharts.Chart} chart
		 *        Created chart.
		 */

		/**
		 * The chart title. The title has an `update` method that allows modifying the
		 * options directly or indirectly via `chart.update`.
		 *
		 * @interface Highcharts.TitleObject
		 * @extends Highcharts.SVGElement
		 *//**
		 * Modify options for the title.
		 *
		 * @function Highcharts.TitleObject#update
		 *
		 * @param {Highcharts.TitleOptions} titleOptions
		 *        Options to modify.
		 */

		/**
		 * The chart subtitle. The subtitle has an `update` method that
		 * allows modifying the options directly or indirectly via
		 * `chart.update`.
		 *
		 * @interface Highcharts.SubtitleObject
		 * @extends Highcharts.SVGElement
		 *//**
		 * Modify options for the subtitle.
		 *
		 * @function Highcharts.SubtitleObject#update
		 *
		 * @param {Highcharts.SubtitleOptions} subtitleOptions
		 *        Options to modify.
		 */



		var addEvent = H.addEvent,
		    animate = H.animate,
		    animObject = H.animObject,
		    attr = H.attr,
		    doc = H.doc,
		    Axis = H.Axis, // @todo add as requirement
		    createElement = H.createElement,
		    defaultOptions = H.defaultOptions,
		    discardElement = H.discardElement,
		    charts = H.charts,
		    css = H.css,
		    defined = H.defined,
		    each = H.each,
		    extend = H.extend,
		    find = H.find,
		    fireEvent = H.fireEvent,
		    grep = H.grep,
		    isNumber = H.isNumber,
		    isObject = H.isObject,
		    isString = H.isString,
		    Legend = H.Legend, // @todo add as requirement
		    marginNames = H.marginNames,
		    merge = H.merge,
		    objectEach = H.objectEach,
		    Pointer = H.Pointer, // @todo add as requirement
		    pick = H.pick,
		    pInt = H.pInt,
		    removeEvent = H.removeEvent,
		    seriesTypes = H.seriesTypes,
		    splat = H.splat,
		    syncTimeout = H.syncTimeout,
		    win = H.win;

		/**
		 * The Chart class. The recommended constructor is {@link Highcharts#chart}.
		 *
		 * @example
		 * var chart = Highcharts.chart('container', {
		 *        title: {
		 *               text: 'My chart'
		 *        },
		 *        series: [{
		 *            data: [1, 3, 2, 4]
		 *        }]
		 * })
		 *
		 * @class
		 * @name Highcharts.Chart
		 *
		 * @param {string|Highcharts.HTMLDOMElement} [renderTo]
		 *        The DOM element to render to, or its id.
		 *
		 * @param {Highcharts.Options} options
		 *        The chart options structure.
		 *
		 * @param {Highcharts.ChartCallbackFunction} [callback]
		 *        Function to run when the chart has loaded and and all external images
		 *        are loaded. Defining a
		 *        {@link https://api.highcharts.com/highcharts/chart.events.load|chart.event.load}
		 *        handler is equivalent.
		 */
		var Chart = H.Chart = function () {
		    this.getArgs.apply(this, arguments);
		};

		/**
		 * Factory function for basic charts.
		 *
		 * @example
		 * // Render a chart in to div#container
		 * var chart = Highcharts.chart('container', {
		 *     title: {
		 *         text: 'My chart'
		 *     },
		 *     series: [{
		 *         data: [1, 3, 2, 4]
		 *     }]
		 * });
		 *
		 * @function Highcharts.chart
		 *
		 * @param {string|Highcharts.HTMLDOMElement} [renderTo]
		 *        The DOM element to render to, or its id.
		 *
		 * @param {Highcharts.Options} options
		 *        The chart options structure.
		 *
		 * @param {Highcharts.ChartCallbackFunction} [callback]
		 *        Function to run when the chart has loaded and and all external images
		 *        are loaded. Defining a
		 *        {@link https://api.highcharts.com/highcharts/chart.events.load|chart.event.load}
		 *        handler is equivalent.
		 *
		 * @return {Highcharts.Chart}
		 *         Returns the Chart object.
		 */
		H.chart = function (a, b, c) {
		    return new Chart(a, b, c);
		};

		extend(Chart.prototype, /** @lends Highcharts.Chart.prototype */ {

		    // Hook for adding callbacks in modules
		    callbacks: [],

		    /**
		     * Handle the arguments passed to the constructor.
		     *
		     * @private
		     * @function Highcharts.Chart#getArgs
		     *
		     * @param {...Array<*>} arguments
		     *        All arguments for the constructor.
		     *
		     * @return {Array<*>}
		     *         Passed arguments without renderTo.
		     *
		     * @fires Highcharts.Chart#event:init
		     * @fires Highcharts.Chart#event:afterInit
		     */
		    getArgs: function () {
		        var args = [].slice.call(arguments);

		        // Remove the optional first argument, renderTo, and
		        // set it on this.
		        if (isString(args[0]) || args[0].nodeName) {
		            this.renderTo = args.shift();
		        }
		        this.init(args[0], args[1]);
		    },

		    /**
		     * Overridable function that initializes the chart. The constructor's
		     * arguments are passed on directly.
		     *
		     * @function Highcharts.Chart#init
		     *
		     * @param {Highcharts.Options} userOptions
		     *        Custom options.
		     *
		     * @param {Function} [callback]
		     *        Function to run when the chart has loaded and and all external
		     *        images are loaded.
		     *
		     * @fires Highcharts.Chart#event:init
		     * @fires Highcharts.Chart#event:afterInit
		     */
		    init: function (userOptions, callback) {

		        // Handle regular options
		        var options,
		            type,
		            // skip merging data points to increase performance
		            seriesOptions = userOptions.series,
		            userPlotOptions = userOptions.plotOptions || {};

		        // Fire the event with a default function
		        fireEvent(this, 'init', { args: arguments }, function () {

		            userOptions.series = null;
		            options = merge(defaultOptions, userOptions); // do the merge

		            // Override (by copy of user options) or clear tooltip options
		            // in chart.options.plotOptions (#6218)
		            for (type in options.plotOptions) {
		                options.plotOptions[type].tooltip = (
		                    userPlotOptions[type] &&
		                    merge(userPlotOptions[type].tooltip) // override by copy
		                ) || undefined; // or clear
		            }
		            // User options have higher priority than default options
		            // (#6218). In case of exporting: path is changed
		            options.tooltip.userOptions = (
		                userOptions.chart &&
		                userOptions.chart.forExport &&
		                userOptions.tooltip.userOptions
		            ) || userOptions.tooltip;

		            // set back the series data
		            options.series = userOptions.series = seriesOptions;
		            this.userOptions = userOptions;

		            var optionsChart = options.chart;

		            var chartEvents = optionsChart.events;

		            this.margin = [];
		            this.spacing = [];

		            // Pixel data bounds for touch zoom
		            this.bounds = { h: {}, v: {} };

		            // An array of functions that returns labels that should be
		            // considered for anti-collision
		            this.labelCollectors = [];

		            this.callback = callback;
		            this.isResizing = 0;

		            /**
		             * The options structure for the chart. It contains members for
		             * the sub elements like series, legend, tooltip etc.
		             *
		             * @name Highcharts.Chart#options
		             * @type {Highcharts.Options}
		             */
		            this.options = options;

		            /**
		             * All the axes in the chart.
		             *
		             * @see  Highcharts.Chart.xAxis
		             * @see  Highcharts.Chart.yAxis
		             *
		             * @name Highcharts.Chart#axes
		             * @type {Array<Highcharts.Axis>}
		             */
		            this.axes = [];

		            /**
		             * All the current series in the chart.
		             *
		             * @name Highcharts.Chart#series
		             * @type {Array<Highcharts.Series>}
		             */
		            this.series = [];

		            /**
		             * The `Time` object associated with the chart. Since v6.0.5,
		             * time settings can be applied individually for each chart. If
		             * no individual settings apply, the `Time` object is shared by
		             * all instances.
		             *
		             * @name Highcharts.Chart#time
		             * @type {Highcharts.Time}
		             */
		            this.time =
		                userOptions.time && H.keys(userOptions.time).length ?
		                    new H.Time(userOptions.time) :
		                    H.time;


		            this.hasCartesianSeries = optionsChart.showAxes;

		            var chart = this;

		            // Add the chart to the global lookup
		            chart.index = charts.length;

		            charts.push(chart);
		            H.chartCount++;

		            // Chart event handlers
		            if (chartEvents) {
		                objectEach(chartEvents, function (event, eventType) {
		                    addEvent(chart, eventType, event);
		                });
		            }

		            /**
		             * A collection of the X axes in the chart.
		             *
		             * @name Highcharts.Chart#xAxis
		             * @type {Array<Highcharts.Axis>}
		             */
		            chart.xAxis = [];

		            /**
		             * A collection of the Y axes in the chart.
		             *
		             * @name Highcharts.Chart#yAxis
		             * @type {Array<Highcharts.Axis>}
		             *
		             * @todo
		             * Make events official: Fire the event `afterInit`.
		             */
		            chart.yAxis = [];

		            chart.pointCount = chart.colorCounter = chart.symbolCounter = 0;

		            // Fire after init but before first render, before axes and series
		            // have been initialized.
		            fireEvent(chart, 'afterInit');

		            chart.firstRender();
		        });
		    },

		    /**
		     * Internal function to unitialize an individual series.
		     *
		     * @private
		     * @function Highcharts.Chart#initSeries
		     *
		     * @param {Highcharts.ChartOptions} options
		     *
		     * @return {Highcharts.Series}
		     */
		    initSeries: function (options) {
		        var chart = this,
		            optionsChart = chart.options.chart,
		            type = (
		                options.type ||
		                optionsChart.type ||
		                optionsChart.defaultSeriesType
		            ),
		            series,
		            Constr = seriesTypes[type];

		        // No such series type
		        if (!Constr) {
		            H.error(17, true);
		        }

		        series = new Constr();
		        series.init(this, options);
		        return series;
		    },

		    /**
		     * Order all series above a given index. When series are added and ordered
		     * by configuration, only the last series is handled (#248, #1123, #2456,
		     * #6112). This function is called on series initialization and destroy.
		     *
		     * @private
		     * @function Highcharts.Series#orderSeries
		     *
		     * @param {number} fromIndex
		     *        If this is given, only the series above this index are handled.
		     */
		    orderSeries: function (fromIndex) {
		        var series = this.series,
		            i = fromIndex || 0;
		        for (; i < series.length; i++) {
		            if (series[i]) {
		                series[i].index = i;
		                series[i].name = series[i].getName();
		            }
		        }
		    },

		    /**
		     * Check whether a given point is within the plot area.
		     *
		     * @function Highcharts.Chart#isInsidePlot
		     *
		     * @param {number} plotX
		     *        Pixel x relative to the plot area.
		     *
		     * @param {number} plotY
		     *        Pixel y relative to the plot area.
		     *
		     * @param {boolean} inverted
		     *        Whether the chart is inverted.
		     *
		     * @return {boolean}
		     *         Returns true if the given point is inside the plot area.
		     */
		    isInsidePlot: function (plotX, plotY, inverted) {
		        var x = inverted ? plotY : plotX,
		            y = inverted ? plotX : plotY;

		        return x >= 0 &&
		            x <= this.plotWidth &&
		            y >= 0 &&
		            y <= this.plotHeight;
		    },

		    /**
		     * Redraw the chart after changes have been done to the data, axis extremes
		     * chart size or chart elements. All methods for updating axes, series or
		     * points have a parameter for redrawing the chart. This is `true` by
		     * default. But in many cases you want to do more than one operation on the
		     * chart before redrawing, for example add a number of points. In those
		     * cases it is a waste of resources to redraw the chart for each new point
		     * added. So you add the points and call `chart.redraw()` after.
		     *
		     * @function Highcharts.Chart#redraw
		     *
		     * @param {boolean|Highcharts.AnimationOptionsObject} [animation]
		     *        If or how to apply animation to the redraw.
		     *
		     * @fires Highcharts.Chart#event:afterSetExtremes
		     * @fires Highcharts.Chart#event:beforeRedraw
		     * @fires Highcharts.Chart#event:predraw
		     * @fires Highcharts.Chart#event:redraw
		     * @fires Highcharts.Chart#event:render
		     * @fires Highcharts.Chart#event:updatedData
		     */
		    redraw: function (animation) {

		        fireEvent(this, 'beforeRedraw');

		        var chart = this,
		            axes = chart.axes,
		            series = chart.series,
		            pointer = chart.pointer,
		            legend = chart.legend,
		            legendUserOptions = chart.userOptions.legend,
		            redrawLegend = chart.isDirtyLegend,
		            hasStackedSeries,
		            hasDirtyStacks,
		            hasCartesianSeries = chart.hasCartesianSeries,
		            isDirtyBox = chart.isDirtyBox,
		            i,
		            serie,
		            renderer = chart.renderer,
		            isHiddenChart = renderer.isHidden(),
		            afterRedraw = [];

		        // Handle responsive rules, not only on resize (#6130)
		        if (chart.setResponsive) {
		            chart.setResponsive(false);
		        }

		        H.setAnimation(animation, chart);

		        if (isHiddenChart) {
		            chart.temporaryDisplay();
		        }

		        // Adjust title layout (reflow multiline text)
		        chart.layOutTitles();

		        // link stacked series
		        i = series.length;
		        while (i--) {
		            serie = series[i];

		            if (serie.options.stacking) {
		                hasStackedSeries = true;

		                if (serie.isDirty) {
		                    hasDirtyStacks = true;
		                    break;
		                }
		            }
		        }
		        if (hasDirtyStacks) { // mark others as dirty
		            i = series.length;
		            while (i--) {
		                serie = series[i];
		                if (serie.options.stacking) {
		                    serie.isDirty = true;
		                }
		            }
		        }

		        // Handle updated data in the series
		        each(series, function (serie) {
		            if (serie.isDirty) {
		                if (serie.options.legendType === 'point') {
		                    if (serie.updateTotals) {
		                        serie.updateTotals();
		                    }
		                    redrawLegend = true;
		                } else if (
		                    legendUserOptions &&
		                    (
		                        legendUserOptions.labelFormatter ||
		                        legendUserOptions.labelFormat
		                    )
		                ) {
		                    redrawLegend = true; // #2165
		                }
		            }
		            if (serie.isDirtyData) {
		                fireEvent(serie, 'updatedData');
		            }
		        });

		        // handle added or removed series
		        if (redrawLegend && legend && legend.options.enabled) {
		            // draw legend graphics
		            legend.render();

		            chart.isDirtyLegend = false;
		        }

		        // reset stacks
		        if (hasStackedSeries) {
		            chart.getStacks();
		        }


		        if (hasCartesianSeries) {
		            // set axes scales
		            each(axes, function (axis) {
		                axis.updateNames();
		                // Update categories in a Gantt chart
		                if (axis.updateYNames) {
		                    axis.updateYNames();
		                }
		                axis.setScale();
		            });
		        }

		        chart.getMargins(); // #3098

		        if (hasCartesianSeries) {
		            // If one axis is dirty, all axes must be redrawn (#792, #2169)
		            each(axes, function (axis) {
		                if (axis.isDirty) {
		                    isDirtyBox = true;
		                }
		            });

		            // redraw axes
		            each(axes, function (axis) {

		                // Fire 'afterSetExtremes' only if extremes are set
		                var key = axis.min + ',' + axis.max;
		                if (axis.extKey !== key) { // #821, #4452
		                    axis.extKey = key;

		                    // prevent a recursive call to chart.redraw() (#1119)
		                    afterRedraw.push(function () {
		                        fireEvent(
		                            axis,
		                            'afterSetExtremes',
		                            extend(axis.eventArgs, axis.getExtremes())
		                        ); // #747, #751
		                        delete axis.eventArgs;
		                    });
		                }
		                if (isDirtyBox || hasStackedSeries) {
		                    axis.redraw();
		                }
		            });
		        }

		        // the plot areas size has changed
		        if (isDirtyBox) {
		            chart.drawChartBox();
		        }

		        // Fire an event before redrawing series, used by the boost module to
		        // clear previous series renderings.
		        fireEvent(chart, 'predraw');

		        // redraw affected series
		        each(series, function (serie) {
		            if ((isDirtyBox || serie.isDirty) && serie.visible) {
		                serie.redraw();
		            }
		            // Set it here, otherwise we will have unlimited 'updatedData' calls
		            // for a hidden series after setData(). Fixes #6012
		            serie.isDirtyData = false;
		        });

		        // move tooltip or reset
		        if (pointer) {
		            pointer.reset(true);
		        }

		        // redraw if canvas
		        renderer.draw();

		        // Fire the events
		        fireEvent(chart, 'redraw');
		        fireEvent(chart, 'render');

		        if (isHiddenChart) {
		            chart.temporaryDisplay(true);
		        }

		        // Fire callbacks that are put on hold until after the redraw
		        each(afterRedraw, function (callback) {
		            callback.call();
		        });
		    },

		    /**
		     * Get an axis, series or point object by `id` as given in the configuration
		     * options. Returns `undefined` if no item is found.
		     *
		     * @sample highcharts/plotoptions/series-id/
		     *         Get series by id
		     *
		     * @function Highcharts.Chart#get
		     *
		     * @param {string} id
		     *        The id as given in the configuration options.
		     *
		     * @return {Highcharts.Axis|Highcharts.Series|Highcharts.Point|undefined}
		     *         The retrieved item.
		     */
		    get: function (id) {

		        var ret,
		            series = this.series,
		            i;

		        function itemById(item) {
		            return item.id === id || (item.options && item.options.id === id);
		        }

		        ret =
		            // Search axes
		            find(this.axes, itemById) ||

		            // Search series
		            find(this.series, itemById);

		        // Search points
		        for (i = 0; !ret && i < series.length; i++) {
		            ret = find(series[i].points || [], itemById);
		        }

		        return ret;
		    },

		    /**
		     * Create the Axis instances based on the config options.
		     *
		     * @private
		     * @function Highcharts.Chart#getAxes
		     *
		     * @fires Highcharts.Chart#event:afterGetAxes
		     * @fires Highcharts.Chart#event:getAxes
		     */
		    getAxes: function () {
		        var chart = this,
		            options = this.options,
		            xAxisOptions = options.xAxis = splat(options.xAxis || {}),
		            yAxisOptions = options.yAxis = splat(options.yAxis || {}),
		            optionsArray;

		        fireEvent(this, 'getAxes');

		        // make sure the options are arrays and add some members
		        each(xAxisOptions, function (axis, i) {
		            axis.index = i;
		            axis.isX = true;
		        });

		        each(yAxisOptions, function (axis, i) {
		            axis.index = i;
		        });

		        // concatenate all axis options into one array
		        optionsArray = xAxisOptions.concat(yAxisOptions);

		        each(optionsArray, function (axisOptions) {
		            new Axis(chart, axisOptions); // eslint-disable-line no-new
		        });

		        fireEvent(this, 'afterGetAxes');
		    },


		    /**
		     * Returns an array of all currently selected points in the chart. Points
		     * can be selected by clicking or programmatically by the
		     * {@link Highcharts.Point#select}
		     * function.
		     *
		     * @sample highcharts/plotoptions/series-allowpointselect-line/
		     *         Get selected points
		     *
		     * @function Highcharts.Chart#getSelectedPoints
		     *
		     * @return {Array<Highcharts.Point>}
		     *         The currently selected points.
		     */
		    getSelectedPoints: function () {
		        var points = [];
		        each(this.series, function (serie) {
		            // series.data - for points outside of viewed range (#6445)
		            points = points.concat(grep(serie.data || [], function (point) {
		                return point.selected;
		            }));
		        });
		        return points;
		    },

		    /**
		     * Returns an array of all currently selected series in the chart. Series
		     * can be selected either programmatically by the
		     * {@link Highcharts.Series#select}
		     * function or by checking the checkbox next to the legend item if
		     * {@link https://api.highcharts.com/highcharts/plotOptions.series.showCheckbox| series.showCheckBox}
		     * is true.
		     *
		     * @sample highcharts/members/chart-getselectedseries/
		     *         Get selected series
		     *
		     * @function Highcharts.Chart#getSelectedSeries
		     *
		     * @return {Array<Highcharts.Series>}
		     *         The currently selected series.
		     */
		    getSelectedSeries: function () {
		        return grep(this.series, function (serie) {
		            return serie.selected;
		        });
		    },

		    /**
		     * Set a new title or subtitle for the chart.
		     *
		     * @sample highcharts/members/chart-settitle/
		     *         Set title text and styles
		     *
		     * @function Highcharts.Chart#setTitle
		     *
		     * @param {Highcharts.TitleOptions} titleOptions
		     *        New title options. The title text itself is set by the
		     *        `titleOptions.text` property.
		     *
		     * @param {Highcharts.SubtitleOptions} subtitleOptions
		     *        New subtitle options. The subtitle text itself is set by the
		     *        `subtitleOptions.text` property.
		     *
		     * @param {boolean} redraw
		     *        Whether to redraw the chart or wait for a later call to
		     *        `chart.redraw()`.
		     */
		    setTitle: function (titleOptions, subtitleOptions, redraw) {
		        var chart = this,
		            options = chart.options,
		            chartTitleOptions,
		            chartSubtitleOptions;

		        chartTitleOptions = options.title = merge(

		            // Default styles
		            {
		                style: {
		                    color: '#333333',
		                    fontSize: options.isStock ? '16px' : '18px' // #2944
		                }
		            },

		            options.title,
		            titleOptions
		        );
		        chartSubtitleOptions = options.subtitle = merge(

		            // Default styles
		            {
		                style: {
		                    color: '#666666'
		                }
		            },

		            options.subtitle,
		            subtitleOptions
		        );


		        // add title and subtitle

		        /**
		         * The chart title. The title has an `update` method that allows
		         * modifying the options directly or indirectly via
		         * `chart.update`.
		         *
		         * @sample highcharts/members/title-update/
		         *         Updating titles
		         *
		         * @name Highcharts.Chart#title
		         * @type {Highcharts.TitleObject}
		         */

		        /**
		         * The chart subtitle. The subtitle has an `update` method that
		         * allows modifying the options directly or indirectly via
		         * `chart.update`.
		         *
		         * @name Highcharts.Chart#subtitle
		         * @type {Highcharts.SubtitleObject}
		         */

		        each([
		            ['title', titleOptions, chartTitleOptions],
		            ['subtitle', subtitleOptions, chartSubtitleOptions]
		        ], function (arr, i) {
		            var name = arr[0],
		                title = chart[name],
		                titleOptions = arr[1],
		                chartTitleOptions = arr[2];

		            if (title && titleOptions) {
		                chart[name] = title = title.destroy(); // remove old
		            }

		            if (chartTitleOptions && !title) {
		                chart[name] = chart.renderer.text(
		                    chartTitleOptions.text,
		                    0,
		                    0,
		                    chartTitleOptions.useHTML
		                )
		                .attr({
		                    align: chartTitleOptions.align,
		                    'class': 'highcharts-' + name,
		                    zIndex: chartTitleOptions.zIndex || 4
		                })
		                .add();

		                // Update methods, shortcut to Chart.setTitle
		                chart[name].update = function (o) {
		                    chart.setTitle(!i && o, i && o);
		                };


		                // Presentational
		                chart[name].css(chartTitleOptions.style);


		            }
		        });
		        chart.layOutTitles(redraw);
		    },

		    /**
		     * Internal function to lay out the chart titles and cache the full offset
		     * height for use in `getMargins`. The result is stored in
		     * `this.titleOffset`.
		     *
		     * @private
		     * @function Highcharts.Chart#layOutTitles
		     *
		     * @param {boolean} [redraw=true]
		     */
		    layOutTitles: function (redraw) {
		        var titleOffset = 0,
		            requiresDirtyBox,
		            renderer = this.renderer,
		            spacingBox = this.spacingBox;

		        // Lay out the title and the subtitle respectively
		        each(['title', 'subtitle'], function (key) {
		            var title = this[key],
		                titleOptions = this.options[key],
		                offset = key === 'title' ? -3 :
		                    // Floating subtitle (#6574)
		                    titleOptions.verticalAlign ? 0 : titleOffset + 2,
		                titleSize;

		            if (title) {

		                titleSize = titleOptions.style.fontSize;

		                titleSize = renderer.fontMetrics(titleSize, title).b;
		                title
		                    .css({
		                        width: (titleOptions.width ||
		                            spacingBox.width + titleOptions.widthAdjust) + 'px'
		                    })
		                    .align(extend({
		                        y: offset + titleSize
		                    }, titleOptions), false, 'spacingBox');

		                if (!titleOptions.floating && !titleOptions.verticalAlign) {
		                    titleOffset = Math.ceil(
		                        titleOffset +
		                        // Skip the cache for HTML (#3481)
		                        title.getBBox(titleOptions.useHTML).height
		                    );
		                }
		            }
		        }, this);

		        requiresDirtyBox = this.titleOffset !== titleOffset;
		        this.titleOffset = titleOffset; // used in getMargins

		        if (!this.isDirtyBox && requiresDirtyBox) {
		            this.isDirtyBox = this.isDirtyLegend = requiresDirtyBox;
		            // Redraw if necessary (#2719, #2744)
		            if (this.hasRendered && pick(redraw, true) && this.isDirtyBox) {
		                this.redraw();
		            }
		        }
		    },

		    /**
		     * Internal function to get the chart width and height according to options
		     * and container size. Sets
		     * {@link Chart.chartWidth} and
		     * {@link Chart.chartHeight}.
		     *
		     * @function Highcharts.Chart#getChartSize
		     */
		    getChartSize: function () {
		        var chart = this,
		            optionsChart = chart.options.chart,
		            widthOption = optionsChart.width,
		            heightOption = optionsChart.height,
		            renderTo = chart.renderTo;

		        // Get inner width and height
		        if (!defined(widthOption)) {
		            chart.containerWidth = H.getStyle(renderTo, 'width');
		        }
		        if (!defined(heightOption)) {
		            chart.containerHeight = H.getStyle(renderTo, 'height');
		        }

		        /**
		         * The current pixel width of the chart.
		         *
		         * @name Highcharts.Chart#chartWidth
		         * @type {number}
		         */
		        chart.chartWidth = Math.max( // #1393
		            0,
		            widthOption || chart.containerWidth || 600 // #1460
		        );
		        /**
		         * The current pixel height of the chart.
		         *
		         * @name Highcharts.Chart#chartHeight
		         * @type {number}
		         */
		        chart.chartHeight = Math.max(
		            0,
		            H.relativeLength(
		                heightOption,
		                chart.chartWidth
		            ) ||
		            (chart.containerHeight > 1 ? chart.containerHeight : 400)
		        );
		    },

		    /**
		     * If the renderTo element has no offsetWidth, most likely one or more of
		     * its parents are hidden. Loop up the DOM tree to temporarily display the
		     * parents, then save the original display properties, and when the true
		     * size is retrieved, reset them. Used on first render and on redraws.
		     *
		     * @private
		     * @function Highcharts.Chart#temporaryDisplay
		     *
		     * @param {boolean} revert
		     *        Revert to the saved original styles.
		     */
		    temporaryDisplay: function (revert) {
		        var node = this.renderTo,
		            tempStyle;
		        if (!revert) {
		            while (node && node.style) {

		                // When rendering to a detached node, it needs to be temporarily
		                // attached in order to read styling and bounding boxes (#5783,
		                // #7024).
		                if (!doc.body.contains(node) && !node.parentNode) {
		                    node.hcOrigDetached = true;
		                    doc.body.appendChild(node);
		                }
		                if (
		                    H.getStyle(node, 'display', false) === 'none' ||
		                    node.hcOricDetached
		                ) {
		                    node.hcOrigStyle = {
		                        display: node.style.display,
		                        height: node.style.height,
		                        overflow: node.style.overflow
		                    };
		                    tempStyle = {
		                        display: 'block',
		                        overflow: 'hidden'
		                    };
		                    if (node !== this.renderTo) {
		                        tempStyle.height = 0;
		                    }

		                    H.css(node, tempStyle);

		                    // If it still doesn't have an offset width after setting
		                    // display to block, it probably has an !important priority
		                    // #2631, 6803
		                    if (!node.offsetWidth) {
		                        node.style.setProperty('display', 'block', 'important');
		                    }
		                }
		                node = node.parentNode;

		                if (node === doc.body) {
		                    break;
		                }
		            }
		        } else {
		            while (node && node.style) {
		                if (node.hcOrigStyle) {
		                    H.css(node, node.hcOrigStyle);
		                    delete node.hcOrigStyle;
		                }
		                if (node.hcOrigDetached) {
		                    doc.body.removeChild(node);
		                    node.hcOrigDetached = false;
		                }
		                node = node.parentNode;
		            }
		        }
		    },

		    /**
		     * Set the {@link Chart.container|chart container's} class name, in
		     * addition to `highcharts-container`.
		     *
		     * @function Highcharts.Chart#setClassName
		     *
		     * @param {string} className
		     */
		    setClassName: function (className) {
		        this.container.className = 'highcharts-container ' + (className || '');
		    },

		    /**
		     * Get the containing element, determine the size and create the inner
		     * container div to hold the chart.
		     *
		     * @private
		     * @function Highcharts.Chart#afterGetContainer
		     *
		     * @fires Highcharts.Chart#event:afterGetContainer
		     */
		    getContainer: function () {
		        var chart = this,
		            container,
		            options = chart.options,
		            optionsChart = options.chart,
		            chartWidth,
		            chartHeight,
		            renderTo = chart.renderTo,
		            indexAttrName = 'data-highcharts-chart',
		            oldChartIndex,
		            Ren,
		            containerId = H.uniqueKey(),
		            containerStyle,
		            key;

		        if (!renderTo) {
		            chart.renderTo = renderTo = optionsChart.renderTo;
		        }

		        if (isString(renderTo)) {
		            chart.renderTo = renderTo = doc.getElementById(renderTo);
		        }

		        // Display an error if the renderTo is wrong
		        if (!renderTo) {
		            H.error(13, true);
		        }

		        // If the container already holds a chart, destroy it. The check for
		        // hasRendered is there because web pages that are saved to disk from
		        // the browser, will preserve the data-highcharts-chart attribute and
		        // the SVG contents, but not an interactive chart. So in this case,
		        // charts[oldChartIndex] will point to the wrong chart if any (#2609).
		        oldChartIndex = pInt(attr(renderTo, indexAttrName));
		        if (
		            isNumber(oldChartIndex) &&
		            charts[oldChartIndex] &&
		            charts[oldChartIndex].hasRendered
		        ) {
		            charts[oldChartIndex].destroy();
		        }

		        // Make a reference to the chart from the div
		        attr(renderTo, indexAttrName, chart.index);

		        // remove previous chart
		        renderTo.innerHTML = '';

		        // If the container doesn't have an offsetWidth, it has or is a child of
		        // a node that has display:none. We need to temporarily move it out to a
		        // visible state to determine the size, else the legend and tooltips
		        // won't render properly. The skipClone option is used in sparklines as
		        // a micro optimization, saving about 1-2 ms each chart.
		        if (!optionsChart.skipClone && !renderTo.offsetWidth) {
		            chart.temporaryDisplay();
		        }

		        // get the width and height
		        chart.getChartSize();
		        chartWidth = chart.chartWidth;
		        chartHeight = chart.chartHeight;

		        // Create the inner container

		        containerStyle = extend({
		            position: 'relative',
		            overflow: 'hidden', // needed for context menu (avoid scrollbars)
		                // and content overflow in IE
		            width: chartWidth + 'px',
		            height: chartHeight + 'px',
		            textAlign: 'left',
		            lineHeight: 'normal', // #427
		            zIndex: 0, // #1072
		            '-webkit-tap-highlight-color': 'rgba(0,0,0,0)'
		        }, optionsChart.style);


		        /**
		         * The containing HTML element of the chart. The container is
		         * dynamically inserted into the element given as the `renderTo`
		         * parameter in the {@link Highcharts#chart} constructor.
		         *
		         * @name Highcharts.Chart#container
		         * @type {Highcharts.HTMLDOMElement}
		         */
		        container = createElement(
		            'div',
		            {
		                id: containerId
		            },
		            containerStyle,
		            renderTo
		        );
		        chart.container = container;

		        // cache the cursor (#1650)
		        chart._cursor = container.style.cursor;

		        // Initialize the renderer
		        Ren = H[optionsChart.renderer] || H.Renderer;

		        /**
		         * The renderer instance of the chart. Each chart instance has only one
		         * associated renderer.
		         *
		         * @name Highcharts.Chart#renderer
		         * @type {Highcharts.SVGRenderer}
		         */
		        chart.renderer = new Ren(
		            container,
		            chartWidth,
		            chartHeight,
		            null,
		            optionsChart.forExport,
		            options.exporting && options.exporting.allowHTML
		        );


		        chart.setClassName(optionsChart.className);

		        chart.renderer.setStyle(optionsChart.style);


		        // Add a reference to the charts index
		        chart.renderer.chartIndex = chart.index;

		        fireEvent(this, 'afterGetContainer');
		    },

		    /**
		     * Calculate margins by rendering axis labels in a preliminary position.
		     * Title, subtitle and legend have already been rendered at this stage, but
		     * will be moved into their final positions.
		     *
		     * @private
		     * @function Highcharts.Chart#getMargins
		     *
		     * @param {boolean} skipAxes
		     *
		     * @fires Highcharts.Chart#event:getMargins
		     */
		    getMargins: function (skipAxes) {
		        var chart = this,
		            spacing = chart.spacing,
		            margin = chart.margin,
		            titleOffset = chart.titleOffset;

		        chart.resetMargins();

		        // Adjust for title and subtitle
		        if (titleOffset && !defined(margin[0])) {
		            chart.plotTop = Math.max(
		                chart.plotTop,
		                titleOffset + chart.options.title.margin + spacing[0]
		            );
		        }

		        // Adjust for legend
		        if (chart.legend && chart.legend.display) {
		            chart.legend.adjustMargins(margin, spacing);
		        }

		        fireEvent(this, 'getMargins');

		        if (!skipAxes) {
		            this.getAxisMargins();
		        }
		    },

		    /**
		     * @private
		     * @function Highcharts.Chart#getAxisMargins
		     */
		    getAxisMargins: function () {

		        var chart = this,
		            // [top, right, bottom, left]
		            axisOffset = chart.axisOffset = [0, 0, 0, 0],
		            margin = chart.margin;

		        // pre-render axes to get labels offset width
		        if (chart.hasCartesianSeries) {
		            each(chart.axes, function (axis) {
		                if (axis.visible) {
		                    axis.getOffset();
		                }
		            });
		        }

		        // Add the axis offsets
		        each(marginNames, function (m, side) {
		            if (!defined(margin[side])) {
		                chart[m] += axisOffset[side];
		            }
		        });

		        chart.setChartSize();

		    },

		    /**
		     * Reflows the chart to its container. By default, the chart reflows
		     * automatically to its container following a `window.resize` event, as per
		     * the {@link https://api.highcharts/highcharts/chart.reflow|chart.reflow}
		     * option. However, there are no reliable events for div resize, so if the
		     * container is resized without a window resize event, this must be called
		     * explicitly.
		     *
		     * @sample highcharts/members/chart-reflow/
		     *         Resize div and reflow
		     * @sample highcharts/chart/events-container/
		     *         Pop up and reflow
		     *
		     * @function Highcharts.Chart#reflow
		     *
		     * @param {global.Event} e
		     *        Event arguments. Used primarily when the function is called
		     *        internally as a response to window resize.
		     */
		    reflow: function (e) {
		        var chart = this,
		            optionsChart = chart.options.chart,
		            renderTo = chart.renderTo,
		            hasUserSize = (
		                defined(optionsChart.width) &&
		                defined(optionsChart.height)
		            ),
		            width = optionsChart.width || H.getStyle(renderTo, 'width'),
		            height = optionsChart.height || H.getStyle(renderTo, 'height'),
		            target = e ? e.target : win;

		        // Width and height checks for display:none. Target is doc in IE8 and
		        // Opera, win in Firefox, Chrome and IE9.
		        if (
		            !hasUserSize &&
		            !chart.isPrinting &&
		            width &&
		            height &&
		            (target === win || target === doc)
		        ) {
		            if (
		                width !== chart.containerWidth ||
		                height !== chart.containerHeight
		            ) {
		                H.clearTimeout(chart.reflowTimeout);
		                // When called from window.resize, e is set, else it's called
		                // directly (#2224)
		                chart.reflowTimeout = syncTimeout(function () {
		                    // Set size, it may have been destroyed in the meantime
		                    // (#1257)
		                    if (chart.container) {
		                        chart.setSize(undefined, undefined, false);
		                    }
		                }, e ? 100 : 0);
		            }
		            chart.containerWidth = width;
		            chart.containerHeight = height;
		        }
		    },

		    /**
		     * Toggle the event handlers necessary for auto resizing, depending on the
		     * `chart.reflow` option.
		     *
		     * @private
		     * @function Highcharts.Chart#setReflow
		     *
		     * @param {boolean} reflow
		     */
		    setReflow: function (reflow) {

		        var chart = this;

		        if (reflow !== false && !this.unbindReflow) {
		            this.unbindReflow = addEvent(win, 'resize', function (e) {
		                chart.reflow(e);
		            });
		            addEvent(this, 'destroy', this.unbindReflow);

		        } else if (reflow === false && this.unbindReflow) {

		            // Unbind and unset
		            this.unbindReflow = this.unbindReflow();
		        }

		        // The following will add listeners to re-fit the chart before and after
		        // printing (#2284). However it only works in WebKit. Should have worked
		        // in Firefox, but not supported in IE.
		        /*
		        if (win.matchMedia) {
		            win.matchMedia('print').addListener(function reflow() {
		                chart.reflow();
		            });
		        }
		        //*/
		    },

		    /**
		     * Resize the chart to a given width and height. In order to set the width
		     * only, the height argument may be skipped. To set the height only, pass
		     * `undefined` for the width.
		     *
		     * @sample highcharts/members/chart-setsize-button/
		     *         Test resizing from buttons
		     * @sample highcharts/members/chart-setsize-jquery-resizable/
		     *         Add a jQuery UI resizable
		     * @sample stock/members/chart-setsize/
		     *         Highstock with UI resizable
		     *
		     * @function Highcharts.Chart#setSize
		     *
		     * @param {number|null} [width]
		     *        The new pixel width of the chart. Since v4.2.6, the argument can
		     *        be `undefined` in order to preserve the current value (when
		     *        setting height only), or `null` to adapt to the width of the
		     *        containing element.
		     *
		     * @param {number|null} [height]
		     *        The new pixel height of the chart. Since v4.2.6, the argument can
		     *        be `undefined` in order to preserve the current value, or `null`
		     *        in order to adapt to the height of the containing element.
		     *
		     * @param {Highcharts.AnimationOptionsObject} [animation=true]
		     *        Whether and how to apply animation.
		     *
		     * @fires Highcharts.Chart#event:endResize
		     * @fires Highcharts.Chart#event:resize
		     */
		    setSize: function (width, height, animation) {
		        var chart = this,
		            renderer = chart.renderer,
		            globalAnimation;

		        // Handle the isResizing counter
		        chart.isResizing += 1;

		        // set the animation for the current process
		        H.setAnimation(animation, chart);

		        chart.oldChartHeight = chart.chartHeight;
		        chart.oldChartWidth = chart.chartWidth;
		        if (width !== undefined) {
		            chart.options.chart.width = width;
		        }
		        if (height !== undefined) {
		            chart.options.chart.height = height;
		        }
		        chart.getChartSize();

		        // Resize the container with the global animation applied if enabled
		        // (#2503)

		        globalAnimation = renderer.globalAnimation;
		        (globalAnimation ? animate : css)(chart.container, {
		            width: chart.chartWidth + 'px',
		            height: chart.chartHeight + 'px'
		        }, globalAnimation);


		        chart.setChartSize(true);
		        renderer.setSize(chart.chartWidth, chart.chartHeight, animation);

		        // handle axes
		        each(chart.axes, function (axis) {
		            axis.isDirty = true;
		            axis.setScale();
		        });

		        chart.isDirtyLegend = true; // force legend redraw
		        chart.isDirtyBox = true; // force redraw of plot and chart border

		        chart.layOutTitles(); // #2857
		        chart.getMargins();

		        chart.redraw(animation);


		        chart.oldChartHeight = null;
		        fireEvent(chart, 'resize');

		        // Fire endResize and set isResizing back. If animation is disabled,
		        // fire without delay
		        syncTimeout(function () {
		            if (chart) {
		                fireEvent(chart, 'endResize', null, function () {
		                    chart.isResizing -= 1;
		                });
		            }
		        }, animObject(globalAnimation).duration);
		    },

		    /**
		     * Set the public chart properties. This is done before and after the
		     * pre-render to determine margin sizes.
		     *
		     * @private
		     * @function Highcharts.Chart#setChartSize
		     *
		     * @param {boolean} skipAxes
		     *
		     * @fires Highcharts.Chart#event:afterSetChartSize
		     */
		    setChartSize: function (skipAxes) {
		        var chart = this,
		            inverted = chart.inverted,
		            renderer = chart.renderer,
		            chartWidth = chart.chartWidth,
		            chartHeight = chart.chartHeight,
		            optionsChart = chart.options.chart,
		            spacing = chart.spacing,
		            clipOffset = chart.clipOffset,
		            clipX,
		            clipY,
		            plotLeft,
		            plotTop,
		            plotWidth,
		            plotHeight,
		            plotBorderWidth;

		        /**
		         * The current left position of the plot area in pixels.
		         *
		         * @name Highcharts.Chart#plotLeft
		         * @type {number}
		         */
		        chart.plotLeft = plotLeft = Math.round(chart.plotLeft);

		        /**
		         * The current top position of the plot area in pixels.
		         *
		         * @name Highcharts.Chart#plotTop
		         * @type {number}
		         */
		        chart.plotTop = plotTop = Math.round(chart.plotTop);

		        /**
		         * The current width of the plot area in pixels.
		         *
		         * @name Highcharts.Chart#plotWidth
		         * @type {number}
		         */
		        chart.plotWidth = plotWidth = Math.max(
		            0,
		            Math.round(chartWidth - plotLeft - chart.marginRight)
		        );

		        /**
		         * The current height of the plot area in pixels.
		         *
		         * @name Highcharts.Chart#plotHeight
		         * @type {number}
		         */
		        chart.plotHeight = plotHeight = Math.max(
		            0,
		            Math.round(chartHeight - plotTop - chart.marginBottom)
		        );

		        chart.plotSizeX = inverted ? plotHeight : plotWidth;
		        chart.plotSizeY = inverted ? plotWidth : plotHeight;

		        chart.plotBorderWidth = optionsChart.plotBorderWidth || 0;

		        // Set boxes used for alignment
		        chart.spacingBox = renderer.spacingBox = {
		            x: spacing[3],
		            y: spacing[0],
		            width: chartWidth - spacing[3] - spacing[1],
		            height: chartHeight - spacing[0] - spacing[2]
		        };
		        chart.plotBox = renderer.plotBox = {
		            x: plotLeft,
		            y: plotTop,
		            width: plotWidth,
		            height: plotHeight
		        };

		        plotBorderWidth = 2 * Math.floor(chart.plotBorderWidth / 2);
		        clipX = Math.ceil(Math.max(plotBorderWidth, clipOffset[3]) / 2);
		        clipY = Math.ceil(Math.max(plotBorderWidth, clipOffset[0]) / 2);
		        chart.clipBox = {
		            x: clipX,
		            y: clipY,
		            width: Math.floor(
		                chart.plotSizeX -
		                Math.max(plotBorderWidth, clipOffset[1]) / 2 -
		                clipX
		            ),
		            height: Math.max(
		                0,
		                Math.floor(
		                    chart.plotSizeY -
		                    Math.max(plotBorderWidth, clipOffset[2]) / 2 -
		                    clipY
		                )
		            )
		        };

		        if (!skipAxes) {
		            each(chart.axes, function (axis) {
		                axis.setAxisSize();
		                axis.setAxisTranslation();
		            });
		        }

		        fireEvent(chart, 'afterSetChartSize', { skipAxes: skipAxes });
		    },

		    /**
		     * Initial margins before auto size margins are applied.
		     *
		     * @private
		     * @function Highcharts.Chart#resetMargins
		     */
		    resetMargins: function () {
		        var chart = this,
		            chartOptions = chart.options.chart;

		        // Create margin and spacing array
		        each(['margin', 'spacing'], function splashArrays(target) {
		            var value = chartOptions[target],
		                values = isObject(value) ? value : [value, value, value, value];

		            each(['Top', 'Right', 'Bottom', 'Left'], function (sideName, side) {
		                chart[target][side] = pick(
		                    chartOptions[target + sideName],
		                    values[side]
		                );
		            });
		        });

		        // Set margin names like chart.plotTop, chart.plotLeft,
		        // chart.marginRight, chart.marginBottom.
		        each(marginNames, function (m, side) {
		            chart[m] = pick(chart.margin[side], chart.spacing[side]);
		        });
		        chart.axisOffset = [0, 0, 0, 0]; // top, right, bottom, left
		        chart.clipOffset = [0, 0, 0, 0];
		    },

		    /**
		     * Internal function to draw or redraw the borders and backgrounds for chart
		     * and plot area.
		     *
		     * @private
		     * @function Highcharts.Chart#drawChartBox
		     *
		     * @fires Highcharts.Chart#event:afterDrawChartBox
		     */
		    drawChartBox: function () {
		        var chart = this,
		            optionsChart = chart.options.chart,
		            renderer = chart.renderer,
		            chartWidth = chart.chartWidth,
		            chartHeight = chart.chartHeight,
		            chartBackground = chart.chartBackground,
		            plotBackground = chart.plotBackground,
		            plotBorder = chart.plotBorder,
		            chartBorderWidth,

		            plotBGImage = chart.plotBGImage,
		            chartBackgroundColor = optionsChart.backgroundColor,
		            plotBackgroundColor = optionsChart.plotBackgroundColor,
		            plotBackgroundImage = optionsChart.plotBackgroundImage,

		            mgn,
		            bgAttr,
		            plotLeft = chart.plotLeft,
		            plotTop = chart.plotTop,
		            plotWidth = chart.plotWidth,
		            plotHeight = chart.plotHeight,
		            plotBox = chart.plotBox,
		            clipRect = chart.clipRect,
		            clipBox = chart.clipBox,
		            verb = 'animate';

		        // Chart area
		        if (!chartBackground) {
		            chart.chartBackground = chartBackground = renderer.rect()
		                .addClass('highcharts-background')
		                .add();
		            verb = 'attr';
		        }


		        // Presentational
		        chartBorderWidth = optionsChart.borderWidth || 0;
		        mgn = chartBorderWidth + (optionsChart.shadow ? 8 : 0);

		        bgAttr = {
		            fill: chartBackgroundColor || 'none'
		        };

		        if (chartBorderWidth || chartBackground['stroke-width']) { // #980
		            bgAttr.stroke = optionsChart.borderColor;
		            bgAttr['stroke-width'] = chartBorderWidth;
		        }
		        chartBackground
		            .attr(bgAttr)
		            .shadow(optionsChart.shadow);

		        chartBackground[verb]({
		            x: mgn / 2,
		            y: mgn / 2,
		            width: chartWidth - mgn - chartBorderWidth % 2,
		            height: chartHeight - mgn - chartBorderWidth % 2,
		            r: optionsChart.borderRadius
		        });

		        // Plot background
		        verb = 'animate';
		        if (!plotBackground) {
		            verb = 'attr';
		            chart.plotBackground = plotBackground = renderer.rect()
		                .addClass('highcharts-plot-background')
		                .add();
		        }
		        plotBackground[verb](plotBox);


		        // Presentational attributes for the background
		        plotBackground
		            .attr({
		                fill: plotBackgroundColor || 'none'
		            })
		            .shadow(optionsChart.plotShadow);

		        // Create the background image
		        if (plotBackgroundImage) {
		            if (!plotBGImage) {
		                chart.plotBGImage = renderer.image(
		                    plotBackgroundImage,
		                    plotLeft,
		                    plotTop,
		                    plotWidth,
		                    plotHeight
		                ).add();
		            } else {
		                plotBGImage.animate(plotBox);
		            }
		        }


		        // Plot clip
		        if (!clipRect) {
		            chart.clipRect = renderer.clipRect(clipBox);
		        } else {
		            clipRect.animate({
		                width: clipBox.width,
		                height: clipBox.height
		            });
		        }

		        // Plot area border
		        verb = 'animate';
		        if (!plotBorder) {
		            verb = 'attr';
		            chart.plotBorder = plotBorder = renderer.rect()
		                .addClass('highcharts-plot-border')
		                .attr({
		                    zIndex: 1 // Above the grid
		                })
		                .add();
		        }


		        // Presentational
		        plotBorder.attr({
		            stroke: optionsChart.plotBorderColor,
		            'stroke-width': optionsChart.plotBorderWidth || 0,
		            fill: 'none'
		        });


		        plotBorder[verb](plotBorder.crisp({
		            x: plotLeft,
		            y: plotTop,
		            width: plotWidth,
		            height: plotHeight
		        }, -plotBorder.strokeWidth())); // #3282 plotBorder should be negative;

		        // reset
		        chart.isDirtyBox = false;

		        fireEvent(this, 'afterDrawChartBox');
		    },

		    /**
		     * Detect whether a certain chart property is needed based on inspecting its
		     * options and series. This mainly applies to the chart.inverted property,
		     * and in extensions to the chart.angular and chart.polar properties.
		     *
		     * @private
		     * @function Highcharts.Chart#propFromSeries
		     */
		    propFromSeries: function () {
		        var chart = this,
		            optionsChart = chart.options.chart,
		            klass,
		            seriesOptions = chart.options.series,
		            i,
		            value;


		        each(['inverted', 'angular', 'polar'], function (key) {

		            // The default series type's class
		            klass = seriesTypes[optionsChart.type ||
		                optionsChart.defaultSeriesType];

		            // Get the value from available chart-wide properties
		            value =
		                optionsChart[key] || // It is set in the options
		                (klass && klass.prototype[key]); // The default series class
		                    // requires it

		            // 4. Check if any the chart's series require it
		            i = seriesOptions && seriesOptions.length;
		            while (!value && i--) {
		                klass = seriesTypes[seriesOptions[i].type];
		                if (klass && klass.prototype[key]) {
		                    value = true;
		                }
		            }

		            // Set the chart property
		            chart[key] = value;
		        });

		    },

		    /**
		     * Internal function to link two or more series together, based on the
		     * `linkedTo` option. This is done from `Chart.render`, and after
		     * `Chart.addSeries` and `Series.remove`.
		     *
		     * @private
		     * @function Highcharts.Chart#linkSeries
		     *
		     * @fires Highcharts.Chart#event:afterLinkSeries
		     */
		    linkSeries: function () {
		        var chart = this,
		            chartSeries = chart.series;

		        // Reset links
		        each(chartSeries, function (series) {
		            series.linkedSeries.length = 0;
		        });

		        // Apply new links
		        each(chartSeries, function (series) {
		            var linkedTo = series.options.linkedTo;
		            if (isString(linkedTo)) {
		                if (linkedTo === ':previous') {
		                    linkedTo = chart.series[series.index - 1];
		                } else {
		                    linkedTo = chart.get(linkedTo);
		                }
		                // #3341 avoid mutual linking
		                if (linkedTo && linkedTo.linkedParent !== series) {
		                    linkedTo.linkedSeries.push(series);
		                    series.linkedParent = linkedTo;
		                    series.visible = pick(
		                        series.options.visible,
		                        linkedTo.options.visible,
		                        series.visible
		                    ); // #3879
		                }
		            }
		        });

		        fireEvent(this, 'afterLinkSeries');
		    },

		    /**
		     * Render series for the chart.
		     *
		     * @private
		     * @function Highcharts.Chart#renderSeries
		     */
		    renderSeries: function () {
		        each(this.series, function (serie) {
		            serie.translate();
		            serie.render();
		        });
		    },

		    /**
		     * Render labels for the chart.
		     *
		     * @private
		     * @function Highcharts.Chart#renderLabels
		     */
		    renderLabels: function () {
		        var chart = this,
		            labels = chart.options.labels;
		        if (labels.items) {
		            each(labels.items, function (label) {
		                var style = extend(labels.style, label.style),
		                    x = pInt(style.left) + chart.plotLeft,
		                    y = pInt(style.top) + chart.plotTop + 12;

		                // delete to prevent rewriting in IE
		                delete style.left;
		                delete style.top;

		                chart.renderer.text(
		                    label.html,
		                    x,
		                    y
		                )
		                .attr({ zIndex: 2 })
		                .css(style)
		                .add();

		            });
		        }
		    },

		    /**
		     * Render all graphics for the chart. Runs internally on initialization.
		     *
		     * @private
		     * @function Highcharts.Chart#render
		     */
		    render: function () {
		        var chart = this,
		            axes = chart.axes,
		            renderer = chart.renderer,
		            options = chart.options,
		            tempWidth,
		            tempHeight,
		            redoHorizontal,
		            redoVertical;

		        // Title
		        chart.setTitle();

		        /**
		         * The overview of the chart's series.
		         *
		         * @name Highcharts.Chart#legend
		         * @type {Highcharts.Legend}
		         */
		        chart.legend = new Legend(chart, options.legend);

		        // Get stacks
		        if (chart.getStacks) {
		            chart.getStacks();
		        }

		        // Get chart margins
		        chart.getMargins(true);
		        chart.setChartSize();

		        // Record preliminary dimensions for later comparison
		        tempWidth = chart.plotWidth;
		        // 21 is the most common correction for X axis labels
		        // use Math.max to prevent negative plotHeight
		        tempHeight = chart.plotHeight = Math.max(chart.plotHeight - 21, 0);

		        // Get margins by pre-rendering axes
		        each(axes, function (axis) {
		            axis.setScale();
		        });
		        chart.getAxisMargins();

		        // If the plot area size has changed significantly, calculate tick
		        // positions again
		        redoHorizontal = tempWidth / chart.plotWidth > 1.1;
		        // Height is more sensitive, use lower threshold
		        redoVertical = tempHeight / chart.plotHeight > 1.05;

		        if (redoHorizontal || redoVertical) {

		            each(axes, function (axis) {
		                if (
		                    (axis.horiz && redoHorizontal) ||
		                    (!axis.horiz && redoVertical)
		                ) {
		                    // update to reflect the new margins
		                    axis.setTickInterval(true);
		                }
		            });
		            chart.getMargins(); // second pass to check for new labels
		        }

		        // Draw the borders and backgrounds
		        chart.drawChartBox();


		        // Axes
		        if (chart.hasCartesianSeries) {
		            each(axes, function (axis) {
		                if (axis.visible) {
		                    axis.render();
		                }
		            });
		        }

		        // The series
		        if (!chart.seriesGroup) {
		            chart.seriesGroup = renderer.g('series-group')
		                .attr({ zIndex: 3 })
		                .add();
		        }
		        chart.renderSeries();

		        // Labels
		        chart.renderLabels();

		        // Credits
		        chart.addCredits();

		        // Handle responsiveness
		        if (chart.setResponsive) {
		            chart.setResponsive();
		        }

		        // Set flag
		        chart.hasRendered = true;

		    },

		    /**
		     * Set a new credits label for the chart.
		     *
		     * @sample highcharts/credits/credits-update/
		     *         Add and update credits
		     *
		     * @function Highcharts.Chart#addCredits
		     *
		     * @param {Highcharts.CreditsOptions} options
		     *        A configuration object for the new credits.
		     */
		    addCredits: function (credits) {
		        var chart = this;

		        credits = merge(true, this.options.credits, credits);
		        if (credits.enabled && !this.credits) {

		            /**
		             * The chart's credits label. The label has an `update` method that
		             * allows setting new options as per the
		             * {@link https://api.highcharts.com/highcharts/credits|credits options set}.
		             *
		             * @name Highcharts.Chart#credits
		             * @type {Highcharts.SVGElement}
		             */
		            this.credits = this.renderer.text(
		                credits.text + (this.mapCredits || ''),
		                0,
		                0
		            )
		            .addClass('highcharts-credits')
		            .on('click', function () {
		                if (credits.href) {
		                    win.location.href = credits.href;
		                }
		            })
		            .attr({
		                align: credits.position.align,
		                zIndex: 8
		            })

		            .css(credits.style)

		            .add()
		            .align(credits.position);

		            // Dynamically update
		            this.credits.update = function (options) {
		                chart.credits = chart.credits.destroy();
		                chart.addCredits(options);
		            };
		        }
		    },

		    /**
		     * Remove the chart and purge memory. This method is called internally
		     * before adding a second chart into the same container, as well as on
		     * window unload to prevent leaks.
		     *
		     * @sample highcharts/members/chart-destroy/
		     *         Destroy the chart from a button
		     * @sample stock/members/chart-destroy/
		     *         Destroy with Highstock
		     *
		     * @function Highcharts.Chart#destroy
		     *
		     * @fires Highcharts.Chart#event:destroy
		     */
		    destroy: function () {
		        var chart = this,
		            axes = chart.axes,
		            series = chart.series,
		            container = chart.container,
		            i,
		            parentNode = container && container.parentNode;

		        // fire the chart.destoy event
		        fireEvent(chart, 'destroy');

		        // Delete the chart from charts lookup array
		        if (chart.renderer.forExport) {
		            H.erase(charts, chart); // #6569
		        } else {
		            charts[chart.index] = undefined;
		        }
		        H.chartCount--;
		        chart.renderTo.removeAttribute('data-highcharts-chart');

		        // remove events
		        removeEvent(chart);

		        // ==== Destroy collections:
		        // Destroy axes
		        i = axes.length;
		        while (i--) {
		            axes[i] = axes[i].destroy();
		        }

		        // Destroy scroller & scroller series before destroying base series
		        if (this.scroller && this.scroller.destroy) {
		            this.scroller.destroy();
		        }

		        // Destroy each series
		        i = series.length;
		        while (i--) {
		            series[i] = series[i].destroy();
		        }

		        // ==== Destroy chart properties:
		        each([
		            'title', 'subtitle', 'chartBackground', 'plotBackground',
		            'plotBGImage', 'plotBorder', 'seriesGroup', 'clipRect', 'credits',
		            'pointer', 'rangeSelector', 'legend', 'resetZoomButton', 'tooltip',
		            'renderer'
		        ], function (name) {
		            var prop = chart[name];

		            if (prop && prop.destroy) {
		                chart[name] = prop.destroy();
		            }
		        });

		        // Remove container and all SVG, check container as it can break in IE
		        // when destroyed before finished loading
		        if (container) {
		            container.innerHTML = '';
		            removeEvent(container);
		            if (parentNode) {
		                discardElement(container);
		            }

		        }

		        // clean it all up
		        objectEach(chart, function (val, key) {
		            delete chart[key];
		        });

		    },

		    /**
		     * Prepare for first rendering after all data are loaded.
		     *
		     * @private
		     * @function Highcharts.Chart#firstRender
		     *
		     * @fires Highcharts.Chart#event:beforeRender
		     */
		    firstRender: function () {
		        var chart = this,
		            options = chart.options;

		        // Hook for oldIE to check whether the chart is ready to render
		        if (chart.isReadyToRender && !chart.isReadyToRender()) {
		            return;
		        }

		        // Create the container
		        chart.getContainer();

		        chart.resetMargins();
		        chart.setChartSize();

		        // Set the common chart properties (mainly invert) from the given series
		        chart.propFromSeries();

		        // get axes
		        chart.getAxes();

		        // Initialize the series
		        each(options.series || [], function (serieOptions) {
		            chart.initSeries(serieOptions);
		        });

		        chart.linkSeries();

		        // Run an event after axes and series are initialized, but before
		        // render. At this stage, the series data is indexed and cached in the
		        // xData and yData arrays, so we can access those before rendering. Used
		        // in Highstock.
		        fireEvent(chart, 'beforeRender');

		        // depends on inverted and on margins being set
		        if (Pointer) {

		            /**
		             * The Pointer that keeps track of mouse and touch interaction.
		             *
		             * @memberof Highcharts.Chart
		             * @name pointer
		             * @type {Highcharts.Pointer}
		             * @instance
		             */
		            chart.pointer = new Pointer(chart, options);
		        }

		        chart.render();

		        // Fire the load event if there are no external images
		        if (!chart.renderer.imgCount && chart.onload) {
		            chart.onload();
		        }

		        // If the chart was rendered outside the top container, put it back in
		        // (#3679)
		        chart.temporaryDisplay(true);

		    },

		    /**
		     * Internal function that runs on chart load, async if any images are loaded
		     * in the chart. Runs the callbacks and triggers the `load` and `render`
		     * events.
		     *
		     * @private
		     * @function Highcharts.Chart#onload
		     *
		     * @fires Highcharts.Chart#event:load
		     * @fires Highcharts.Chart#event:render
		     */
		    onload: function () {

		        // Run callbacks
		        each([this.callback].concat(this.callbacks), function (fn) {
		            // Chart destroyed in its own callback (#3600)
		            if (fn && this.index !== undefined) {
		                fn.apply(this, [this]);
		            }
		        }, this);

		        fireEvent(this, 'load');
		        fireEvent(this, 'render');


		        // Set up auto resize, check for not destroyed (#6068)
		        if (defined(this.index)) {
		            this.setReflow(this.options.chart.reflow);
		        }

		        // Don't run again
		        this.onload = null;
		    }

		}); // end Chart

	}(Highcharts));
	(function (H) {
		/**
		 * (c) 2010-2018 Torstein Honsi
		 *
		 * License: www.highcharts.com/license
		 *
		 * Highcharts feature to make the Y axis stay fixed when scrolling the chart
		 * horizontally on mobile devices. Supports left and right side axes.
		 */



		var addEvent = H.addEvent,
		    Chart = H.Chart,
		    each = H.each;

		/**
		 * Options for a scrollable plot area. This feature provides a minimum width for
		 * the plot area of the chart. If the width gets smaller than this, typically
		 * on mobile devices, a native browser scrollbar is presented below the chart.
		 * This scrollbar provides smooth scrolling for the contents of the plot area,
		 * whereas the title, legend and axes are fixed.
		 *
		 * @sample {highcharts} highcharts/chart/scrollable-plotarea
		 *         Scrollable plot area
		 *
		 * @since     6.1.0
		 * @product   highcharts gantt
		 * @apioption chart.scrollablePlotArea
		 */

		/**
		 * The minimum width for the plot area. If it gets smaller than this, the plot
		 * area will become scrollable.
		 *
		 * @type      {number}
		 * @apioption chart.scrollablePlotArea.minWidth
		 */

		/**
		 * The initial scrolling position of the scrollable plot area. Ranges from 0 to
		 * 1, where 0 aligns the plot area to the left and 1 aligns it to the right.
		 * Typically we would use 1 if the chart has right aligned Y axes.
		 *
		 * @type      {number}
		 * @apioption chart.scrollablePlotArea.scrollPositionX
		 */

		addEvent(Chart, 'afterSetChartSize', function (e) {

		    var scrollablePlotArea = this.options.chart.scrollablePlotArea,
		        scrollableMinWidth =
		            scrollablePlotArea && scrollablePlotArea.minWidth,
		        scrollablePixels;

		    if (scrollableMinWidth && !this.renderer.forExport) {

		        // The amount of pixels to scroll, the difference between chart
		        // width and scrollable width
		        this.scrollablePixels = scrollablePixels = Math.max(
		            0,
		            scrollableMinWidth - this.chartWidth
		        );

		        if (scrollablePixels) {
		            this.plotWidth += scrollablePixels;
		            this.clipBox.width += scrollablePixels;

		            if (!e.skipAxes) {
		                each(this.axes, function (axis) {
		                    if (axis.side === 1) {
		                        // Get the plot lines right in getPlotLinePath,
		                        // temporarily set it to the adjusted plot width.
		                        axis.getPlotLinePath = function () {
		                            var right = this.right,
		                                path;
		                            this.right = right - axis.chart.scrollablePixels;
		                            path = H.Axis.prototype.getPlotLinePath.apply(
		                                this,
		                                arguments
		                            );
		                            this.right = right;
		                            return path;
		                        };

		                    } else {
		                        // Apply the corrected plotWidth
		                        axis.setAxisSize();
		                        axis.setAxisTranslation();
		                    }
		                });
		            }
		        }
		    }
		});

		addEvent(Chart, 'render', function () {
		    if (this.scrollablePixels) {
		        if (this.setUpScrolling) {
		            this.setUpScrolling();
		        }
		        this.applyFixed();

		    } else if (this.fixedDiv) { // Has been in scrollable mode
		        this.applyFixed();
		    }
		});

		/**
		 * @private
		 * @function Highcharts.Chart#setUpScrolling
		 */
		Chart.prototype.setUpScrolling = function () {

		    // Add the necessary divs to provide scrolling
		    this.scrollingContainer = H.createElement('div', {
		        'className': 'highcharts-scrolling'
		    }, {
		        overflowX: 'auto',
		        WebkitOverflowScrolling: 'touch'
		    }, this.renderTo);

		    this.innerContainer = H.createElement('div', {
		        'className': 'highcharts-inner-container'
		    }, null, this.scrollingContainer);

		    // Now move the container inside
		    this.innerContainer.appendChild(this.container);

		    // Don't run again
		    this.setUpScrolling = null;
		};

		/**
		 * @private
		 * @function Highcharts.Chart#applyFixed
		 */
		Chart.prototype.applyFixed = function () {
		    var container = this.container,
		        fixedRenderer,
		        scrollableWidth,
		        firstTime = !this.fixedDiv;

		    // First render
		    if (firstTime) {

		        this.fixedDiv = H.createElement(
		            'div',
		            {
		                className: 'highcharts-fixed'
		            },
		            {
		                position: 'absolute',
		                overflow: 'hidden',
		                pointerEvents: 'none',
		                zIndex: 2
		            },
		            null,
		            true
		        );
		        this.renderTo.insertBefore(
		            this.fixedDiv,
		            this.renderTo.firstChild
		        );

		        this.fixedRenderer = fixedRenderer = new H.Renderer(
		            this.fixedDiv,
		            0,
		            0
		        );

		        // Mask
		        this.scrollableMask = fixedRenderer.path()
		            .attr({
		                fill: H.color(
		                    this.options.chart.backgroundColor || '#fff'
		                ).setOpacity(0.85).get(),
		                zIndex: -1
		            })
		            .addClass('highcharts-scrollable-mask')
		            .add();

		        // These elements are moved over to the fixed renderer and stay fixed
		        // when the user scrolls the chart.
		        H.each([
		            this.inverted ?
		                '.highcharts-xaxis' :
		                '.highcharts-yaxis',
		            this.inverted ?
		                '.highcharts-xaxis-labels' :
		                '.highcharts-yaxis-labels',
		            '.highcharts-contextbutton',
		            '.highcharts-credits',
		            '.highcharts-legend',
		            '.highcharts-subtitle',
		            '.highcharts-title',
		            '.highcharts-legend-checkbox'
		        ], function (className) {
		            H.each(container.querySelectorAll(className), function (elem) {
		                (
		                    elem.namespaceURI === fixedRenderer.SVG_NS ?
		                        fixedRenderer.box :
		                        fixedRenderer.box.parentNode
		                ).appendChild(elem);
		                elem.style.pointerEvents = 'auto';
		            });
		        });
		    }

		    // Set the size of the fixed renderer to the visible width
		    this.fixedRenderer.setSize(
		        this.chartWidth,
		        this.chartHeight
		    );

		    // Increase the size of the scrollable renderer and background
		    scrollableWidth = this.chartWidth + this.scrollablePixels;
		    H.stop(this.container);
		    this.container.style.width = scrollableWidth + 'px';
		    this.renderer.boxWrapper.attr({
		        width: scrollableWidth,
		        height: this.chartHeight,
		        viewBox: [0, 0, scrollableWidth, this.chartHeight].join(' ')
		    });
		    this.chartBackground.attr({ width: scrollableWidth });

		    // Set scroll position
		    if (firstTime) {
		        var options = this.options.chart.scrollablePlotArea;
		        if (options.scrollPositionX) {
		            this.scrollingContainer.scrollLeft =
		                this.scrollablePixels * options.scrollPositionX;
		        }
		    }

		    // Mask behind the left and right side
		    var axisOffset = this.axisOffset,
		        maskTop = this.plotTop - axisOffset[0] - 1,
		        maskBottom = this.plotTop + this.plotHeight + axisOffset[2],
		        maskPlotRight = this.plotLeft + this.plotWidth -
		            this.scrollablePixels;

		    this.scrollableMask.attr({
		        d: this.scrollablePixels ? [
		            // Left side
		            'M', 0, maskTop,
		            'L', this.plotLeft - 1, maskTop,
		            'L', this.plotLeft - 1, maskBottom,
		            'L', 0, maskBottom,
		            'Z',

		            // Right side
		            'M', maskPlotRight, maskTop,
		            'L', this.chartWidth, maskTop,
		            'L', this.chartWidth, maskBottom,
		            'L', maskPlotRight, maskBottom,
		            'Z'
		        ] : ['M', 0, 0]
		    });
		};

	}(Highcharts));
	(function (Highcharts) {
		/**
		 * (c) 2010-2018 Torstein Honsi
		 *
		 * License: www.highcharts.com/license
		 */

		/**
		 * Configuration hash for the data label and tooltip formatters.
		 *
		 * @typedef Highcharts.PointLabelObject
		 *
		 * @property {number|string} x
		 *           For categorized axes this property holds the category name for the
		 *           point. For other axes it holds the X value.
		 *
		 * @property {number} [y]
		 *           The y value of the point.
		 *
		 * @property {Highcharts.ColorString} color
		 *           The point's current color.
		 *
		 * @property {number} colorIndex
		 *           The point's current color index, used in styled mode instead of
		 *           `color`. The color index is inserted in class names used for
		 *           styling.
		 *
		 * @property {number|string} key
		 *           The name of the related point.
		 *
		 * @property {Highcharts.Series} series
		 *           The related series.
		 *
		 * @property {Highcharts.Point} point
		 *           The related point.
		 *
		 * @property {number} percentage
		 *           The percentage for related points in a stacked series or pies.
		 *
		 * @property {number} total
		 *           The total of values in either a stack for stacked series, or a pie
		 *           in a pie series.
		 */



		var Point,
		    H = Highcharts,
		    each = H.each,
		    extend = H.extend,
		    erase = H.erase,
		    fireEvent = H.fireEvent,
		    format = H.format,
		    isArray = H.isArray,
		    isNumber = H.isNumber,
		    pick = H.pick,
		    uniqueKey = H.uniqueKey,
		    defined = H.defined,
		    removeEvent = H.removeEvent;

		/**
		 * The Point object. The point objects are generated from the `series.data`
		 * configuration objects or raw numbers. They can be accessed from the
		 * `Series.points` array. Other ways to instantiate points are through {@link
		 * Highcharts.Series#addPoint} or {@link Highcharts.Series#setData}.
		 *
		 * @class
		 * @name Highcharts.Point
		 */
		Highcharts.Point = Point = function () {};
		Highcharts.Point.prototype = {

		    /**
		     * Initialize the point. Called internally based on the `series.data`
		     * option.
		     *
		     * @function Highcharts.Point#init
		     *
		     * @param {Highcharts.Series} series
		     *        The series object containing this point.
		     *
		     * @param {number|Array<number>|*} options
		     *        The data in either number, array or object format.
		     *
		     * @param {number} x
		     *        Optionally, the X value of the point.
		     *
		     * @return {Highcharts.Point}
		     *         The Point instance.
		     *
		     * @fires Highcharts.Point#event:afterInit
		     */
		    init: function (series, options, x) {

		        var point = this,
		            colors,
		            colorCount = series.chart.options.chart.colorCount,
		            colorIndex;

		        /**
		         * The series object associated with the point.
		         *
		         * @name Highcharts.Point#series
		         * @type {Highcharts.Series}
		         */
		        point.series = series;



		        /**
		         * The point's current color.
		         *
		         * @name Highcharts.Point#color
		         * @type {Highcharts.ColorString}
		         */
		        point.color = series.color; // #3445



		        point.applyOptions(options, x);

		        // Add a unique ID to the point if none is assigned
		        point.id = defined(point.id) ? point.id : uniqueKey();

		        if (series.options.colorByPoint) {



		            colors = series.options.colors || series.chart.options.colors;
		            point.color = point.color || colors[series.colorCounter];
		            colorCount = colors.length;



		            colorIndex = series.colorCounter;
		            series.colorCounter++;
		            // loop back to zero
		            if (series.colorCounter === colorCount) {
		                series.colorCounter = 0;
		            }
		        } else {
		            colorIndex = series.colorIndex;
		        }

		        /**
		         * The point's current color index, used in styled mode instead of
		         * `color`. The color index is inserted in class names used for styling.
		         *
		         * @name Highcharts.Point#colorIndex
		         * @type {number}
		         */
		        point.colorIndex = pick(point.colorIndex, colorIndex);

		        series.chart.pointCount++;

		        fireEvent(point, 'afterInit');

		        return point;
		    },
		    /**
		     * Apply the options containing the x and y data and possible some extra
		     * properties. Called on point init or from point.update.
		     *
		     * @private
		     * @function Highcharts.Point#applyOptions
		     *
		     * @param {*} options
		     *        The point options as defined in series.data.
		     *
		     * @param {number} x
		     *        Optionally, the x value.
		     *
		     * @return {Highcharts.Point}
		     *         The Point instance.
		     */
		    applyOptions: function (options, x) {
		        var point = this,
		            series = point.series,
		            pointValKey = series.options.pointValKey || series.pointValKey;

		        options = Point.prototype.optionsToObject.call(this, options);

		        // copy options directly to point
		        extend(point, options);

		        /**
		         * The point's options as applied in the initial configuration, or
		         * extended through `Point.update`.
		         *
		         * @name Highcharts.Point#options
		         * @type {*}
		         */
		        point.options = point.options ?
		            extend(point.options, options) :
		            options;

		        // Since options are copied into the Point instance, some accidental
		        // options must be shielded (#5681)
		        if (options.group) {
		            delete point.group;
		        }
		        if (options.dataLabels) {
		            delete point.dataLabels;
		        }

		        /**
		         * The y value of the point.
		         *
		         * @name Highcharts.Point#y
		         * @type {number|undefined}
		         */
		        // For higher dimension series types. For instance, for ranges, point.y
		        // is mapped to point.low.
		        if (pointValKey) {
		            point.y = point[pointValKey];
		        }
		        point.isNull = pick(
		            point.isValid && !point.isValid(),
		            point.x === null || !isNumber(point.y, true)
		        ); // #3571, check for NaN

		        // The point is initially selected by options (#5777)
		        if (point.selected) {
		            point.state = 'select';
		        }

		        /**
		         * The x value of the point.
		         *
		         * @name Highcharts.Point#x
		         * @type {number}
		         */
		        // If no x is set by now, get auto incremented value. All points must
		        // have an x value, however the y value can be null to create a gap in
		        // the series
		        if (
		            'name' in point &&
		            x === undefined &&
		            series.xAxis &&
		            series.xAxis.hasNames
		        ) {
		            point.x = series.xAxis.nameToX(point);
		        }
		        if (point.x === undefined && series) {
		            if (x === undefined) {
		                point.x = series.autoIncrement(point);
		            } else {
		                point.x = x;
		            }
		        }

		        return point;
		    },

		    /**
		     * Set a value in an object, on the property defined by key. The key
		     * supports nested properties using dot notation. The function modifies the
		     * input object and does not make a copy.
		     *
		     * @function Highcharts.Point#setNestedProperty
		     *
		     * @param {*} object
		     *        The object to set the value on.
		     *
		     * @param {*} value
		     *        The value to set.
		     *
		     * @param {string} key
		     *        Key to the property to set.
		     *
		     * @return {*}
		     *         The modified object.
		     */
		    setNestedProperty: function (object, value, key) {
		        var nestedKeys = key.split('.');
		        H.reduce(nestedKeys, function (result, key, i, arr) {
		            var isLastKey = arr.length - 1 === i;
		            result[key] = (
		                isLastKey ?
		                value :
		                (H.isObject(result[key], true) ? result[key] : {})
		            );
		            return result[key];
		        }, object);
		        return object;
		    },

		    /**
		     * Transform number or array configs into objects. Used internally to unify
		     * the different configuration formats for points. For example, a simple
		     * number `10` in a line series will be transformed to `{ y: 10 }`, and an
		     * array config like `[1, 10]` in a scatter series will be transformed to
		     * `{ x: 1, y: 10 }`.
		     *
		     * @function Highcharts.Point#optionsToObject
		     *
		     * @param {number|Array<number>|*} options
		     *        The input option.
		     *
		     * @return {*}
		     *         Transformed options.
		     */
		    optionsToObject: function (options) {
		        var ret = {},
		            series = this.series,
		            keys = series.options.keys,
		            pointArrayMap = keys || series.pointArrayMap || ['y'],
		            valueCount = pointArrayMap.length,
		            firstItemType,
		            i = 0,
		            j = 0;

		        if (isNumber(options) || options === null) {
		            ret[pointArrayMap[0]] = options;

		        } else if (isArray(options)) {
		            // with leading x value
		            if (!keys && options.length > valueCount) {
		                firstItemType = typeof options[0];
		                if (firstItemType === 'string') {
		                    ret.name = options[0];
		                } else if (firstItemType === 'number') {
		                    ret.x = options[0];
		                }
		                i++;
		            }
		            while (j < valueCount) {
		                // Skip undefined positions for keys
		                if (!keys || options[i] !== undefined) {
		                    if (pointArrayMap[j].indexOf('.') > 0) {
		                        // Handle nested keys, e.g. ['color.pattern.image']
		                        // Avoid function call unless necessary.
		                        H.Point.prototype.setNestedProperty(
		                            ret, options[i], pointArrayMap[j]
		                        );
		                    } else {
		                        ret[pointArrayMap[j]] = options[i];
		                    }
		                }
		                i++;
		                j++;
		            }
		        } else if (typeof options === 'object') {
		            ret = options;

		            // This is the fastest way to detect if there are individual point
		            // dataLabels that need to be considered in drawDataLabels. These
		            // can only occur in object configs.
		            if (options.dataLabels) {
		                series._hasPointLabels = true;
		            }

		            // Same approach as above for markers
		            if (options.marker) {
		                series._hasPointMarkers = true;
		            }
		        }
		        return ret;
		    },

		    /**
		     * Get the CSS class names for individual points. Used internally where the
		     * returned value is set on every point.
		     *
		     * @function Highcharts.Point#getClassName
		     *
		     * @return {string}
		     *         The class names.
		     */
		    getClassName: function () {
		        return 'highcharts-point' +
		            (this.selected ? ' highcharts-point-select' : '') +
		            (this.negative ? ' highcharts-negative' : '') +
		            (this.isNull ? ' highcharts-null-point' : '') +
		            (this.colorIndex !== undefined ? ' highcharts-color-' +
		                this.colorIndex : '') +
		            (this.options.className ? ' ' + this.options.className : '') +
		            (this.zone && this.zone.className ? ' ' +
		                this.zone.className.replace('highcharts-negative', '') : '');
		    },

		    /**
		     * In a series with `zones`, return the zone that the point belongs to.
		     *
		     * @function Highcharts.Point#getZone
		     *
		     * @return {Highcharts.PlotSeriesZonesOptions}
		     *         The zone item.
		     */
		    getZone: function () {
		        var series = this.series,
		            zones = series.zones,
		            zoneAxis = series.zoneAxis || 'y',
		            i = 0,
		            zone;

		        zone = zones[i];
		        while (this[zoneAxis] >= zone.value) {
		            zone = zones[++i];
		        }

		        // For resetting or reusing the point (#8100)
		        if (!this.nonZonedColor) {
		            this.nonZonedColor = this.color;
		        }

		        if (zone && zone.color && !this.options.color) {
		            this.color = zone.color;
		        } else {
		            this.color = this.nonZonedColor;
		        }

		        return zone;
		    },

		    /**
		     * Destroy a point to clear memory. Its reference still stays in
		     * `series.data`.
		     *
		     * @private
		     * @function Highcharts.Point#destroy
		     */
		    destroy: function () {
		        var point = this,
		            series = point.series,
		            chart = series.chart,
		            hoverPoints = chart.hoverPoints,
		            prop;

		        chart.pointCount--;

		        if (hoverPoints) {
		            point.setState();
		            erase(hoverPoints, point);
		            if (!hoverPoints.length) {
		                chart.hoverPoints = null;
		            }

		        }
		        if (point === chart.hoverPoint) {
		            point.onMouseOut();
		        }

		        // Remove all events and elements
		        if (point.graphic || point.dataLabel || point.dataLabels) {
		            removeEvent(point);
		            point.destroyElements();
		        }

		        if (point.legendItem) { // pies have legend items
		            chart.legend.destroyItem(point);
		        }

		        for (prop in point) {
		            point[prop] = null;
		        }
		    },

		    /**
		     * Destroy SVG elements associated with the point.
		     *
		     * @private
		     * @function Highcharts.Point#destroyElements
		     */
		    destroyElements: function () {
		        var point = this,
		            props = [
		                'graphic',
		                'dataLabel',
		                'dataLabelUpper',
		                'connector',
		                'shadowGroup'
		            ],
		            prop,
		            i = 6;
		        while (i--) {
		            prop = props[i];
		            if (point[prop]) {
		                point[prop] = point[prop].destroy();
		            }
		        }
		        // Handle point.dataLabels and point.connectors
		        if (point.dataLabels) {
		            each(point.dataLabels, function (label) {
		                if (label.element) {
		                    label.destroy();
		                }
		            });
		            delete point.dataLabels;
		        }
		        if (point.connectors) {
		            each(point.connectors, function (connector) {
		                if (connector.element) {
		                    connector.destroy();
		                }
		            });
		            delete point.connectors;
		        }
		    },

		    /**
		     * Return the configuration hash needed for the data label and tooltip
		     * formatters.
		     *
		     * @function Highcharts.Point#getLabelConfig
		     *
		     * @return {Highcharts.PointLabelObject}
		     *         Abstract object used in formatters and formats.
		     */
		    getLabelConfig: function () {
		        return {
		            x: this.category,
		            y: this.y,
		            color: this.color,
		            colorIndex: this.colorIndex,
		            key: this.name || this.category,
		            series: this.series,
		            point: this,
		            percentage: this.percentage,
		            total: this.total || this.stackTotal
		        };
		    },

		    /**
		     * Extendable method for formatting each point's tooltip line.
		     *
		     * @function Highcharts.Point#tooltipFormatter
		     *
		     * @param {string} pointFormat
		     *        The point format.
		     *
		     * @return {string}
		     *         A string to be concatenated in to the common tooltip text.
		     */
		    tooltipFormatter: function (pointFormat) {

		        // Insert options for valueDecimals, valuePrefix, and valueSuffix
		        var series = this.series,
		            seriesTooltipOptions = series.tooltipOptions,
		            valueDecimals = pick(seriesTooltipOptions.valueDecimals, ''),
		            valuePrefix = seriesTooltipOptions.valuePrefix || '',
		            valueSuffix = seriesTooltipOptions.valueSuffix || '';

		        // Loop over the point array map and replace unformatted values with
		        // sprintf formatting markup
		        each(series.pointArrayMap || ['y'], function (key) {
		            key = '{point.' + key; // without the closing bracket
		            if (valuePrefix || valueSuffix) {
		                pointFormat = pointFormat.replace(
		                    RegExp(key + '}', 'g'),
		                    valuePrefix + key + '}' + valueSuffix
		                );
		            }
		            pointFormat = pointFormat.replace(
		                RegExp(key + '}', 'g'),
		                key + ':,.' + valueDecimals + 'f}'
		            );
		        });

		        return format(pointFormat, {
		            point: this,
		            series: this.series
		        }, series.chart.time);
		    },

		    /**
		     * Fire an event on the Point object.
		     *
		     * @private
		     * @function Highcharts.Point#firePointEvent
		     *
		     * @param {string} eventType
		     *        Type of the event.
		     *
		     * @param {*} eventArgs
		     *        Additional event arguments.
		     *
		     * @param {Function} defaultFunction
		     *        Default event handler.
		     *
		     * @fires Highcharts.Point#event:*
		     */
		    firePointEvent: function (eventType, eventArgs, defaultFunction) {
		        var point = this,
		            series = this.series,
		            seriesOptions = series.options;

		        // load event handlers on demand to save time on mouseover/out
		        if (
		            seriesOptions.point.events[eventType] ||
		            (
		                point.options &&
		                point.options.events &&
		                point.options.events[eventType]
		            )
		        ) {
		            this.importEvents();
		        }

		        // add default handler if in selection mode
		        if (eventType === 'click' && seriesOptions.allowPointSelect) {
		            defaultFunction = function (event) {
		                // Control key is for Windows, meta (= Cmd key) for Mac, Shift
		                // for Opera.
		                if (point.select) { // #2911
		                    point.select(
		                        null,
		                        event.ctrlKey || event.metaKey || event.shiftKey
		                    );
		                }
		            };
		        }

		        fireEvent(this, eventType, eventArgs, defaultFunction);
		    },

		    /**
		     * For certain series types, like pie charts, where individual points can
		     * be shown or hidden.
		     *
		     * @name Highcharts.Point#visible
		     * @type {boolean}
		     */
		    visible: true
		};

		/**
		 * For categorized axes this property holds the category name for the
		 * point. For other axes it holds the X value.
		 *
		 * @name Highcharts.Point#category
		 * @type {number|string}
		 */

		/**
		 * The name of the point. The name can be given as the first position of the
		 * point configuration array, or as a `name` property in the configuration:
		 *
		 * @example
		 * // Array config
		 * data: [
		 *     ['John', 1],
		 *     ['Jane', 2]
		 * ]
		 *
		 * // Object config
		 * data: [{
		 *        name: 'John',
		 *        y: 1
		 * }, {
		 *     name: 'Jane',
		 *     y: 2
		 * }]
		 *
		 * @name Highcharts.Point#name
		 * @type {string}
		 */


		/**
		 * The percentage for points in a stacked series or pies.
		 *
		 * @name Highcharts.Point#percentage
		 * @type {number}
		 */

		/**
		 * The total of values in either a stack for stacked series, or a pie in a pie
		 * series.
		 *
		 * @name Highcharts.Point#total
		 * @type {number}
		 */

	}(Highcharts));
	(function (H) {
		/**
		 * (c) 2010-2018 Torstein Honsi
		 *
		 * License: www.highcharts.com/license
		 */

		/**
		 * Translation and scale for the plot area of a series.
		 *
		 * @typedef Highcharts.SeriesPlotBoxObject
		 *
		 * @property {number} translateX
		 *
		 * @property {number} translateY
		 *
		 * @property {number} scaleX
		 *
		 * @property {number} scaleY
		 */



		var addEvent = H.addEvent,
		    animObject = H.animObject,
		    arrayMax = H.arrayMax,
		    arrayMin = H.arrayMin,
		    correctFloat = H.correctFloat,
		    defaultOptions = H.defaultOptions,
		    defaultPlotOptions = H.defaultPlotOptions,
		    defined = H.defined,
		    each = H.each,
		    erase = H.erase,
		    extend = H.extend,
		    fireEvent = H.fireEvent,
		    grep = H.grep,
		    isArray = H.isArray,
		    isNumber = H.isNumber,
		    isString = H.isString,
		    LegendSymbolMixin = H.LegendSymbolMixin, // @todo add as a requirement
		    merge = H.merge,
		    objectEach = H.objectEach,
		    pick = H.pick,
		    Point = H.Point, // @todo  add as a requirement
		    removeEvent = H.removeEvent,
		    splat = H.splat,
		    SVGElement = H.SVGElement,
		    syncTimeout = H.syncTimeout,
		    win = H.win;

		/**
		 * This is the base series prototype that all other series types inherit from.
		 * A new series is initialized either through the
		 * {@link https://api.highcharts.com/highcharts/series|series}
		 * option structure, or after the chart is initialized, through
		 * {@link Highcharts.Chart#addSeries}.
		 *
		 * The object can be accessed in a number of ways. All series and point event
		 * handlers give a reference to the `series` object. The chart object has a
		 * {@link Highcharts.Chart.series|series} property that is a collection of all
		 * the chart's series. The point objects and axis objects also have the same
		 * reference.
		 *
		 * Another way to reference the series programmatically is by `id`. Add an id
		 * in the series configuration options, and get the series object by
		 * {@link Highcharts.Chart#get}.
		 *
		 * Configuration options for the series are given in three levels. Options for
		 * all series in a chart are given in the
		 * {@link https://api.highcharts.com/highcharts/plotOptions.series|
		 * plotOptions.series} object. Then options for all series of a specific type
		 * are given in the plotOptions of that type, for example `plotOptions.line`.
		 * Next, options for one single series are given in the series array, or as
		 * arguements to `chart.addSeries`.
		 *
		 * The data in the series is stored in various arrays.
		 *
		 * - First, `series.options.data` contains all the original config options for
		 *   each point whether added by options or methods like `series.addPoint`.
		 *
		 * - Next, `series.data` contains those values converted to points, but in case
		 *   the series data length exceeds the `cropThreshold`, or if the data is
		 *   grouped, `series.data` doesn't contain all the points. It only contains the
		 *   points that have been created on demand.
		 *
		 * - Then there's `series.points` that contains all currently visible point
		 *   objects. In case of cropping, the cropped-away points are not part of this
		 *   array. The `series.points` array starts at `series.cropStart` compared to
		 *   `series.data` and `series.options.data`. If however the series data is
		 *   grouped, these can't be correlated one to one.
		 *
		 * - `series.xData` and `series.processedXData` contain clean x values,
		 *   equivalent to `series.data` and `series.points`.
		 *
		 * - `series.yData` and `series.processedYData` contain clean y values,
		 *   equivalent to `series.data` and `series.points`.
		 *
		 * @class
		 * @name Highcharts.Series
		 *
		 * @param {Highcharts.Chart} chart
		 *        The chart instance.
		 *
		 * @param {Highcharts.PlotSeriesOptions} options
		 *        The series options.
		 *//**
		 * The line series is the base type and is therefor the series base prototype.
		 *
		 * @private
		 * @class
		 * @name Highcharts.seriesTypes.line
		 *
		 * @augments Highcharts.Series
		 */
		H.Series = H.seriesType('line', null

		/**
		 * General options for all series types.
		 *
		 * @optionparent plotOptions.series
		 */
		, { // base series options



		    /**
		     * Pixel width of the graph line.
		     *
		     * @see In styled mode, the line stroke-width can be set with the
		     *      `.highcharts-graph` class name.
		     *
		     * @sample {highcharts} highcharts/plotoptions/series-linewidth-general/
		     *         On all series
		     * @sample {highcharts} highcharts/plotoptions/series-linewidth-specific/
		     *         On one single series
		     *
		     * @product highcharts highstock
		     */
		    lineWidth: 2,



		    /**
		     * For some series, there is a limit that shuts down initial animation
		     * by default when the total number of points in the chart is too high.
		     * For example, for a column chart and its derivatives, animation doesn't
		     * run if there is more than 250 points totally. To disable this cap, set
		     * `animationLimit` to `Infinity`.
		     *
		     * @type      {number}
		     * @apioption plotOptions.series.animationLimit
		     */

		    /**
		     * Allow this series' points to be selected by clicking on the graphic
		     * (columns, point markers, pie slices, map areas etc).
		     *
		     * @see {@link Highcharts.Chart#getSelectedPoints}.
		     *
		     * @sample {highcharts} highcharts/plotoptions/series-allowpointselect-line/
		     *         Line
		     * @sample {highcharts} highcharts/plotoptions/series-allowpointselect-column/
		     *         Column
		     * @sample {highcharts} highcharts/plotoptions/series-allowpointselect-pie/
		     *         Pie
		     * @sample {highmaps} maps/plotoptions/series-allowpointselect/
		     *         Map area
		     * @sample {highmaps} maps/plotoptions/mapbubble-allowpointselect/
		     *         Map bubble
		     *
		     * @since 1.2.0
		     */
		    allowPointSelect: false,

		    /**
		     * If true, a checkbox is displayed next to the legend item to allow
		     * selecting the series. The state of the checkbox is determined by
		     * the `selected` option.
		     *
		     * @productdesc {highmaps}
		     * Note that if a `colorAxis` is defined, the color axis is represented in
		     * the legend, not the series.
		     *
		     * @sample {highcharts} highcharts/plotoptions/series-showcheckbox-true/
		     *         Show select box
		     *
		     * @since 1.2.0
		     */
		    showCheckbox: false,

		    /**
		     * Enable or disable the initial animation when a series is displayed.
		     * The animation can also be set as a configuration object. Please
		     * note that this option only applies to the initial animation of the
		     * series itself. For other animations, see [chart.animation](
		     * #chart.animation) and the animation parameter under the API methods. The
		     * following properties are supported:
		     *
		     * <dl>
		     *
		     * <dt>duration</dt>
		     *
		     * <dd>The duration of the animation in milliseconds.</dd>
		     *
		     * <dt>easing</dt>
		     *
		     * <dd>Can be a string reference to an easing function set on the `Math`
		     * object or a function. See the _Custom easing function_ demo below.</dd>
		     *
		     * </dl>
		     *
		     * Due to poor performance, animation is disabled in old IE browsers
		     * for several chart types.
		     *
		     * @sample {highcharts} highcharts/plotoptions/series-animation-disabled/
		     *         Animation disabled
		     * @sample {highcharts} highcharts/plotoptions/series-animation-slower/
		     *         Slower animation
		     * @sample {highcharts} highcharts/plotoptions/series-animation-easing/
		     *         Custom easing function
		     * @sample {highstock} stock/plotoptions/animation-slower/
		     *         Slower animation
		     * @sample {highstock} stock/plotoptions/animation-easing/
		     *         Custom easing function
		     * @sample {highmaps} maps/plotoptions/series-animation-true/
		     *         Animation enabled on map series
		     * @sample {highmaps} maps/plotoptions/mapbubble-animation-false/
		     *         Disabled on mapbubble series
		     *
		     * @type    {boolean|Highcharts.AnimationOptionsObject}
		     * @default {highcharts} true
		     * @default {highstock} true
		     * @default {highmaps} false
		     */
		    animation: {

		        /**
		         * @type      {number}
		         * @default   1000
		         * @apioption plotOptions.series.animation.duration
		         */
		        duration: 1000
		    },

		    /**
		     * An additional class name to apply to the series' graphical elements. This
		     * option does not replace default class names of the graphical element.
		     *
		     * @type      {string}
		     * @since     5.0.0
		     * @apioption plotOptions.series.className
		     */

		    /**
		     * Disable this option to allow series rendering in the whole plotting
		     * area.
		     *
		     * **Note:** Clipping should be always enabled when
		     * [chart.zoomType](#chart.zoomType) is set
		     *
		     * @sample {highcharts} highcharts/plotoptions/series-clip/
		     *         Disabled clipping
		     *
		     * @default   true
		     * @type      {boolean}
		     * @since     3.0.0
		     * @apioption plotOptions.series.clip
		     */

		    /**
		     * The main color of the series. In line type series it applies to the
		     * line and the point markers unless otherwise specified. In bar type
		     * series it applies to the bars unless a color is specified per point.
		     * The default value is pulled from the `options.colors` array.
		     *
		     * In styled mode, the color can be defined by the
		     * [colorIndex](#plotOptions.series.colorIndex) option. Also, the series
		     * color can be set with the `.highcharts-series`, `.highcharts-color-{n}`,
		     * `.highcharts-{type}-series` or `.highcharts-series-{n}` class, or
		     * individual classes given by the `className` option.
		     *
		     * @productdesc {highmaps}
		     * In maps, the series color is rarely used, as most choropleth maps use the
		     * color to denote the value of each point. The series color can however be
		     * used in a map with multiple series holding categorized data.
		     *
		     * @sample {highcharts} highcharts/plotoptions/series-color-general/
		     *         General plot option
		     * @sample {highcharts} highcharts/plotoptions/series-color-specific/
		     *         One specific series
		     * @sample {highcharts} highcharts/plotoptions/series-color-area/
		     *         Area color
		     * @sample {highcharts} highcharts/series/infographic/
		     *         Pattern fill
		     * @sample {highmaps} maps/demo/category-map/
		     *         Category map by multiple series
		     *
		     * @type      {Highcharts.ColorString}
		     * @apioption plotOptions.series.color
		     */

		    /**
		     * Styled mode only. A specific color index to use for the series, so its
		     * graphic representations are given the class name `highcharts-color-{n}`.
		     *
		     * @type      {number}
		     * @since     5.0.0
		     * @apioption plotOptions.series.colorIndex
		     */


		    /**
		     * Whether to connect a graph line across null points, or render a gap
		     * between the two points on either side of the null.
		     *
		     * @sample {highcharts} highcharts/plotoptions/series-connectnulls-false/
		     *         False by default
		     * @sample {highcharts} highcharts/plotoptions/series-connectnulls-true/
		     *         True
		     *
		     * @type      {boolean}
		     * @default   false
		     * @product   highcharts highstock
		     * @apioption plotOptions.series.connectNulls
		     */


		    /**
		     * You can set the cursor to "pointer" if you have click events attached
		     * to the series, to signal to the user that the points and lines can
		     * be clicked.
		     *
		     * In styled mode, the series cursor can be set with the same classes
		     * as listed under [series.color](#plotOptions.series.color).
		     *
		     * @sample {highcharts} highcharts/plotoptions/series-cursor-line/
		     *         On line graph
		     * @sample {highcharts} highcharts/plotoptions/series-cursor-column/
		     *         On columns
		     * @sample {highcharts} highcharts/plotoptions/series-cursor-scatter/
		     *         On scatter markers
		     * @sample {highstock} stock/plotoptions/cursor/
		     *         Pointer on a line graph
		     * @sample {highmaps} maps/plotoptions/series-allowpointselect/
		     *         Map area
		     * @sample {highmaps} maps/plotoptions/mapbubble-allowpointselect/
		     *         Map bubble
		     *
		     * @type       {string}
		     * @validvalue ["crosshair","default","help","none","pointer"]
		     * @apioption  plotOptions.series.cursor
		     */


		    /**
		     * A name for the dash style to use for the graph, or for some series types
		     * the outline of each shape.
		     *
		     * In styled mode, the [stroke dash-array](https://jsfiddle.net/gh/get/
		     * library/pure/highcharts/highcharts/tree/master/samples/highcharts/css/
		     * series-dashstyle/) can be set with the same classes as listed under
		     * [series.color](#plotOptions.series.color).
		     *
		     * @sample {highcharts} highcharts/plotoptions/series-dashstyle-all/
		     *         Possible values demonstrated
		     * @sample {highcharts} highcharts/plotoptions/series-dashstyle/
		     *         Chart suitable for printing in black and white
		     * @sample {highstock} highcharts/plotoptions/series-dashstyle-all/
		     *         Possible values demonstrated
		     * @sample {highmaps} highcharts/plotoptions/series-dashstyle-all/
		     *         Possible values demonstrated
		     * @sample {highmaps} maps/plotoptions/series-dashstyle/
		     *         Dotted borders on a map
		     *
		     * @type       {string}
		     * @default    Solid
		     * @since      2.1
		     * @validvalue ["Dash","DashDot","Dot","LongDash","LongDashDot",
		     *             "LongDashDotDot","ShortDash","ShortDashDot",
		     *             "ShortDashDotDot","ShortDot","Solid"]
		     * @apioption  plotOptions.series.dashStyle
		     */

		    /**
		     * Requires the Accessibility module.
		     *
		     * A description of the series to add to the screen reader information
		     * about the series.
		     *
		     * @type      {string}
		     * @since     5.0.0
		     * @apioption plotOptions.series.description
		     */

		    /**
		     * Enable or disable the mouse tracking for a specific series. This
		     * includes point tooltips and click events on graphs and points. For
		     * large datasets it improves performance.
		     *
		     * @sample {highcharts} highcharts/plotoptions/series-enablemousetracking-false/
		     *         No mouse tracking
		     * @sample {highmaps} maps/plotoptions/series-enablemousetracking-false/
		     *         No mouse tracking
		     *
		     * @type      {boolean}
		     * @default   true
		     * @apioption plotOptions.series.enableMouseTracking
		     */

		    /**
		     * By default, series are exposed to screen readers as regions. By enabling
		     * this option, the series element itself will be exposed in the same
		     * way as the data points. This is useful if the series is not used
		     * as a grouping entity in the chart, but you still want to attach a
		     * description to the series.
		     *
		     * Requires the Accessibility module.
		     *
		     * @sample highcharts/accessibility/art-grants/
		     *         Accessible data visualization
		     *
		     * @type      {boolean}
		     * @since     5.0.12
		     * @apioption plotOptions.series.exposeElementToA11y
		     */

		    /**
		     * Whether to use the Y extremes of the total chart width or only the
		     * zoomed area when zooming in on parts of the X axis. By default, the
		     * Y axis adjusts to the min and max of the visible data. Cartesian
		     * series only.
		     *
		     * @type      {boolean}
		     * @default   false
		     * @since     4.1.6
		     * @product   highcharts highstock gantt
		     * @apioption plotOptions.series.getExtremesFromAll
		     */

		    /**
		     * An array specifying which option maps to which key in the data point
		     * array. This makes it convenient to work with unstructured data arrays
		     * from different sources.
		     *
		     * @see [series.data](#series.line.data)
		     *
		     * @sample {highcharts|highstock} highcharts/series/data-keys/
		     *         An extended data array with keys
		     * @sample {highcharts|highstock} highcharts/series/data-nested-keys/
		     *         Nested keys used to access object properties
		     *
		     * @type      {Array<string>}
		     * @since     4.1.6
		     * @apioption plotOptions.series.keys
		     */

		    /**
		     * The line cap used for line ends and line joins on the graph.
		     *
		     * @type       {string}
		     * @default    round
		     * @product    highcharts highstock
		     * @validvalue ["round", "square"]
		     * @apioption  plotOptions.series.linecap
		     */

		    /**
		     * The [id](#series.id) of another series to link to. Additionally,
		     * the value can be ":previous" to link to the previous series. When
		     * two series are linked, only the first one appears in the legend.
		     * Toggling the visibility of this also toggles the linked series.
		     *
		     * @sample {highcharts|highstock} highcharts/demo/arearange-line/
		     *         Linked series
		     *
		     * @type      {string}
		     * @since     3.0
		     * @product   highcharts highstock gantt
		     * @apioption plotOptions.series.linkedTo
		     */

		    /**
		     * Options for the corresponding navigator series if `showInNavigator`
		     * is `true` for this series. Available options are the same as any
		     * series, documented at [plotOptions](#plotOptions.series) and
		     * [series](#series).
		     *
		     * These options are merged with options in [navigator.series](
		     * #navigator.series), and will take precedence if the same option is
		     * defined both places.
		     *
		     * @see [navigator.series](#navigator.series)
		     *
		     * @type      {*}
		     * @since     5.0.0
		     * @product   highstock
		     * @apioption plotOptions.series.navigatorOptions
		     */

		    /**
		     * The color for the parts of the graph or points that are below the
		     * [threshold](#plotOptions.series.threshold).
		     *
		     * @see In styled mode, a negative color is applied by setting this option
		     *      to `true` combined with the `.highcharts-negative` class name.
		     *
		     * @sample {highcharts} highcharts/plotoptions/series-negative-color/
		     *         Spline, area and column
		     * @sample {highcharts} highcharts/plotoptions/arearange-negativecolor/
		     *         Arearange
		     * @sample {highcharts} highcharts/css/series-negative-color/
		     *         Styled mode
		     * @sample {highstock} highcharts/plotoptions/series-negative-color/
		     *         Spline, area and column
		     * @sample {highstock} highcharts/plotoptions/arearange-negativecolor/
		     *         Arearange
		     * @sample {highmaps} highcharts/plotoptions/series-negative-color/
		     *         Spline, area and column
		     * @sample {highmaps} highcharts/plotoptions/arearange-negativecolor/
		     *         Arearange
		     *
		     * @type      {Highcharts.ColorString}
		     * @since     3.0
		     * @apioption plotOptions.series.negativeColor
		     */

		    /**
		     * Same as [accessibility.pointDescriptionFormatter](
		     * #accessibility.pointDescriptionFormatter), but for an individual series.
		     * Overrides the chart wide configuration.
		     *
		     * @type      {Function}
		     * @since     5.0.12
		     * @apioption plotOptions.series.pointDescriptionFormatter
		     */

		    /**
		     * If no x values are given for the points in a series, `pointInterval`
		     * defines the interval of the x values. For example, if a series contains
		     * one value every decade starting from year 0, set `pointInterval` to
		     * `10`. In true `datetime` axes, the `pointInterval` is set in
		     * milliseconds.
		     *
		     * It can be also be combined with `pointIntervalUnit` to draw irregular
		     * time intervals.
		     *
		     * Please note that this options applies to the _series data_, not the
		     * interval of the axis ticks, which is independent.
		     *
		     * @sample {highcharts} highcharts/plotoptions/series-pointstart-datetime/
		     *         Datetime X axis
		     * @sample {highstock} stock/plotoptions/pointinterval-pointstart/
		     *         Using pointStart and pointInterval
		     *
		     * @type      {number}
		     * @default   1
		     * @product   highcharts highstock gantt
		     * @apioption plotOptions.series.pointInterval
		     */

		    /**
		     * On datetime series, this allows for setting the
		     * [pointInterval](#plotOptions.series.pointInterval) to irregular time
		     * units, `day`, `month` and `year`. A day is usually the same as 24 hours,
		     * but `pointIntervalUnit` also takes the DST crossover into consideration
		     * when dealing with local time. Combine this option with `pointInterval`
		     * to draw weeks, quarters, 6 months, 10 years etc.
		     *
		     * Please note that this options applies to the _series data_, not the
		     * interval of the axis ticks, which is independent.
		     *
		     * @sample {highcharts} highcharts/plotoptions/series-pointintervalunit/
		     *         One point a month
		     * @sample {highstock} highcharts/plotoptions/series-pointintervalunit/
		     *         One point a month
		     *
		     * @type       {string}
		     * @since      4.1.0
		     * @product    highcharts highstock gantt
		     * @validvalue ["day", "month", "year"]
		     * @apioption  plotOptions.series.pointIntervalUnit
		     */

		    /**
		     * Possible values: `"on"`, `"between"`, `number`.
		     *
		     * In a column chart, when pointPlacement is `"on"`, the point will
		     * not create any padding of the X axis. In a polar column chart this
		     * means that the first column points directly north. If the pointPlacement
		     * is `"between"`, the columns will be laid out between ticks. This
		     * is useful for example for visualising an amount between two points
		     * in time or in a certain sector of a polar chart.
		     *
		     * Since Highcharts 3.0.2, the point placement can also be numeric,
		     * where 0 is on the axis value, -0.5 is between this value and the
		     * previous, and 0.5 is between this value and the next. Unlike the
		     * textual options, numeric point placement options won't affect axis
		     * padding.
		     *
		     * Note that pointPlacement needs a [pointRange](
		     * #plotOptions.series.pointRange) to work. For column series this is
		     * computed, but for line-type series it needs to be set.
		     *
		     * For the `xrange` series type and gantt charts, if the Y axis is a
		     * category axis, the `pointPlacement` applies to the Y axis rather than
		     * the (typically datetime) X axis.
		     *
		     * Defaults to `undefined` in cartesian charts, `"between"` in polar charts.
		     *
		     * @see [xAxis.tickmarkPlacement](#xAxis.tickmarkPlacement)
		     *
		     * @sample {highcharts|highstock} highcharts/plotoptions/series-pointplacement-between/
		     *         Between in a column chart
		     * @sample {highcharts|highstock} highcharts/plotoptions/series-pointplacement-numeric/
		     *         Numeric placement for custom layout
		     *
		     * @type      {string|number}
		     * @since     2.3.0
		     * @product   highcharts highstock gantt
		     * @apioption plotOptions.series.pointPlacement
		     */

		    /**
		     * If no x values are given for the points in a series, pointStart defines
		     * on what value to start. For example, if a series contains one yearly
		     * value starting from 1945, set pointStart to 1945.
		     *
		     * @sample {highcharts} highcharts/plotoptions/series-pointstart-linear/
		     *         Linear
		     * @sample {highcharts} highcharts/plotoptions/series-pointstart-datetime/
		     *         Datetime
		     * @sample {highstock} stock/plotoptions/pointinterval-pointstart/
		     *         Using pointStart and pointInterval
		     *
		     * @type      {number}
		     * @default   0
		     * @product   highcharts highstock gantt
		     * @apioption plotOptions.series.pointStart
		     */

		    /**
		     * Whether to select the series initially. If `showCheckbox` is true,
		     * the checkbox next to the series name in the legend will be checked for a
		     * selected series.
		     *
		     * @sample {highcharts} highcharts/plotoptions/series-selected/
		     *         One out of two series selected
		     *
		     * @type      {boolean}
		     * @default   false
		     * @since     1.2.0
		     * @apioption plotOptions.series.selected
		     */

		    /**
		     * Whether to apply a drop shadow to the graph line. Since 2.3 the shadow
		     * can be an object configuration containing `color`, `offsetX`, `offsetY`,
		     * `opacity` and `width`.
		     *
		     * @sample {highcharts} highcharts/plotoptions/series-shadow/
		     *         Shadow enabled
		     *
		     * @type      {boolean|Highcharts.ShadowOptionsObject}
		     * @default   false
		     * @apioption plotOptions.series.shadow
		     */

		    /**
		     * Whether to display this particular series or series type in the legend.
		     * The default value is `true` for standalone series, `false` for linked
		     * series.
		     *
		     * @sample {highcharts} highcharts/plotoptions/series-showinlegend/
		     *         One series in the legend, one hidden
		     *
		     * @type      {boolean}
		     * @default   true
		     * @apioption plotOptions.series.showInLegend
		     */

		    /**
		     * Whether or not to show the series in the navigator. Takes precedence
		     * over [navigator.baseSeries](#navigator.baseSeries) if defined.
		     *
		     * @type      {boolean}
		     * @since     5.0.0
		     * @product   highstock
		     * @apioption plotOptions.series.showInNavigator
		     */

		    /**
		     * If set to `true`, the accessibility module will skip past the points
		     * in this series for keyboard navigation.
		     *
		     * @type      {boolean}
		     * @since     5.0.12
		     * @apioption plotOptions.series.skipKeyboardNavigation
		     */

		    /**
		     * Whether to stack the values of each series on top of each other. Possible
		     * values are `undefined` to disable, `"normal"` to stack by value or
		     * `"percent"`. When stacking is enabled, data must be sorted in ascending
		     * X order. A special stacking option is with the streamgraph series type,
		     * where the stacking option is set to `"stream"`.
		     *
		     * @see [yAxis.reversedStacks](#yAxis.reversedStacks)
		     *
		     * @sample {highcharts} highcharts/plotoptions/series-stacking-line/
		     *         Line
		     * @sample {highcharts} highcharts/plotoptions/series-stacking-column/
		     *         Column
		     * @sample {highcharts} highcharts/plotoptions/series-stacking-bar/
		     *         Bar
		     * @sample {highcharts} highcharts/plotoptions/series-stacking-area/
		     *         Area
		     * @sample {highcharts} highcharts/plotoptions/series-stacking-percent-line/
		     *         Line
		     * @sample {highcharts} highcharts/plotoptions/series-stacking-percent-column/
		     *         Column
		     * @sample {highcharts} highcharts/plotoptions/series-stacking-percent-bar/
		     *         Bar
		     * @sample {highcharts} highcharts/plotoptions/series-stacking-percent-area/
		     *         Area
		     * @sample {highstock} stock/plotoptions/stacking/
		     *         Area
		     *
		     * @type       {string}
		     * @product    highcharts highstock
		     * @validvalue ["normal", "percent"]
		     * @apioption  plotOptions.series.stacking
		     */

		    /**
		     * Whether to apply steps to the line. Possible values are `left`, `center`
		     * and `right`.
		     *
		     * @sample {highcharts} highcharts/plotoptions/line-step/
		     *         Different step line options
		     * @sample {highcharts} highcharts/plotoptions/area-step/
		     *         Stepped, stacked area
		     * @sample {highstock} stock/plotoptions/line-step/
		     *         Step line
		     *
		     * @type       {string}
		     * @since      1.2.5
		     * @product    highcharts highstock
		     * @validvalue ["left", "center", "right"]
		     * @apioption  plotOptions.series.step
		     */

		    /**
		     * The threshold, also called zero level or base level. For line type
		     * series this is only used in conjunction with
		     * [negativeColor](#plotOptions.series.negativeColor).
		     *
		     * @see [softThreshold](#plotOptions.series.softThreshold).
		     *
		     * @type      {number}
		     * @default   0
		     * @since     3.0
		     * @product   highcharts highstock
		     * @apioption plotOptions.series.threshold
		     */

		    /**
		     * Set the initial visibility of the series.
		     *
		     * @sample {highcharts} highcharts/plotoptions/series-visible/
		     *         Two series, one hidden and one visible
		     * @sample {highstock} stock/plotoptions/series-visibility/
		     *         Hidden series
		     *
		     * @type      {boolean}
		     * @default   true
		     * @apioption plotOptions.series.visible
		     */

		    /**
		     * Defines the Axis on which the zones are applied.
		     *
		     * @see [zones](#plotOptions.series.zones)
		     *
		     * @sample {highcharts} highcharts/series/color-zones-zoneaxis-x/
		     *         Zones on the X-Axis
		     * @sample {highstock} highcharts/series/color-zones-zoneaxis-x/
		     *         Zones on the X-Axis
		     *
		     * @type      {string}
		     * @default   y
		     * @since     4.1.0
		     * @product   highcharts highstock
		     * @apioption plotOptions.series.zoneAxis
		     */

		    /**
		     * General event handlers for the series items. These event hooks can also
		     * be attached to the series at run time using the `Highcharts.addEvent`
		     * function.
		     */
		    events: {},

		    /**
		     * Fires after the series has finished its initial animation, or in
		     * case animation is disabled, immediately as the series is displayed.
		     *
		     * @sample {highcharts} highcharts/plotoptions/series-events-afteranimate/
		     *         Show label after animate
		     * @sample {highstock} highcharts/plotoptions/series-events-afteranimate/
		     *         Show label after animate
		     *
		     * @type      {Function}
		     * @since     4.0
		     * @product   highcharts highstock
		     * @context   Series
		     * @apioption plotOptions.series.events.afterAnimate
		     */

		    /**
		     * Fires when the checkbox next to the series' name in the legend is
		     * clicked. One parameter, `event`, is passed to the function. The state
		     * of the checkbox is found by `event.checked`. The checked item is
		     * found by `event.item`. Return `false` to prevent the default action
		     * which is to toggle the select state of the series.
		     *
		     * @sample {highcharts} highcharts/plotoptions/series-events-checkboxclick/
		     *         Alert checkbox status
		     *
		     * @type      {Function}
		     * @since     1.2.0
		     * @context   Series
		     * @apioption plotOptions.series.events.checkboxClick
		     */

		    /**
		     * Fires when the series is clicked. One parameter, `event`, is passed to
		     * the function, containing common event information. Additionally,
		     * `event.point` holds a pointer to the nearest point on the graph.
		     *
		     * @sample {highcharts} highcharts/plotoptions/series-events-click/
		     *         Alert click info
		     * @sample {highstock} stock/plotoptions/series-events-click/
		     *         Alert click info
		     * @sample {highmaps} maps/plotoptions/series-events-click/
		     *         Display click info in subtitle
		     *
		     * @type      {Function}
		     * @context   Series
		     * @apioption plotOptions.series.events.click
		     */

		    /**
		     * Fires when the series is hidden after chart generation time, either
		     * by clicking the legend item or by calling `.hide()`.
		     *
		     * @sample {highcharts} highcharts/plotoptions/series-events-hide/
		     *         Alert when the series is hidden by clicking the legend item
		     *
		     * @type      {Function}
		     * @since     1.2.0
		     * @context   Series
		     * @apioption plotOptions.series.events.hide
		     */

		    /**
		     * Fires when the legend item belonging to the series is clicked. One
		     * parameter, `event`, is passed to the function. The default action
		     * is to toggle the visibility of the series. This can be prevented
		     * by returning `false` or calling `event.preventDefault()`.
		     *
		     * @sample {highcharts} highcharts/plotoptions/series-events-legenditemclick/
		     *         Confirm hiding and showing
		     *
		     * @type      {Function}
		     * @context   Series
		     * @apioption plotOptions.series.events.legendItemClick
		     */

		    /**
		     * Fires when the mouse leaves the graph. One parameter, `event`, is
		     * passed to the function, containing common event information. If the
		     * [stickyTracking](#plotOptions.series) option is true, `mouseOut`
		     * doesn't happen before the mouse enters another graph or leaves the
		     * plot area.
		     *
		     * @sample {highcharts} highcharts/plotoptions/series-events-mouseover-sticky/
		     *         With sticky tracking by default
		     * @sample {highcharts} highcharts/plotoptions/series-events-mouseover-no-sticky/
		     *         Without sticky tracking
		     *
		     * @type      {Function}
		     * @context   Series
		     * @apioption plotOptions.series.events.mouseOut
		     */

		    /**
		     * Fires when the mouse enters the graph. One parameter, `event`, is
		     * passed to the function, containing common event information.
		     *
		     * @sample {highcharts} highcharts/plotoptions/series-events-mouseover-sticky/
		     *         With sticky tracking by default
		     * @sample {highcharts} highcharts/plotoptions/series-events-mouseover-no-sticky/
		     *         Without sticky tracking
		     *
		     * @type      {Function}
		     * @context   Series
		     * @apioption plotOptions.series.events.mouseOver
		     */

		    /**
		     * Fires when the series is shown after chart generation time, either
		     * by clicking the legend item or by calling `.show()`.
		     *
		     * @sample {highcharts} highcharts/plotoptions/series-events-show/
		     *         Alert when the series is shown by clicking the legend item.
		     *
		     * @type      {Function}
		     * @since     1.2.0
		     * @context   Series
		     * @apioption plotOptions.series.events.show
		     */

		    /**
		     * Options for the point markers of line-like series. Properties like
		     * `fillColor`, `lineColor` and `lineWidth` define the visual appearance
		     * of the markers. Other series types, like column series, don't have
		     * markers, but have visual options on the series level instead.
		     *
		     * In styled mode, the markers can be styled with the `.highcharts-point`,
		     * `.highcharts-point-hover` and `.highcharts-point-select`
		     * class names.
		     */
		    marker: {



		        /**
		         * The width of the point marker's outline.
		         *
		         * @sample {highcharts} highcharts/plotoptions/series-marker-fillcolor/
		         *         2px blue marker
		         */
		        lineWidth: 0,

		        /**
		         * The color of the point marker's outline. When `undefined`, the
		         * series' or point's color is used.
		         *
		         * @sample {highcharts} highcharts/plotoptions/series-marker-fillcolor/
		         *         Inherit from series color (undefined)
		         *
		         * @type {Highcharts.ColorString}
		         */
		        lineColor: '#ffffff',

		        /**
		         * The fill color of the point marker. When `undefined`, the series' or
		         * point's color is used.
		         *
		         * @sample {highcharts} highcharts/plotoptions/series-marker-fillcolor/
		         *         White fill
		         *
		         * @type      {Highcharts.ColorString}
		         * @apioption plotOptions.series.marker.fillColor
		         */



		        /**
		         * Enable or disable the point marker. If `undefined`, the markers are
		         * hidden when the data is dense, and shown for more widespread data
		         * points.
		         *
		         * @sample {highcharts} highcharts/plotoptions/series-marker-enabled/
		         *         Disabled markers
		         * @sample {highcharts} highcharts/plotoptions/series-marker-enabled-false/
		         *         Disabled in normal state but enabled on hover
		         * @sample {highstock} stock/plotoptions/series-marker/
		         *         Enabled markers
		         *
		         * @type      {boolean}
		         * @default   {highcharts} undefined
		         * @default   {highstock} false
		         * @apioption plotOptions.series.marker.enabled
		         */

		        /**
		         * Image markers only. Set the image width explicitly. When using this
		         * option, a `width` must also be set.
		         *
		         * @sample {highcharts} highcharts/plotoptions/series-marker-width-height/
		         *         Fixed width and height
		         * @sample {highstock} highcharts/plotoptions/series-marker-width-height/
		         *         Fixed width and height
		         *
		         * @type      {number}
		         * @since     4.0.4
		         * @apioption plotOptions.series.marker.height
		         */

		        /**
		         * A predefined shape or symbol for the marker. When undefined, the
		         * symbol is pulled from options.symbols. Other possible values are
		         * "circle", "square", "diamond", "triangle" and "triangle-down".
		         *
		         * Additionally, the URL to a graphic can be given on this form:
		         * "url(graphic.png)". Note that for the image to be applied to exported
		         * charts, its URL needs to be accessible by the export server.
		         *
		         * Custom callbacks for symbol path generation can also be added to
		         * `Highcharts.SVGRenderer.prototype.symbols`. The callback is then
		         * used by its method name, as shown in the demo.
		         *
		         * @sample {highcharts} highcharts/plotoptions/series-marker-symbol/
		         *         Predefined, graphic and custom markers
		         * @sample {highstock} highcharts/plotoptions/series-marker-symbol/
		         *         Predefined, graphic and custom markers
		         *
		         * @type      {string}
		         * @apioption plotOptions.series.marker.symbol
		         */

		        /**
		         * The threshold for how dense the point markers should be before they
		         * are hidden, given that `enabled` is not defined. The number indicates
		         * the horizontal distance between the two closest points in the series,
		         * as multiples of the `marker.radius`. In other words, the default
		         * value of 2 means points are hidden if overlapping horizontally.
		         *
		         * @sample highcharts/plotoptions/series-marker-enabledthreshold
		         *         A higher threshold
		         *
		         * @since 6.0.5
		         */
		        enabledThreshold: 2,

		        /**
		         * The radius of the point marker.
		         *
		         * @sample {highcharts} highcharts/plotoptions/series-marker-radius/
		         *         Bigger markers
		         */
		        radius: 4,

		        /**
		         * Image markers only. Set the image width explicitly. When using this
		         * option, a `height` must also be set.
		         *
		         * @sample {highcharts} highcharts/plotoptions/series-marker-width-height/
		         *         Fixed width and height
		         * @sample {highstock} highcharts/plotoptions/series-marker-width-height/
		         *         Fixed width and height
		         *
		         * @type      {number}
		         * @since     4.0.4
		         * @apioption plotOptions.series.marker.width
		         */

		        /**
		         * States for a single point marker.
		         */
		        states: {

		            /**
		             * The normal state of a single point marker. Currently only used
		             * for setting animation when returning to normal state from hover.
		             */
		            normal: {
		                /**
		                 * Animation when returning to normal state after hovering.
		                 *
		                 * @type {boolean|Highcharts.AnimationOptionsObject}
		                 */
		                animation: true
		            },

		            /**
		             * The hover state for a single point marker.
		             */
		            hover: {

		                /**
		                 * Animation when hovering over the marker.
		                 *
		                 * @type {boolean|Highcharts.AnimationOptionsObject}
		                 */
		                animation: {

		                    duration: 50

		                },

		                /**
		                 * Enable or disable the point marker.
		                 *
		                 * @sample {highcharts} highcharts/plotoptions/series-marker-states-hover-enabled/
		                 *         Disabled hover state
		                 */
		                enabled: true,

		                /**
		                 * The fill color of the marker in hover state. When
		                 * `undefined`, the series' or point's fillColor for normal
		                 * state is used.
		                 *
		                 * @type      {Highcharts.ColorString}
		                 * @apioption plotOptions.series.marker.states.hover.fillColor
		                 */

		                /**
		                 * The color of the point marker's outline. When `undefined`,
		                 * the series' or point's lineColor for normal state is used.
		                 *
		                 * @sample {highcharts} highcharts/plotoptions/series-marker-states-hover-linecolor/
		                 *         White fill color, black line color
		                 *
		                 * @type      {Highcharts.ColorString}
		                 * @apioption plotOptions.series.marker.states.hover.lineColor
		                 */

		                /**
		                 * The width of the point marker's outline. When `undefined`,
		                 * the series' or point's lineWidth for normal state is used.
		                 *
		                 * @sample {highcharts} highcharts/plotoptions/series-marker-states-hover-linewidth/
		                 *         3px line width
		                 *
		                 * @type      {number}
		                 * @apioption plotOptions.series.marker.states.hover.lineWidth
		                 */

		                /**
		                 * The radius of the point marker. In hover state, it defaults
		                 * to the normal state's radius + 2 as per the [radiusPlus](
		                 * #plotOptions.series.marker.states.hover.radiusPlus)
		                 * option.
		                 *
		                 * @sample {highcharts} highcharts/plotoptions/series-marker-states-hover-radius/
		                 *         10px radius
		                 *
		                 * @type      {number}
		                 * @apioption plotOptions.series.marker.states.hover.radius
		                 */

		                /**
		                 * The number of pixels to increase the radius of the hovered
		                 * point.
		                 *
		                 * @sample {highcharts} highcharts/plotoptions/series-states-hover-linewidthplus/
		                 *         5 pixels greater radius on hover
		                 * @sample {highstock} highcharts/plotoptions/series-states-hover-linewidthplus/
		                 *         5 pixels greater radius on hover
		                 *
		                 * @since 4.0.3
		                 */
		                radiusPlus: 2,



		                /**
		                 * The additional line width for a hovered point.
		                 *
		                 * @sample {highcharts} highcharts/plotoptions/series-states-hover-linewidthplus/
		                 *         2 pixels wider on hover
		                 * @sample {highstock} highcharts/plotoptions/series-states-hover-linewidthplus/
		                 *         2 pixels wider on hover
		                 *
		                 * @since 4.0.3
		                 */
		                lineWidthPlus: 1



		            },



		            /**
		             * The appearance of the point marker when selected. In order to
		             * allow a point to be selected, set the `series.allowPointSelect`
		             * option to true.
		             */
		            select: {

		                /**
		                 * The radius of the point marker. In hover state, it defaults
		                 * to the normal state's radius + 2.
		                 *
		                 * @sample {highcharts} highcharts/plotoptions/series-marker-states-select-radius/
		                 *         10px radius for selected points
		                 *
		                 * @type      {number}
		                 * @apioption plotOptions.series.marker.states.select.radius
		                 */

		                /**
		                 * Enable or disable visible feedback for selection.
		                 *
		                 * @sample {highcharts} highcharts/plotoptions/series-marker-states-select-enabled/
		                 *         Disabled select state
		                 *
		                 * @type      {boolean}
		                 * @default   true
		                 * @apioption plotOptions.series.marker.states.select.enabled
		                 */

		                /**
		                 * The fill color of the point marker.
		                 *
		                 * @sample {highcharts} highcharts/plotoptions/series-marker-states-select-fillcolor/
		                 *         Solid red discs for selected points
		                 *
		                 * @type {Highcharts.ColorString}
		                 */
		                fillColor: '#cccccc',

		                /**
		                 * The color of the point marker's outline. When `undefined`,
		                 * the series' or point's color is used.
		                 *
		                 * @sample {highcharts} highcharts/plotoptions/series-marker-states-select-linecolor/
		                 *         Red line color for selected points
		                 *
		                 * @type {Highcharts.ColorString}
		                 */
		                lineColor: '#000000',

		                /**
		                 * The width of the point marker's outline.
		                 *
		                 * @sample {highcharts} highcharts/plotoptions/series-marker-states-select-linewidth/
		                 *         3px line width for selected points
		                 */
		                lineWidth: 2
		            }



		        }
		    },

		    /**
		     * Properties for each single point.
		     */
		    point: {

		        /**
		         * Fires when a point is clicked. One parameter, `event`, is passed
		         * to the function, containing common event information.
		         *
		         * If the `series.allowPointSelect` option is true, the default
		         * action for the point's click event is to toggle the point's
		         * select state. Returning `false` cancels this action.
		         *
		         * @sample {highcharts} highcharts/plotoptions/series-point-events-click/
		         *         Click marker to alert values
		         * @sample {highcharts} highcharts/plotoptions/series-point-events-click-column/
		         *         Click column
		         * @sample {highcharts} highcharts/plotoptions/series-point-events-click-url/
		         *         Go to URL
		         * @sample {highmaps} maps/plotoptions/series-point-events-click/
		         *         Click marker to display values
		         * @sample {highmaps} maps/plotoptions/series-point-events-click-url/
		         *         Go to URL
		         *
		         * @type      {Function}
		         * @context   Point
		         * @apioption plotOptions.series.point.events.click
		         */

		        /**
		         * Fires when the mouse leaves the area close to the point. One
		         * parameter, `event`, is passed to the function, containing common
		         * event information.
		         *
		         * @sample {highcharts} highcharts/plotoptions/series-point-events-mouseover/
		         *         Show values in the chart's corner on mouse over
		         *
		         * @type      {Function}
		         * @context   Point
		         * @apioption plotOptions.series.point.events.mouseOut
		         */

		        /**
		         * Fires when the mouse enters the area close to the point. One
		         * parameter, `event`, is passed to the function, containing common
		         * event information.
		         *
		         * @sample {highcharts} highcharts/plotoptions/series-point-events-mouseover/
		         *         Show values in the chart's corner on mouse over
		         *
		         * @type      {Function}
		         * @context   Point
		         * @apioption plotOptions.series.point.events.mouseOver
		         */

		        /**
		         * Fires when the point is removed using the `.remove()` method. One
		         * parameter, `event`, is passed to the function. Returning `false`
		         * cancels the operation.
		         *
		         * @sample {highcharts} highcharts/plotoptions/series-point-events-remove/
		         *         Remove point and confirm
		         *
		         * @type      {Function}
		         * @since     1.2.0
		         * @context   Point
		         * @apioption plotOptions.series.point.events.remove
		         */

		        /**
		         * Fires when the point is selected either programmatically or
		         * following a click on the point. One parameter, `event`, is passed
		         * to the function. Returning `false` cancels the operation.
		         *
		         * @sample {highcharts} highcharts/plotoptions/series-point-events-select/
		         *         Report the last selected point
		         * @sample {highmaps} maps/plotoptions/series-allowpointselect/
		         *         Report select and unselect
		         *
		         * @type      {Function}
		         * @since     1.2.0
		         * @context   Point
		         * @apioption plotOptions.series.point.events.select
		         */

		        /**
		         * Fires when the point is unselected either programmatically or
		         * following a click on the point. One parameter, `event`, is passed
		         * to the function.
		         *  Returning `false` cancels the operation.
		         *
		         * @sample {highcharts} highcharts/plotoptions/series-point-events-unselect/
		         *         Report the last unselected point
		         * @sample {highmaps} maps/plotoptions/series-allowpointselect/
		         *         Report select and unselect
		         *
		         * @type      {Function}
		         * @since     1.2.0
		         * @context   Point
		         * @apioption plotOptions.series.point.events.unselect
		         */

		        /**
		         * Fires when the point is updated programmatically through the
		         * `.update()` method. One parameter, `event`, is passed to the
		         * function. The new point options can be accessed through
		         * `event.options`. Returning `false` cancels the operation.
		         *
		         * @sample {highcharts} highcharts/plotoptions/series-point-events-update/
		         *         Confirm point updating
		         *
		         * @type      {Function}
		         * @since     1.2.0
		         * @context   Point
		         * @apioption plotOptions.series.point.events.update
		         */

		        /**
		         * Events for each single point.
		         */
		        events: {}
		    },



		    /**
		     * Options for the series data labels, appearing next to each data point.
		     *
		     * Since v6.2.0, multiple data labels can be applied to each single point by
		     * defining them as an array of configs.
		     *
		     * In styled mode, the data labels can be styled with the
		     * `.highcharts-data-label-box` and `.highcharts-data-label` class names
		     * ([see example](https://jsfiddle.net/gh/get/library/pure/highcharts/highcharts/tree/master/samples/highcharts/css/series-datalabels)).
		     *
		     * @sample highcharts/plotoptions/series-datalabels-enabled
		     *         Data labels enabled
		     * @sample highcharts/plotoptions/series-datalabels-multiple
		     *         Multiple data labels on a bar series
		     */
		    dataLabels: {


		        /**
		         * The alignment of the data label compared to the point. If `right`,
		         * the right side of the label should be touching the point. For
		         * points with an extent, like columns, the alignments also dictates
		         * how to align it inside the box, as given with the
		         * [inside](#plotOptions.column.dataLabels.inside) option. Can be one of
		         * `left`, `center` or `right`.
		         *
		         * @sample {highcharts} highcharts/plotoptions/series-datalabels-align-left/
		         *         Left aligned
		         *
		         * @validvalue ["left", "center", "right"]
		         */
		        align: 'center',


		        /**
		         * Whether to allow data labels to overlap. To make the labels less
		         * sensitive for overlapping, the [dataLabels.padding](
		         * #plotOptions.series.dataLabels.padding) can be set to 0.
		         *
		         * @sample highcharts/plotoptions/series-datalabels-allowoverlap-false/
		         *         Don't allow overlap
		         *
		         * @type      {boolean}
		         * @default   false
		         * @since     4.1.0
		         * @apioption plotOptions.series.dataLabels.allowOverlap
		         */


		        /**
		         * The border radius in pixels for the data label.
		         *
		         * @sample {highcharts} highcharts/plotoptions/series-datalabels-box/
		         *         Data labels box options
		         * @sample {highstock} highcharts/plotoptions/series-datalabels-box/
		         *         Data labels box options
		         * @sample {highmaps} maps/plotoptions/series-datalabels-box/
		         *         Data labels box options
		         *
		         * @type      {number}
		         * @default   0
		         * @since     2.2.1
		         * @apioption plotOptions.series.dataLabels.borderRadius
		         */


		        /**
		         * The border width in pixels for the data label.
		         *
		         * @sample {highcharts} highcharts/plotoptions/series-datalabels-box/
		         *         Data labels box options
		         * @sample {highstock} highcharts/plotoptions/series-datalabels-box/
		         *         Data labels box options
		         *
		         * @type      {number}
		         * @default   0
		         * @since     2.2.1
		         * @apioption plotOptions.series.dataLabels.borderWidth
		         */

		        /**
		         * A class name for the data label. Particularly in styled mode, this
		         * can be used to give each series' or point's data label unique
		         * styling. In addition to this option, a default color class name is
		         * added so that we can give the labels a
		         * [contrast text shadow](https://jsfiddle.net/gh/get/library/pure/highcharts/highcharts/tree/master/samples/highcharts/css/data-label-contrast/).
		         *
		         * @sample {highcharts} highcharts/css/series-datalabels/
		         *         Styling by CSS
		         * @sample {highstock} highcharts/css/series-datalabels/
		         *         Styling by CSS
		         * @sample {highmaps} highcharts/css/series-datalabels/
		         *         Styling by CSS
		         *
		         * @type      {string}
		         * @since     5.0.0
		         * @apioption plotOptions.series.dataLabels.className
		         */

		        /**
		         * The text color for the data labels. Defaults to `undefined`. For
		         * certain series types, like column or map, the data labels can be
		         * drawn inside the points. In this case the data label will be drawn
		         * with maximum contrast by default. Additionally, it will be given a
		         * `text-outline` style with the opposite color, to further increase the
		         * contrast. This can be overridden by setting the `text-outline` style
		         * to `none` in the `dataLabels.style` option.
		         *
		         * @sample {highcharts} highcharts/plotoptions/series-datalabels-color/
		         *         Red data labels
		         * @sample {highmaps} maps/demo/color-axis/
		         *         White data labels
		         *
		         * @type      {Highcharts.ColorString}
		         * @apioption plotOptions.series.dataLabels.color
		         */

		        /**
		         * Whether to hide data labels that are outside the plot area. By
		         * default, the data label is moved inside the plot area according to
		         * the [overflow](#plotOptions.series.dataLabels.overflow) option.
		         *
		         * @type      {boolean}
		         * @default   true
		         * @since     2.3.3
		         * @apioption plotOptions.series.dataLabels.crop
		         */

		        /**
		         * Whether to defer displaying the data labels until the initial series
		         * animation has finished.
		         *
		         * @type      {boolean}
		         * @default   true
		         * @since     4.0
		         * @product   highcharts highstock gantt
		         * @apioption plotOptions.series.dataLabels.defer
		         */

		        /**
		         * Enable or disable the data labels.
		         *
		         * @sample {highcharts} highcharts/plotoptions/series-datalabels-enabled/
		         *         Data labels enabled
		         * @sample {highmaps} maps/demo/color-axis/
		         *         Data labels enabled
		         *
		         * @type      {boolean}
		         * @default   false
		         * @apioption plotOptions.series.dataLabels.enabled
		         */

		        /**
		         * A [format string](https://www.highcharts.com/docs/chart-concepts/labels-and-string-formatting)
		         * for the data label. Available variables are the same as for
		         * `formatter`.
		         *
		         * @sample {highcharts|highstock} highcharts/plotoptions/series-datalabels-format/
		         *         Add a unit
		         * @sample {highmaps} maps/plotoptions/series-datalabels-format/
		         *         Formatted value in the data label
		         *
		         * @type      {string}
		         * @default   {highcharts} {y}
		         * @default   {highstock} {y}
		         * @default   {highmaps} {point.value}
		         * @since     3.0
		         * @apioption plotOptions.series.dataLabels.format
		         */

		        /**
		         * Callback JavaScript function to format the data label. Note that if a
		         * `format` is defined, the format takes precedence and the formatter is
		         * ignored. Available data are:
		         *
		         * <table>
		         *
		         * <tbody>
		         *
		         * <tr>
		         *
		         * <td>`this.percentage`</td>
		         *
		         * <td>Stacked series and pies only. The point's percentage of the
		         * total.</td>
		         *
		         * </tr>
		         *
		         * <tr>
		         *
		         * <td>`this.point`</td>
		         *
		         * <td>The point object. The point name, if defined, is available
		         * through `this.point.name`.</td>
		         *
		         * </tr>
		         *
		         * <tr>
		         *
		         * <td>`this.series`:</td>
		         *
		         * <td>The series object. The series name is available through
		         * `this.series.name`.</td>
		         *
		         * </tr>
		         *
		         * <tr>
		         *
		         * <td>`this.total`</td>
		         *
		         * <td>Stacked series only. The total value at this point's x value.
		         * </td>
		         *
		         * </tr>
		         *
		         * <tr>
		         *
		         * <td>`this.x`:</td>
		         *
		         * <td>The x value.</td>
		         *
		         * </tr>
		         *
		         * <tr>
		         *
		         * <td>`this.y`:</td>
		         *
		         * <td>The y value.</td>
		         *
		         * </tr>
		         *
		         * </tbody>
		         *
		         * </table>
		         *
		         * @sample {highmaps} maps/plotoptions/series-datalabels-format/
		         *         Formatted value
		         *
		         * @type    {Highcharts.FormatterCallbackFunction}
		         * @default function () { return this.y; }
		         */
		        formatter: function () {
		            return this.y === null ? '' : H.numberFormat(this.y, -1);
		        },



		        /**
		         * Styles for the label. The default `color` setting is `"contrast"`,
		         * which is a pseudo color that Highcharts picks up and applies the
		         * maximum contrast to the underlying point item, for example the
		         * bar in a bar chart.
		         *
		         * The `textOutline` is a pseudo property that
		         * applies an outline of the given width with the given color, which
		         * by default is the maximum contrast to the text. So a bright text
		         * color will result in a black text outline for maximum readability
		         * on a mixed background. In some cases, especially with grayscale
		         * text, the text outline doesn't work well, in which cases it can
		         * be disabled by setting it to `"none"`. When `useHTML` is true, the
		         * `textOutline` will not be picked up. In this, case, the same effect
		         * can be acheived through the `text-shadow` CSS property.
		         *
		         * For some series types, where each point has an extent, like for
		         * example tree maps, the data label may overflow the point. There are
		         * two strategies for handling overflow. By default, the text will wrap
		         * to multiple lines. The other strategy is to set
		         * `style.textOverflow` to `ellipsis`, which will keep the text on one
		         * line plus it will break inside long words.
		         *
		         * @sample {highcharts} highcharts/plotoptions/series-datalabels-style/
		         *         Bold labels
		         * @sample {highmaps} maps/demo/color-axis/
		         *         Bold labels
		         *
		         * @type    {Highcharts.CSSObject}
		         * @default {"color": "contrast", "fontSize": "11px", "fontWeight": "bold", "textOutline": "1px contrast" }
		         * @since   4.1.0
		         */
		        style: {
		            /**
		             * @ignore
		             */
		            fontSize: '11px',
		            /**
		             * @ignore
		             */
		            fontWeight: 'bold',
		            /**
		             * @ignore
		             */
		            color: 'contrast',
		            /**
		             * @ignore
		             */
		            textOutline: '1px contrast'
		        },

		        /**
		         * The name of a symbol to use for the border around the label. Symbols
		         * are predefined functions on the Renderer object.
		         *
		         * @sample highcharts/plotoptions/series-datalabels-shape/
		         *         A callout for annotations
		         *
		         * @type      {string}
		         * @default   square
		         * @since     4.1.2
		         * @apioption plotOptions.series.dataLabels.shape
		         */

		        /**
		         * The Z index of the data labels. The default Z index puts it above
		         * the series. Use a Z index of 2 to display it behind the series.
		         *
		         * @type      {number}
		         * @default   6
		         * @since     2.3.5
		         * @apioption plotOptions.series.dataLabels.zIndex
		         */

		        /**
		         * A declarative filter for which data labels to display. The
		         * declarative filter is designed for use when callback functions are
		         * not available, like when the chart options require a pure JSON
		         * structure or for use with graphical editors. For programmatic
		         * control, use the `formatter` instead, and return `undefined` to
		         * disable a single data label.
		         *
		         * @example
		         * filter: {
		         *     property: 'percentage',
		         *     operator: '>',
		         *     value: 4
		         * }
		         *
		         * @sample highcharts/demo/pie-monochrome
		         *         Data labels filtered by percentage
		         *
		         * @since     6.0.3
		         * @apioption plotOptions.series.dataLabels.filter
		         */

		        /**
		         * The point property to filter by. Point options are passed directly to
		         * properties, additionally there are `y` value, `percentage` and others
		         * listed under [Point](https://api.highcharts.com/class-reference/Highcharts.Point)
		         * members.
		         *
		         * @type      {string}
		         * @apioption plotOptions.series.dataLabels.filter.property
		         */

		        /**
		         * The operator to compare by. Can be one of `>`, `<`, `>=`, `<=`, `==`,
		         * and `===`.
		         *
		         * @type       {string}
		         * @validvalue [">", "<", ">=", "<=", "==", "==="]
		         * @apioption  plotOptions.series.dataLabels.filter.operator
		         */

		        /**
		         * The value to compare against.
		         *
		         * @type      {*}
		         * @apioption plotOptions.series.dataLabels.filter.value
		         */

		        /**
		         * The background color or gradient for the data label.
		         *
		         * @sample {highcharts} highcharts/plotoptions/series-datalabels-box/
		         *         Data labels box options
		         * @sample {highmaps} maps/plotoptions/series-datalabels-box/
		         *         Data labels box options
		         *
		         * @type      {Highcharts.ColorString}
		         * @since     2.2.1
		         * @apioption plotOptions.series.dataLabels.backgroundColor
		         */

		        /**
		         * The border color for the data label. Defaults to `undefined`.
		         *
		         * @sample {highcharts|highstock} highcharts/plotoptions/series-datalabels-box/
		         *         Data labels box options
		         *
		         * @type      {Highcharts.ColorString}
		         * @since     2.2.1
		         * @apioption plotOptions.series.dataLabels.borderColor
		         */

		        /**
		         * The shadow of the box. Works best with `borderWidth` or
		         * `backgroundColor`. Since 2.3 the shadow can be an object
		         * configuration containing `color`, `offsetX`, `offsetY`, `opacity` and
		         * `width`.
		         *
		         * @sample {highcharts|highstock} highcharts/plotoptions/series-datalabels-box/
		         *         Data labels box options
		         *
		         * @type      {boolean|*}
		         * @default   false
		         * @since     2.2.1
		         * @apioption plotOptions.series.dataLabels.shadow
		         */



		        /**
		         * For points with an extent, like columns or map areas, whether to
		         * align the data label inside the box or to the actual value point.
		         * Defaults to `false` in most cases, `true` in stacked columns.
		         *
		         * @type      {boolean}
		         * @since     3.0
		         * @apioption plotOptions.series.dataLabels.inside
		         */

		        /**
		         * How to handle data labels that flow outside the plot area. The
		         * default is `"justify"`, which aligns them inside the plot area. For
		         * columns and bars, this means it will be moved inside the bar. To
		         * display data labels outside the plot area, set `crop` to `false` and
		         * `overflow` to `"allow"`.
		         *
		         * @type       {string}
		         * @default    justify
		         * @since      3.0.6
		         * @validvalue ["allow", "justify"]
		         * @apioption  plotOptions.series.dataLabels.overflow
		         */

		        /**
		         * Text rotation in degrees. Note that due to a more complex structure,
		         * backgrounds, borders and padding will be lost on a rotated data
		         * label.
		         *
		         * @sample {highcharts} highcharts/plotoptions/series-datalabels-rotation/
		         *         Vertical labels
		         *
		         * @type      {number}
		         * @default   0
		         * @apioption plotOptions.series.dataLabels.rotation
		         */

		        /**
		         * Whether to
		         * [use HTML](https://www.highcharts.com/docs/chart-concepts/labels-and-string-formatting#html)
		         * to render the labels.
		         *
		         * @type      {boolean}
		         * @default   false
		         * @apioption plotOptions.series.dataLabels.useHTML
		         */

		        /**
		         * The vertical alignment of a data label. Can be one of `top`, `middle`
		         * or `bottom`. The default value depends on the data, for instance
		         * in a column chart, the label is above positive values and below
		         * negative values.
		         *
		         * @since      2.3.3
		         * @validvalue ["top", "middle", "bottom"]
		         */
		        verticalAlign: 'bottom', // above singular point


		        /**
		         * The x position offset of the label relative to the point in pixels.
		         *
		         * @sample {highcharts} highcharts/plotoptions/series-datalabels-rotation/
		         *         Vertical and positioned
		         */
		        x: 0,


		        /**
		         * The y position offset of the label relative to the point in pixels.
		         *
		         * @sample {highcharts} highcharts/plotoptions/series-datalabels-rotation/
		         *         Vertical and positioned
		         */
		        y: 0,


		        /**
		         * When either the `borderWidth` or the `backgroundColor` is set,
		         * this is the padding within the box.
		         *
		         * @sample {highcharts|highstock} highcharts/plotoptions/series-datalabels-box/
		         *         Data labels box options
		         * @sample {highmaps} maps/plotoptions/series-datalabels-box/
		         *         Data labels box options
		         *
		         * @default {highcharts} 5
		         * @default {highstock} 5
		         * @default {highmaps} 0
		         * @since   2.2.1
		         */
		        padding: 5
		    },

		    /**
		     * When the series contains less points than the crop threshold, all
		     * points are drawn, even if the points fall outside the visible plot
		     * area at the current zoom. The advantage of drawing all points (including
		     * markers and columns), is that animation is performed on updates.
		     * On the other hand, when the series contains more points than the
		     * crop threshold, the series data is cropped to only contain points
		     * that fall within the plot area. The advantage of cropping away invisible
		     * points is to increase performance on large series.
		     *
		     * @since   2.2
		     * @product highcharts highstock
		     */
		    cropThreshold: 300,



		    /**
		     * The width of each point on the x axis. For example in a column chart
		     * with one value each day, the pointRange would be 1 day (= 24 * 3600
		     * * 1000 milliseconds). This is normally computed automatically, but
		     * this option can be used to override the automatic value.
		     *
		     * @product highstock
		     */
		    pointRange: 0,

		    /**
		     * When this is true, the series will not cause the Y axis to cross
		     * the zero plane (or [threshold](#plotOptions.series.threshold) option)
		     * unless the data actually crosses the plane.
		     *
		     * For example, if `softThreshold` is `false`, a series of 0, 1, 2,
		     * 3 will make the Y axis show negative values according to the `minPadding`
		     * option. If `softThreshold` is `true`, the Y axis starts at 0.
		     *
		     * @since   4.1.9
		     * @product highcharts highstock
		     */
		    softThreshold: true,



		    /**
		     * A wrapper object for all the series options in specific states.
		     */
		    states: {

		        /**
		         * The normal state of a series, or for point items in column, pie and
		         * similar series. Currently only used for setting animation when
		         * returning to normal state from hover.
		         */
		        normal: {
		            /**
		             * Animation when returning to normal state after hovering.
		             *
		             * @type {boolean|Highcharts.AnimationOptionsObject}
		             */
		            animation: true
		        },

		        /**
		         * Options for the hovered series. These settings override the normal
		         * state options when a series is moused over or touched.
		         */
		        hover: {

		            /**
		             * Enable separate styles for the hovered series to visualize that
		             * the user hovers either the series itself or the legend. .
		             *
		             * @sample {highcharts} highcharts/plotoptions/series-states-hover-enabled/
		             *         Line
		             * @sample {highcharts} highcharts/plotoptions/series-states-hover-enabled-column/
		             *         Column
		             * @sample {highcharts} highcharts/plotoptions/series-states-hover-enabled-pie/
		             *         Pie
		             *
		             * @type      {boolean}
		             * @default   true
		             * @since     1.2
		             * @apioption plotOptions.series.states.hover.enabled
		             */


		            /**
		             * Animation setting for hovering the graph in line-type series.
		             *
		             * @type    {boolean|Highcharts.AnimationOptionsObject}
		             * @since   5.0.8
		             * @product highcharts
		             */
		            animation: {

		                /**
		                 * The duration of the hover animation in milliseconds. By
		                 * default the hover state animates quickly in, and slowly back
		                 * to normal.
		                 */
		                duration: 50
		            },

		            /**
		             * Pixel width of the graph line. By default this property is
		             * undefined, and the `lineWidthPlus` property dictates how much
		             * to increase the linewidth from normal state.
		             *
		             * @sample {highcharts} highcharts/plotoptions/series-states-hover-linewidth/
		             *         5px line on hover
		             *
		             * @type      {number}
		             * @product   highcharts highstock
		             * @apioption plotOptions.series.states.hover.lineWidth
		             */


		            /**
		             * The additional line width for the graph of a hovered series.
		             *
		             * @sample {highcharts} highcharts/plotoptions/series-states-hover-linewidthplus/
		             *         5 pixels wider
		             * @sample {highstock} highcharts/plotoptions/series-states-hover-linewidthplus/
		             *         5 pixels wider
		             *
		             * @since   4.0.3
		             * @product highcharts highstock
		             */
		            lineWidthPlus: 1,

		            /**
		             * In Highcharts 1.0, the appearance of all markers belonging to the
		             * hovered series. For settings on the hover state of the individual
		             * point, see
		             * [marker.states.hover](#plotOptions.series.marker.states.hover).
		             *
		             * @deprecated
		             *
		             * @extends plotOptions.series.marker
		             * @product highcharts highstock
		             */
		            marker: {
		                // lineWidth: base + 1,
		                // radius: base + 1
		            },

		            /**
		             * Options for the halo appearing around the hovered point in line-
		             * type series as well as outside the hovered slice in pie charts.
		             * By default the halo is filled by the current point or series
		             * color with an opacity of 0.25\. The halo can be disabled by
		             * setting the `halo` option to `false`.
		             *
		             * In styled mode, the halo is styled with the `.highcharts-halo`
		             * class, with colors inherited from `.highcharts-color-{n}`.
		             *
		             * @sample {highcharts} highcharts/plotoptions/halo/
		             *         Halo options
		             * @sample {highstock} highcharts/plotoptions/halo/
		             *         Halo options
		             *
		             * @since   4.0
		             * @product highcharts highstock
		             */
		            halo: {

		                /**
		                 * A collection of SVG attributes to override the appearance of
		                 * the halo, for example `fill`, `stroke` and `stroke-width`.
		                 *
		                 * @type      {Highcharts.SVGAttributes}
		                 * @since     4.0
		                 * @product   highcharts highstock
		                 * @apioption plotOptions.series.states.hover.halo.attributes
		                 */


		                /**
		                 * The pixel size of the halo. For point markers this is the
		                 * radius of the halo. For pie slices it is the width of the
		                 * halo outside the slice. For bubbles it defaults to 5 and is
		                 * the width of the halo outside the bubble.
		                 *
		                 * @since   4.0
		                 * @product highcharts highstock
		                 */
		                size: 10,



		                /**
		                 * Opacity for the halo unless a specific fill is overridden
		                 * using the `attributes` setting. Note that Highcharts is only
		                 * able to apply opacity to colors of hex or rgb(a) formats.
		                 *
		                 * @since   4.0
		                 * @product highcharts highstock
		                 */
		                opacity: 0.25



		            }
		        },


		        /**
		         * Specific options for point in selected states, after being selected
		         * by [allowPointSelect](#plotOptions.series.allowPointSelect) or
		         * programmatically.
		         *
		         * @sample {highmaps} maps/plotoptions/series-allowpointselect/
		         *         Allow point select demo
		         *
		         * @extends   plotOptions.series.states.hover
		         * @excluding brightness
		         * @product   highmaps
		         */
		        select: {
		            // marker: {}
		        }
		    },



		    /**
		     * Sticky tracking of mouse events. When true, the `mouseOut` event
		     * on a series isn't triggered until the mouse moves over another series,
		     * or out of the plot area. When false, the `mouseOut` event on a
		     * series is triggered when the mouse leaves the area around the series'
		     * graph or markers. This also implies the tooltip when not shared. When
		     * `stickyTracking` is false and `tooltip.shared` is false, the tooltip will
		     * be hidden when moving the mouse between series. Defaults to true for line
		     * and area type series, but to false for columns, pies etc.
		     *
		     * @sample {highcharts} highcharts/plotoptions/series-stickytracking-true/
		     *         True by default
		     * @sample {highcharts} highcharts/plotoptions/series-stickytracking-false/
		     *         False
		     *
		     * @default {highcharts} true
		     * @default {highstock} true
		     * @default {highmaps} false
		     * @since   2.0
		     */
		    stickyTracking: true,

		    /**
		     * A configuration object for the tooltip rendering of each single series.
		     * Properties are inherited from [tooltip](#tooltip), but only the
		     * following properties can be defined on a series level.
		     *
		     * @since     2.3
		     * @extends   tooltip
		     * @excluding animation,backgroundColor,borderColor,borderRadius,
		     *            borderWidth,crosshairs,enabled,formatter,positioner,shadow,
		     *            shared,shape,snap,style,useHTML
		     * @apioption plotOptions.series.tooltip
		     */

		    /**
		     * When a series contains a data array that is longer than this, only
		     * one dimensional arrays of numbers, or two dimensional arrays with
		     * x and y values are allowed. Also, only the first point is tested,
		     * and the rest are assumed to be the same format. This saves expensive
		     * data checking and indexing in long series. Set it to `0` disable.
		     *
		     * @since   2.2
		     * @product highcharts highstock gantt
		     */
		    turboThreshold: 1000,

		    /**
		     * An array defining zones within a series. Zones can be applied to
		     * the X axis, Y axis or Z axis for bubbles, according to the `zoneAxis`
		     * option. The zone definitions have to be in ascending order regarding to
		     * the value.
		     *
		     * In styled mode, the color zones are styled with the
		     * `.highcharts-zone-{n}` class, or custom classed from the `className`
		     * option
		     * ([view live demo](https://jsfiddle.net/gh/get/library/pure/highcharts/highcharts/tree/master/samples/highcharts/css/color-zones/)).
		     *
		     * @see [zoneAxis](#plotOptions.series.zoneAxis)
		     *
		     * @sample {highcharts} highcharts/series/color-zones-simple/
		     *         Color zones
		     * @sample {highstock} highcharts/series/color-zones-simple/
		     *         Color zones
		     *
		     * @type      {Array<*>}
		     * @since     4.1.0
		     * @product   highcharts highstock
		     * @apioption plotOptions.series.zones
		     */

		    /**
		     * Styled mode only. A custom class name for the zone.
		     *
		     * @sample highcharts/css/color-zones/
		     *         Zones styled by class name
		     *
		     * @type      {string}
		     * @since     5.0.0
		     * @apioption plotOptions.series.zones.className
		     */

		    /**
		     * Defines the color of the series.
		     *
		     * @see [series color](#plotOptions.series.color)
		     *
		     * @type      {Highcharts.ColorString}
		     * @since     4.1.0
		     * @product   highcharts highstock
		     * @apioption plotOptions.series.zones.color
		     */

		    /**
		     * A name for the dash style to use for the graph.
		     *
		     * @see [series.dashStyle](#plotOptions.series.dashStyle)
		     *
		     * @sample {highcharts|highstock} highcharts/series/color-zones-dashstyle-dot/
		     *         Dashed line indicates prognosis
		     *
		     * @type      {string}
		     * @since     4.1.0
		     * @product   highcharts highstock
		     * @apioption plotOptions.series.zones.dashStyle
		     */

		    /**
		     * Defines the fill color for the series (in area type series)
		     *
		     * @see [fillColor](#plotOptions.area.fillColor)
		     *
		     * @type      {Highcharts.ColorString}
		     * @since     4.1.0
		     * @product   highcharts highstock
		     * @apioption plotOptions.series.zones.fillColor
		     */

		    /**
		     * The value up to where the zone extends, if undefined the zones stretches
		     * to the last value in the series.
		     *
		     * @type      {number}
		     * @since     4.1.0
		     * @product   highcharts highstock
		     * @apioption plotOptions.series.zones.value
		     */

		    /**
		     * Determines whether the series should look for the nearest point
		     * in both dimensions or just the x-dimension when hovering the series.
		     * Defaults to `'xy'` for scatter series and `'x'` for most other
		     * series. If the data has duplicate x-values, it is recommended to
		     * set this to `'xy'` to allow hovering over all points.
		     *
		     * Applies only to series types using nearest neighbor search (not
		     * direct hover) for tooltip.
		     *
		     * @sample {highcharts} highcharts/series/findnearestpointby/
		     *         Different hover behaviors
		     * @sample {highstock} highcharts/series/findnearestpointby/
		     *         Different hover behaviors
		     * @sample {highmaps} highcharts/series/findnearestpointby/
		     *         Different hover behaviors
		     *
		     * @since      5.0.10
		     * @validvalue ["x", "xy"]
		     */
		    findNearestPointBy: 'x'

		}, /** @lends Highcharts.Series.prototype */ {

		    /**
		     * Series options for specific data and the data itself. In TypeScript you
		     * have to cast the series options to specific series types, to get all
		     * possible options for a series.
		     *
		     * @example
		     * // TypeScript example
		     * Highcharts.chart('container', {
		     *     series: [{
		     *         color: '#06C',
		     *         data: [[0, 1], [2, 3]]
		     *     } as Highcharts.SeriesLineOptions ]
		     * });
		     *
		     *
		     * @type      {Array<*>}
		     * @apioption series
		     */

		    /**
		     * An id for the series. This can be used after render time to get a pointer
		     * to the series object through `chart.get()`.
		     *
		     * @sample {highcharts} highcharts/plotoptions/series-id/
		     *         Get series by id
		     *
		     * @type      {string}
		     * @since     1.2.0
		     * @apioption series.id
		     */

		    /**
		     * The index of the series in the chart, affecting the internal index in the
		     * `chart.series` array, the visible Z index as well as the order in the
		     * legend.
		     *
		     * @type      {number}
		     * @since     2.3.0
		     * @apioption series.index
		     */

		    /**
		     * The sequential index of the series in the legend.
		     *
		     * @see [legend.reversed](#legend.reversed),
		     *      [yAxis.reversedStacks](#yAxis.reversedStacks)
		     *
		     * @sample {highcharts|highstock} highcharts/series/legendindex/
		     *         Legend in opposite order
		     *
		     * @type      {number}
		     * @apioption series.legendIndex
		     */
		    /**
		     * The name of the series as shown in the legend, tooltip etc.
		     *
		     * @sample {highcharts} highcharts/series/name/
		     *         Series name
		     * @sample {highmaps} maps/demo/category-map/
		     *         Series name
		     *
		     * @type      {string}
		     * @apioption series.name
		     */

		    /**
		     * This option allows grouping series in a stacked chart. The stack option
		     * can be a string or anything else, as long as the grouped series' stack
		     * options match each other after conversion into a string.
		     *
		     * @sample {highcharts} highcharts/series/stack/
		     *         Stacked and grouped columns
		     *
		     * @type      {string|*}
		     * @since     2.1
		     * @product   highcharts highstock
		     * @apioption series.stack
		     */

		    /**
		     * The type of series, for example `line` or `column`. By default, the
		     * series type is inherited from [chart.type](#chart.type), so unless the
		     * chart is a combination of series types, there is no need to set it on the
		     * series level.
		     *
		     * @sample {highcharts} highcharts/series/type/
		     *         Line and column in the same chart
		     * @sample {highmaps} maps/demo/mapline-mappoint/
		     *         Multiple types in the same map
		     *
		     * @type      {string}
		     * @apioption series.type
		     */

		    /**
		     * When using dual or multiple x axes, this number defines which xAxis the
		     * particular series is connected to. It refers to either the
		     * {@link #xAxis.id|axis id}
		     * or the index of the axis in the xAxis array, with 0 being the first.
		     *
		     * @type      {number|string}
		     * @default   0
		     * @product   highcharts highstock
		     * @apioption series.xAxis
		     */

		    /**
		     * When using dual or multiple y axes, this number defines which yAxis the
		     * particular series is connected to. It refers to either the
		     * {@link #yAxis.id|axis id}
		     * or the index of the axis in the yAxis array, with 0 being the first.
		     *
		     * @sample {highcharts} highcharts/series/yaxis/
		     *         Apply the column series to the secondary Y axis
		     *
		     * @type      {number|string}
		     * @default   0
		     * @product   highcharts highstock
		     * @apioption series.yAxis
		     */

		    /**
		     * Define the visual z index of the series.
		     *
		     * @sample {highcharts} highcharts/plotoptions/series-zindex-default/
		     *         With no z index, the series defined last are on top
		     * @sample {highcharts} highcharts/plotoptions/series-zindex/
		     *         With a z index, the series with the highest z index is on top
		     * @sample {highstock} highcharts/plotoptions/series-zindex-default/
		     *         With no z index, the series defined last are on top
		     * @sample {highstock} highcharts/plotoptions/series-zindex/
		     *         With a z index, the series with the highest z index is on top
		     *
		     * @type      {number}
		     * @product   highcharts highstock
		     * @apioption series.zIndex
		     */

		    isCartesian: true,
		    pointClass: Point,
		    sorted: true, // requires the data to be sorted
		    requireSorting: true,
		    directTouch: false,
		    axisTypes: ['xAxis', 'yAxis'],
		    colorCounter: 0,
		    // each point's x and y values are stored in this.xData and this.yData
		    parallelArrays: ['x', 'y'],
		    coll: 'series',
		    init: function (chart, options) {
		        var series = this,
		            events,
		            chartSeries = chart.series,
		            lastSeries;

		        /**
		         * Read only. The chart that the series belongs to.
		         *
		         * @name Highcharts.Series#chart
		         * @type {Highcharts.Chart}
		         */
		        series.chart = chart;

		        /**
		         * Read only. The series' type, like "line", "area", "column" etc. The
		         * type in the series options anc can be altered using {@link
		         * Series#update}.
		         *
		         * @name Highcharts.Series#type
		         * @type {string}
		         */

		        /**
		         * Read only. The series' current options. To update, use {@link
		         * Series#update}.
		         *
		         * @name Highcharts.Series#options
		         * @type {Highcharts.PlotSeriesOptions}
		         */
		        series.options = options = series.setOptions(options);
		        series.linkedSeries = [];

		        // bind the axes
		        series.bindAxes();

		        // set some variables
		        extend(series, {
		            /**
		             * The series name as given in the options. Defaults to
		             * "Series {n}".
		             *
		             * @name Highcharts.Series#name
		             * @type {string}
		             */
		            name: options.name,
		            state: '',
		            /**
		             * Read only. The series' visibility state as set by {@link
		             * Series#show}, {@link Series#hide}, or in the initial
		             * configuration.
		             *
		             * @name Highcharts.Series#visible
		             * @type {boolean}
		             */
		            visible: options.visible !== false, // true by default
		            /**
		             * Read only. The series' selected state as set by {@link
		             * Highcharts.Series#select}.
		             *
		             * @name Highcharts.Series#selected
		             * @type {boolean}
		             */
		            selected: options.selected === true // false by default
		        });

		        // register event listeners
		        events = options.events;

		        objectEach(events, function (event, eventType) {
		            addEvent(series, eventType, event);
		        });
		        if (
		            (events && events.click) ||
		            (
		                options.point &&
		                options.point.events &&
		                options.point.events.click
		            ) ||
		            options.allowPointSelect
		        ) {
		            chart.runTrackerClick = true;
		        }

		        series.getColor();
		        series.getSymbol();

		        // Set the data
		        each(series.parallelArrays, function (key) {
		            series[key + 'Data'] = [];
		        });
		        series.setData(options.data, false);

		        // Mark cartesian
		        if (series.isCartesian) {
		            chart.hasCartesianSeries = true;
		        }

		        // Get the index and register the series in the chart. The index is one
		        // more than the current latest series index (#5960).
		        if (chartSeries.length) {
		            lastSeries = chartSeries[chartSeries.length - 1];
		        }
		        series._i = pick(lastSeries && lastSeries._i, -1) + 1;

		        // Insert the series and re-order all series above the insertion point.
		        chart.orderSeries(this.insert(chartSeries));

		        fireEvent(this, 'afterInit');
		    },

		    /**
		     * Insert the series in a collection with other series, either the chart
		     * series or yAxis series, in the correct order according to the index
		     * option. Used internally when adding series.
		     *
		     * @private
		     * @function Highcharts.Series#insert
		     *
		     * @param {Array<Highcharts.Series>} collection
		     *        A collection of series, like `chart.series` or `xAxis.series`.
		     *
		     * @return {number}
		     *         The index of the series in the collection.
		     */
		    insert: function (collection) {
		        var indexOption = this.options.index,
		            i;

		        // Insert by index option
		        if (isNumber(indexOption)) {
		            i = collection.length;
		            while (i--) {
		                // Loop down until the interted element has higher index
		                if (indexOption >=
		                        pick(collection[i].options.index, collection[i]._i)) {
		                    collection.splice(i + 1, 0, this);
		                    break;
		                }
		            }
		            if (i === -1) {
		                collection.unshift(this);
		            }
		            i = i + 1;

		        // Or just push it to the end
		        } else {
		            collection.push(this);
		        }
		        return pick(i, collection.length - 1);
		    },

		    /**
		     * Set the xAxis and yAxis properties of cartesian series, and register the
		     * series in the `axis.series` array.
		     *
		     * @private
		     * @function Highcharts.Series#bindAxes
		     *
		     * @exception 18
		     */
		    bindAxes: function () {
		        var series = this,
		            seriesOptions = series.options,
		            chart = series.chart,
		            axisOptions;

		        // repeat for xAxis and yAxis
		        each(series.axisTypes || [], function (AXIS) {

		            // loop through the chart's axis objects
		            each(chart[AXIS], function (axis) {
		                axisOptions = axis.options;

		                // apply if the series xAxis or yAxis option mathches the number
		                // of the axis, or if undefined, use the first axis
		                if (
		                    seriesOptions[AXIS] === axisOptions.index ||
		                    (
		                        seriesOptions[AXIS] !== undefined &&
		                        seriesOptions[AXIS] === axisOptions.id
		                    ) ||
		                    (
		                        seriesOptions[AXIS] === undefined &&
		                        axisOptions.index === 0
		                    )
		                ) {

		                    // register this series in the axis.series lookup
		                    series.insert(axis.series);

		                    // set this series.xAxis or series.yAxis reference
		                    /**
		                     * Read only. The unique xAxis object associated with the
		                     * series.
		                     *
		                     * @name Highcharts.Series#xAxis
		                     * @type {Highcharts.Axis}
		                     */
		                    /**
		                     * Read only. The unique yAxis object associated with the
		                     * series.
		                     *
		                     * @name Highcharts.Series#yAxis
		                     * @type {Highcharts.Axis}
		                     */
		                    series[AXIS] = axis;

		                    // mark dirty for redraw
		                    axis.isDirty = true;
		                }
		            });

		            // The series needs an X and an Y axis
		            if (!series[AXIS] && series.optionalAxis !== AXIS) {
		                H.error(18, true);
		            }

		        });
		    },

		    /**
		     * For simple series types like line and column, the data values are held in
		     * arrays like xData and yData for quick lookup to find extremes and more.
		     * For multidimensional series like bubble and map, this can be extended
		     * with arrays like zData and valueData by adding to the
		     * `series.parallelArrays` array.
		     *
		     * @private
		     * @function Highcharts.Series#updateParallelArrays
		     *
		     * @param {Highcharts.Point} point
		     *
		     * @param {number|string} i
		     */
		    updateParallelArrays: function (point, i) {
		        var series = point.series,
		            args = arguments,
		            fn = isNumber(i) ?
		                // Insert the value in the given position
		                function (key) {
		                    var val = key === 'y' && series.toYData ?
		                        series.toYData(point) :
		                        point[key];
		                    series[key + 'Data'][i] = val;
		                } :
		                // Apply the method specified in i with the following arguments
		                // as arguments
		                function (key) {
		                    Array.prototype[i].apply(
		                        series[key + 'Data'],
		                        Array.prototype.slice.call(args, 2)
		                    );
		                };

		        each(series.parallelArrays, fn);
		    },

		    /**
		     * Return an auto incremented x value based on the pointStart and
		     * pointInterval options. This is only used if an x value is not given for
		     * the point that calls autoIncrement.
		     *
		     * @private
		     * @function Highcharts.Series#autoIncrement
		     *
		     * @return {number}
		     */
		    autoIncrement: function () {

		        var options = this.options,
		            xIncrement = this.xIncrement,
		            date,
		            pointInterval,
		            pointIntervalUnit = options.pointIntervalUnit,
		            time = this.chart.time;

		        xIncrement = pick(xIncrement, options.pointStart, 0);

		        this.pointInterval = pointInterval = pick(
		            this.pointInterval,
		            options.pointInterval,
		            1
		        );

		        // Added code for pointInterval strings
		        if (pointIntervalUnit) {
		            date = new time.Date(xIncrement);

		            if (pointIntervalUnit === 'day') {
		                time.set(
		                    'Date',
		                    date,
		                    time.get('Date', date) + pointInterval
		                );
		            } else if (pointIntervalUnit === 'month') {
		                time.set(
		                    'Month',
		                    date,
		                    time.get('Month', date) + pointInterval
		                );
		            } else if (pointIntervalUnit === 'year') {
		                time.set(
		                    'FullYear',
		                    date,
		                    time.get('FullYear', date) + pointInterval
		                );
		            }

		            pointInterval = date.getTime() - xIncrement;

		        }

		        this.xIncrement = xIncrement + pointInterval;
		        return xIncrement;
		    },

		    /**
		     * Set the series options by merging from the options tree. Called
		     * internally on initiating and updating series. This function will not
		     * redraw the series. For API usage, use {@link Series#update}.
		     *
		     * @function Highcharts.Series#setOptions
		     *
		     * @param {Highcharts.PlotSeriesOptions} itemOptions
		     *        The series options.
		     *
		     * @return {Highcharts.PlotSeriesOptions}
		     *
		     * @fires Highcharts.Series#event:afterSetOptions
		     */
		    setOptions: function (itemOptions) {
		        var chart = this.chart,
		            chartOptions = chart.options,
		            plotOptions = chartOptions.plotOptions,
		            userOptions = chart.userOptions || {},
		            userPlotOptions = userOptions.plotOptions || {},
		            typeOptions = plotOptions[this.type],
		            options,
		            zones;

		        this.userOptions = itemOptions;

		        // General series options take precedence over type options because
		        // otherwise, default type options like column.animation would be
		        // overwritten by the general option. But issues have been raised here
		        // (#3881), and the solution may be to distinguish between default
		        // option and userOptions like in the tooltip below.
		        options = merge(
		            typeOptions,
		            plotOptions.series,
		            itemOptions
		        );

		        // The tooltip options are merged between global and series specific
		        // options. Importance order asscendingly:
		        // globals: (1)tooltip, (2)plotOptions.series, (3)plotOptions[this.type]
		        // init userOptions with possible later updates: 4-6 like 1-3 and
		        // (7)this series options
		        this.tooltipOptions = merge(
		            defaultOptions.tooltip, // 1
		            defaultOptions.plotOptions.series &&
		                defaultOptions.plotOptions.series.tooltip, // 2
		            defaultOptions.plotOptions[this.type].tooltip, // 3
		            chartOptions.tooltip.userOptions, // 4
		            plotOptions.series && plotOptions.series.tooltip, // 5
		            plotOptions[this.type].tooltip, // 6
		            itemOptions.tooltip // 7
		        );

		        // When shared tooltip, stickyTracking is true by default,
		        // unless user says otherwise.
		        this.stickyTracking = pick(
		            itemOptions.stickyTracking,
		            userPlotOptions[this.type] &&
		                userPlotOptions[this.type].stickyTracking,
		            userPlotOptions.series && userPlotOptions.series.stickyTracking,
		            (
		                this.tooltipOptions.shared && !this.noSharedTooltip ?
		                true :
		                options.stickyTracking
		            )
		        );

		        // Delete marker object if not allowed (#1125)
		        if (typeOptions.marker === null) {
		            delete options.marker;
		        }

		        // Handle color zones
		        this.zoneAxis = options.zoneAxis;
		        zones = this.zones = (options.zones || []).slice();
		        if (
		            (options.negativeColor || options.negativeFillColor) &&
		            !options.zones
		        ) {
		            zones.push({
		                value:
		                    options[this.zoneAxis + 'Threshold'] ||
		                    options.threshold ||
		                    0,
		                className: 'highcharts-negative',

		                color: options.negativeColor,
		                fillColor: options.negativeFillColor

		            });
		        }
		        if (zones.length) { // Push one extra zone for the rest
		            if (defined(zones[zones.length - 1].value)) {
		                zones.push({

		                    color: this.color,
		                    fillColor: this.fillColor

		                });
		            }
		        }

		        fireEvent(this, 'afterSetOptions', { options: options });

		        return options;
		    },

		    /**
		     * Return series name in "Series {Number}" format or the one defined by a
		     * user. This method can be simply overridden as series name format can
		     * vary (e.g. technical indicators).
		     *
		     * @function Highcharts.Series#getName
		     *
		     * @return {string}
		     *         The series name.
		     */
		    getName: function () {
		        return this.name || 'Series ' + (this.index + 1);
		    },

		    /**
		     * @private
		     * @function Highcharts.Series#getCyclic
		     *
		     * @param {string} prop
		     *
		     * @param {*} value
		     *
		     * @param {*} [defaults]
		     */
		    getCyclic: function (prop, value, defaults) {
		        var i,
		            chart = this.chart,
		            userOptions = this.userOptions,
		            indexName = prop + 'Index',
		            counterName = prop + 'Counter',
		            len = defaults ? defaults.length : pick(
		                chart.options.chart[prop + 'Count'],
		                chart[prop + 'Count']
		            ),
		            setting;

		        if (!value) {
		            // Pick up either the colorIndex option, or the _colorIndex after
		            // Series.update()
		            setting = pick(
		                userOptions[indexName],
		                userOptions['_' + indexName]
		            );
		            if (defined(setting)) { // after Series.update()
		                i = setting;
		            } else {
		                // #6138
		                if (!chart.series.length) {
		                    chart[counterName] = 0;
		                }
		                userOptions['_' + indexName] = i = chart[counterName] % len;
		                chart[counterName] += 1;
		            }
		            if (defaults) {
		                value = defaults[i];
		            }
		        }
		        // Set the colorIndex
		        if (i !== undefined) {
		            this[indexName] = i;
		        }
		        this[prop] = value;
		    },

		    /**
		     * Get the series' color based on either the options or pulled from global
		     * options.
		     *
		     * @function Highcharts.Series#getColor
		     */

		    getColor: function () {
		        if (this.options.colorByPoint) {
		            // #4359, selected slice got series.color even when colorByPoint was
		            // set.
		            this.options.color = null;
		        } else {
		            this.getCyclic(
		                'color',
		                this.options.color || defaultPlotOptions[this.type].color,
		                this.chart.options.colors
		            );
		        }
		    },

		    /**
		     * Get the series' symbol based on either the options or pulled from global
		     * options.
		     *
		     * @function Highcharts.Series#getSymbol
		     */
		    getSymbol: function () {
		        var seriesMarkerOption = this.options.marker;
		        this.getCyclic(
		            'symbol',
		            seriesMarkerOption.symbol,
		            this.chart.options.symbols
		        );
		    },

		    /**
		     * @private
		     * @borrows LegendSymbolMixin.drawLineMarker as Highcharts.Series#drawLegendSymbol
		     */
		    drawLegendSymbol: LegendSymbolMixin.drawLineMarker,

		    /**
		     * Internal function called from setData. If the point count is the same as
		     * is was, or if there are overlapping X values, just run Point.update which
		     * is cheaper, allows animation, and keeps references to points. This also
		     * allows adding or removing points if the X-es don't match.
		     *
		     * @private
		     * @function Highcharts.Series#updateData
		     *
		     * @param {Array<*>} data
		     *
		     * @return {boolean}
		     */
		    updateData: function (data) {
		        var options = this.options,
		            oldData = this.points,
		            pointsToAdd = [],
		            hasUpdatedByKey,
		            i,
		            point,
		            lastIndex,
		            requireSorting = this.requireSorting;

		        // Iterate the new data
		        each(data, function (pointOptions) {
		            var x,
		                pointIndex;

		            // Get the x of the new data point
		            x = (
		                H.defined(pointOptions) &&
		                this.pointClass.prototype.optionsToObject.call(
		                    { series: this },
		                    pointOptions
		                ).x
		            );

		            if (isNumber(x)) {
		                // Search for the same X in the existing data set
		                pointIndex = H.inArray(x, this.xData, lastIndex);

		                // Matching X not found
		                // or used already due to ununique x values (#8995),
		                // add point (but later)
		                if (pointIndex === -1 || oldData[pointIndex].touched) {
		                    pointsToAdd.push(pointOptions);

		                // Matching X found, update
		                } else if (pointOptions !== options.data[pointIndex]) {
		                    oldData[pointIndex].update(
		                        pointOptions,
		                        false,
		                        null,
		                        false
		                    );

		                    // Mark it touched, below we will remove all points that
		                    // are not touched.
		                    oldData[pointIndex].touched = true;

		                    // Speed optimize by only searching after last known index.
		                    // Performs ~20% bettor on large data sets.
		                    if (requireSorting) {
		                        lastIndex = pointIndex + 1;
		                    }
		                // Point exists, no changes, don't remove it
		                } else if (oldData[pointIndex]) {
		                    oldData[pointIndex].touched = true;
		                }
		                hasUpdatedByKey = true;
		            }
		        }, this);

		        // Remove points that don't exist in the updated data set
		        if (hasUpdatedByKey) {
		            i = oldData.length;
		            while (i--) {
		                point = oldData[i];
		                if (!point.touched) {
		                    point.remove(false);
		                }
		                point.touched = false;
		            }

		        // If we did not find keys (x-values), and the length is the same,
		        // update one-to-one
		        } else if (data.length === oldData.length) {
		            each(data, function (point, i) {
		                // .update doesn't exist on a linked, hidden series (#3709)
		                if (oldData[i].update && point !== options.data[i]) {
		                    oldData[i].update(point, false, null, false);
		                }
		            });

		        // Did not succeed in updating data
		        } else {
		            return false;
		        }

		        // Add new points
		        each(pointsToAdd, function (point) {
		            this.addPoint(point, false);
		        }, this);

		        return true;
		    },

		    /**
		     * Apply a new set of data to the series and optionally redraw it. The new
		     * data array is passed by reference (except in case of `updatePoints`), and
		     * may later be mutated when updating the chart data.
		     *
		     * Note the difference in behaviour when setting the same amount of points,
		     * or a different amount of points, as handled by the `updatePoints`
		     * parameter.
		     *
		     * @sample highcharts/members/series-setdata/
		     *         Set new data from a button
		     * @sample highcharts/members/series-setdata-pie/
		     *         Set data in a pie
		     * @sample stock/members/series-setdata/
		     *         Set new data in Highstock
		     * @sample maps/members/series-setdata/
		     *         Set new data in Highmaps
		     *
		     * @function Highcharts.Series#setData
		     *
		     * @param {Array<*>} data
		     *        Takes an array of data in the same format as described under
		     *        `series.{type}.data` for the given series type, for example a
		     *        line series would take data in the form described under
		     *        [series.line.data](https://api.highcharts.com/highcharts/series.line.data).
		     *
		     * @param {boolean} [redraw=true]
		     *        Whether to redraw the chart after the series is altered. If doing
		     *        more operations on the chart, it is a good idea to set redraw to
		     *        false and call {@link Chart#redraw} after.
		     *
		     * @param {Highcharts.AnimationOptionsObject} [animation]
		     *        When the updated data is the same length as the existing data,
		     *        points will be updated by default, and animation visualizes how
		     *        the points are changed. Set false to disable animation, or a
		     *        configuration object to set duration or easing.
		     *
		     * @param {boolean} [updatePoints=true]
		     *        When the updated data is the same length as the existing data, or
		     *        points can be matched by X values, points will be updated instead
		     *        of replaced. This allows updating with animation and performs
		     *        better. In this case, the original array is not passed by
		     *        reference. Set `false` to prevent.
		     */
		    setData: function (data, redraw, animation, updatePoints) {
		        var series = this,
		            oldData = series.points,
		            oldDataLength = (oldData && oldData.length) || 0,
		            dataLength,
		            options = series.options,
		            chart = series.chart,
		            firstPoint = null,
		            xAxis = series.xAxis,
		            i,
		            turboThreshold = options.turboThreshold,
		            pt,
		            xData = this.xData,
		            yData = this.yData,
		            pointArrayMap = series.pointArrayMap,
		            valueCount = pointArrayMap && pointArrayMap.length,
		            updatedData;

		        data = data || [];
		        dataLength = data.length;
		        redraw = pick(redraw, true);

		        // If the point count is the same as is was, just run Point.update which
		        // is cheaper, allows animation, and keeps references to points.
		        if (
		            updatePoints !== false &&
		            dataLength &&
		            oldDataLength &&
		            !series.cropped &&
		            !series.hasGroupedData &&
		            series.visible &&
		            // Soft updating has no benefit in boost, and causes JS error
		            // (#8355)
		            !series.isSeriesBoosting
		        ) {
		            updatedData = this.updateData(data);
		        }

		        if (!updatedData) {

		            // Reset properties
		            series.xIncrement = null;

		            series.colorCounter = 0; // for series with colorByPoint (#1547)

		            // Update parallel arrays
		            each(this.parallelArrays, function (key) {
		                series[key + 'Data'].length = 0;
		            });

		            // In turbo mode, only one- or twodimensional arrays of numbers are
		            // allowed. The first value is tested, and we assume that all the
		            // rest are defined the same way. Although the 'for' loops are
		            // similar, they are repeated inside each if-else conditional for
		            // max performance.
		            if (turboThreshold && dataLength > turboThreshold) {

		                // find the first non-null point
		                i = 0;
		                while (firstPoint === null && i < dataLength) {
		                    firstPoint = data[i];
		                    i++;
		                }


		                if (isNumber(firstPoint)) { // assume all points are numbers
		                    for (i = 0; i < dataLength; i++) {
		                        xData[i] = this.autoIncrement();
		                        yData[i] = data[i];
		                    }

		                // Assume all points are arrays when first point is
		                } else if (isArray(firstPoint)) {
		                    if (valueCount) { // [x, low, high] or [x, o, h, l, c]
		                        for (i = 0; i < dataLength; i++) {
		                            pt = data[i];
		                            xData[i] = pt[0];
		                            yData[i] = pt.slice(1, valueCount + 1);
		                        }
		                    } else { // [x, y]
		                        for (i = 0; i < dataLength; i++) {
		                            pt = data[i];
		                            xData[i] = pt[0];
		                            yData[i] = pt[1];
		                        }
		                    }
		                } else {
		                    // Highcharts expects configs to be numbers or arrays in
		                    // turbo mode
		                    H.error(12);
		                }
		            } else {
		                for (i = 0; i < dataLength; i++) {
		                    if (data[i] !== undefined) { // stray commas in oldIE
		                        pt = { series: series };
		                        series.pointClass.prototype.applyOptions.apply(
		                            pt,
		                            [data[i]]
		                        );
		                        series.updateParallelArrays(pt, i);
		                    }
		                }
		            }

		            // Forgetting to cast strings to numbers is a common caveat when
		            // handling CSV or JSON
		            if (yData && isString(yData[0])) {
		                H.error(14, true);
		            }

		            series.data = [];
		            series.options.data = series.userOptions.data = data;

		            // destroy old points
		            i = oldDataLength;
		            while (i--) {
		                if (oldData[i] && oldData[i].destroy) {
		                    oldData[i].destroy();
		                }
		            }

		            // reset minRange (#878)
		            if (xAxis) {
		                xAxis.minRange = xAxis.userMinRange;
		            }

		            // redraw
		            series.isDirty = chart.isDirtyBox = true;
		            series.isDirtyData = !!oldData;
		            animation = false;
		        }

		        // Typically for pie series, points need to be processed and generated
		        // prior to rendering the legend
		        if (options.legendType === 'point') {
		            this.processData();
		            this.generatePoints();
		        }

		        if (redraw) {
		            chart.redraw(animation);
		        }
		    },

		    /**
		     * Internal function to process the data by cropping away unused data points
		     * if the series is longer than the crop threshold. This saves computing
		     * time for large series. In Highstock, this function is extended to
		     * provide data grouping.
		     *
		     * @private
		     * @function Highcharts.Series#processData
		     *
		     * @param {boolean} force
		     *        Force data grouping.
		     *
		     * @return {boolean|undefined}
		     */
		    processData: function (force) {
		        var series = this,
		            processedXData = series.xData, // copied during slice operation
		            processedYData = series.yData,
		            dataLength = processedXData.length,
		            croppedData,
		            cropStart = 0,
		            cropped,
		            distance,
		            closestPointRange,
		            xAxis = series.xAxis,
		            i, // loop variable
		            options = series.options,
		            cropThreshold = options.cropThreshold,
		            getExtremesFromAll =
		                series.getExtremesFromAll ||
		                options.getExtremesFromAll, // #4599
		            isCartesian = series.isCartesian,
		            xExtremes,
		            val2lin = xAxis && xAxis.val2lin,
		            isLog = xAxis && xAxis.isLog,
		            throwOnUnsorted = series.requireSorting,
		            min,
		            max;

		        // If the series data or axes haven't changed, don't go through this.
		        // Return false to pass the message on to override methods like in data
		        // grouping.
		        if (
		            isCartesian &&
		            !series.isDirty &&
		            !xAxis.isDirty &&
		            !series.yAxis.isDirty &&
		            !force
		        ) {
		            return false;
		        }

		        if (xAxis) {
		            xExtremes = xAxis.getExtremes(); // corrected for log axis (#3053)
		            min = xExtremes.min;
		            max = xExtremes.max;
		        }

		        // optionally filter out points outside the plot area
		        if (
		            isCartesian &&
		            series.sorted &&
		            !getExtremesFromAll &&
		            (!cropThreshold || dataLength > cropThreshold || series.forceCrop)
		        ) {

		            // it's outside current extremes
		            if (
		                processedXData[dataLength - 1] < min ||
		                processedXData[0] > max
		            ) {
		                processedXData = [];
		                processedYData = [];

		            // only crop if it's actually spilling out
		            } else if (
		                series.yData && (
		                    processedXData[0] < min ||
		                    processedXData[dataLength - 1] > max
		                )
		            ) {
		                croppedData = this.cropData(
		                    series.xData,
		                    series.yData,
		                    min,
		                    max
		                );
		                processedXData = croppedData.xData;
		                processedYData = croppedData.yData;
		                cropStart = croppedData.start;
		                cropped = true;
		            }
		        }


		        // Find the closest distance between processed points
		        i = processedXData.length || 1;
		        while (--i) {
		            distance = isLog ?
		                val2lin(processedXData[i]) - val2lin(processedXData[i - 1]) :
		                processedXData[i] - processedXData[i - 1];

		            if (
		                distance > 0 &&
		                (
		                    closestPointRange === undefined ||
		                    distance < closestPointRange
		                )
		            ) {
		                closestPointRange = distance;

		            // Unsorted data is not supported by the line tooltip, as well as
		            // data grouping and navigation in Stock charts (#725) and width
		            // calculation of columns (#1900)
		            } else if (distance < 0 && throwOnUnsorted) {
		                H.error(15);
		                throwOnUnsorted = false; // Only once
		            }
		        }

		        // Record the properties
		        series.cropped = cropped; // undefined or true
		        series.cropStart = cropStart;
		        series.processedXData = processedXData;
		        series.processedYData = processedYData;

		        series.closestPointRange = closestPointRange;

		    },

		    /**
		     * Iterate over xData and crop values between min and max. Returns object
		     * containing crop start/end cropped xData with corresponding part of yData,
		     * dataMin and dataMax within the cropped range.
		     *
		     * @private
		     * @function Highcharts.Series#cropData
		     *
		     * @param {Array<number>} xData
		     *
		     * @param {Array<number>} yData
		     *
		     * @param {number} min
		     *
		     * @param {number} max
		     *
		     * @param {number} [cropShoulder]
		     *
		     * @return {*}
		     */
		    cropData: function (xData, yData, min, max, cropShoulder) {
		        var dataLength = xData.length,
		            cropStart = 0,
		            cropEnd = dataLength,
		            i,
		            j;

		        // line-type series need one point outside
		        cropShoulder = pick(cropShoulder, this.cropShoulder, 1);

		        // iterate up to find slice start
		        for (i = 0; i < dataLength; i++) {
		            if (xData[i] >= min) {
		                cropStart = Math.max(0, i - cropShoulder);
		                break;
		            }
		        }

		        // proceed to find slice end
		        for (j = i; j < dataLength; j++) {
		            if (xData[j] > max) {
		                cropEnd = j + cropShoulder;
		                break;
		            }
		        }

		        return {
		            xData: xData.slice(cropStart, cropEnd),
		            yData: yData.slice(cropStart, cropEnd),
		            start: cropStart,
		            end: cropEnd
		        };
		    },


		    /**
		     * Generate the data point after the data has been processed by cropping
		     * away unused points and optionally grouped in Highcharts Stock.
		     *
		     * @private
		     * @function Highcharts.Series#generatePoints
		     */
		    generatePoints: function () {
		        var series = this,
		            options = series.options,
		            dataOptions = options.data,
		            data = series.data,
		            dataLength,
		            processedXData = series.processedXData,
		            processedYData = series.processedYData,
		            PointClass = series.pointClass,
		            processedDataLength = processedXData.length,
		            cropStart = series.cropStart || 0,
		            cursor,
		            hasGroupedData = series.hasGroupedData,
		            keys = options.keys,
		            point,
		            points = [],
		            i;

		        if (!data && !hasGroupedData) {
		            var arr = [];
		            arr.length = dataOptions.length;
		            data = series.data = arr;
		        }

		        if (keys && hasGroupedData) {
		            // grouped data has already applied keys (#6590)
		            series.options.keys = false;
		        }

		        for (i = 0; i < processedDataLength; i++) {
		            cursor = cropStart + i;
		            if (!hasGroupedData) {
		                point = data[cursor];
		                if (!point && dataOptions[cursor] !== undefined) { // #970
		                    data[cursor] = point = (new PointClass()).init(
		                        series,
		                        dataOptions[cursor],
		                        processedXData[i]
		                    );
		                }
		            } else {
		                // splat the y data in case of ohlc data array
		                point = (new PointClass()).init(
		                    series,
		                    [processedXData[i]].concat(splat(processedYData[i]))
		                );

		                /**
		                 * Highstock only. If a point object is created by data
		                 * grouping, it doesn't reflect actual points in the raw data.
		                 * In this case, the `dataGroup` property holds information
		                 * that points back to the raw data.
		                 *
		                 * - `dataGroup.start` is the index of the first raw data point
		                 * in the group.
		                 * - `dataGroup.length` is the amount of points in the group.
		                 *
		                 * @name Highcharts.Point#dataGroup
		                 * @type {Highcharts.SVGElement|undefined}
		                 *
		                 * @product highstock
		                 */
		                point.dataGroup = series.groupMap[i];
		                if (point.dataGroup.options) {
		                    point.options = point.dataGroup.options;
		                    extend(point, point.dataGroup.options);
		                }
		            }
		            if (point) { // #6279
		                point.index = cursor; // For faster access in Point.update
		                points[i] = point;
		            }
		        }

		        // restore keys options (#6590)
		        series.options.keys = keys;

		        // Hide cropped-away points - this only runs when the number of points
		        // is above cropThreshold, or when swithching view from non-grouped
		        // data to grouped data (#637)
		        if (
		            data &&
		            (
		                processedDataLength !== (dataLength = data.length) ||
		                hasGroupedData
		            )
		        ) {
		            for (i = 0; i < dataLength; i++) {
		                // when has grouped data, clear all points
		                if (i === cropStart && !hasGroupedData) {
		                    i += processedDataLength;
		                }
		                if (data[i]) {
		                    data[i].destroyElements();
		                    data[i].plotX = undefined; // #1003
		                }
		            }
		        }

		        /**
		         * Read only. An array containing those values converted to points.
		         * In case the series data length exceeds the `cropThreshold`, or if the
		         * data is grouped, `series.data` doesn't contain all the points. Also,
		         * in case a series is hidden, the `data` array may be empty. To access
		         * raw values, `series.options.data` will always be up to date.
		         * `Series.data` only contains the points that have been created on
		         * demand. To modify the data, use {@link Highcharts.Series#setData} or
		         * {@link Highcharts.Point#update}.
		         *
		         * @see Series.points
		         *
		         * @name Highcharts.Series#data
		         * @type {Array<Point>}
		         */
		        series.data = data;

		        /**
		         * An array containing all currently visible point objects. In case of
		         * cropping, the cropped-away points are not part of this array. The
		         * `series.points` array starts at `series.cropStart` compared to
		         * `series.data` and `series.options.data`. If however the series data
		         * is grouped, these can't be correlated one to one. To
		         * modify the data, use {@link Highcharts.Series#setData} or {@link
		         * Highcharts.Point#update}.
		         *
		         * @name Highcharts.Series#points
		         * @type {Array<Highcharts.Point>}
		         */
		        series.points = points;
		    },

		    /**
		     * Calculate Y extremes for the visible data. The result is set as
		     * `dataMin` and `dataMax` on the Series item.
		     *
		     * @function Highcharts.Series#getExtremes
		     *
		     * @param {Array<number>} [yData]
		     *        The data to inspect. Defaults to the current data within the
		     *        visible range.
		     */
		    getExtremes: function (yData) {
		        var xAxis = this.xAxis,
		            yAxis = this.yAxis,
		            xData = this.processedXData,
		            yDataLength,
		            activeYData = [],
		            activeCounter = 0,
		            // #2117, need to compensate for log X axis
		            xExtremes = xAxis.getExtremes(),
		            xMin = xExtremes.min,
		            xMax = xExtremes.max,
		            validValue,
		            withinRange,
		            // Handle X outside the viewed area. This does not work with non-
		            // sorted data like scatter (#7639).
		            shoulder = this.requireSorting ? 1 : 0,
		            x,
		            y,
		            i,
		            j;

		        yData = yData || this.stackedYData || this.processedYData || [];
		        yDataLength = yData.length;

		        for (i = 0; i < yDataLength; i++) {

		            x = xData[i];
		            y = yData[i];

		            // For points within the visible range, including the first point
		            // outside the visible range (#7061), consider y extremes.
		            validValue = (
		                (isNumber(y, true) || isArray(y)) &&
		                (!yAxis.positiveValuesOnly || (y.length || y > 0))
		            );
		            withinRange = (
		                this.getExtremesFromAll ||
		                this.options.getExtremesFromAll ||
		                this.cropped ||
		                (
		                    (xData[i + shoulder] || x) >= xMin &&
		                    (xData[i - shoulder] || x) <= xMax
		                )
		            );

		            if (validValue && withinRange) {

		                j = y.length;
		                if (j) { // array, like ohlc or range data
		                    while (j--) {
		                        if (typeof y[j] === 'number') { // #7380
		                            activeYData[activeCounter++] = y[j];
		                        }
		                    }
		                } else {
		                    activeYData[activeCounter++] = y;
		                }
		            }
		        }

		        this.dataMin = arrayMin(activeYData);
		        this.dataMax = arrayMax(activeYData);
		    },

		    /**
		     * Translate data points from raw data values to chart specific positioning
		     * data needed later in the `drawPoints` and `drawGraph` functions. This
		     * function can be overridden in plugins and custom series type
		     * implementations.
		     *
		     * @function Highcharts.Series#translate
		     *
		     * @todo
		     * Make events official: Fires the event `afterTranslate`.
		     */
		    translate: function () {
		        if (!this.processedXData) { // hidden series
		            this.processData();
		        }
		        this.generatePoints();
		        var series = this,
		            options = series.options,
		            stacking = options.stacking,
		            xAxis = series.xAxis,
		            categories = xAxis.categories,
		            yAxis = series.yAxis,
		            points = series.points,
		            dataLength = points.length,
		            hasModifyValue = !!series.modifyValue,
		            i,
		            pointPlacement = options.pointPlacement,
		            dynamicallyPlaced =
		                pointPlacement === 'between' ||
		                isNumber(pointPlacement),
		            threshold = options.threshold,
		            stackThreshold = options.startFromThreshold ? threshold : 0,
		            plotX,
		            plotY,
		            lastPlotX,
		            stackIndicator,
		            closestPointRangePx = Number.MAX_VALUE;

		        /*
		         * Plotted coordinates need to be within a limited range. Drawing too
		         * far outside the viewport causes various rendering issues (#3201,
		         * #3923, #7555).
		         */
		        function limitedRange(val) {
		            return Math.min(Math.max(-1e5, val), 1e5);
		        }

		        // Point placement is relative to each series pointRange (#5889)
		        if (pointPlacement === 'between') {
		            pointPlacement = 0.5;
		        }
		        if (isNumber(pointPlacement)) {
		            pointPlacement *= pick(options.pointRange || xAxis.pointRange);
		        }

		        // Translate each point
		        for (i = 0; i < dataLength; i++) {
		            var point = points[i],
		                xValue = point.x,
		                yValue = point.y,
		                yBottom = point.low,
		                stack = stacking && yAxis.stacks[(
		                    series.negStacks &&
		                    yValue < (stackThreshold ? 0 : threshold) ? '-' : ''
		                ) + series.stackKey],
		                pointStack,
		                stackValues;

		            // Discard disallowed y values for log axes (#3434)
		            if (yAxis.positiveValuesOnly && yValue !== null && yValue <= 0) {
		                point.isNull = true;
		            }

		            // Get the plotX translation
		            point.plotX = plotX = correctFloat( // #5236
		                limitedRange(xAxis.translate( // #3923
		                    xValue,
		                    0,
		                    0,
		                    0,
		                    1,
		                    pointPlacement,
		                    this.type === 'flags'
		                )) // #3923
		            );

		            // Calculate the bottom y value for stacked series
		            if (
		                stacking &&
		                series.visible &&
		                !point.isNull &&
		                stack &&
		                stack[xValue]
		            ) {
		                stackIndicator = series.getStackIndicator(
		                    stackIndicator,
		                    xValue,
		                    series.index
		                );
		                pointStack = stack[xValue];
		                stackValues = pointStack.points[stackIndicator.key];
		                yBottom = stackValues[0];
		                yValue = stackValues[1];

		                if (
		                    yBottom === stackThreshold &&
		                    stackIndicator.key === stack[xValue].base
		                ) {
		                    yBottom = pick(isNumber(threshold) && threshold, yAxis.min);
		                }
		                if (yAxis.positiveValuesOnly && yBottom <= 0) { // #1200, #1232
		                    yBottom = null;
		                }

		                point.total = point.stackTotal = pointStack.total;
		                point.percentage =
		                    pointStack.total &&
		                    (point.y / pointStack.total * 100);
		                point.stackY = yValue;

		                // Place the stack label
		                pointStack.setOffset(
		                    series.pointXOffset || 0,
		                    series.barW || 0
		                );

		            }

		            // Set translated yBottom or remove it
		            point.yBottom = defined(yBottom) ?
		                limitedRange(yAxis.translate(yBottom, 0, 1, 0, 1)) :
		                null;

		            // general hook, used for Highstock compare mode
		            if (hasModifyValue) {
		                yValue = series.modifyValue(yValue, point);
		            }

		            // Set the the plotY value, reset it for redraws
		            point.plotY = plotY =
		                (typeof yValue === 'number' && yValue !== Infinity) ?
		                    limitedRange(yAxis.translate(yValue, 0, 1, 0, 1)) : // #3201
		                    undefined;

		            point.isInside =
		                plotY !== undefined &&
		                plotY >= 0 &&
		                plotY <= yAxis.len && // #3519
		                plotX >= 0 &&
		                plotX <= xAxis.len;


		            // Set client related positions for mouse tracking
		            point.clientX = dynamicallyPlaced ?
		                correctFloat(
		                    xAxis.translate(xValue, 0, 0, 0, 1, pointPlacement)
		                ) :
		                plotX; // #1514, #5383, #5518

		            point.negative = point.y < (threshold || 0);

		            // some API data
		            point.category = categories && categories[point.x] !== undefined ?
		                categories[point.x] : point.x;

		            // Determine auto enabling of markers (#3635, #5099)
		            if (!point.isNull) {
		                if (lastPlotX !== undefined) {
		                    closestPointRangePx = Math.min(
		                        closestPointRangePx,
		                        Math.abs(plotX - lastPlotX)
		                    );
		                }
		                lastPlotX = plotX;
		            }

		            // Find point zone
		            point.zone = this.zones.length && point.getZone();
		        }
		        series.closestPointRangePx = closestPointRangePx;

		        fireEvent(this, 'afterTranslate');
		    },

		    /**
		     * Return the series points with null points filtered out.
		     *
		     * @param {Array<Highcharts.Point>} [points]
		     *        The points to inspect, defaults to {@link Series.points}.
		     *
		     * @param {boolean} [insideOnly=false]
		     *        Whether to inspect only the points that are inside the visible
		     *        view.
		     *
		     * @return {Array<Highcharts.Point>}
		     *         The valid points.
		     */
		    getValidPoints: function (points, insideOnly) {
		        var chart = this.chart;
		        // #3916, #5029, #5085
		        return grep(points || this.points || [], function isValidPoint(point) {
		            if (insideOnly && !chart.isInsidePlot(
		                point.plotX,
		                point.plotY,
		                chart.inverted
		            )) {
		                return false;
		            }
		            return !point.isNull;
		        });
		    },

		    /**
		     * Set the clipping for the series. For animated series it is called twice,
		     * first to initiate animating the clip then the second time without the
		     * animation to set the final clip.
		     *
		     * @private
		     * @function Highcharts.Series#setClip
		     *
		     * @param {boolean} [animation]
		     */
		    setClip: function (animation) {
		        var chart = this.chart,
		            options = this.options,
		            renderer = chart.renderer,
		            inverted = chart.inverted,
		            seriesClipBox = this.clipBox,
		            clipBox = seriesClipBox || chart.clipBox,
		            sharedClipKey =
		                this.sharedClipKey ||
		                [
		                    '_sharedClip',
		                    animation && animation.duration,
		                    animation && animation.easing,
		                    clipBox.height,
		                    options.xAxis,
		                    options.yAxis
		                ].join(','), // #4526
		            clipRect = chart[sharedClipKey],
		            markerClipRect = chart[sharedClipKey + 'm'];

		        // If a clipping rectangle with the same properties is currently present
		        // in the chart, use that.
		        if (!clipRect) {

		            // When animation is set, prepare the initial positions
		            if (animation) {
		                clipBox.width = 0;
		                if (inverted) {
		                    clipBox.x = chart.plotSizeX;
		                }

		                chart[sharedClipKey + 'm'] = markerClipRect = renderer.clipRect(
		                    // include the width of the first marker
		                    inverted ? chart.plotSizeX + 99 : -99,
		                    inverted ? -chart.plotLeft : -chart.plotTop,
		                    99,
		                    inverted ? chart.chartWidth : chart.chartHeight
		                );
		            }
		            chart[sharedClipKey] = clipRect = renderer.clipRect(clipBox);
		            // Create hashmap for series indexes
		            clipRect.count = { length: 0 };

		        }
		        if (animation) {
		            if (!clipRect.count[this.index]) {
		                clipRect.count[this.index] = true;
		                clipRect.count.length += 1;
		            }
		        }

		        if (options.clip !== false) {
		            this.group.clip(
		                animation || seriesClipBox ? clipRect : chart.clipRect
		            );
		            this.markerGroup.clip(markerClipRect);
		            this.sharedClipKey = sharedClipKey;
		        }

		        // Remove the shared clipping rectangle when all series are shown
		        if (!animation) {
		            if (clipRect.count[this.index]) {
		                delete clipRect.count[this.index];
		                clipRect.count.length -= 1;
		            }

		            if (
		                clipRect.count.length === 0 &&
		                sharedClipKey &&
		                chart[sharedClipKey]
		            ) {
		                if (!seriesClipBox) {
		                    chart[sharedClipKey] = chart[sharedClipKey].destroy();
		                }
		                if (chart[sharedClipKey + 'm']) {
		                    chart[sharedClipKey + 'm'] =
		                        chart[sharedClipKey + 'm'].destroy();
		                }
		            }
		        }
		    },

		    /**
		     * Animate in the series. Called internally twice. First with the `init`
		     * parameter set to true, which sets up the initial state of the animation.
		     * Then when ready, it is called with the `init` parameter undefined, in
		     * order to perform the actual animation. After the second run, the function
		     * is removed.
		     *
		     * @function Highcharts.Series#animate
		     *
		     * @param {boolean} init
		     *        Initialize the animation.
		     */
		    animate: function (init) {
		        var series = this,
		            chart = series.chart,
		            clipRect,
		            animation = animObject(series.options.animation),
		            sharedClipKey;

		        // Initialize the animation. Set up the clipping rectangle.
		        if (init) {

		            series.setClip(animation);

		        // Run the animation
		        } else {
		            sharedClipKey = this.sharedClipKey;
		            clipRect = chart[sharedClipKey];
		            if (clipRect) {
		                clipRect.animate({
		                    width: chart.plotSizeX,
		                    x: 0
		                }, animation);
		            }
		            if (chart[sharedClipKey + 'm']) {
		                chart[sharedClipKey + 'm'].animate({
		                    width: chart.plotSizeX + 99,
		                    x: 0
		                }, animation);
		            }

		            // Delete this function to allow it only once
		            series.animate = null;

		        }
		    },

		    /**
		     * This runs after animation to land on the final plot clipping.
		     *
		     * @private
		     * @function Highcharts.Series#afterAnimate
		     *
		     * @todo
		     * Make events official: Fires the event `afterAnimate`.
		     */
		    afterAnimate: function () {
		        this.setClip();
		        fireEvent(this, 'afterAnimate');
		        this.finishedAnimating = true;
		    },

		    /**
		     * Draw the markers for line-like series types, and columns or other
		     * graphical representation for {@link Point} objects for other series
		     * types. The resulting element is typically stored as {@link
		     * Point.graphic}, and is created on the first call and updated and moved on
		     * subsequent calls.
		     *
		     * @function Highcharts.Series#drawPoints
		     */
		    drawPoints: function () {
		        var series = this,
		            points = series.points,
		            chart = series.chart,
		            i,
		            point,
		            symbol,
		            graphic,
		            options = series.options,
		            seriesMarkerOptions = options.marker,
		            pointMarkerOptions,
		            hasPointMarker,
		            enabled,
		            isInside,
		            markerGroup = series[series.specialGroup] || series.markerGroup,
		            xAxis = series.xAxis,
		            markerAttribs,
		            globallyEnabled = pick(
		                seriesMarkerOptions.enabled,
		                xAxis.isRadial ? true : null,
		                // Use larger or equal as radius is null in bubbles (#6321)
		                series.closestPointRangePx >= (
		                    seriesMarkerOptions.enabledThreshold *
		                    seriesMarkerOptions.radius
		                )
		            );

		        if (seriesMarkerOptions.enabled !== false || series._hasPointMarkers) {

		            for (i = 0; i < points.length; i++) {
		                point = points[i];
		                graphic = point.graphic;
		                pointMarkerOptions = point.marker || {};
		                hasPointMarker = !!point.marker;
		                enabled = (
		                    globallyEnabled &&
		                    pointMarkerOptions.enabled === undefined
		                ) || pointMarkerOptions.enabled;
		                isInside = point.isInside;

		                // only draw the point if y is defined
		                if (enabled && !point.isNull) {

		                    // Shortcuts
		                    symbol = pick(pointMarkerOptions.symbol, series.symbol);

		                    markerAttribs = series.markerAttribs(
		                        point,
		                        point.selected && 'select'
		                    );

		                    if (graphic) { // update
		                        // Since the marker group isn't clipped, each individual
		                        // marker must be toggled
		                        graphic[isInside ? 'show' : 'hide'](true)
		                            .animate(markerAttribs);
		                    } else if (
		                        isInside &&
		                        (markerAttribs.width > 0 || point.hasImage)
		                    ) {

		                        /**
		                         * The graphic representation of the point. Typically
		                         * this is a simple shape, like a `rect` for column
		                         * charts or `path` for line markers, but for some
		                         * complex series types like boxplot or 3D charts, the
		                         * graphic may be a `g` element containing other shapes.
		                         * The graphic is generated the first time {@link
		                         * Series#drawPoints} runs, and updated and moved on
		                         * subsequent runs.
		                         *
		                         * @memberof Point
		                         * @name graphic
		                         * @type {SVGElement}
		                         */
		                        point.graphic = graphic = chart.renderer.symbol(
		                            symbol,
		                            markerAttribs.x,
		                            markerAttribs.y,
		                            markerAttribs.width,
		                            markerAttribs.height,
		                            hasPointMarker ?
		                                pointMarkerOptions :
		                                seriesMarkerOptions
		                        )
		                        .add(markerGroup);
		                    }


		                    // Presentational attributes
		                    if (graphic) {
		                        graphic.attr(
		                            series.pointAttribs(
		                                point,
		                                point.selected && 'select'
		                            )
		                        );
		                    }


		                    if (graphic) {
		                        graphic.addClass(point.getClassName(), true);
		                    }

		                } else if (graphic) {
		                    point.graphic = graphic.destroy(); // #1269
		                }
		            }
		        }

		    },

		    /**
		     * Get non-presentational attributes for a point. Used internally for both
		     * styled mode and classic. Can be overridden for different series types.
		     *
		     * @see Series#pointAttribs
		     *
		     * @param {Highcharts.Point} point
		     *        The Point to inspect.
		     *
		     * @param {string} [state]
		     *        The state, can be either `hover`, `select` or undefined.
		     *
		     * @return {Highcharts.SVGAttributes}
		     *         A hash containing those attributes that are not settable from
		     *         CSS.
		     */
		    markerAttribs: function (point, state) {
		        var seriesMarkerOptions = this.options.marker,
		            seriesStateOptions,
		            pointMarkerOptions = point.marker || {},
		            symbol = pointMarkerOptions.symbol || seriesMarkerOptions.symbol,
		            pointStateOptions,
		            radius = pick(
		                pointMarkerOptions.radius,
		                seriesMarkerOptions.radius
		            ),
		            attribs;

		        // Handle hover and select states
		        if (state) {
		            seriesStateOptions = seriesMarkerOptions.states[state];
		            pointStateOptions = pointMarkerOptions.states &&
		                pointMarkerOptions.states[state];

		            radius = pick(
		                pointStateOptions && pointStateOptions.radius,
		                seriesStateOptions && seriesStateOptions.radius,
		                radius + (
		                    seriesStateOptions && seriesStateOptions.radiusPlus ||
		                    0
		                )
		            );
		        }

		        point.hasImage = symbol && symbol.indexOf('url') === 0;

		        if (point.hasImage) {
		            radius = 0; // and subsequently width and height is not set
		        }

		        attribs = {
		            x: Math.floor(point.plotX) - radius, // Math.floor for #1843
		            y: point.plotY - radius
		        };

		        if (radius) {
		            attribs.width = attribs.height = 2 * radius;
		        }

		        return attribs;

		    },



		    /**
		     * Internal function to get presentational attributes for each point. Unlike
		     * {@link Series#markerAttribs}, this function should return those
		     * attributes that can also be set in CSS. In styled mode, `pointAttribs`
		     * won't be called.
		     *
		     * @param {Highcharts.Point} point
		     *        The point instance to inspect.
		     *
		     * @param {string} [state]
		     *        The point state, can be either `hover`, `select` or undefined for
		     *        normal state.
		     *
		     * @return {Highcharts.SVGAttributes}
		     *         The presentational attributes to be set on the point.
		     */
		    pointAttribs: function (point, state) {
		        var seriesMarkerOptions = this.options.marker,
		            seriesStateOptions,
		            pointOptions = point && point.options,
		            pointMarkerOptions = (pointOptions && pointOptions.marker) || {},
		            pointStateOptions,
		            color = this.color,
		            pointColorOption = pointOptions && pointOptions.color,
		            pointColor = point && point.color,
		            strokeWidth = pick(
		                pointMarkerOptions.lineWidth,
		                seriesMarkerOptions.lineWidth
		            ),
		            zoneColor = point && point.zone && point.zone.color,
		            fill,
		            stroke;

		        color = (
		            pointColorOption ||
		            zoneColor ||
		            pointColor ||
		            color
		        );
		        fill = (
		            pointMarkerOptions.fillColor ||
		            seriesMarkerOptions.fillColor ||
		            color
		        );
		        stroke = (
		            pointMarkerOptions.lineColor ||
		            seriesMarkerOptions.lineColor ||
		            color
		        );

		        // Handle hover and select states
		        if (state) {
		            seriesStateOptions = seriesMarkerOptions.states[state];
		            pointStateOptions = (
		                pointMarkerOptions.states && pointMarkerOptions.states[state]
		            ) || {};
		            strokeWidth = pick(
		                pointStateOptions.lineWidth,
		                seriesStateOptions.lineWidth,
		                strokeWidth + pick(
		                    pointStateOptions.lineWidthPlus,
		                    seriesStateOptions.lineWidthPlus,
		                    0
		                )
		            );
		            fill = (
		                pointStateOptions.fillColor ||
		                seriesStateOptions.fillColor ||
		                fill
		            );
		            stroke = (
		                pointStateOptions.lineColor ||
		                seriesStateOptions.lineColor ||
		                stroke
		            );
		        }

		        return {
		            'stroke': stroke,
		            'stroke-width': strokeWidth,
		            'fill': fill
		        };
		    },



		    /**
		     * Clear DOM objects and free up memory.
		     *
		     * @private
		     * @function Highcharts.Series#destroy
		     *
		     * @todo
		     * Make events official: Fires the event `destroy`.
		     */
		    destroy: function () {
		        var series = this,
		            chart = series.chart,
		            issue134 = /AppleWebKit\/533/.test(win.navigator.userAgent),
		            destroy,
		            i,
		            data = series.data || [],
		            point,
		            axis;

		        // add event hook
		        fireEvent(series, 'destroy');

		        // remove all events
		        removeEvent(series);

		        // erase from axes
		        each(series.axisTypes || [], function (AXIS) {
		            axis = series[AXIS];
		            if (axis && axis.series) {
		                erase(axis.series, series);
		                axis.isDirty = axis.forceRedraw = true;
		            }
		        });

		        // remove legend items
		        if (series.legendItem) {
		            series.chart.legend.destroyItem(series);
		        }

		        // destroy all points with their elements
		        i = data.length;
		        while (i--) {
		            point = data[i];
		            if (point && point.destroy) {
		                point.destroy();
		            }
		        }
		        series.points = null;

		        // Clear the animation timeout if we are destroying the series during
		        // initial animation
		        H.clearTimeout(series.animationTimeout);

		        // Destroy all SVGElements associated to the series
		        objectEach(series, function (val, prop) {
		            // Survive provides a hook for not destroying
		            if (val instanceof SVGElement && !val.survive) {

		                // issue 134 workaround
		                destroy = issue134 && prop === 'group' ?
		                'hide' :
		                'destroy';

		                val[destroy]();
		            }
		        });

		        // remove from hoverSeries
		        if (chart.hoverSeries === series) {
		            chart.hoverSeries = null;
		        }
		        erase(chart.series, series);
		        chart.orderSeries();

		        // clear all members
		        objectEach(series, function (val, prop) {
		            delete series[prop];
		        });
		    },

		    /**
		     * Get the graph path.
		     *
		     * @private
		     * @function Highcharts.Series#getGraphPath
		     *
		     * @param {Array<*>} points
		     *
		     * @param {boolean} nullsAsZeroes
		     *
		     * @param {boolean} connectCliffs
		     *
		     * @return {Array<number|string>}
		     */
		    getGraphPath: function (points, nullsAsZeroes, connectCliffs) {
		        var series = this,
		            options = series.options,
		            step = options.step,
		            reversed,
		            graphPath = [],
		            xMap = [],
		            gap;

		        points = points || series.points;

		        // Bottom of a stack is reversed
		        reversed = points.reversed;
		        if (reversed) {
		            points.reverse();
		        }
		        // Reverse the steps (#5004)
		        step = { right: 1, center: 2 }[step] || (step && 3);
		        if (step && reversed) {
		            step = 4 - step;
		        }

		        // Remove invalid points, especially in spline (#5015)
		        if (options.connectNulls && !nullsAsZeroes && !connectCliffs) {
		            points = this.getValidPoints(points);
		        }

		        // Build the line
		        each(points, function (point, i) {

		            var plotX = point.plotX,
		                plotY = point.plotY,
		                lastPoint = points[i - 1],
		                pathToPoint; // the path to this point from the previous

		            if (
		                (point.leftCliff || (lastPoint && lastPoint.rightCliff)) &&
		                !connectCliffs
		            ) {
		                gap = true; // ... and continue
		            }

		            // Line series, nullsAsZeroes is not handled
		            if (point.isNull && !defined(nullsAsZeroes) && i > 0) {
		                gap = !options.connectNulls;

		            // Area series, nullsAsZeroes is set
		            } else if (point.isNull && !nullsAsZeroes) {
		                gap = true;

		            } else {

		                if (i === 0 || gap) {
		                    pathToPoint = ['M', point.plotX, point.plotY];

		                // Generate the spline as defined in the SplineSeries object
		                } else if (series.getPointSpline) {

		                    pathToPoint = series.getPointSpline(points, point, i);

		                } else if (step) {

		                    if (step === 1) { // right
		                        pathToPoint = [
		                            'L',
		                            lastPoint.plotX,
		                            plotY
		                        ];

		                    } else if (step === 2) { // center
		                        pathToPoint = [
		                            'L',
		                            (lastPoint.plotX + plotX) / 2,
		                            lastPoint.plotY,
		                            'L',
		                            (lastPoint.plotX + plotX) / 2,
		                            plotY
		                        ];

		                    } else {
		                        pathToPoint = [
		                            'L',
		                            plotX,
		                            lastPoint.plotY
		                        ];
		                    }
		                    pathToPoint.push('L', plotX, plotY);

		                } else {
		                    // normal line to next point
		                    pathToPoint = [
		                        'L',
		                        plotX,
		                        plotY
		                    ];
		                }

		                // Prepare for animation. When step is enabled, there are two
		                // path nodes for each x value.
		                xMap.push(point.x);
		                if (step) {
		                    xMap.push(point.x);
		                    if (step === 2) { // step = center (#8073)
		                        xMap.push(point.x);
		                    }
		                }

		                graphPath.push.apply(graphPath, pathToPoint);
		                gap = false;
		            }
		        });

		        graphPath.xMap = xMap;
		        series.graphPath = graphPath;

		        return graphPath;

		    },

		    /**
		     * Draw the graph. Called internally when rendering line-like series types.
		     * The first time it generates the `series.graph` item and optionally other
		     * series-wide items like `series.area` for area charts. On subsequent calls
		     * these items are updated with new positions and attributes.
		     *
		     * @function Highcharts.Series#drawGraph
		     */
		    drawGraph: function () {
		        var series = this,
		            options = this.options,
		            graphPath = (this.gappedPath || this.getGraphPath).call(this),
		            props = [[
		                'graph',
		                'highcharts-graph',

		                options.lineColor || this.color,
		                options.dashStyle

		            ]];

		        props = series.getZonesGraphs(props);

		        // Draw the graph
		        each(props, function (prop, i) {
		            var graphKey = prop[0],
		                graph = series[graphKey],
		                attribs;

		            if (graph) {
		                graph.endX = series.preventGraphAnimation ?
		                    null :
		                    graphPath.xMap;
		                graph.animate({ d: graphPath });

		            } else if (graphPath.length) { // #1487

		                series[graphKey] = series.chart.renderer.path(graphPath)
		                    .addClass(prop[1])
		                    .attr({ zIndex: 1 }) // #1069
		                    .add(series.group);


		                attribs = {
		                    'stroke': prop[2],
		                    'stroke-width': options.lineWidth,
		                    // Polygon series use filled graph
		                    'fill': (series.fillGraph && series.color) || 'none'
		                };

		                if (prop[3]) {
		                    attribs.dashstyle = prop[3];
		                } else if (options.linecap !== 'square') {
		                    attribs['stroke-linecap'] = attribs['stroke-linejoin'] =
		                        'round';
		                }

		                graph = series[graphKey]
		                    .attr(attribs)
		                    // Add shadow to normal series (0) or to first zone (1)
		                    // #3932
		                    .shadow((i < 2) && options.shadow);

		            }

		            // Helpers for animation
		            if (graph) {
		                graph.startX = graphPath.xMap;
		                graph.isArea = graphPath.isArea; // For arearange animation
		            }
		        });
		    },

		    /**
		     * Get zones properties for building graphs.
		     * Extendable by series with multiple lines within one series.
		     *
		     * @private
		     * @function Highcharts.Series#getZonesGraphs
		     *
		     * @param {Array<Array<string>>} props
		     *
		     * @return {Array<Array<string>>}
		     */
		    getZonesGraphs: function (props) {
		        // Add the zone properties if any
		        each(this.zones, function (zone, i) {
		            props.push([
		                'zone-graph-' + i,
		                'highcharts-graph highcharts-zone-graph-' + i + ' ' +
		                    (zone.className || ''),

		                zone.color || this.color,
		                zone.dashStyle || this.options.dashStyle

		            ]);
		        }, this);

		        return props;
		    },

		    /**
		     * Clip the graphs into zones for colors and styling.
		     *
		     * @private
		     * @function Highcharts.Series#applyZones
		     */
		    applyZones: function () {
		        var series = this,
		            chart = this.chart,
		            renderer = chart.renderer,
		            zones = this.zones,
		            translatedFrom,
		            translatedTo,
		            clips = this.clips || [],
		            clipAttr,
		            graph = this.graph,
		            area = this.area,
		            chartSizeMax = Math.max(chart.chartWidth, chart.chartHeight),
		            axis = this[(this.zoneAxis || 'y') + 'Axis'],
		            extremes,
		            reversed,
		            inverted = chart.inverted,
		            horiz,
		            pxRange,
		            pxPosMin,
		            pxPosMax,
		            ignoreZones = false;

		        if (zones.length && (graph || area) && axis && axis.min !== undefined) {
		            reversed = axis.reversed;
		            horiz = axis.horiz;
		            // The use of the Color Threshold assumes there are no gaps
		            // so it is safe to hide the original graph and area
		            // unless it is not waterfall series, then use showLine property to
		            // set lines between columns to be visible (#7862)
		            if (graph && !this.showLine) {
		                graph.hide();
		            }
		            if (area) {
		                area.hide();
		            }

		            // Create the clips
		            extremes = axis.getExtremes();
		            each(zones, function (threshold, i) {

		                translatedFrom = reversed ?
		                    (horiz ? chart.plotWidth : 0) :
		                    (horiz ? 0 : axis.toPixels(extremes.min));
		                translatedFrom = Math.min(
		                    Math.max(
		                        pick(translatedTo, translatedFrom), 0
		                    ),
		                    chartSizeMax
		                );
		                translatedTo = Math.min(
		                    Math.max(
		                        Math.round(
		                            axis.toPixels(
		                                pick(threshold.value, extremes.max),
		                                true
		                            )
		                        ),
		                        0
		                    ),
		                    chartSizeMax
		                );

		                if (ignoreZones) {
		                    translatedFrom = translatedTo = axis.toPixels(extremes.max);
		                }

		                pxRange = Math.abs(translatedFrom - translatedTo);
		                pxPosMin = Math.min(translatedFrom, translatedTo);
		                pxPosMax = Math.max(translatedFrom, translatedTo);
		                if (axis.isXAxis) {
		                    clipAttr = {
		                        x: inverted ? pxPosMax : pxPosMin,
		                        y: 0,
		                        width: pxRange,
		                        height: chartSizeMax
		                    };
		                    if (!horiz) {
		                        clipAttr.x = chart.plotHeight - clipAttr.x;
		                    }
		                } else {
		                    clipAttr = {
		                        x: 0,
		                        y: inverted ? pxPosMax : pxPosMin,
		                        width: chartSizeMax,
		                        height: pxRange
		                    };
		                    if (horiz) {
		                        clipAttr.y = chart.plotWidth - clipAttr.y;
		                    }
		                }


		                // VML SUPPPORT
		                if (inverted && renderer.isVML) {
		                    if (axis.isXAxis) {
		                        clipAttr = {
		                            x: 0,
		                            y: reversed ? pxPosMin : pxPosMax,
		                            height: clipAttr.width,
		                            width: chart.chartWidth
		                        };
		                    } else {
		                        clipAttr = {
		                            x: clipAttr.y - chart.plotLeft - chart.spacingBox.x,
		                            y: 0,
		                            width: clipAttr.height,
		                            height: chart.chartHeight
		                        };
		                    }
		                }
		                // END OF VML SUPPORT


		                if (clips[i]) {
		                    clips[i].animate(clipAttr);
		                } else {
		                    clips[i] = renderer.clipRect(clipAttr);

		                    if (graph) {
		                        series['zone-graph-' + i].clip(clips[i]);
		                    }

		                    if (area) {
		                        series['zone-area-' + i].clip(clips[i]);
		                    }
		                }
		                // if this zone extends out of the axis, ignore the others
		                ignoreZones = threshold.value > extremes.max;

		                // Clear translatedTo for indicators
		                if (series.resetZones && translatedTo === 0) {
		                    translatedTo = undefined;
		                }
		            });
		            this.clips = clips;
		        }
		    },

		    /**
		     * Initialize and perform group inversion on series.group and
		     * series.markerGroup.
		     *
		     * @private
		     * @function Highcharts.Series#invertGroups
		     *
		     * @param {boolean} inverted
		     */
		    invertGroups: function (inverted) {
		        var series = this,
		            chart = series.chart,
		            remover;

		        function setInvert() {
		            each(['group', 'markerGroup'], function (groupName) {
		                if (series[groupName]) {

		                    // VML/HTML needs explicit attributes for flipping
		                    if (chart.renderer.isVML) {
		                        series[groupName].attr({
		                            width: series.yAxis.len,
		                            height: series.xAxis.len
		                        });
		                    }

		                    series[groupName].width = series.yAxis.len;
		                    series[groupName].height = series.xAxis.len;
		                    series[groupName].invert(inverted);
		                }
		            });
		        }

		        // Pie, go away (#1736)
		        if (!series.xAxis) {
		            return;
		        }

		        // A fixed size is needed for inversion to work
		        remover = addEvent(chart, 'resize', setInvert);
		        addEvent(series, 'destroy', remover);

		        // Do it now
		        setInvert(inverted); // do it now

		        // On subsequent render and redraw, just do setInvert without setting up
		        // events again
		        series.invertGroups = setInvert;
		    },

		    /**
		     * General abstraction for creating plot groups like series.group,
		     * series.dataLabelsGroup and series.markerGroup. On subsequent calls, the
		     * group will only be adjusted to the updated plot size.
		     *
		     * @private
		     * @function Highcharts.Series#plotGroup
		     *
		     * @param {string} prop
		     *
		     * @param {string} name
		     *
		     * @param {string} visibility
		     *
		     * @param {number} zIndex
		     *
		     * @param {Highcharts.SVGElement} parent
		     *
		     * @return {Highcharts.SVGElement}
		     */
		    plotGroup: function (prop, name, visibility, zIndex, parent) {
		        var group = this[prop],
		            isNew = !group;

		        // Generate it on first call
		        if (isNew) {
		            this[prop] = group = this.chart.renderer.g()
		                .attr({
		                    zIndex: zIndex || 0.1 // IE8 and pointer logic use this
		                })
		                .add(parent);

		        }

		        // Add the class names, and replace existing ones as response to
		        // Series.update (#6660)
		        group.addClass(
		            (
		                'highcharts-' + name +
		                ' highcharts-series-' + this.index +
		                ' highcharts-' + this.type + '-series ' +
		                (
		                    defined(this.colorIndex) ?
		                        'highcharts-color-' + this.colorIndex + ' ' :
		                        ''
		                ) +
		                (this.options.className || '') +
		                (
		                    group.hasClass('highcharts-tracker') ?
		                        ' highcharts-tracker' :
		                        ''
		                )
		            ),
		            true
		        );

		        // Place it on first and subsequent (redraw) calls
		        group.attr({ visibility: visibility })[isNew ? 'attr' : 'animate'](
		            this.getPlotBox()
		        );
		        return group;
		    },

		    /**
		     * Get the translation and scale for the plot area of this series.
		     *
		     * @function Highcharts.Series#getPlotBox
		     *
		     * @return {Highcharts.SeriesPlotBoxObject}
		     */
		    getPlotBox: function () {
		        var chart = this.chart,
		            xAxis = this.xAxis,
		            yAxis = this.yAxis;

		        // Swap axes for inverted (#2339)
		        if (chart.inverted) {
		            xAxis = yAxis;
		            yAxis = this.xAxis;
		        }
		        return {
		            translateX: xAxis ? xAxis.left : chart.plotLeft,
		            translateY: yAxis ? yAxis.top : chart.plotTop,
		            scaleX: 1, // #1623
		            scaleY: 1
		        };
		    },

		    /**
		     * Render the graph and markers. Called internally when first rendering and
		     * later when redrawing the chart. This function can be extended in plugins,
		     * but normally shouldn't be called directly.
		     *
		     * @function Highcharts.Series#render
		     *
		     * @todo
		     * Make events official: Fires the event `afterRender`.
		     */
		    render: function () {
		        var series = this,
		            chart = series.chart,
		            group,
		            options = series.options,
		            // Animation doesn't work in IE8 quirks when the group div is
		            // hidden, and looks bad in other oldIE
		            animDuration = (
		                !!series.animate &&
		                chart.renderer.isSVG &&
		                animObject(options.animation).duration
		            ),
		            visibility = series.visible ? 'inherit' : 'hidden', // #2597
		            zIndex = options.zIndex,
		            hasRendered = series.hasRendered,
		            chartSeriesGroup = chart.seriesGroup,
		            inverted = chart.inverted;

		        // the group
		        group = series.plotGroup(
		            'group',
		            'series',
		            visibility,
		            zIndex,
		            chartSeriesGroup
		        );

		        series.markerGroup = series.plotGroup(
		            'markerGroup',
		            'markers',
		            visibility,
		            zIndex,
		            chartSeriesGroup
		        );

		        // initiate the animation
		        if (animDuration) {
		            series.animate(true);
		        }

		        // SVGRenderer needs to know this before drawing elements (#1089, #1795)
		        group.inverted = series.isCartesian ? inverted : false;

		        // draw the graph if any
		        if (series.drawGraph) {
		            series.drawGraph();
		            series.applyZones();
		        }

		/*        each(series.points, function (point) {
		            if (point.redraw) {
		                point.redraw();
		            }
		        });*/

		        // draw the data labels (inn pies they go before the points)
		        if (series.drawDataLabels) {
		            series.drawDataLabels();
		        }

		        // draw the points
		        if (series.visible) {
		            series.drawPoints();
		        }


		        // draw the mouse tracking area
		        if (
		            series.drawTracker &&
		            series.options.enableMouseTracking !== false
		        ) {
		            series.drawTracker();
		        }

		        // Handle inverted series and tracker groups
		        series.invertGroups(inverted);

		        // Initial clipping, must be defined after inverting groups for VML.
		        // Applies to columns etc. (#3839).
		        if (options.clip !== false && !series.sharedClipKey && !hasRendered) {
		            group.clip(chart.clipRect);
		        }

		        // Run the animation
		        if (animDuration) {
		            series.animate();
		        }

		        // Call the afterAnimate function on animation complete (but don't
		        // overwrite the animation.complete option which should be available to
		        // the user).
		        if (!hasRendered) {
		            series.animationTimeout = syncTimeout(function () {
		                series.afterAnimate();
		            }, animDuration);
		        }

		        series.isDirty = false; // means data is in accordance with what you see
		        // (See #322) series.isDirty = series.isDirtyData = false; // means
		        // data is in accordance with what you see
		        series.hasRendered = true;

		        fireEvent(series, 'afterRender');
		    },

		    /**
		     * Redraw the series. This function is called internally from `chart.redraw`
		     * and normally shouldn't be called directly.
		     *
		     * @private
		     * @function Highcharts.Series#redraw
		     */
		    redraw: function () {
		        var series = this,
		            chart = series.chart,
		            // cache it here as it is set to false in render, but used after
		            wasDirty = series.isDirty || series.isDirtyData,
		            group = series.group,
		            xAxis = series.xAxis,
		            yAxis = series.yAxis;

		        // reposition on resize
		        if (group) {
		            if (chart.inverted) {
		                group.attr({
		                    width: chart.plotWidth,
		                    height: chart.plotHeight
		                });
		            }

		            group.animate({
		                translateX: pick(xAxis && xAxis.left, chart.plotLeft),
		                translateY: pick(yAxis && yAxis.top, chart.plotTop)
		            });
		        }

		        series.translate();
		        series.render();
		        if (wasDirty) { // #3868, #3945
		            delete this.kdTree;
		        }
		    },

		    kdAxisArray: ['clientX', 'plotY'],

		    /**
		     * @private
		     * @function Highcharts.Series#searchPoint
		     *
		     * @param {*} e
		     *
		     * @param {*} compareX
		     *
		     * @return {Highcharts.Point}
		     */
		    searchPoint: function (e, compareX) {
		        var series = this,
		            xAxis = series.xAxis,
		            yAxis = series.yAxis,
		            inverted = series.chart.inverted;

		        return this.searchKDTree({
		            clientX: inverted ?
		                xAxis.len - e.chartY + xAxis.pos :
		                e.chartX - xAxis.pos,
		            plotY: inverted ?
		                yAxis.len - e.chartX + yAxis.pos :
		                e.chartY - yAxis.pos
		        }, compareX);
		    },

		    /**
		     * Build the k-d-tree that is used by mouse and touch interaction to get the
		     * closest point. Line-like series typically have a one-dimensional tree
		     * where points are searched along the X axis, while scatter-like series
		     * typically search in two dimensions, X and Y.
		     *
		     * @private
		     * @function Highcharts.Series#buildKDTree
		     */
		    buildKDTree: function () {

		        // Prevent multiple k-d-trees from being built simultaneously (#6235)
		        this.buildingKdTree = true;

		        var series = this,
		            dimensions = series.options.findNearestPointBy.indexOf('y') > -1 ?
		                            2 : 1;

		        // Internal function
		        function _kdtree(points, depth, dimensions) {
		            var axis,
		                median,
		                length = points && points.length;

		            if (length) {

		                // alternate between the axis
		                axis = series.kdAxisArray[depth % dimensions];

		                // sort point array
		                points.sort(function (a, b) {
		                    return a[axis] - b[axis];
		                });

		                median = Math.floor(length / 2);

		                // build and return nod
		                return {
		                    point: points[median],
		                    left: _kdtree(
		                        points.slice(0, median), depth + 1, dimensions
		                    ),
		                    right: _kdtree(
		                        points.slice(median + 1), depth + 1, dimensions
		                    )
		                };

		            }
		        }

		        // Start the recursive build process with a clone of the points array
		        // and null points filtered out (#3873)
		        function startRecursive() {
		            series.kdTree = _kdtree(
		                series.getValidPoints(
		                    null,
		                    // For line-type series restrict to plot area, but
		                    // column-type series not (#3916, #4511)
		                    !series.directTouch
		                ),
		                dimensions,
		                dimensions
		            );
		            series.buildingKdTree = false;
		        }
		        delete series.kdTree;

		        // For testing tooltips, don't build async
		        syncTimeout(startRecursive, series.options.kdNow ? 0 : 1);
		    },

		    /**
		     * @private
		     * @function Highcharts.Series#searchKDTree
		     *
		     * @param {*} point
		     *
		     * @param {*} compareX
		     *
		     * @return {Highcharts.Point}
		     */
		    searchKDTree: function (point, compareX) {
		        var series = this,
		            kdX = this.kdAxisArray[0],
		            kdY = this.kdAxisArray[1],
		            kdComparer = compareX ? 'distX' : 'dist',
		            kdDimensions = series.options.findNearestPointBy.indexOf('y') > -1 ?
		                            2 : 1;

		        // Set the one and two dimensional distance on the point object
		        function setDistance(p1, p2) {
		            var x = (defined(p1[kdX]) && defined(p2[kdX])) ?
		                    Math.pow(p1[kdX] - p2[kdX], 2) :
		                    null,
		                y = (defined(p1[kdY]) && defined(p2[kdY])) ?
		                    Math.pow(p1[kdY] - p2[kdY], 2) :
		                    null,
		                r = (x || 0) + (y || 0);

		            p2.dist = defined(r) ? Math.sqrt(r) : Number.MAX_VALUE;
		            p2.distX = defined(x) ? Math.sqrt(x) : Number.MAX_VALUE;
		        }
		        function _search(search, tree, depth, dimensions) {
		            var point = tree.point,
		                axis = series.kdAxisArray[depth % dimensions],
		                tdist,
		                sideA,
		                sideB,
		                ret = point,
		                nPoint1,
		                nPoint2;

		            setDistance(search, point);

		            // Pick side based on distance to splitting point
		            tdist = search[axis] - point[axis];
		            sideA = tdist < 0 ? 'left' : 'right';
		            sideB = tdist < 0 ? 'right' : 'left';

		            // End of tree
		            if (tree[sideA]) {
		                nPoint1 = _search(search, tree[sideA], depth + 1, dimensions);

		                ret = (nPoint1[kdComparer] < ret[kdComparer] ? nPoint1 : point);
		            }
		            if (tree[sideB]) {
		                // compare distance to current best to splitting point to decide
		                // wether to check side B or not
		                if (Math.sqrt(tdist * tdist) < ret[kdComparer]) {
		                    nPoint2 = _search(
		                        search,
		                        tree[sideB],
		                        depth + 1,
		                        dimensions
		                    );
		                    ret = nPoint2[kdComparer] < ret[kdComparer] ?
		                        nPoint2 :
		                        ret;
		                }
		            }

		            return ret;
		        }

		        if (!this.kdTree && !this.buildingKdTree) {
		            this.buildKDTree();
		        }

		        if (this.kdTree) {
		            return _search(point, this.kdTree, kdDimensions, kdDimensions);
		        }
		    }

		}); // end Series prototype

		/**
		 * A line series displays information as a series of data points connected by
		 * straight line segments.
		 *
		 * @sample {highcharts} highcharts/demo/line-basic/
		 *         Line chart
		 * @sample {highstock} stock/demo/basic-line/
		 *         Line chart
		 *
		 * @extends   plotOptions.series
		 * @product   highcharts highstock
		 * @apioption plotOptions.line
		 */



		/**
		 * The SVG value used for the `stroke-linecap` and `stroke-linejoin`
		 * of a line graph. Round means that lines are rounded in the ends and
		 * bends.
		 *
		 * @type       {string}
		 * @validvalue ["round", "butt", "square"]
		 * @default    round
		 * @since      3.0.7
		 * @apioption  plotOptions.line.linecap
		 */



		/**
		 * A `line` series. If the [type](#series.line.type) option is not
		 * specified, it is inherited from [chart.type](#chart.type).
		 *
		 * @extends   series,plotOptions.line
		 * @excluding dataParser,dataURL
		 * @product   highcharts highstock
		 * @apioption series.line
		 */

		/**
		 * An array of data points for the series. For the `line` series type,
		 * points can be given in the following ways:
		 *
		 * 1.  An array of numerical values. In this case, the numerical values
		 * will be interpreted as `y` options. The `x` values will be automatically
		 * calculated, either starting at 0 and incremented by 1, or from `pointStart`
		 * and `pointInterval` given in the series options. If the axis has
		 * categories, these will be used. Example:
		 *
		 *  ```js
		 *  data: [0, 5, 3, 5]
		 *  ```
		 *
		 * 2.  An array of arrays with 2 values. In this case, the values correspond
		 * to `x,y`. If the first value is a string, it is applied as the name
		 * of the point, and the `x` value is inferred.
		 *
		 *  ```js
		 *     data: [
		 *         [0, 1],
		 *         [1, 2],
		 *         [2, 8]
		 *     ]
		 *  ```
		 *
		 * 3.  An array of objects with named values. The following snippet shows only a
		 * few settings, see the complete options set below. If the total number of data
		 * points exceeds the series' [turboThreshold](#series.line.turboThreshold),
		 * this option is not available.
		 *
		 *  ```js
		 *     data: [{
		 *         x: 1,
		 *         y: 9,
		 *         name: "Point2",
		 *         color: "#00FF00"
		 *     }, {
		 *         x: 1,
		 *         y: 6,
		 *         name: "Point1",
		 *         color: "#FF00FF"
		 *     }]
		 *  ```
		 *
		 * @sample {highcharts} highcharts/chart/reflow-true/
		 *         Numerical values
		 * @sample {highcharts} highcharts/series/data-array-of-arrays/
		 *         Arrays of numeric x and y
		 * @sample {highcharts} highcharts/series/data-array-of-arrays-datetime/
		 *         Arrays of datetime x and y
		 * @sample {highcharts} highcharts/series/data-array-of-name-value/
		 *         Arrays of point.name and y
		 * @sample {highcharts} highcharts/series/data-array-of-objects/
		 *         Config objects
		 *
		 * @type      {Array<number|Array<number|string|Date>|*>}
		 * @apioption series.line.data
		 */

		/**
		 * An additional, individual class name for the data point's graphic
		 * representation.
		 *
		 * @type      {string}
		 * @since     5.0.0
		 * @product   highcharts
		 * @apioption series.line.data.className
		 */

		/**
		 * Individual color for the point. By default the color is pulled from
		 * the global `colors` array.
		 *
		 * In styled mode, the `color` option doesn't take effect. Instead, use
		 * `colorIndex`.
		 *
		 * @sample {highcharts} highcharts/point/color/
		 *         Mark the highest point
		 *
		 * @type      {Highcharts.ColorString}
		 * @product   highcharts highstock
		 * @apioption series.line.data.color
		 */

		/**
		 * A specific color index to use for the point, so its graphic representations
		 * are given the class name `highcharts-color-{n}`. In styled mode this will
		 * change the color of the graphic. In non-styled mode, the color by is set by
		 * the `fill` attribute, so the change in class name won't have a visual effect
		 * by default.
		 *
		 * @type      {number}
		 * @since     5.0.0
		 * @product   highcharts
		 * @apioption series.line.data.colorIndex
		 */

		/**
		 * Individual data label for each point. The options are the same as
		 * the ones for [plotOptions.series.dataLabels](
		 * #plotOptions.series.dataLabels).
		 *
		 * @sample highcharts/point/datalabels/
		 *         Show a label for the last value
		 *
		 * @type      {Highcharts.PlotSeriesDataLabelsOptions}
		 * @product   highcharts highstock
		 * @apioption series.line.data.dataLabels
		 */

		/**
		 * A description of the point to add to the screen reader information
		 * about the point. Requires the Accessibility module.
		 *
		 * @type      {string}
		 * @since     5.0.0
		 * @apioption series.line.data.description
		 */

		/**
		 * An id for the point. This can be used after render time to get a
		 * pointer to the point object through `chart.get()`.
		 *
		 * @sample {highcharts} highcharts/point/id/
		 *         Remove an id'd point
		 *
		 * @type      {string}
		 * @since     1.2.0
		 * @product   highcharts highstock
		 * @apioption series.line.data.id
		 */

		/**
		 * The rank for this point's data label in case of collision. If two
		 * data labels are about to overlap, only the one with the highest `labelrank`
		 * will be drawn.
		 *
		 * @type      {number}
		 * @apioption series.line.data.labelrank
		 */

		/**
		 * The name of the point as shown in the legend, tooltip, dataLabel
		 * etc.
		 *
		 * @see [xAxis.uniqueNames](#xAxis.uniqueNames)
		 *
		 * @sample {highcharts} highcharts/series/data-array-of-objects/
		 *         Point names
		 *
		 * @type      {string}
		 * @apioption series.line.data.name
		 */

		/**
		 * Whether the data point is selected initially.
		 *
		 * @type      {boolean}
		 * @default   false
		 * @product   highcharts highstock
		 * @apioption series.line.data.selected
		 */

		/**
		 * The x value of the point. For datetime axes, the X value is the timestamp
		 * in milliseconds since 1970.
		 *
		 * @type      {number}
		 * @product   highcharts highstock
		 * @apioption series.line.data.x
		 */

		/**
		 * The y value of the point.
		 *
		 * @type      {number}
		 * @product   highcharts highstock
		 * @apioption series.line.data.y
		 */

		/**
		 * Individual point events
		 *
		 * @extends   plotOptions.series.point.events
		 * @product   highcharts highstock
		 * @apioption series.line.data.events
		 */

		/**
		 * @extends   plotOptions.series.marker
		 * @product   highcharts highstock
		 * @apioption series.line.data.marker
		 */

	}(Highcharts));
	(function (H) {
		/**
		 * (c) 2010-2018 Torstein Honsi
		 *
		 * License: www.highcharts.com/license
		 */



		var Axis = H.Axis,
		    Chart = H.Chart,
		    correctFloat = H.correctFloat,
		    defined = H.defined,
		    destroyObjectProperties = H.destroyObjectProperties,
		    each = H.each,
		    format = H.format,
		    objectEach = H.objectEach,
		    pick = H.pick,
		    Series = H.Series;

		/**
		 * The class for stacks. Each stack, on a specific X value and either negative
		 * or positive, has its own stack item.
		 *
		 * @private
		 * @class
		 * @name Highcharts.StackItem
		 *
		 * @param {Highcharts.Axis} axis
		 *
		 * @param {Highcharts.Options} options
		 *
		 * @param {boolean} isNegative
		 *
		 * @param {number} x
		 *
		 * @param {string|*} stackOption
		 */
		H.StackItem = function (axis, options, isNegative, x, stackOption) {

		    var inverted = axis.chart.inverted;

		    this.axis = axis;

		    // Tells if the stack is negative
		    this.isNegative = isNegative;

		    // Save the options to be able to style the label
		    this.options = options;

		    // Save the x value to be able to position the label later
		    this.x = x;

		    // Initialize total value
		    this.total = null;

		    // This will keep each points' extremes stored by series.index and point
		    // index
		    this.points = {};

		    // Save the stack option on the series configuration object, and whether to
		    // treat it as percent
		    this.stack = stackOption;
		    this.leftCliff = 0;
		    this.rightCliff = 0;

		    // The align options and text align varies on whether the stack is negative
		    // and if the chart is inverted or not.
		    // First test the user supplied value, then use the dynamic.
		    this.alignOptions = {
		        align: options.align ||
		            (inverted ? (isNegative ? 'left' : 'right') : 'center'),
		        verticalAlign: options.verticalAlign ||
		            (inverted ? 'middle' : (isNegative ? 'bottom' : 'top')),
		        y: pick(options.y, inverted ? 4 : (isNegative ? 14 : -6)),
		        x: pick(options.x, inverted ? (isNegative ? -6 : 6) : 0)
		    };

		    this.textAlign = options.textAlign ||
		        (inverted ? (isNegative ? 'right' : 'left') : 'center');
		};

		H.StackItem.prototype = {

		    /**
		     * @private
		     * @function Highcharts.StackItem#destroy
		     */
		    destroy: function () {
		        destroyObjectProperties(this, this.axis);
		    },

		    /**
		     * Renders the stack total label and adds it to the stack label group.
		     *
		     * @private
		     * @function Highcharts.StackItem#render
		     *
		     * @param {Highcharts.SVGElement} group
		     */
		    render: function (group) {
		        var chart = this.axis.chart,
		            options = this.options,
		            formatOption = options.format,
		            str = formatOption ?
		                format(formatOption, this, chart.time) :
		                options.formatter.call(this);  // format the text in the label

		        // Change the text to reflect the new total and set visibility to hidden
		        // in case the serie is hidden
		        if (this.label) {
		            this.label.attr({ text: str, visibility: 'hidden' });
		        // Create new label
		        } else {
		            this.label =
		                chart.renderer.text(str, null, null, options.useHTML)
		                    .css(options.style)
		                    .attr({
		                        align: this.textAlign,
		                        rotation: options.rotation,
		                        visibility: 'hidden' // hidden until setOffset is called
		                    })
		                    .add(group); // add to the labels-group
		        }

		        // Rank it higher than data labels (#8742)
		        this.label.labelrank = chart.plotHeight;
		    },

		    /**
		     * Sets the offset that the stack has from the x value and repositions the
		     * label.
		     *
		     * @private
		     * @function Highcarts.StackItem#setOffset
		     *
		     * @param {number} xOffset
		     *
		     * @param {number} xWidth
		     */
		    setOffset: function (xOffset, xWidth) {
		        var stackItem = this,
		            axis = stackItem.axis,
		            chart = axis.chart,
		            // stack value translated mapped to chart coordinates
		            y = axis.translate(
		                axis.usePercentage ? 100 : stackItem.total,
		                0,
		                0,
		                0,
		                1
		            ),
		            yZero = axis.translate(0), // stack origin
		            h = defined(y) && Math.abs(y - yZero), // stack height
		            x = chart.xAxis[0].translate(stackItem.x) + xOffset, // x position
		            stackBox = defined(y) && stackItem.getStackBox(
		                chart,
		                stackItem,
		                x,
		                y,
		                xWidth,
		                h,
		                axis
		            ),
		            label = stackItem.label,
		            alignAttr;

		        if (label && stackBox) {
		            // Align the label to the box
		            label.align(stackItem.alignOptions, null, stackBox);

		            // Set visibility (#678)
		            alignAttr = label.alignAttr;
		            label[
		                stackItem.options.crop === false || chart.isInsidePlot(
		                    alignAttr.x,
		                    alignAttr.y
		                ) ? 'show' : 'hide'](true);
		        }
		    },

		    /**
		     * @private
		     * @function Highcharts.StackItem#getStackBox
		     *
		     * @param {Highcharts.Chart} chart
		     *
		     * @param {Highcharts.StackItem} stackItem
		     *
		     * @param {number} x
		     *
		     * @param {number} y
		     *
		     * @param {number} xWidth
		     *
		     * @param {number} h
		     *
		     * @param {Highcharts.Axis} axis
		     *
		     * @return {*}
		     */
		    getStackBox: function (chart, stackItem, x, y, xWidth, h, axis) {
		        var reversed = stackItem.axis.reversed,
		            inverted = chart.inverted,
		            axisPos = axis.height + axis.pos - (inverted ? chart.plotLeft :
		                chart.plotTop),
		            neg = (stackItem.isNegative && !reversed) ||
		                (!stackItem.isNegative && reversed); // #4056

		        return { // this is the box for the complete stack
		            x: inverted ? (neg ? y : y - h) : x,
		            y: inverted ?
		                    axisPos - x - xWidth :
		                    (neg ?
		                        (axisPos - y - h) :
		                        axisPos - y
		                    ),
		            width: inverted ? h : xWidth,
		            height: inverted ? xWidth : h
		        };
		    }
		};

		/**
		 * Generate stacks for each series and calculate stacks total values
		 *
		 * @private
		 * @function Highcharts.Chart#getStacks
		 */
		Chart.prototype.getStacks = function () {
		    var chart = this;

		    // reset stacks for each yAxis
		    each(chart.yAxis, function (axis) {
		        if (axis.stacks && axis.hasVisibleSeries) {
		            axis.oldStacks = axis.stacks;
		        }
		    });

		    each(chart.series, function (series) {
		        if (series.options.stacking && (series.visible === true ||
		                chart.options.chart.ignoreHiddenSeries === false)) {
		            series.stackKey = series.type + pick(series.options.stack, '');
		        }
		    });
		};


		// Stacking methods defined on the Axis prototype

		/**
		 * Build the stacks from top down
		 *
		 * @private
		 * @function Highcharts.Axis#buildStacks
		 */
		Axis.prototype.buildStacks = function () {
		    var axisSeries = this.series,
		        reversedStacks = pick(this.options.reversedStacks, true),
		        len = axisSeries.length,
		        i;
		    if (!this.isXAxis) {
		        this.usePercentage = false;
		        i = len;
		        while (i--) {
		            axisSeries[reversedStacks ? i : len - i - 1].setStackedPoints();
		        }

		        // Loop up again to compute percent and stream stack
		        for (i = 0; i < len; i++) {
		            axisSeries[i].modifyStacks();
		        }
		    }
		};

		/**
		 * @private
		 * @function Highcharts.Axis#renderStackTotals
		 */
		Axis.prototype.renderStackTotals = function () {
		    var axis = this,
		        chart = axis.chart,
		        renderer = chart.renderer,
		        stacks = axis.stacks,
		        stackTotalGroup = axis.stackTotalGroup;

		    // Create a separate group for the stack total labels
		    if (!stackTotalGroup) {
		        axis.stackTotalGroup = stackTotalGroup =
		            renderer.g('stack-labels')
		                .attr({
		                    visibility: 'visible',
		                    zIndex: 6
		                })
		                .add();
		    }

		    // plotLeft/Top will change when y axis gets wider so we need to translate
		    // the stackTotalGroup at every render call. See bug #506 and #516
		    stackTotalGroup.translate(chart.plotLeft, chart.plotTop);

		    // Render each stack total
		    objectEach(stacks, function (type) {
		        objectEach(type, function (stack) {
		            stack.render(stackTotalGroup);
		        });
		    });
		};

		/**
		 * Set all the stacks to initial states and destroy unused ones.
		 *
		 * @private
		 * @function Highcharts.Axis#resetStacks
		 */
		Axis.prototype.resetStacks = function () {
		    var axis = this,
		        stacks = axis.stacks;
		    if (!axis.isXAxis) {
		        objectEach(stacks, function (type) {
		            objectEach(type, function (stack, key) {
		                // Clean up memory after point deletion (#1044, #4320)
		                if (stack.touched < axis.stacksTouched) {
		                    stack.destroy();
		                    delete type[key];

		                // Reset stacks
		                } else {
		                    stack.total = null;
		                    stack.cumulative = null;
		                }
		            });
		        });
		    }
		};

		/**
		 * @private
		 * @function Highcharts.Axis#cleanStacks
		 */
		Axis.prototype.cleanStacks = function () {
		    var stacks;

		    if (!this.isXAxis) {
		        if (this.oldStacks) {
		            stacks = this.stacks = this.oldStacks;
		        }

		        // reset stacks
		        objectEach(stacks, function (type) {
		            objectEach(type, function (stack) {
		                stack.cumulative = stack.total;
		            });
		        });
		    }
		};


		// Stacking methods defnied for Series prototype

		/**
		 * Adds series' points value to corresponding stack
		 *
		 * @private
		 * @function Highcharts.Series#setStackedPoints
		 */
		Series.prototype.setStackedPoints = function () {
		    if (!this.options.stacking || (this.visible !== true &&
		            this.chart.options.chart.ignoreHiddenSeries !== false)) {
		        return;
		    }

		    var series = this,
		        xData = series.processedXData,
		        yData = series.processedYData,
		        stackedYData = [],
		        yDataLength = yData.length,
		        seriesOptions = series.options,
		        threshold = seriesOptions.threshold,
		        stackThreshold = pick(seriesOptions.startFromThreshold && threshold, 0),
		        stackOption = seriesOptions.stack,
		        stacking = seriesOptions.stacking,
		        stackKey = series.stackKey,
		        negKey = '-' + stackKey,
		        negStacks = series.negStacks,
		        yAxis = series.yAxis,
		        stacks = yAxis.stacks,
		        oldStacks = yAxis.oldStacks,
		        stackIndicator,
		        isNegative,
		        stack,
		        other,
		        key,
		        pointKey,
		        i,
		        x,
		        y;


		    yAxis.stacksTouched += 1;

		    // loop over the non-null y values and read them into a local array
		    for (i = 0; i < yDataLength; i++) {
		        x = xData[i];
		        y = yData[i];
		        stackIndicator = series.getStackIndicator(
		            stackIndicator,
		            x,
		            series.index
		        );
		        pointKey = stackIndicator.key;
		        // Read stacked values into a stack based on the x value,
		        // the sign of y and the stack key. Stacking is also handled for null
		        // values (#739)
		        isNegative = negStacks && y < (stackThreshold ? 0 : threshold);
		        key = isNegative ? negKey : stackKey;

		        // Create empty object for this stack if it doesn't exist yet
		        if (!stacks[key]) {
		            stacks[key] = {};
		        }

		        // Initialize StackItem for this x
		        if (!stacks[key][x]) {
		            if (oldStacks[key] && oldStacks[key][x]) {
		                stacks[key][x] = oldStacks[key][x];
		                stacks[key][x].total = null;
		            } else {
		                stacks[key][x] = new H.StackItem(
		                    yAxis,
		                    yAxis.options.stackLabels,
		                    isNegative,
		                    x,
		                    stackOption
		                );
		            }
		        }

		        // If the StackItem doesn't exist, create it first
		        stack = stacks[key][x];
		        if (y !== null) {
		            stack.points[pointKey] = stack.points[series.index] =
		                [pick(stack.cumulative, stackThreshold)];

		            // Record the base of the stack
		            if (!defined(stack.cumulative)) {
		                stack.base = pointKey;
		            }
		            stack.touched = yAxis.stacksTouched;


		            // In area charts, if there are multiple points on the same X value,
		            // let the area fill the full span of those points
		            if (stackIndicator.index > 0 && series.singleStacks === false) {
		                stack.points[pointKey][0] =
		                    stack.points[series.index + ',' + x + ',0'][0];
		            }

		        // When updating to null, reset the point stack (#7493)
		        } else {
		            stack.points[pointKey] = stack.points[series.index] = null;
		        }

		        // Add value to the stack total
		        if (stacking === 'percent') {

		            // Percent stacked column, totals are the same for the positive and
		            // negative stacks
		            other = isNegative ? stackKey : negKey;
		            if (negStacks && stacks[other] && stacks[other][x]) {
		                other = stacks[other][x];
		                stack.total = other.total =
		                    Math.max(other.total, stack.total) + Math.abs(y) || 0;

		            // Percent stacked areas
		            } else {
		                stack.total = correctFloat(stack.total + (Math.abs(y) || 0));
		            }
		        } else {
		            stack.total = correctFloat(stack.total + (y || 0));
		        }

		        stack.cumulative = pick(stack.cumulative, stackThreshold) + (y || 0);

		        if (y !== null) {
		            stack.points[pointKey].push(stack.cumulative);
		            stackedYData[i] = stack.cumulative;
		        }

		    }

		    if (stacking === 'percent') {
		        yAxis.usePercentage = true;
		    }

		    this.stackedYData = stackedYData; // To be used in getExtremes

		    // Reset old stacks
		    yAxis.oldStacks = {};
		};

		/**
		 * Iterate over all stacks and compute the absolute values to percent
		 *
		 * @private
		 * @function Highcharts.Series#modifyStacks
		 */
		Series.prototype.modifyStacks = function () {
		    var series = this,
		        stackKey = series.stackKey,
		        stacks = series.yAxis.stacks,
		        processedXData = series.processedXData,
		        stackIndicator,
		        stacking = series.options.stacking;

		    if (series[stacking + 'Stacker']) { // Modifier function exists
		        each([stackKey, '-' + stackKey], function (key) {
		            var i = processedXData.length,
		                x,
		                stack,
		                pointExtremes;

		            while (i--) {
		                x = processedXData[i];
		                stackIndicator = series.getStackIndicator(
		                    stackIndicator,
		                    x,
		                    series.index,
		                    key
		                );
		                stack = stacks[key] && stacks[key][x];
		                pointExtremes = stack && stack.points[stackIndicator.key];
		                if (pointExtremes) {
		                    series[stacking + 'Stacker'](pointExtremes, stack, i);
		                }
		            }
		        });
		    }
		};

		/**
		 * Modifier function for percent stacks. Blows up the stack to 100%.
		 *
		 * @private
		 * @function Highcharts.Series#percentStacker
		 *
		 * @param {Array<number>} pointExtremes
		 *
		 * @param {Highcharts.StackItem} stack
		 *
		 * @param {number} i
		 */
		Series.prototype.percentStacker = function (pointExtremes, stack, i) {
		    var totalFactor = stack.total ? 100 / stack.total : 0;
		    // Y bottom value
		    pointExtremes[0] = correctFloat(pointExtremes[0] * totalFactor);
		    // Y value
		    pointExtremes[1] = correctFloat(pointExtremes[1] * totalFactor);
		    this.stackedYData[i] = pointExtremes[1];
		};

		/**
		 * Get stack indicator, according to it's x-value, to determine points with the
		 * same x-value
		 *
		 * @private
		 * @function Highcharts.Series#getStackIndicator
		 *
		 * @param {*} stackIndicator
		 *
		 * @param {number} x
		 *
		 * @param {number} index
		 *
		 * @param {string} key
		 *
		 * @return {*}
		 */
		Series.prototype.getStackIndicator = function (stackIndicator, x, index, key) {
		    // Update stack indicator, when:
		    // first point in a stack || x changed || stack type (negative vs positive)
		    // changed:
		    if (!defined(stackIndicator) || stackIndicator.x !== x ||
		            (key && stackIndicator.key !== key)) {
		        stackIndicator = {
		            x: x,
		            index: 0,
		            key: key
		        };
		    } else {
		        stackIndicator.index++;
		    }

		    stackIndicator.key = [index, x, stackIndicator.index].join(',');

		    return stackIndicator;
		};

	}(Highcharts));
	(function (H) {
		/**
		 * (c) 2010-2018 Torstein Honsi
		 *
		 * License: www.highcharts.com/license
		 */



		var addEvent = H.addEvent,
		    animate = H.animate,
		    Axis = H.Axis,
		    Chart = H.Chart,
		    createElement = H.createElement,
		    css = H.css,
		    defined = H.defined,
		    each = H.each,
		    erase = H.erase,
		    extend = H.extend,
		    fireEvent = H.fireEvent,
		    inArray = H.inArray,
		    isNumber = H.isNumber,
		    isObject = H.isObject,
		    isArray = H.isArray,
		    merge = H.merge,
		    objectEach = H.objectEach,
		    pick = H.pick,
		    Point = H.Point,
		    Series = H.Series,
		    seriesTypes = H.seriesTypes,
		    setAnimation = H.setAnimation,
		    splat = H.splat;

		// Extend the Chart prototype for dynamic methods
		extend(Chart.prototype, /** @lends Highcharts.Chart.prototype */ {

		    /**
		     * Add a series to the chart after render time. Note that this method should
		     * never be used when adding data synchronously at chart render time, as it
		     * adds expense to the calculations and rendering. When adding data at the
		     * same time as the chart is initialized, add the series as a configuration
		     * option instead. With multiple axes, the `offset` is dynamically adjusted.
		     *
		     * @sample highcharts/members/chart-addseries/
		     *         Add a series from a button
		     * @sample stock/members/chart-addseries/
		     *         Add a series in Highstock
		     *
		     * @function Highcharts.Chart#addSeries
		     *
		     * @param {Highcharts.SeriesOptions} options
		     *        The config options for the series.
		     *
		     * @param {boolean} [redraw=true]
		     *        Whether to redraw the chart after adding.
		     *
		     * @param {boolean|Highcharts.AnimationOptionsObject} [animation]
		     *        Whether to apply animation, and optionally animation
		     *        configuration.
		     *
		     * @return {Highcharts.Series}
		     *         The newly created series object.
		     *
		     * @fires Highcharts.Chart#event:addSeries
		     * @fires Highcharts.Chart#event:afterAddSeries
		     */
		    addSeries: function (options, redraw, animation) {
		        var series,
		            chart = this;

		        if (options) {
		            redraw = pick(redraw, true); // defaults to true

		            fireEvent(chart, 'addSeries', { options: options }, function () {
		                series = chart.initSeries(options);

		                chart.isDirtyLegend = true;
		                chart.linkSeries();

		                fireEvent(chart, 'afterAddSeries');

		                if (redraw) {
		                    chart.redraw(animation);
		                }
		            });
		        }

		        return series;
		    },

		    /**
		     * Add an axis to the chart after render time. Note that this method should
		     * never be used when adding data synchronously at chart render time, as it
		     * adds expense to the calculations and rendering. When adding data at the
		     * same time as the chart is initialized, add the axis as a configuration
		     * option instead.
		     *
		     * @sample highcharts/members/chart-addaxis/
		     *         Add and remove axes
		     *
		     * @function Highcharts.Chart#addAxis
		     *
		     * @param {Highcharts.XAxisOptions|Highcharts.YAxisOptions|Highcharts.ZAxisOptions} options
		     *        The axis options.
		     *
		     * @param {boolean} [isX=false]
		     *        Whether it is an X axis or a value axis.
		     *
		     * @param {boolean} [redraw=true]
		     *        Whether to redraw the chart after adding.
		     *
		     * @param {boolean|Highcharts.AnimationOptionsObject} [animation=true]
		     *        Whether and how to apply animation in the redraw.
		     *
		     * @return {Highcharts.Axis}
		     *         The newly generated Axis object.
		     */
		    addAxis: function (options, isX, redraw, animation) {
		        var key = isX ? 'xAxis' : 'yAxis',
		            chartOptions = this.options,
		            userOptions = merge(options, {
		                index: this[key].length,
		                isX: isX
		            }),
		            axis;

		        axis = new Axis(this, userOptions);

		        // Push the new axis options to the chart options
		        chartOptions[key] = splat(chartOptions[key] || {});
		        chartOptions[key].push(userOptions);

		        if (pick(redraw, true)) {
		            this.redraw(animation);
		        }

		        return axis;
		    },

		    /**
		     * Dim the chart and show a loading text or symbol. Options for the loading
		     * screen are defined in {@link
		     * https://api.highcharts.com/highcharts/loading|the loading options}.
		     *
		     * @sample highcharts/members/chart-hideloading/
		     *         Show and hide loading from a button
		     * @sample highcharts/members/chart-showloading/
		     *         Apply different text labels
		     * @sample stock/members/chart-show-hide-loading/
		     *         Toggle loading in Highstock
		     *
		     * @function Highcharts.Chart#showLoading
		     *
		     * @param {string} str
		     *        An optional text to show in the loading label instead of the
		     *        default one. The default text is set in
		     *        {@link http://api.highcharts.com/highcharts/lang.loading|lang.loading}.
		     */
		    showLoading: function (str) {
		        var chart = this,
		            options = chart.options,
		            loadingDiv = chart.loadingDiv,
		            loadingOptions = options.loading,
		            setLoadingSize = function () {
		                if (loadingDiv) {
		                    css(loadingDiv, {
		                        left: chart.plotLeft + 'px',
		                        top: chart.plotTop + 'px',
		                        width: chart.plotWidth + 'px',
		                        height: chart.plotHeight + 'px'
		                    });
		                }
		            };

		        // create the layer at the first call
		        if (!loadingDiv) {
		            chart.loadingDiv = loadingDiv = createElement('div', {
		                className: 'highcharts-loading highcharts-loading-hidden'
		            }, null, chart.container);

		            chart.loadingSpan = createElement(
		                'span',
		                { className: 'highcharts-loading-inner' },
		                null,
		                loadingDiv
		            );
		            addEvent(chart, 'redraw', setLoadingSize); // #1080
		        }

		        loadingDiv.className = 'highcharts-loading';

		        // Update text
		        chart.loadingSpan.innerHTML = str || options.lang.loading;


		        // Update visuals
		        css(loadingDiv, extend(loadingOptions.style, {
		            zIndex: 10
		        }));
		        css(chart.loadingSpan, loadingOptions.labelStyle);

		        // Show it
		        if (!chart.loadingShown) {
		            css(loadingDiv, {
		                opacity: 0,
		                display: ''
		            });
		            animate(loadingDiv, {
		                opacity: loadingOptions.style.opacity || 0.5
		            }, {
		                duration: loadingOptions.showDuration || 0
		            });
		        }


		        chart.loadingShown = true;
		        setLoadingSize();
		    },

		    /**
		     * Hide the loading layer.
		     *
		     * @see Highcharts.Chart#showLoading
		     *
		     * @sample highcharts/members/chart-hideloading/
		     *         Show and hide loading from a button
		     * @sample stock/members/chart-show-hide-loading/
		     *         Toggle loading in Highstock
		     *
		     * @function Highcharts.Chart#hideLoading
		     */
		    hideLoading: function () {

		        var options = this.options,
		            loadingDiv = this.loadingDiv;

		        if (loadingDiv) {
		            loadingDiv.className =
		                'highcharts-loading highcharts-loading-hidden';

		            animate(loadingDiv, {
		                opacity: 0
		            }, {
		                duration: options.loading.hideDuration || 100,
		                complete: function () {
		                    css(loadingDiv, { display: 'none' });
		                }
		            });

		        }

		        this.loadingShown = false;
		    },

		    /**
		     * These properties cause isDirtyBox to be set to true when updating. Can be
		     * extended from plugins.
		     */
		    propsRequireDirtyBox: [
		        'backgroundColor',
		        'borderColor',
		        'borderWidth',
		        'margin',
		        'marginTop',
		        'marginRight',
		        'marginBottom',
		        'marginLeft',
		        'spacing',
		        'spacingTop',
		        'spacingRight',
		        'spacingBottom',
		        'spacingLeft',
		        'borderRadius',
		        'plotBackgroundColor',
		        'plotBackgroundImage',
		        'plotBorderColor',
		        'plotBorderWidth',
		        'plotShadow',
		        'shadow'
		    ],

		    /**
		     * These properties cause all series to be updated when updating. Can be
		     * extended from plugins.
		     */
		    propsRequireUpdateSeries: [
		        'chart.inverted',
		        'chart.polar',
		        'chart.ignoreHiddenSeries',
		        'chart.type',
		        'colors',
		        'plotOptions',
		        'time',
		        'tooltip'
		    ],

		    /**
		     * A generic function to update any element of the chart. Elements can be
		     * enabled and disabled, moved, re-styled, re-formatted etc.
		     *
		     * A special case is configuration objects that take arrays, for example
		     * {@link https://api.highcharts.com/highcharts/xAxis|xAxis},
		     * {@link https://api.highcharts.com/highcharts/yAxis|yAxis} or
		     * {@link https://api.highcharts.com/highcharts/series|series}. For these
		     * collections, an `id` option is used to map the new option set to an
		     * existing object. If an existing object of the same id is not found, the
		     * corresponding item is updated. So for example, running `chart.update`
		     * with a series item without an id, will cause the existing chart's series
		     * with the same index in the series array to be updated. When the
		     * `oneToOne` parameter is true, `chart.update` will also take care of
		     * adding and removing items from the collection. Read more under the
		     * parameter description below.
		     *
		     * See also the
		     * {@link https://api.highcharts.com/highcharts/responsive|responsive option set}.
		     * Switching between `responsive.rules` basically runs `chart.update` under
		     * the hood.
		     *
		     * @sample highcharts/members/chart-update/
		     *         Update chart geometry
		     *
		     * @function Highcharts.Chart#update
		     *
		     * @param {Highcharts.Options} options
		     *        A configuration object for the new chart options.
		     *
		     * @param {boolean} [redraw=true]
		     *        Whether to redraw the chart.
		     *
		     * @param {boolean} [oneToOne=false]
		     *        When `true`, the `series`, `xAxis` and `yAxis` collections will
		     *        be updated one to one, and items will be either added or removed
		     *        to match the new updated options. For example, if the chart has
		     *        two series and we call `chart.update` with a configuration
		     *        containing three series, one will be added. If we call
		     *        `chart.update` with one series, one will be removed. Setting an
		     *        empty `series` array will remove all series, but leaving out the
		     *        `series` property will leave all series untouched. If the series
		     *        have id's, the new series options will be matched by id, and the
		     *        remaining ones removed.
		     *
		     * @param {boolean|Highcharts.AnimationOptionsObject} [animation=true]
		     *        Whether to apply animation, and optionally animation
		     *        configuration.
		     *
		     * @fires Highcharts.Chart#event:update
		     * @fires Highcharts.Chart#event:afterUpdate
		     */
		    update: function (options, redraw, oneToOne, animation) {
		        var chart = this,
		            adders = {
		                credits: 'addCredits',
		                title: 'setTitle',
		                subtitle: 'setSubtitle'
		            },
		            optionsChart = options.chart,
		            updateAllAxes,
		            updateAllSeries,
		            newWidth,
		            newHeight,
		            itemsForRemoval = [];

		        fireEvent(chart, 'update', { options: options });

		        // If the top-level chart option is present, some special updates are
		        // required
		        if (optionsChart) {
		            merge(true, chart.options.chart, optionsChart);

		            // Setter function
		            if ('className' in optionsChart) {
		                chart.setClassName(optionsChart.className);
		            }

		            if ('reflow' in optionsChart) {
		                chart.setReflow(optionsChart.reflow);
		            }

		            if (
		                'inverted' in optionsChart ||
		                'polar' in optionsChart ||
		                'type' in optionsChart
		            ) {
		                // Parse options.chart.inverted and options.chart.polar together
		                // with the available series.
		                chart.propFromSeries();
		                updateAllAxes = true;
		            }

		            if ('alignTicks' in optionsChart) { // #6452
		                updateAllAxes = true;
		            }

		            objectEach(optionsChart, function (val, key) {
		                if (
		                    inArray('chart.' + key, chart.propsRequireUpdateSeries) !==
		                    -1
		                ) {
		                    updateAllSeries = true;
		                }
		                // Only dirty box
		                if (inArray(key, chart.propsRequireDirtyBox) !== -1) {
		                    chart.isDirtyBox = true;
		                }
		            });


		            if ('style' in optionsChart) {
		                chart.renderer.setStyle(optionsChart.style);
		            }

		        }

		        // Moved up, because tooltip needs updated plotOptions (#6218)

		        if (options.colors) {
		            this.options.colors = options.colors;
		        }


		        if (options.plotOptions) {
		            merge(true, this.options.plotOptions, options.plotOptions);
		        }

		        // Some option stuctures correspond one-to-one to chart objects that
		        // have update methods, for example
		        // options.credits => chart.credits
		        // options.legend => chart.legend
		        // options.title => chart.title
		        // options.tooltip => chart.tooltip
		        // options.subtitle => chart.subtitle
		        // options.mapNavigation => chart.mapNavigation
		        // options.navigator => chart.navigator
		        // options.scrollbar => chart.scrollbar
		        objectEach(options, function (val, key) {
		            if (chart[key] && typeof chart[key].update === 'function') {
		                chart[key].update(val, false);

		            // If a one-to-one object does not exist, look for an adder function
		            } else if (typeof chart[adders[key]] === 'function') {
		                chart[adders[key]](val);
		            }

		            if (
		                key !== 'chart' &&
		                inArray(key, chart.propsRequireUpdateSeries) !== -1
		            ) {
		                updateAllSeries = true;
		            }
		        });

		        // Setters for collections. For axes and series, each item is referred
		        // by an id. If the id is not found, it defaults to the corresponding
		        // item in the collection, so setting one series without an id, will
		        // update the first series in the chart. Setting two series without
		        // an id will update the first and the second respectively (#6019)
		        // chart.update and responsive.
		        each([
		            'xAxis',
		            'yAxis',
		            'zAxis',
		            'series',
		            'colorAxis',
		            'pane'
		        ], function (coll) {
		            var indexMap;

		            if (options[coll]) {

		                // In stock charts, the navigator series are also part of the
		                // chart.series array, but those series should not be handled
		                // here (#8196).
		                if (coll === 'series') {
		                    indexMap = [];
		                    each(chart[coll], function (s, i) {
		                        if (!s.options.isInternal) {
		                            indexMap.push(i);
		                        }
		                    });
		                }


		                each(splat(options[coll]), function (newOptions, i) {
		                    var item = (
		                        defined(newOptions.id) &&
		                        chart.get(newOptions.id)
		                    ) || chart[coll][indexMap ? indexMap[i] : i];
		                    if (item && item.coll === coll) {
		                        item.update(newOptions, false);

		                        if (oneToOne) {
		                            item.touched = true;
		                        }
		                    }

		                    // If oneToOne and no matching item is found, add one
		                    if (!item && oneToOne) {
		                        if (coll === 'series') {
		                            chart.addSeries(newOptions, false)
		                                .touched = true;
		                        } else if (coll === 'xAxis' || coll === 'yAxis') {
		                            chart.addAxis(newOptions, coll === 'xAxis', false)
		                                .touched = true;
		                        }
		                    }

		                });

		                // Add items for removal
		                if (oneToOne) {
		                    each(chart[coll], function (item) {
		                        if (!item.touched && !item.options.isInternal) {
		                            itemsForRemoval.push(item);
		                        } else {
		                            delete item.touched;
		                        }
		                    });
		                }


		            }
		        });

		        each(itemsForRemoval, function (item) {
		            if (item.remove) {
		                item.remove(false);
		            }
		        });

		        if (updateAllAxes) {
		            each(chart.axes, function (axis) {
		                axis.update({}, false);
		            });
		        }

		        // Certain options require the whole series structure to be thrown away
		        // and rebuilt
		        if (updateAllSeries) {
		            each(chart.series, function (series) {
		                series.update({}, false);
		            });
		        }

		        // For loading, just update the options, do not redraw
		        if (options.loading) {
		            merge(true, chart.options.loading, options.loading);
		        }

		        // Update size. Redraw is forced.
		        newWidth = optionsChart && optionsChart.width;
		        newHeight = optionsChart && optionsChart.height;
		        if ((isNumber(newWidth) && newWidth !== chart.chartWidth) ||
		                (isNumber(newHeight) && newHeight !== chart.chartHeight)) {
		            chart.setSize(newWidth, newHeight, animation);
		        } else if (pick(redraw, true)) {
		            chart.redraw(animation);
		        }

		        fireEvent(chart, 'afterUpdate', { options: options });

		    },

		    /**
		     * Shortcut to set the subtitle options. This can also be done from {@link
		     * Chart#update} or {@link Chart#setTitle}.
		     *
		     * @function Highcharts.Chart#setSubtitle
		     *
		     * @param {Highcharts.SubtitleOptions} options
		     *        New subtitle options. The subtitle text itself is set by the
		     *        `options.text` property.
		     */
		    setSubtitle: function (options) {
		        this.setTitle(undefined, options);
		    }


		});

		// extend the Point prototype for dynamic methods
		extend(Point.prototype, /** @lends Highcharts.Point.prototype */ {
		    /**
		     * Update point with new options (typically x/y data) and optionally redraw
		     * the series.
		     *
		     * @sample highcharts/members/point-update-column/
		     *         Update column value
		     * @sample highcharts/members/point-update-pie/
		     *         Update pie slice
		     * @sample maps/members/point-update/
		     *         Update map area value in Highmaps
		     *
		     * @function Highcharts.Point#update
		     *
		     * @param {*} options
		     *        The point options. Point options are handled as described under
		     *        the `series.type.data` item for each series type. For example
		     *        for a line series, if options is a single number, the point will
		     *        be given that number as the main y value. If it is an array, it
		     *        will be interpreted as x and y values respectively. If it is an
		     *        object, advanced options are applied.
		     *
		     * @param {boolean} [redraw=true]
		     *        Whether to redraw the chart after the point is updated. If doing
		     *        more operations on the chart, it is best practice to set
		     *        `redraw` to false and call `chart.redraw()` after.
		     *
		     * @param {boolean|Highcharts.AnimationOptionsObject} [animation=true]
		     *        Whether to apply animation, and optionally animation
		     *        configuration.
		     *
		     * @fires Highcharts.Point#event:update
		     */
		    update: function (options, redraw, animation, runEvent) {
		        var point = this,
		            series = point.series,
		            graphic = point.graphic,
		            i,
		            chart = series.chart,
		            seriesOptions = series.options;

		        redraw = pick(redraw, true);

		        function update() {

		            point.applyOptions(options);

		            // Update visuals
		            if (point.y === null && graphic) { // #4146
		                point.graphic = graphic.destroy();
		            }
		            if (isObject(options, true)) {
		                // Destroy so we can get new elements
		                if (graphic && graphic.element) {
		                    // "null" is also a valid symbol
		                    if (
		                        options &&
		                        options.marker &&
		                        options.marker.symbol !== undefined
		                    ) {
		                        point.graphic = graphic.destroy();
		                    }
		                }
		                if (options && options.dataLabels && point.dataLabel) { // #2468
		                    point.dataLabel = point.dataLabel.destroy();
		                }
		                if (point.connector) {
		                    point.connector = point.connector.destroy(); // #7243
		                }
		            }

		            // record changes in the parallel arrays
		            i = point.index;
		            series.updateParallelArrays(point, i);

		            // Record the options to options.data. If the old or the new config
		            // is an object, use point options, otherwise use raw options
		            // (#4701, #4916).
		            seriesOptions.data[i] = (
		                    isObject(seriesOptions.data[i], true) ||
		                    isObject(options, true)
		                ) ?
		                point.options :
		                pick(options, seriesOptions.data[i]);

		            // redraw
		            series.isDirty = series.isDirtyData = true;
		            if (!series.fixedBox && series.hasCartesianSeries) { // #1906, #2320
		                chart.isDirtyBox = true;
		            }

		            if (seriesOptions.legendType === 'point') { // #1831, #1885
		                chart.isDirtyLegend = true;
		            }
		            if (redraw) {
		                chart.redraw(animation);
		            }
		        }

		        // Fire the event with a default handler of doing the update
		        if (runEvent === false) { // When called from setData
		            update();
		        } else {
		            point.firePointEvent('update', { options: options }, update);
		        }
		    },

		    /**
		     * Remove a point and optionally redraw the series and if necessary the axes
		     *
		     * @sample highcharts/plotoptions/series-point-events-remove/
		     *         Remove point and confirm
		     * @sample highcharts/members/point-remove/
		     *         Remove pie slice
		     * @sample maps/members/point-remove/
		     *         Remove selected points in Highmaps
		     *
		     * @function Highcharts.Point#remove
		     *
		     * @param {boolean} redraw
		     *        Whether to redraw the chart or wait for an explicit call. When
		     *        doing more operations on the chart, for example running
		     *        `point.remove()` in a loop, it is best practice to set `redraw`
		     *        to false and call `chart.redraw()` after.
		     *
		     * @param {boolean|Highcharts.AnimationOptionsObject} [animation=false]
		     *        Whether to apply animation, and optionally animation
		     *        configuration.
		     */
		    remove: function (redraw, animation) {
		        this.series.removePoint(
		            inArray(this, this.series.data),
		            redraw,
		            animation
		        );
		    }
		});

		// Extend the series prototype for dynamic methods
		extend(Series.prototype, /** @lends Series.prototype */ {
		    /**
		     * Add a point to the series after render time. The point can be added at
		     * the end, or by giving it an X value, to the start or in the middle of the
		     * series.
		     *
		     * @sample highcharts/members/series-addpoint-append/
		     *         Append point
		     * @sample highcharts/members/series-addpoint-append-and-shift/
		     *         Append and shift
		     * @sample highcharts/members/series-addpoint-x-and-y/
		     *         Both X and Y values given
		     * @sample highcharts/members/series-addpoint-pie/
		     *         Append pie slice
		     * @sample stock/members/series-addpoint/
		     *         Append 100 points in Highstock
		     * @sample stock/members/series-addpoint-shift/
		     *         Append and shift in Highstock
		     * @sample maps/members/series-addpoint/
		     *         Add a point in Highmaps
		     *
		     * @function Highcharts.Series#addPoint
		     *
		     * @param {number|Array<number>|*} options
		     *        The point options. If options is a single number, a point with
		     *        that y value is appended to the series. If it is an array, it will
		     *        be interpreted as x and y values respectively. If it is an
		     *        object, advanced options as outlined under `series.data` are
		     *        applied.
		     *
		     * @param {boolean} [redraw=true]
		     *        Whether to redraw the chart after the point is added. When adding
		     *        more than one point, it is highly recommended that the redraw
		     *        option be set to false, and instead {@link Chart#redraw} is
		     *        explicitly called after the adding of points is finished.
		     *        Otherwise, the chart will redraw after adding each point.
		     *
		     * @param {boolean} [shift=false]
		     *        If true, a point is shifted off the start of the series as one is
		     *        appended to the end.
		     *
		     * @param {boolean|Highcharts.AnimationOptionsObject} [animation]
		     *        Whether to apply animation, and optionally animation
		     *        configuration.
		     */
		    addPoint: function (options, redraw, shift, animation) {
		        var series = this,
		            seriesOptions = series.options,
		            data = series.data,
		            chart = series.chart,
		            xAxis = series.xAxis,
		            names = xAxis && xAxis.hasNames && xAxis.names,
		            dataOptions = seriesOptions.data,
		            point,
		            isInTheMiddle,
		            xData = series.xData,
		            i,
		            x;

		        // Optional redraw, defaults to true
		        redraw = pick(redraw, true);

		        // Get options and push the point to xData, yData and series.options. In
		        // series.generatePoints the Point instance will be created on demand
		        // and pushed to the series.data array.
		        point = { series: series };
		        series.pointClass.prototype.applyOptions.apply(point, [options]);
		        x = point.x;

		        // Get the insertion point
		        i = xData.length;
		        if (series.requireSorting && x < xData[i - 1]) {
		            isInTheMiddle = true;
		            while (i && xData[i - 1] > x) {
		                i--;
		            }
		        }

		        // Insert undefined item
		        series.updateParallelArrays(point, 'splice', i, 0, 0);
		        // Update it
		        series.updateParallelArrays(point, i);

		        if (names && point.name) {
		            names[x] = point.name;
		        }
		        dataOptions.splice(i, 0, options);

		        if (isInTheMiddle) {
		            series.data.splice(i, 0, null);
		            series.processData();
		        }

		        // Generate points to be added to the legend (#1329)
		        if (seriesOptions.legendType === 'point') {
		            series.generatePoints();
		        }

		        // Shift the first point off the parallel arrays
		        if (shift) {
		            if (data[0] && data[0].remove) {
		                data[0].remove(false);
		            } else {
		                data.shift();
		                series.updateParallelArrays(point, 'shift');

		                dataOptions.shift();
		            }
		        }

		        // redraw
		        series.isDirty = true;
		        series.isDirtyData = true;

		        if (redraw) {
		            chart.redraw(animation); // Animation is set anyway on redraw, #5665
		        }
		    },

		    /**
		     * Remove a point from the series. Unlike the
		     * {@link Highcharts.Point#remove} method, this can also be done on a point
		     * that is not instanciated because it is outside the view or subject to
		     * Highstock data grouping.
		     *
		     * @sample highcharts/members/series-removepoint/
		     *         Remove cropped point
		     *
		     * @function Highcharts.Series#removePoint
		     *
		     * @param {number} i
		     *        The index of the point in the {@link Highcharts.Series.data|data}
		     *        array.
		     *
		     * @param {boolean} [redraw=true]
		     *        Whether to redraw the chart after the point is added. When
		     *        removing more than one point, it is highly recommended that the
		     *        `redraw` option be set to `false`, and instead {@link
		     *        Highcharts.Chart#redraw} is explicitly called after the adding of
		     *        points is finished.
		     *
		     * @param {boolean|Highcharts.AnimationOptionsObject} [animation]
		     *        Whether and optionally how the series should be animated.
		     *
		     * @fires Highcharts.Point#event:remove
		     */
		    removePoint: function (i, redraw, animation) {

		        var series = this,
		            data = series.data,
		            point = data[i],
		            points = series.points,
		            chart = series.chart,
		            remove = function () {

		                if (points && points.length === data.length) { // #4935
		                    points.splice(i, 1);
		                }
		                data.splice(i, 1);
		                series.options.data.splice(i, 1);
		                series.updateParallelArrays(
		                    point || { series: series },
		                    'splice',
		                    i,
		                    1
		                );

		                if (point) {
		                    point.destroy();
		                }

		                // redraw
		                series.isDirty = true;
		                series.isDirtyData = true;
		                if (redraw) {
		                    chart.redraw();
		                }
		            };

		        setAnimation(animation, chart);
		        redraw = pick(redraw, true);

		        // Fire the event with a default handler of removing the point
		        if (point) {
		            point.firePointEvent('remove', null, remove);
		        } else {
		            remove();
		        }
		    },

		    /**
		     * Remove a series and optionally redraw the chart.
		     *
		     * @sample highcharts/members/series-remove/
		     *         Remove first series from a button
		     *
		     * @function Highcharts.Series#remove
		     *
		     * @param {boolean} [redraw=true]
		     *        Whether to redraw the chart or wait for an explicit call to
		     *        {@link Highcharts.Chart#redraw}.
		     *
		     * @param {boolean|Highcharts.AnimationOptionsObject} [animation]
		     *        Whether to apply animation, and optionally animation
		     *        configuration.
		     *
		     * @param {boolean} [withEvent=true]
		     *        Used internally, whether to fire the series `remove` event.
		     *
		     * @fires Highcharts.Series#event:remove
		     */
		    remove: function (redraw, animation, withEvent) {
		        var series = this,
		            chart = series.chart;

		        function remove() {

		            // Destroy elements
		            series.destroy();
		            series.remove = null; // Prevent from doing again (#9097)

		            // Redraw
		            chart.isDirtyLegend = chart.isDirtyBox = true;
		            chart.linkSeries();

		            if (pick(redraw, true)) {
		                chart.redraw(animation);
		            }
		        }

		        // Fire the event with a default handler of removing the point
		        if (withEvent !== false) {
		            fireEvent(series, 'remove', null, remove);
		        } else {
		            remove();
		        }
		    },

		    /**
		     * Update the series with a new set of options. For a clean and precise
		     * handling of new options, all methods and elements from the series are
		     * removed, and it is initiated from scratch. Therefore, this method is more
		     * performance expensive than some other utility methods like {@link
		     * Series#setData} or {@link Series#setVisible}.
		     *
		     * @sample highcharts/members/series-update/
		     *         Updating series options
		     * @sample maps/members/series-update/
		     *         Update series options in Highmaps
		     *
		     * @function Highcharts.Series#update
		     *
		     * @param {Highcharts.SeriesOptions} options
		     *        New options that will be merged with the series' existing options.
		     *
		     * @param {boolean} [redraw=true]
		     *        Whether to redraw the chart after the series is altered. If doing
		     *        more operations on the chart, it is a good idea to set redraw to
		     *        false and call {@link Chart#redraw} after.
		     *
		     * @fires Highcharts.Series#event:afterUpdate
		     */
		    update: function (newOptions, redraw) {
		        var series = this,
		            chart = series.chart,
		            // must use user options when changing type because series.options
		            // is merged in with type specific plotOptions
		            oldOptions = series.userOptions,
		            oldType = series.oldType || series.type,
		            newType = (
		                newOptions.type ||
		                oldOptions.type ||
		                chart.options.chart.type
		            ),
		            proto = seriesTypes[oldType].prototype,
		            n,
		            groups = [
		                'group',
		                'markerGroup',
		                'dataLabelsGroup'
		            ],
		            preserve = [
		                'navigatorSeries',
		                'baseSeries'
		            ],

		            // Animation must be enabled when calling update before the initial
		            // animation has first run. This happens when calling update
		            // directly after chart initialization, or when applying responsive
		            // rules (#6912).
		            animation = series.finishedAnimating && { animation: false },
		            allowSoftUpdate = [
		                'data',
		                'name',
		                'turboThreshold'
		            ],
		            keys = H.keys(newOptions),
		            doSoftUpdate = keys.length > 0;

		        // Running Series.update to update the data only is an intuitive usage,
		        // so we want to make sure that when used like this, we run the
		        // cheaper setData function and allow animation instead of completely
		        // recreating the series instance. This includes sideways animation when
		        // adding points to the data set. The `name` should also support soft
		        // update because the data module sets name and data when setting new
		        // data by `chart.update`.
		        each(keys, function (key) {
		            if (inArray(key, allowSoftUpdate) === -1) {
		                doSoftUpdate = false;
		            }
		        });
		        if (doSoftUpdate) {
		            if (newOptions.data) {
		                this.setData(newOptions.data, false);
		            }
		            if (newOptions.name) {
		                this.setName(newOptions.name, false);
		            }
		        } else {

		            // Make sure preserved properties are not destroyed (#3094)
		            preserve = groups.concat(preserve);
		            each(preserve, function (prop) {
		                preserve[prop] = series[prop];
		                delete series[prop];
		            });

		            // Do the merge, with some forced options
		            newOptions = merge(oldOptions, animation, {
		                index: series.index,
		                pointStart: pick(
		                    oldOptions.pointStart, // when updating from blank (#7933)
		                    series.xData[0] // when updating after addPoint
		                )
		            }, { data: series.options.data }, newOptions);

		            // Destroy the series and delete all properties. Reinsert all
		            // methods and properties from the new type prototype (#2270,
		            // #3719).
		            series.remove(false, null, false);
		            for (n in proto) {
		                series[n] = undefined;
		            }
		            if (seriesTypes[newType || oldType]) {
		                extend(series, seriesTypes[newType || oldType].prototype);
		            } else {
		                H.error(17, true);
		            }

		            // Re-register groups (#3094) and other preserved properties
		            each(preserve, function (prop) {
		                series[prop] = preserve[prop];
		            });

		            series.init(chart, newOptions);

		            // Update the Z index of groups (#3380, #7397)
		            if (newOptions.zIndex !== oldOptions.zIndex) {
		                each(groups, function (groupName) {
		                    if (series[groupName]) {
		                        series[groupName].attr({
		                            zIndex: newOptions.zIndex
		                        });
		                    }
		                });
		            }


		            series.oldType = oldType;
		            chart.linkSeries(); // Links are lost in series.remove (#3028)

		        }
		        fireEvent(this, 'afterUpdate');

		        if (pick(redraw, true)) {
		            chart.redraw(doSoftUpdate ? undefined : false);
		        }
		    },

		    /**
		     * Used from within series.update
		     *
		     * @private
		     * @function Highcharts.Series#setName
		     *
		     * @param {string} name
		     */
		    setName: function (name) {
		        this.name = this.options.name = this.userOptions.name = name;
		        this.chart.isDirtyLegend = true;
		    }
		});

		// Extend the Axis.prototype for dynamic methods
		extend(Axis.prototype, /** @lends Highcharts.Axis.prototype */ {

		    /**
		     * Update an axis object with a new set of options. The options are merged
		     * with the existing options, so only new or altered options need to be
		     * specified.
		     *
		     * @sample highcharts/members/axis-update/
		     *         Axis update demo
		     *
		     * @function Highcharts.Axis#update
		     *
		     * @param {Highcharts.XAxisOptions|Highcharts.YAxisOptions|Highcharts.ZAxisOptions} options
		     *        The new options that will be merged in with existing options on
		     *        the axis.
		     */
		    update: function (options, redraw) {
		        var chart = this.chart,
		            newEvents = ((options && options.events) || {});

		        options = merge(this.userOptions, options);

		        // Color Axis is not an array,
		        // This change is applied in the ColorAxis wrapper
		        if (chart.options[this.coll].indexOf) {
		            // Don't use this.options.index,
		            // StockChart has Axes in navigator too
		            chart.options[this.coll][
		                chart.options[this.coll].indexOf(this.userOptions)
		            ] = options;
		        }

		        // Remove old events, if no new exist (#8161)
		        objectEach(chart.options[this.coll].events, function (fn, ev) {
		            if (typeof newEvents[ev] === 'undefined') {
		                newEvents[ev] = undefined;
		            }
		        });

		        this.destroy(true);
		        this.init(chart, extend(options, { events: newEvents }));

		        chart.isDirtyBox = true;
		        if (pick(redraw, true)) {
		            chart.redraw();
		        }
		    },

		    /**
		     * Remove the axis from the chart.
		     *
		     * @sample highcharts/members/chart-addaxis/
		     *         Add and remove axes
		     *
		     * @function Highcharts.Axis#remove
		     *
		     * @param {boolean} [redraw=true]
		     *        Whether to redraw the chart following the remove.
		     */
		    remove: function (redraw) {
		        var chart = this.chart,
		            key = this.coll, // xAxis or yAxis
		            axisSeries = this.series,
		            i = axisSeries.length;

		        // Remove associated series (#2687)
		        while (i--) {
		            if (axisSeries[i]) {
		                axisSeries[i].remove(false);
		            }
		        }

		        // Remove the axis
		        erase(chart.axes, this);
		        erase(chart[key], this);

		        if (isArray(chart.options[key])) {
		            chart.options[key].splice(this.options.index, 1);
		        } else { // color axis, #6488
		            delete chart.options[key];
		        }

		        each(chart[key], function (axis, i) { // Re-index, #1706, #8075
		            axis.options.index = axis.userOptions.index = i;
		        });
		        this.destroy();
		        chart.isDirtyBox = true;

		        if (pick(redraw, true)) {
		            chart.redraw();
		        }
		    },

		    /**
		     * Update the axis title by options after render time.
		     *
		     * @sample highcharts/members/axis-settitle/
		     *         Set a new Y axis title
		     *
		     * @function Highcharts.Axis#setTitle
		     *
		     * @param {Highcharts.XAxisTitleOptions|Highcharts.YAxisTitleOptions|Highcharts.ZAxisTitleOptions} titleOptions
		     *        The additional title options.
		     *
		     * @param {boolean} [redraw=true]
		     *        Whether to redraw the chart after setting the title.
		     */
		    setTitle: function (titleOptions, redraw) {
		        this.update({ title: titleOptions }, redraw);
		    },

		    /**
		     * Set new axis categories and optionally redraw.
		     *
		     * @sample highcharts/members/axis-setcategories/
		     *         Set categories by click on a button
		     *
		     * @function Highcharts.Axis#setCategories
		     *
		     * @param {Array<string>} categories
		     *        The new categories.
		     *
		     * @param {boolean} [redraw=true]
		     *        Whether to redraw the chart.
		     */
		    setCategories: function (categories, redraw) {
		        this.update({ categories: categories }, redraw);
		    }

		});

	}(Highcharts));
	(function (H) {
		/**
		 * (c) 2010-2018 Torstein Honsi
		 *
		 * License: www.highcharts.com/license
		 */



		var color = H.color,
		    each = H.each,
		    LegendSymbolMixin = H.LegendSymbolMixin,
		    map = H.map,
		    pick = H.pick,
		    Series = H.Series,
		    seriesType = H.seriesType;

		/**
		 * Area series type.
		 *
		 * @private
		 * @class
		 * @name Highcharts.seriesTypes.area
		 *
		 * @augments Highcharts.Series
		 */
		seriesType('area', 'line'

		/**
		 * The area series type.
		 *
		 * @sample {highcharts} highcharts/demo/area-basic/
		 *         Area chart
		 * @sample {highstock} stock/demo/area/
		 *         Area chart
		 *
		 * @extends      plotOptions.line
		 * @product      highcharts highstock
		 * @optionparent plotOptions.area
		 */
		, {

		    /**
		     * Fill color or gradient for the area. When `null`, the series' `color`
		     * is used with the series' `fillOpacity`.
		     *
		     * In styled mode, the fill color can be set with the `.highcharts-area`
		     * class name.
		     *
		     * @sample {highcharts} highcharts/plotoptions/area-fillcolor-default/
		     *         Null by default
		     * @sample {highcharts} highcharts/plotoptions/area-fillcolor-gradient/
		     *         Gradient
		     *
		     * @type      {Highcharts.ColorString}
		     * @product   highcharts highstock
		     * @apioption plotOptions.area.fillColor
		     */

		    /**
		     * Fill opacity for the area. When you set an explicit `fillColor`,
		     * the `fillOpacity` is not applied. Instead, you should define the
		     * opacity in the `fillColor` with an rgba color definition. The
		     * `fillOpacity` setting, also the default setting, overrides the alpha
		     * component of the `color` setting.
		     *
		     * In styled mode, the fill opacity can be set with the `.highcharts-area`
		     * class name.
		     *
		     * @sample {highcharts} highcharts/plotoptions/area-fillopacity/
		     *         Automatic fill color and fill opacity of 0.1
		     *
		     * @type      {number}
		     * @default   {highcharts} 0.75
		     * @default   {highstock} 0.75
		     * @product   highcharts highstock
		     * @apioption plotOptions.area.fillOpacity
		     */

		    /**
		     * A separate color for the graph line. By default the line takes the
		     * `color` of the series, but the lineColor setting allows setting a
		     * separate color for the line without altering the `fillColor`.
		     *
		     * In styled mode, the line stroke can be set with the `.highcharts-graph`
		     * class name.
		     *
		     * @sample {highcharts} highcharts/plotoptions/area-linecolor/
		     *         Dark gray line
		     *
		     * @type      {Highcharts.ColorString}
		     * @product   highcharts highstock
		     * @apioption plotOptions.area.lineColor
		     */

		    /**
		     * A separate color for the negative part of the area.
		     *
		     * In styled mode, a negative color is set with the `.highcharts-negative`
		     * class name.
		     *
		     * @see [negativeColor](#plotOptions.area.negativeColor)
		     *
		     * @sample {highcharts} highcharts/css/series-negative-color/
		     *         Negative color in styled mode
		     *
		     * @type      {Highcharts.ColorString}
		     * @since     3.0
		     * @product   highcharts
		     * @apioption plotOptions.area.negativeFillColor
		     */

		    /**
		     * Whether the whole area or just the line should respond to mouseover
		     * tooltips and other mouse or touch events.
		     *
		     * @sample {highcharts|highstock} highcharts/plotoptions/area-trackbyarea/
		     *         Display the tooltip when the area is hovered
		     *
		     * @type      {boolean}
		     * @default   false
		     * @since     1.1.6
		     * @product   highcharts highstock
		     * @apioption plotOptions.area.trackByArea
		     */

		    /**
		     * When this is true, the series will not cause the Y axis to cross
		     * the zero plane (or [threshold](#plotOptions.series.threshold) option)
		     * unless the data actually crosses the plane.
		     *
		     * For example, if `softThreshold` is `false`, a series of 0, 1, 2,
		     * 3 will make the Y axis show negative values according to the `minPadding`
		     * option. If `softThreshold` is `true`, the Y axis starts at 0.
		     *
		     * @since   4.1.9
		     * @product highcharts highstock
		     */
		    softThreshold: false,

		    /**
		     * The Y axis value to serve as the base for the area, for distinguishing
		     * between values above and below a threshold. The area between the graph
		     * and the threshold is filled.
		     *
		     * * If a number is given, the Y axis will scale to the threshold.
		     * * If `null`, the scaling behaves like a line series with fill between the
		     *   graph and the Y axis minimum.
		     * * If `Infinity` or `-Infinity`, the area between the graph and the
		     *   corresponing Y axis extreme is filled (since v6.1.0).
		     *
		     * @sample {highcharts} highcharts/plotoptions/area-threshold/
		     *         A threshold of 100
		     * @sample {highcharts} highcharts/plotoptions/area-threshold-infinity/
		     *         A threshold of Infinity
		     *
		     * @since   2.0
		     * @product highcharts highstock
		     */
		    threshold: 0


		}, /** @lends seriesTypes.area.prototype */ {

		    singleStacks: false,

		    /**
		     * Return an array of stacked points, where null and missing points are
		     * replaced by dummy points in order for gaps to be drawn correctly
		     * in stacks.
		     *
		     * @private
		     * @function Highcharts.seriesTypes.area#getStackPoints
		     *
		     * @param {Array<Highcharts.Point>} points
		     *
		     * @return {Array<*>}
		     */
		    getStackPoints: function (points) {
		        var series = this,
		            segment = [],
		            keys = [],
		            xAxis = this.xAxis,
		            yAxis = this.yAxis,
		            stack = yAxis.stacks[this.stackKey],
		            pointMap = {},
		            seriesIndex = series.index,
		            yAxisSeries = yAxis.series,
		            seriesLength = yAxisSeries.length,
		            visibleSeries,
		            upOrDown = pick(yAxis.options.reversedStacks, true) ? 1 : -1,
		            i;


		        points = points || this.points;

		        if (this.options.stacking) {

		            for (i = 0; i < points.length; i++) {
		                // Reset after point update (#7326)
		                points[i].leftNull = points[i].rightNull = null;

		                // Create a map where we can quickly look up the points by their
		                // X values.
		                pointMap[points[i].x] = points[i];
		            }

		            // Sort the keys (#1651)
		            H.objectEach(stack, function (stackX, x) {
		                // nulled after switching between
		                // grouping and not (#1651, #2336)
		                if (stackX.total !== null) {
		                    keys.push(x);
		                }
		            });
		            keys.sort(function (a, b) {
		                return a - b;
		            });

		            visibleSeries = map(yAxisSeries, function () {
		                return this.visible;
		            });

		            each(keys, function (x, idx) {
		                var y = 0,
		                    stackPoint,
		                    stackedValues;

		                if (pointMap[x] && !pointMap[x].isNull) {
		                    segment.push(pointMap[x]);

		                    // Find left and right cliff. -1 goes left, 1 goes right.
		                    each([-1, 1], function (direction) {
		                        var nullName = direction === 1 ?
		                                'rightNull' :
		                                'leftNull',
		                            cliffName = direction === 1 ?
		                                'rightCliff' :
		                                'leftCliff',
		                            cliff = 0,
		                            otherStack = stack[keys[idx + direction]];

		                        // If there is a stack next to this one,
		                        // to the left or to the right...
		                        if (otherStack) {
		                            i = seriesIndex;
		                            // Can go either up or down,
		                            // depending on reversedStacks
		                            while (i >= 0 && i < seriesLength) {
		                                stackPoint = otherStack.points[i];
		                                if (!stackPoint) {
		                                    // If the next point in this series
		                                    // is missing, mark the point
		                                    // with point.leftNull or
		                                    // point.rightNull = true.
		                                    if (i === seriesIndex) {
		                                        pointMap[x][nullName] = true;

		                                    // If there are missing points in
		                                    // the next stack in any of the
		                                    // series below this one, we need
		                                    // to substract the missing values
		                                    // and add a hiatus to the left or right.
		                                    } else if (visibleSeries[i]) {
		                                        stackedValues = stack[x].points[i];
		                                        if (stackedValues) {
		                                            cliff -= stackedValues[1] -
		                                                stackedValues[0];
		                                        }
		                                    }
		                                }
		                                // When reversedStacks is true, loop up,
		                                // else loop down
		                                i += upOrDown;
		                            }
		                        }
		                        pointMap[x][cliffName] = cliff;
		                    });


		                // There is no point for this X value in this series, so we
		                // insert a dummy point in order for the areas to be drawn
		                // correctly.
		                } else {

		                    // Loop down the stack to find the series below this
		                    // one that has a value (#1991)
		                    i = seriesIndex;
		                    while (i >= 0 && i < seriesLength) {
		                        stackPoint = stack[x].points[i];
		                        if (stackPoint) {
		                            y = stackPoint[1];
		                            break;
		                        }
		                        // When reversedStacks is true, loop up, else loop down
		                        i += upOrDown;
		                    }
		                    y = yAxis.translate(y, 0, 1, 0, 1); // #6272
		                    segment.push({
		                        isNull: true,
		                        plotX: xAxis.translate(x, 0, 0, 0, 1), // #6272
		                        x: x,
		                        plotY: y,
		                        yBottom: y
		                    });
		                }
		            });

		        }

		        return segment;
		    },

		    /**
		     * @private
		     * @function Highcharts.seriesTypes.area#getGraphPath
		     *
		     * @param {Array<Highcharts.Point>} points
		     *
		     * @return {Highcharts.SVGPathArray}
		     */
		    getGraphPath: function (points) {
		        var getGraphPath = Series.prototype.getGraphPath,
		            graphPath,
		            options = this.options,
		            stacking = options.stacking,
		            yAxis = this.yAxis,
		            topPath,
		            bottomPath,
		            bottomPoints = [],
		            graphPoints = [],
		            seriesIndex = this.index,
		            i,
		            areaPath,
		            plotX,
		            stacks = yAxis.stacks[this.stackKey],
		            threshold = options.threshold,
		            translatedThreshold = yAxis.getThreshold(options.threshold),
		            isNull,
		            yBottom,
		            connectNulls = options.connectNulls || stacking === 'percent',
		            /**
		             * To display null points in underlying stacked series, this
		             * series graph must be broken, and the area also fall down
		             * to fill the gap left by the null point. #2069
		             */
		            addDummyPoints = function (i, otherI, side) {
		                var point = points[i],
		                    stackedValues = stacking &&
		                        stacks[point.x].points[seriesIndex],
		                    nullVal = point[side + 'Null'] || 0,
		                    cliffVal = point[side + 'Cliff'] || 0,
		                    top,
		                    bottom,
		                    isNull = true;

		                if (cliffVal || nullVal) {

		                    top = (nullVal ? stackedValues[0] : stackedValues[1]) +
		                        cliffVal;
		                    bottom = stackedValues[0] + cliffVal;
		                    isNull = !!nullVal;

		                } else if (
		                    !stacking &&
		                    points[otherI] &&
		                    points[otherI].isNull
		                ) {
		                    top = bottom = threshold;
		                }

		                // Add to the top and bottom line of the area
		                if (top !== undefined) {
		                    graphPoints.push({
		                        plotX: plotX,
		                        plotY: top === null ?
		                            translatedThreshold :
		                            yAxis.getThreshold(top),
		                        isNull: isNull,
		                        isCliff: true
		                    });
		                    bottomPoints.push({
		                        plotX: plotX,
		                        plotY: bottom === null ?
		                            translatedThreshold :
		                            yAxis.getThreshold(bottom),
		                        doCurve: false // #1041, gaps in areaspline areas
		                    });
		                }
		            };

		        // Find what points to use
		        points = points || this.points;

		        // Fill in missing points
		        if (stacking) {
		            points = this.getStackPoints(points);
		        }

		        for (i = 0; i < points.length; i++) {
		            isNull = points[i].isNull;
		            plotX = pick(points[i].rectPlotX, points[i].plotX);
		            yBottom = pick(points[i].yBottom, translatedThreshold);

		            if (!isNull || connectNulls) {

		                if (!connectNulls) {
		                    addDummyPoints(i, i - 1, 'left');
		                }
		                // Skip null point when stacking is false and connectNulls true
		                if (!(isNull && !stacking && connectNulls)) {
		                    graphPoints.push(points[i]);
		                    bottomPoints.push({
		                        x: i,
		                        plotX: plotX,
		                        plotY: yBottom
		                    });
		                }

		                if (!connectNulls) {
		                    addDummyPoints(i, i + 1, 'right');
		                }
		            }
		        }

		        topPath = getGraphPath.call(this, graphPoints, true, true);

		        bottomPoints.reversed = true;
		        bottomPath = getGraphPath.call(this, bottomPoints, true, true);
		        if (bottomPath.length) {
		            bottomPath[0] = 'L';
		        }

		        areaPath = topPath.concat(bottomPath);
		        // TODO: don't set leftCliff and rightCliff when connectNulls?
		        graphPath = getGraphPath.call(this, graphPoints, false, connectNulls);
		        areaPath.xMap = topPath.xMap;
		        this.areaPath = areaPath;

		        return graphPath;
		    },

		    /**
		     * Draw the graph and the underlying area. This method calls the Series base
		     * function and adds the area. The areaPath is calculated in the
		     * getSegmentPath method called from Series.prototype.drawGraph.
		     *
		     * @private
		     * @function Highcharts.seriesTypes.area#drawGraph
		     */
		    drawGraph: function () {

		        // Define or reset areaPath
		        this.areaPath = [];

		        // Call the base method
		        Series.prototype.drawGraph.apply(this);

		        // Define local variables
		        var series = this,
		            areaPath = this.areaPath,
		            options = this.options,
		            zones = this.zones,
		            props = [[
		                'area',
		                'highcharts-area',

		                this.color,
		                options.fillColor

		            ]]; // area name, main color, fill color

		        each(zones, function (zone, i) {
		            props.push([
		                'zone-area-' + i,
		                'highcharts-area highcharts-zone-area-' + i + ' ' +
		                    zone.className,

		                zone.color || series.color,
		                zone.fillColor || options.fillColor

		            ]);
		        });

		        each(props, function (prop) {
		            var areaKey = prop[0],
		                area = series[areaKey];

		            // Create or update the area
		            if (area) { // update
		                area.endX = series.preventGraphAnimation ? null : areaPath.xMap;
		                area.animate({ d: areaPath });

		            } else { // create
		                area = series[areaKey] = series.chart.renderer.path(areaPath)
		                    .addClass(prop[1])
		                    .attr({

		                        fill: pick(
		                            prop[3],
		                            color(prop[2])
		                                .setOpacity(pick(options.fillOpacity, 0.75))
		                                .get()
		                        ),

		                        zIndex: 0 // #1069
		                    }).add(series.group);
		                area.isArea = true;
		            }
		            area.startX = areaPath.xMap;
		            area.shiftUnit = options.step ? 2 : 1;
		        });
		    },

		    drawLegendSymbol: LegendSymbolMixin.drawRectangle
		});

		/**
		 * A `area` series. If the [type](#series.area.type) option is not
		 * specified, it is inherited from [chart.type](#chart.type).
		 *
		 * @extends   series,plotOptions.area
		 * @excluding dataParser, dataURL
		 * @product   highcharts highstock
		 * @apioption series.area
		 */

		/**
		 * An array of data points for the series. For the `area` series type,
		 * points can be given in the following ways:
		 *
		 * 1.  An array of numerical values. In this case, the numerical values
		 * will be interpreted as `y` options. The `x` values will be automatically
		 * calculated, either starting at 0 and incremented by 1, or from `pointStart`
		 * and `pointInterval` given in the series options. If the axis has
		 * categories, these will be used. Example:
		 *
		 *  ```js
		 *  data: [0, 5, 3, 5]
		 *  ```
		 *
		 * 2.  An array of arrays with 2 values. In this case, the values correspond
		 * to `x,y`. If the first value is a string, it is applied as the name
		 * of the point, and the `x` value is inferred.
		 *
		 *  ```js
		 *     data: [
		 *         [0, 9],
		 *         [1, 7],
		 *         [2, 6]
		 *     ]
		 *  ```
		 *
		 * 3.  An array of objects with named values. The following snippet shows only a
		 * few settings, see the complete options set below. If the total number of data
		 * points exceeds the series' [turboThreshold](#series.area.turboThreshold),
		 * this option is not available.
		 *
		 *  ```js
		 *     data: [{
		 *         x: 1,
		 *         y: 9,
		 *         name: "Point2",
		 *         color: "#00FF00"
		 *     }, {
		 *         x: 1,
		 *         y: 6,
		 *         name: "Point1",
		 *         color: "#FF00FF"
		 *     }]
		 *  ```
		 *
		 * @sample {highcharts} highcharts/chart/reflow-true/
		 *         Numerical values
		 * @sample {highcharts} highcharts/series/data-array-of-arrays/
		 *         Arrays of numeric x and y
		 * @sample {highcharts} highcharts/series/data-array-of-arrays-datetime/
		 *         Arrays of datetime x and y
		 * @sample {highcharts} highcharts/series/data-array-of-name-value/
		 *         Arrays of point.name and y
		 * @sample {highcharts} highcharts/series/data-array-of-objects/
		 *         Config objects
		 *
		 * @type      {Array<number|Array<number>|*>}
		 * @extends   series.line.data
		 * @product   highcharts highstock
		 * @apioption series.area.data
		 */

	}(Highcharts));
	(function (H) {
		/**
		 * (c) 2010-2018 Torstein Honsi
		 *
		 * License: www.highcharts.com/license
		 */



		var pick = H.pick,
		    seriesType = H.seriesType;

		/**
		 * Spline series type.
		 *
		 * @private
		 * @class
		 * @name Highcharts.seriesTypes.spline
		 *
		 * @augments Highcarts.Series
		 */
		seriesType('spline', 'line'

		/**
		 * A spline series is a special type of line series, where the segments
		 * between the data points are smoothed.
		 *
		 * @sample {highcharts} highcharts/demo/spline-irregular-time/
		 *         Spline chart
		 * @sample {highstock} stock/demo/spline/
		 *         Spline chart
		 *
		 * @extends      plotOptions.series
		 * @excluding    step
		 * @product      highcharts highstock
		 * @optionparent plotOptions.spline
		 */
		, {

		}, /** @lends seriesTypes.spline.prototype */ {

		    /**
		     * Get the spline segment from a given point's previous neighbour to the
		     * given point.
		     *
		     * @private
		     * @function Highcharts.seriesTypes.spline#getPointSpline
		     *
		     * @param {Array<Highcharts.Point>}
		     *
		     * @param {Highcharts.Point} point
		     *
		     * @param {number} i
		     *
		     * @return {Highcharts.SVGPathArray}
		     */
		    getPointSpline: function (points, point, i) {
		        var
		            // 1 means control points midway between points, 2 means 1/3 from
		            // the point, 3 is 1/4 etc
		            smoothing = 1.5,
		            denom = smoothing + 1,
		            plotX = point.plotX,
		            plotY = point.plotY,
		            lastPoint = points[i - 1],
		            nextPoint = points[i + 1],
		            leftContX,
		            leftContY,
		            rightContX,
		            rightContY,
		            ret;

		        function doCurve(otherPoint) {
		            return otherPoint &&
		                !otherPoint.isNull &&
		                otherPoint.doCurve !== false &&
		                !point.isCliff; // #6387, area splines next to null
		        }

		        // Find control points
		        if (doCurve(lastPoint) && doCurve(nextPoint)) {
		            var lastX = lastPoint.plotX,
		                lastY = lastPoint.plotY,
		                nextX = nextPoint.plotX,
		                nextY = nextPoint.plotY,
		                correction = 0;

		            leftContX = (smoothing * plotX + lastX) / denom;
		            leftContY = (smoothing * plotY + lastY) / denom;
		            rightContX = (smoothing * plotX + nextX) / denom;
		            rightContY = (smoothing * plotY + nextY) / denom;

		            // Have the two control points make a straight line through main
		            // point
		            if (rightContX !== leftContX) { // #5016, division by zero
		                correction = ((rightContY - leftContY) * (rightContX - plotX)) /
		                    (rightContX - leftContX) + plotY - rightContY;
		            }

		            leftContY += correction;
		            rightContY += correction;

		            // to prevent false extremes, check that control points are between
		            // neighbouring points' y values
		            if (leftContY > lastY && leftContY > plotY) {
		                leftContY = Math.max(lastY, plotY);
		                // mirror of left control point
		                rightContY = 2 * plotY - leftContY;
		            } else if (leftContY < lastY && leftContY < plotY) {
		                leftContY = Math.min(lastY, plotY);
		                rightContY = 2 * plotY - leftContY;
		            }
		            if (rightContY > nextY && rightContY > plotY) {
		                rightContY = Math.max(nextY, plotY);
		                leftContY = 2 * plotY - rightContY;
		            } else if (rightContY < nextY && rightContY < plotY) {
		                rightContY = Math.min(nextY, plotY);
		                leftContY = 2 * plotY - rightContY;
		            }

		            // record for drawing in next point
		            point.rightContX = rightContX;
		            point.rightContY = rightContY;


		        }

		        // Visualize control points for debugging
		        /*
		        if (leftContX) {
		            this.chart.renderer.circle(
		                    leftContX + this.chart.plotLeft,
		                    leftContY + this.chart.plotTop,
		                    2
		                )
		                .attr({
		                    stroke: 'red',
		                    'stroke-width': 2,
		                    fill: 'none',
		                    zIndex: 9
		                })
		                .add();
		            this.chart.renderer.path(['M', leftContX + this.chart.plotLeft,
		                leftContY + this.chart.plotTop,
		                'L', plotX + this.chart.plotLeft, plotY + this.chart.plotTop])
		                .attr({
		                    stroke: 'red',
		                    'stroke-width': 2,
		                    zIndex: 9
		                })
		                .add();
		        }
		        if (rightContX) {
		            this.chart.renderer.circle(
		                    rightContX + this.chart.plotLeft,
		                    rightContY + this.chart.plotTop,
		                    2
		                )
		                .attr({
		                    stroke: 'green',
		                    'stroke-width': 2,
		                    fill: 'none',
		                    zIndex: 9
		                })
		                .add();
		            this.chart.renderer.path(['M', rightContX + this.chart.plotLeft,
		                rightContY + this.chart.plotTop,
		                'L', plotX + this.chart.plotLeft, plotY + this.chart.plotTop])
		                .attr({
		                    stroke: 'green',
		                    'stroke-width': 2,
		                    zIndex: 9
		                })
		                .add();
		        }
		        // */
		        ret = [
		            'C',
		            pick(lastPoint.rightContX, lastPoint.plotX),
		            pick(lastPoint.rightContY, lastPoint.plotY),
		            pick(leftContX, plotX),
		            pick(leftContY, plotY),
		            plotX,
		            plotY
		        ];
		        // reset for updating series later
		        lastPoint.rightContX = lastPoint.rightContY = null;
		        return ret;
		    }
		});

		/**
		 * A `spline` series. If the [type](#series.spline.type) option is
		 * not specified, it is inherited from [chart.type](#chart.type).
		 *
		 * @extends   series,plotOptions.spline
		 * @excluding dataParser, dataURL, step
		 * @product   highcharts highstock
		 * @apioption series.spline
		 */

		/**
		 * An array of data points for the series. For the `spline` series type,
		 * points can be given in the following ways:
		 *
		 * 1.  An array of numerical values. In this case, the numerical values
		 * will be interpreted as `y` options. The `x` values will be automatically
		 * calculated, either starting at 0 and incremented by 1, or from `pointStart`
		 * and `pointInterval` given in the series options. If the axis has
		 * categories, these will be used. Example:
		 *
		 *  ```js
		 *  data: [0, 5, 3, 5]
		 *  ```
		 *
		 * 2.  An array of arrays with 2 values. In this case, the values correspond
		 * to `x,y`. If the first value is a string, it is applied as the name
		 * of the point, and the `x` value is inferred.
		 *
		 *  ```js
		 *     data: [
		 *         [0, 9],
		 *         [1, 2],
		 *         [2, 8]
		 *     ]
		 *  ```
		 *
		 * 3.  An array of objects with named values. The following snippet shows only a
		 * few settings, see the complete options set below. If the total number of data
		 * points exceeds the series' [turboThreshold](#series.spline.turboThreshold),
		 * this option is not available.
		 *
		 *  ```js
		 *     data: [{
		 *         x: 1,
		 *         y: 9,
		 *         name: "Point2",
		 *         color: "#00FF00"
		 *     }, {
		 *         x: 1,
		 *         y: 0,
		 *         name: "Point1",
		 *         color: "#FF00FF"
		 *     }]
		 *  ```
		 *
		 * @sample {highcharts} highcharts/chart/reflow-true/
		 *         Numerical values
		 * @sample {highcharts} highcharts/series/data-array-of-arrays/
		 *         Arrays of numeric x and y
		 * @sample {highcharts} highcharts/series/data-array-of-arrays-datetime/
		 *         Arrays of datetime x and y
		 * @sample {highcharts} highcharts/series/data-array-of-name-value/
		 *         Arrays of point.name and y
		 * @sample {highcharts} highcharts/series/data-array-of-objects/
		 *         Config objects
		 *
		 * @type      {Array<number|Array<number>|*>}
		 * @extends   series.line.data
		 * @product   highcharts highstock
		 * @apioption series.spline.data
		 */

	}(Highcharts));
	(function (H) {
		/**
		 * (c) 2010-2018 Torstein Honsi
		 *
		 * License: www.highcharts.com/license
		 */



		var areaProto = H.seriesTypes.area.prototype,
		    defaultPlotOptions = H.defaultPlotOptions,
		    LegendSymbolMixin = H.LegendSymbolMixin,
		    seriesType = H.seriesType;

		/**
		 * AreaSpline series type.
		 *
		 * @private
		 * @class
		 * @name Highcharts.seriesTypes.areaspline
		 *
		 * @augments Highcharts.Series
		 */
		seriesType('areaspline', 'spline',

		    /**
		     * The area spline series is an area series where the graph between the
		     * points is smoothed into a spline.
		     *
		     * @sample {highcharts} highcharts/demo/areaspline/
		     *         Area spline chart
		     * @sample {highstock} stock/demo/areaspline/
		     *         Area spline chart
		     *
		     * @extends   plotOptions.area
		     * @excluding step
		     * @product   highcharts highstock
		     * @apioption plotOptions.areaspline
		     */
		    defaultPlotOptions.area
		, {

		    /**
		     * @private
		     * @function Highcharts.seriesTypes.areaspline#getStackPoints
		     */
		    getStackPoints: areaProto.getStackPoints,

		    /**
		     * @private
		     * @function Highcharts.seriesTypes.areaspline#getGraphPath
		     */
		    getGraphPath: areaProto.getGraphPath,

		    /**
		     * @private
		     * @function Highcharts.seriesTypes.areaspline#drawGraph
		     */
		    drawGraph: areaProto.drawGraph,

		    /**
		     * @private
		     * @borrows Highcharts.LegendSymbolMixin#drawRectangle as Highcharts.seriesTypes.areaspline#drawLegendSymbol
		     */
		    drawLegendSymbol: LegendSymbolMixin.drawRectangle

		});

		/**
		 * A `areaspline` series. If the [type](#series.areaspline.type) option
		 * is not specified, it is inherited from [chart.type](#chart.type).
		 *
		 *
		 * @extends   series,plotOptions.areaspline
		 * @excluding dataParser, dataURL
		 * @product   highcharts highstock
		 * @apioption series.areaspline
		 */

		/**
		 * An array of data points for the series. For the `areaspline` series
		 * type, points can be given in the following ways:
		 *
		 * 1.  An array of numerical values. In this case, the numerical values
		 * will be interpreted as `y` options. The `x` values will be automatically
		 * calculated, either starting at 0 and incremented by 1, or from `pointStart`
		 * and `pointInterval` given in the series options. If the axis has
		 * categories, these will be used. Example:
		 *
		 *  ```js
		 *  data: [0, 5, 3, 5]
		 *  ```
		 *
		 * 2.  An array of arrays with 2 values. In this case, the values correspond
		 * to `x,y`. If the first value is a string, it is applied as the name
		 * of the point, and the `x` value is inferred.
		 *
		 *  ```js
		 *     data: [
		 *         [0, 10],
		 *         [1, 9],
		 *         [2, 3]
		 *     ]
		 *  ```
		 *
		 * 3.  An array of objects with named values. The following snippet shows only a
		 * few settings, see the complete options set below. If the total number of data
		 * points exceeds the series'
		 * [turboThreshold](#series.areaspline.turboThreshold), this option is not
		 * available.
		 *
		 *  ```js
		 *     data: [{
		 *         x: 1,
		 *         y: 4,
		 *         name: "Point2",
		 *         color: "#00FF00"
		 *     }, {
		 *         x: 1,
		 *         y: 4,
		 *         name: "Point1",
		 *         color: "#FF00FF"
		 *     }]
		 *  ```
		 *
		 * @sample {highcharts} highcharts/chart/reflow-true/
		 *         Numerical values
		 * @sample {highcharts} highcharts/series/data-array-of-arrays/
		 *         Arrays of numeric x and y
		 * @sample {highcharts} highcharts/series/data-array-of-arrays-datetime/
		 *         Arrays of datetime x and y
		 * @sample {highcharts} highcharts/series/data-array-of-name-value/
		 *         Arrays of point.name and y
		 * @sample {highcharts} highcharts/series/data-array-of-objects/
		 *         Config objects
		 *
		 * @type      {Array<number|Array<number|string|Date>|*>}
		 * @extends   series.line.data
		 * @product   highcharts highstock
		 * @apioption series.areaspline.data
		 */

	}(Highcharts));
	(function (H) {
		/**
		 * (c) 2010-2018 Torstein Honsi
		 *
		 * License: www.highcharts.com/license
		 */

		/**
		 * Adjusted width and x offset of the columns for grouping.
		 *
		 * @typedef Highcharts.ColumnMetricsObject
		 *
		 * @property {number} width
		 *           Width of the columns.
		 *
		 * @property {number} offset
		 *           Offset of the columns.
		 */



		var animObject = H.animObject,
		    color = H.color,
		    each = H.each,
		    extend = H.extend,
		    defined = H.defined,
		    isNumber = H.isNumber,
		    LegendSymbolMixin = H.LegendSymbolMixin,
		    merge = H.merge,
		    noop = H.noop,
		    pick = H.pick,
		    Series = H.Series,
		    seriesType = H.seriesType,
		    svg = H.svg;

		/**
		 * The column series type.
		 *
		 * @private
		 * @class
		 * @name Highcharts.seriesTypes.column
		 *
		 * @augments Highcharts.Series
		 */
		seriesType('column', 'line'

		/**
		 * Column series display one column per value along an X axis.
		 *
		 * @sample {highcharts} highcharts/demo/column-basic/
		 *         Column chart
		 * @sample {highstock} stock/demo/column/
		 *         Column chart
		 *
		 * @extends      plotOptions.line
		 * @excluding    connectNulls, dashStyle, gapSize, gapUnit, linecap,
		 *               lineWidth, marker, connectEnds, step
		 * @product      highcharts highstock
		 * @optionparent plotOptions.column
		 */
		, {

		    /**
		     * The corner radius of the border surrounding each column or bar.
		     *
		     * @sample {highcharts} highcharts/plotoptions/column-borderradius/
		     *         Rounded columns
		     *
		     * @product highcharts highstock gantt
		     */
		    borderRadius: 0,

		    /**
		     * When using automatic point colors pulled from the global [colors](colors)
		     * or series-specific [plotOptions.column.colors](series.colors)
		     * collections, this option determines whether the chart should receive
		     * one color per series or one color per point.
		     *
		     * In styled mode, the `colors` or `series.colors` arrays are not supported,
		     * and instead this option gives the points individual color class names on
		     * the form `highcharts-color-{n}`.
		     *
		     * @see [series colors](#plotOptions.column.colors)
		     *
		     * @sample {highcharts} highcharts/plotoptions/column-colorbypoint-false/
		     *         False by default
		     * @sample {highcharts} highcharts/plotoptions/column-colorbypoint-true/
		     *         True
		     *
		     * @type      {boolean}
		     * @default   false
		     * @since     2.0
		     * @product   highcharts highstock gantt
		     * @apioption plotOptions.column.colorByPoint
		     */

		    /**
		     * A series specific or series type specific color set to apply instead
		     * of the global [colors](#colors) when [colorByPoint](
		     * #plotOptions.column.colorByPoint) is true.
		     *
		     * @type      {Array<Highcharts.ColorString>}
		     * @since     3.0
		     * @product   highcharts highstock gantt
		     * @apioption plotOptions.column.colors
		     */

		    /**
		     * When true, each column edge is rounded to its nearest pixel in order
		     * to render sharp on screen. In some cases, when there are a lot of
		     * densely packed columns, this leads to visible difference in column
		     * widths or distance between columns. In these cases, setting `crisp`
		     * to `false` may look better, even though each column is rendered
		     * blurry.
		     *
		     * @sample {highcharts} highcharts/plotoptions/column-crisp-false/
		     *         Crisp is false
		     *
		     * @since   5.0.10
		     * @product highcharts highstock gantt
		     */
		    crisp: true,

		    /**
		     * Padding between each value groups, in x axis units.
		     *
		     * @sample {highcharts} highcharts/plotoptions/column-grouppadding-default/
		     *         0.2 by default
		     * @sample {highcharts} highcharts/plotoptions/column-grouppadding-none/
		     *         No group padding - all columns are evenly spaced
		     *
		     * @product highcharts highstock gantt
		     */
		    groupPadding: 0.2,

		    /**
		     * Whether to group non-stacked columns or to let them render independent
		     * of each other. Non-grouped columns will be laid out individually
		     * and overlap each other.
		     *
		     * @sample {highcharts} highcharts/plotoptions/column-grouping-false/
		     *         Grouping disabled
		     * @sample {highstock} highcharts/plotoptions/column-grouping-false/
		     *         Grouping disabled
		     *
		     * @type      {boolean}
		     * @default   true
		     * @since     2.3.0
		     * @product   highcharts highstock gantt
		     * @apioption plotOptions.column.grouping
		     */

		    /**
		     * @ignore-option
		     */
		    marker: null, // point options are specified in the base options

		    /**
		     * The maximum allowed pixel width for a column, translated to the height
		     * of a bar in a bar chart. This prevents the columns from becoming
		     * too wide when there is a small number of points in the chart.
		     *
		     * @see [pointWidth](#plotOptions.column.pointWidth)
		     *
		     * @sample {highcharts} highcharts/plotoptions/column-maxpointwidth-20/
		     *         Limited to 50
		     * @sample {highstock} highcharts/plotoptions/column-maxpointwidth-20/
		     *         Limited to 50
		     *
		     * @type      {number}
		     * @since     4.1.8
		     * @product   highcharts highstock gantt
		     * @apioption plotOptions.column.maxPointWidth
		     */

		    /**
		     * Padding between each column or bar, in x axis units.
		     *
		     * @sample {highcharts} highcharts/plotoptions/column-pointpadding-default/
		     *         0.1 by default
		     * @sample {highcharts} highcharts/plotoptions/column-pointpadding-025/
		     *          0.25
		     * @sample {highcharts} highcharts/plotoptions/column-pointpadding-none/
		     *         0 for tightly packed columns
		     *
		     * @product highcharts highstock gantt
		     */
		    pointPadding: 0.1,

		    /**
		     * A pixel value specifying a fixed width for each column or bar. When
		     * `null`, the width is calculated from the `pointPadding` and
		     * `groupPadding`.
		     *
		     * @see [maxPointWidth](#plotOptions.column.maxPointWidth)
		     *
		     * @sample {highcharts} highcharts/plotoptions/column-pointwidth-20/
		     *         20px wide columns regardless of chart width or the amount of data
		     *         points
		     *
		     * @type      {number}
		     * @since     1.2.5
		     * @product   highcharts highstock gantt
		     * @apioption plotOptions.column.pointWidth
		     */

		    /**
		     * A pixel value specifying a fixed width for the column or bar. Overrides
		     * pointWidth on the series.
		     *
		     * @type      {Number}
		     * @see       [series.pointWidth](#plotOptions.column.pointWidth)
		     * @default   undefined
		     * @since     7.0.0
		     * @product   highcharts highstock gantt
		     * @apioption series.column.data.pointWidth
		     */

		    /**
		     * The minimal height for a column or width for a bar. By default,
		     * 0 values are not shown. To visualize a 0 (or close to zero) point,
		     * set the minimal point length to a pixel value like 3\. In stacked
		     * column charts, minPointLength might not be respected for tightly
		     * packed values.
		     *
		     * @sample {highcharts} highcharts/plotoptions/column-minpointlength/
		     *         Zero base value
		     * @sample {highcharts} highcharts/plotoptions/column-minpointlength-pos-and-neg/
		     *         Positive and negative close to zero values
		     *
		     * @product highcharts highstock gantt
		     */
		    minPointLength: 0,

		    /**
		     * When the series contains less points than the crop threshold, all
		     * points are drawn, event if the points fall outside the visible plot
		     * area at the current zoom. The advantage of drawing all points (including
		     * markers and columns), is that animation is performed on updates.
		     * On the other hand, when the series contains more points than the
		     * crop threshold, the series data is cropped to only contain points
		     * that fall within the plot area. The advantage of cropping away invisible
		     * points is to increase performance on large series.
		     *
		     * @product highcharts highstock gantt
		     */
		    cropThreshold: 50,

		    /**
		     * The X axis range that each point is valid for. This determines the
		     * width of the column. On a categorized axis, the range will be 1
		     * by default (one category unit). On linear and datetime axes, the
		     * range will be computed as the distance between the two closest data
		     * points.
		     *
		     * The default `null` means it is computed automatically, but this option
		     * can be used to override the automatic value.
		     *
		     * @sample {highcharts} highcharts/plotoptions/column-pointrange/
		     *         Set the point range to one day on a data set with one week
		     *         between the points
		     *
		     * @type    {number|null}
		     * @since   2.3
		     * @product highcharts highstock gantt
		     */
		    pointRange: null,

		    states: {

		        /**
		         * Options for the hovered point. These settings override the normal
		         * state options when a point is moused over or touched.
		         *
		         * @extends   plotOptions.series.states.hover
		         * @excluding halo, lineWidth, lineWidthPlus, marker
		         * @product   highcharts highstock gantt
		         */
		        hover: {

		            /**
		             * @ignore-option
		             */
		            halo: false,

		            /**
		             * A specific border color for the hovered point. Defaults to
		             * inherit the normal state border color.
		             *
		             * @type      {Highcharts.ColorString}
		             * @product   highcharts gantt
		             * @apioption plotOptions.column.states.hover.borderColor
		             */

		            /**
		             * A specific color for the hovered point.
		             *
		             * @type      {Highcharts.ColorString}
		             * @product   highcharts gantt
		             * @apioption plotOptions.column.states.hover.color
		             */



		            /**
		             * How much to brighten the point on interaction. Requires the main
		             * color to be defined in hex or rgb(a) format.
		             *
		             * In styled mode, the hover brightening is by default replaced
		             * with a fill-opacity set in the `.highcharts-point:hover` rule.
		             *
		             * @sample {highcharts} highcharts/plotoptions/column-states-hover-brightness/
		             *         Brighten by 0.5
		             *
		             * @product highcharts highstock gantt
		             */
		            brightness: 0.1


		        },



		        /**
		         * Options for the selected point. These settings override the normal
		         * state options when a point is selected.
		         *
		         * @extends   plotOptions.series.states.select
		         * @excluding halo, lineWidth, lineWidthPlus, marker
		         * @product   highcharts highstock gantt
		         */
		        select: {

		            /**
		             * A specific color for the selected point.
		             *
		             * @type    {Highcharts.ColorString}
		             * @default #cccccc
		             * @product highcharts highstock gantt
		             */
		            color: '#cccccc',

		            /**
		             * A specific border color for the selected point.
		             *
		             * @type    {Highcharts.ColorString}
		             * @default #000000
		             * @product highcharts highstock gantt
		             */
		            borderColor: '#000000'
		        }



		    },

		    dataLabels: {

		        /**
		         * @type       {string|null}
		         */
		        align: null, // auto

		        /**
		         * @type       {string|null}
		         */
		        verticalAlign: null, // auto

		        /**
		         * @type       {number|null}
		         */
		        y: null
		    },

		    /**
		     * When this is true, the series will not cause the Y axis to cross
		     * the zero plane (or [threshold](#plotOptions.series.threshold) option)
		     * unless the data actually crosses the plane.
		     *
		     * For example, if `softThreshold` is `false`, a series of 0, 1, 2,
		     * 3 will make the Y axis show negative values according to the `minPadding`
		     * option. If `softThreshold` is `true`, the Y axis starts at 0.
		     *
		     * @since   4.1.9
		     * @product highcharts highstock
		     */
		    softThreshold: false,

		    // false doesn't work well: https://jsfiddle.net/highcharts/hz8fopan/14/
		    /**
		     * @ignore-option
		     */
		    startFromThreshold: true,

		    stickyTracking: false,

		    tooltip: {
		        distance: 6
		    },

		    /**
		     * The Y axis value to serve as the base for the columns, for distinguishing
		     * between values above and below a threshold. If `null`, the columns
		     * extend from the padding Y axis minimum.
		     *
		     * @since   2.0
		     * @product highcharts
		     */
		    threshold: 0,



		    /**
		     * The width of the border surrounding each column or bar.
		     *
		     * In styled mode, the stroke width can be set with the `.highcharts-point`
		     * rule.
		     *
		     * @sample {highcharts} highcharts/plotoptions/column-borderwidth/
		     *         2px black border
		     *
		     * @type      {number}
		     * @default   1
		     * @product   highcharts highstock gantt
		     * @apioption plotOptions.column.borderWidth
		     */

		    /**
		     * The color of the border surrounding each column or bar.
		     *
		     * In styled mode, the border stroke can be set with the `.highcharts-point`
		     * rule.
		     *
		     * @sample {highcharts} highcharts/plotoptions/column-bordercolor/
		     *         Dark gray border
		     *
		     * @type      {Highcharts.ColorString}
		     * @default   #ffffff
		     * @product   highcharts highstock gantt
		     */
		    borderColor: '#ffffff'



		}, /** @lends seriesTypes.column.prototype */ {
		    cropShoulder: 0,
		    // When tooltip is not shared, this series (and derivatives) requires direct
		    // touch/hover. KD-tree does not apply.
		    directTouch: true,
		    trackerGroups: ['group', 'dataLabelsGroup'],
		    // use separate negative stacks, unlike area stacks where a negative point
		    // is substracted from previous (#1910)
		    negStacks: true,

		    /**
		     * Initialize the series. Extends the basic Series.init method by
		     * marking other series of the same type as dirty.
		     *
		     * @private
		     * @function Highcharts.seriesTypes.column#init
		     */
		    init: function () {
		        Series.prototype.init.apply(this, arguments);

		        var series = this,
		            chart = series.chart;

		        // if the series is added dynamically, force redraw of other
		        // series affected by a new column
		        if (chart.hasRendered) {
		            each(chart.series, function (otherSeries) {
		                if (otherSeries.type === series.type) {
		                    otherSeries.isDirty = true;
		                }
		            });
		        }
		    },

		    /**
		     * Return the width and x offset of the columns adjusted for grouping,
		     * groupPadding, pointPadding, pointWidth etc.
		     *
		     * @private
		     * @function Highcharts.seriesTypes.column#getColumnMetrics
		     *
		     * @return {Highcharts.ColumnMetricsObject}
		     */
		    getColumnMetrics: function () {

		        var series = this,
		            options = series.options,
		            xAxis = series.xAxis,
		            yAxis = series.yAxis,
		            reversedStacks = xAxis.options.reversedStacks,
		            // Keep backward compatibility: reversed xAxis had reversed stacks
		            reverseStacks = (xAxis.reversed && !reversedStacks) ||
		                (!xAxis.reversed && reversedStacks),
		            stackKey,
		            stackGroups = {},
		            columnCount = 0;

		        // Get the total number of column type series. This is called on every
		        // series. Consider moving this logic to a chart.orderStacks() function
		        // and call it on init, addSeries and removeSeries
		        if (options.grouping === false) {
		            columnCount = 1;
		        } else {
		            each(series.chart.series, function (otherSeries) {
		                var otherOptions = otherSeries.options,
		                    otherYAxis = otherSeries.yAxis,
		                    columnIndex;
		                if (
		                    otherSeries.type === series.type &&
		                    (
		                        otherSeries.visible ||
		                        !series.chart.options.chart.ignoreHiddenSeries
		                    ) &&
		                    yAxis.len === otherYAxis.len &&
		                    yAxis.pos === otherYAxis.pos
		                ) {  // #642, #2086
		                    if (otherOptions.stacking) {
		                        stackKey = otherSeries.stackKey;
		                        if (stackGroups[stackKey] === undefined) {
		                            stackGroups[stackKey] = columnCount++;
		                        }
		                        columnIndex = stackGroups[stackKey];
		                    } else if (otherOptions.grouping !== false) { // #1162
		                        columnIndex = columnCount++;
		                    }
		                    otherSeries.columnIndex = columnIndex;
		                }
		            });
		        }

		        var categoryWidth = Math.min(
		                Math.abs(xAxis.transA) * (
		                    xAxis.ordinalSlope ||
		                    options.pointRange ||
		                    xAxis.closestPointRange ||
		                    xAxis.tickInterval ||
		                    1
		                ), // #2610
		                xAxis.len // #1535
		            ),
		            groupPadding = categoryWidth * options.groupPadding,
		            groupWidth = categoryWidth - 2 * groupPadding,
		            pointOffsetWidth = groupWidth / (columnCount || 1),
		            pointWidth = Math.min(
		                options.maxPointWidth || xAxis.len,
		                pick(
		                    options.pointWidth,
		                    pointOffsetWidth * (1 - 2 * options.pointPadding)
		                )
		            ),
		            pointPadding = (pointOffsetWidth - pointWidth) / 2,
		            // #1251, #3737
		            colIndex = (series.columnIndex || 0) + (reverseStacks ? 1 : 0),
		            pointXOffset =
		                pointPadding +
		                (
		                    groupPadding +
		                    colIndex * pointOffsetWidth -
		                    (categoryWidth / 2)
		                ) * (reverseStacks ? -1 : 1);

		        // Save it for reading in linked series (Error bars particularly)
		        series.columnMetrics = {
		            width: pointWidth,
		            offset: pointXOffset
		        };
		        return series.columnMetrics;

		    },

		    /**
		     * Make the columns crisp. The edges are rounded to the nearest full pixel.
		     *
		     * @private
		     * @function Highcharts.seriesTypes.column#crispCol
		     *
		     * @param {number} x
		     *
		     * @param {number} y
		     *
		     * @param {number} w
		     *
		     * @param {number} h
		     *
		     * @return {*}
		     */
		    crispCol: function (x, y, w, h) {
		        var chart = this.chart,
		            borderWidth = this.borderWidth,
		            xCrisp = -(borderWidth % 2 ? 0.5 : 0),
		            yCrisp = borderWidth % 2 ? 0.5 : 1,
		            right,
		            bottom,
		            fromTop;

		        if (chart.inverted && chart.renderer.isVML) {
		            yCrisp += 1;
		        }

		        // Horizontal. We need to first compute the exact right edge, then round
		        // it and compute the width from there.
		        if (this.options.crisp) {
		            right = Math.round(x + w) + xCrisp;
		            x = Math.round(x) + xCrisp;
		            w = right - x;
		        }

		        // Vertical
		        bottom = Math.round(y + h) + yCrisp;
		        fromTop = Math.abs(y) <= 0.5 && bottom > 0.5; // #4504, #4656
		        y = Math.round(y) + yCrisp;
		        h = bottom - y;

		        // Top edges are exceptions
		        if (fromTop && h) { // #5146
		            y -= 1;
		            h += 1;
		        }

		        return {
		            x: x,
		            y: y,
		            width: w,
		            height: h
		        };
		    },

		    /**
		     * Translate each point to the plot area coordinate system and find shape
		     * positions
		     *
		     * @private
		     * @function Highcharts.seriesTypes.column#translate
		     */
		    translate: function () {
		        var series = this,
		            chart = series.chart,
		            options = series.options,
		            dense = series.dense =
		                series.closestPointRange * series.xAxis.transA < 2,
		            borderWidth = series.borderWidth = pick(
		                options.borderWidth,
		                dense ? 0 : 1  // #3635
		            ),
		            yAxis = series.yAxis,
		            threshold = options.threshold,
		            translatedThreshold = series.translatedThreshold =
		                yAxis.getThreshold(threshold),
		            minPointLength = pick(options.minPointLength, 5),
		            metrics = series.getColumnMetrics(),
		            seriesPointWidth = metrics.width,
		            // postprocessed for border width
		            seriesBarW = series.barW =
		                Math.max(seriesPointWidth, 1 + 2 * borderWidth),
		            seriesXOffset = series.pointXOffset = metrics.offset;

		        if (chart.inverted) {
		            translatedThreshold -= 0.5; // #3355
		        }

		        // When the pointPadding is 0, we want the columns to be packed tightly,
		        // so we allow individual columns to have individual sizes. When
		        // pointPadding is greater, we strive for equal-width columns (#2694).
		        if (options.pointPadding) {
		            seriesBarW = Math.ceil(seriesBarW);
		        }

		        Series.prototype.translate.apply(series);

		        // Record the new values
		        each(series.points, function (point) {
		            var yBottom = pick(point.yBottom, translatedThreshold),
		                safeDistance = 999 + Math.abs(yBottom),
		                pointWidth = seriesPointWidth,
		                plotY = Math.min(
		                    Math.max(-safeDistance, point.plotY),
		                    yAxis.len + safeDistance
		                ), // Don't draw too far outside plot area (#1303, #2241, #4264)
		                barX = point.plotX + seriesXOffset,
		                barW = seriesBarW,
		                barY = Math.min(plotY, yBottom),
		                up,
		                barH = Math.max(plotY, yBottom) - barY;

		            // Handle options.minPointLength
		            if (minPointLength && Math.abs(barH) < minPointLength) {
		                barH = minPointLength;
		                up = (!yAxis.reversed && !point.negative) ||
		                    (yAxis.reversed && point.negative);

		                // Reverse zeros if there's no positive value in the series
		                // in visible range (#7046)
		                if (
		                    point.y === threshold &&
		                    series.dataMax <= threshold &&
		                    yAxis.min < threshold // and if there's room for it (#7311)
		                ) {
		                    up = !up;
		                }

		                // If stacked...
		                barY = Math.abs(barY - translatedThreshold) > minPointLength ?
		                        // ...keep position
		                        yBottom - minPointLength :
		                        // #1485, #4051
		                        translatedThreshold - (up ? minPointLength : 0);
		            }

		            // Handle point.options.pointWidth
		            // TODO: Handle grouping/stacking as well. Calculate offset properly
		            if (defined(point.options.pointWidth)) {
		                pointWidth = barW = Math.ceil(point.options.pointWidth);
		                barX -= Math.round((pointWidth - seriesPointWidth) / 2);
		            }

		            // Cache for access in polar
		            point.barX = barX;
		            point.pointWidth = pointWidth;

		            // Fix the tooltip on center of grouped columns (#1216, #424, #3648)
		            point.tooltipPos = chart.inverted ?
		            [
		                yAxis.len + yAxis.pos - chart.plotLeft - plotY,
		                series.xAxis.len - barX - barW / 2, barH
		            ] :
		            [barX + barW / 2, plotY + yAxis.pos - chart.plotTop, barH];

		            // Register shape type and arguments to be used in drawPoints
		            point.shapeType = 'rect';
		            point.shapeArgs = series.crispCol.apply(
		                series,
		                point.isNull ?
		                    // #3169, drilldown from null must have a position to work
		                    // from #6585, dataLabel should be placed on xAxis, not
		                    // floating in the middle of the chart
		                    [barX, translatedThreshold, barW, 0] :
		                    [barX, barY, barW, barH]
		            );
		        });

		    },

		    getSymbol: noop,

		    /**
		     * Use a solid rectangle like the area series types
		     *
		     * @private
		     * @function Highcharts.seriesTypes.column#drawLegendSymbol
		     *
		     * @param {Highcharts.Legend} legend
		     *        The legend object
		     *
		     * @param {Highcharts.Series|Highcharts.Point} item
		     *        The series (this) or point
		     */
		    drawLegendSymbol: LegendSymbolMixin.drawRectangle,


		    /**
		     * Columns have no graph
		     *
		     * @private
		     * @function Highcharts.seriesTypes.column#drawGraph
		     */
		    drawGraph: function () {
		        this.group[
		            this.dense ? 'addClass' : 'removeClass'
		        ]('highcharts-dense-data');
		    },


		    /**
		     * Get presentational attributes
		     *
		     * @private
		     * @function Highcharts.seriesTypes.column#pointAttribs
		     *
		     * @param {Highcharts.Point} point
		     *
		     * @param {string} state
		     *
		     * @return {Highcharts.Dictionary<any>}
		     */
		    pointAttribs: function (point, state) {
		        var options = this.options,
		            stateOptions,
		            ret,
		            p2o = this.pointAttrToOptions || {},
		            strokeOption = p2o.stroke || 'borderColor',
		            strokeWidthOption = p2o['stroke-width'] || 'borderWidth',
		            fill = (point && point.color) || this.color,
		            stroke = (point && point[strokeOption]) || options[strokeOption] ||
		                this.color || fill, // set to fill when borderColor null
		            strokeWidth = (point && point[strokeWidthOption]) ||
		                options[strokeWidthOption] || this[strokeWidthOption] || 0,
		            dashstyle = options.dashStyle,
		            zone,
		            brightness;

		        // Handle zone colors
		        if (point && this.zones.length) {
		            zone = point.getZone();
		            // When zones are present, don't use point.color (#4267). Changed
		            // order (#6527)
		            fill = point.options.color || (zone && zone.color) || this.color;
		        }

		        // Select or hover states
		        if (state) {
		            stateOptions = merge(
		                options.states[state],
		                // #6401
		                point.options.states && point.options.states[state] || {}
		            );
		            brightness = stateOptions.brightness;
		            fill = stateOptions.color ||
		                (
		                    brightness !== undefined &&
		                    color(fill).brighten(stateOptions.brightness).get()
		                ) ||
		                fill;
		            stroke = stateOptions[strokeOption] || stroke;
		            strokeWidth = stateOptions[strokeWidthOption] || strokeWidth;
		            dashstyle = stateOptions.dashStyle || dashstyle;
		        }

		        ret = {
		            'fill': fill,
		            'stroke': stroke,
		            'stroke-width': strokeWidth
		        };

		        if (dashstyle) {
		            ret.dashstyle = dashstyle;
		        }

		        return ret;
		    },


		    /**
		     * Draw the columns. For bars, the series.group is rotated, so the same
		     * coordinates apply for columns and bars. This method is inherited by
		     * scatter series.
		     *
		     * @private
		     * @function Highcharts.seriesTypes.column#drawPoints
		     */
		    drawPoints: function () {
		        var series = this,
		            chart = this.chart,
		            options = series.options,
		            renderer = chart.renderer,
		            animationLimit = options.animationLimit || 250,
		            shapeArgs;

		        // draw the columns
		        each(series.points, function (point) {
		            var plotY = point.plotY,
		                graphic = point.graphic,
		                verb = graphic && chart.pointCount < animationLimit ?
		                    'animate' : 'attr';

		            if (isNumber(plotY) && point.y !== null) {
		                shapeArgs = point.shapeArgs;

		                if (graphic) { // update
		                    graphic[verb](
		                        merge(shapeArgs)
		                    );

		                } else {
		                    point.graphic = graphic =
		                        renderer[point.shapeType](shapeArgs)
		                            .add(point.group || series.group);
		                }

		                // Border radius is not stylable (#6900)
		                if (options.borderRadius) {
		                    graphic.attr({
		                        r: options.borderRadius
		                    });
		                }


		                // Presentational
		                graphic[verb](series.pointAttribs(
		                        point,
		                        point.selected && 'select'
		                    ))
		                    .shadow(
		                        options.shadow,
		                        null,
		                        options.stacking && !options.borderRadius
		                    );


		                graphic.addClass(point.getClassName(), true);


		            } else if (graphic) {
		                point.graphic = graphic.destroy(); // #1269
		            }
		        });
		    },

		    /**
		     * Animate the column heights one by one from zero.
		     *
		     * @private
		     * @function Highcharts.seriesTypes.column#animate
		     *
		     * @param {boolean} init
		     *        Whether to initialize the animation or run it
		     */
		    animate: function (init) {
		        var series = this,
		            yAxis = this.yAxis,
		            options = series.options,
		            inverted = this.chart.inverted,
		            attr = {},
		            translateProp = inverted ? 'translateX' : 'translateY',
		            translateStart,
		            translatedThreshold;

		        if (svg) { // VML is too slow anyway
		            if (init) {
		                attr.scaleY = 0.001;
		                translatedThreshold = Math.min(
		                    yAxis.pos + yAxis.len,
		                    Math.max(yAxis.pos, yAxis.toPixels(options.threshold))
		                );
		                if (inverted) {
		                    attr.translateX = translatedThreshold - yAxis.len;
		                } else {
		                    attr.translateY = translatedThreshold;
		                }
		                series.group.attr(attr);

		            } else { // run the animation
		                translateStart = series.group.attr(translateProp);
		                series.group.animate(
		                    { scaleY: 1 },
		                    extend(animObject(series.options.animation
		                ), {
		                    // Do the scale synchronously to ensure smooth updating
		                    // (#5030, #7228)
		                    step: function (val, fx) {

		                        attr[translateProp] =
		                            translateStart +
		                            fx.pos * (yAxis.pos - translateStart);
		                        series.group.attr(attr);
		                    }
		                }));

		                // delete this function to allow it only once
		                series.animate = null;
		            }
		        }
		    },

		    /**
		     * Remove this series from the chart
		     *
		     * @private
		     * @function Highcharts.seriesTypes.column#remove
		     */
		    remove: function () {
		        var series = this,
		            chart = series.chart;

		        // column and bar series affects other series of the same type
		        // as they are either stacked or grouped
		        if (chart.hasRendered) {
		            each(chart.series, function (otherSeries) {
		                if (otherSeries.type === series.type) {
		                    otherSeries.isDirty = true;
		                }
		            });
		        }

		        Series.prototype.remove.apply(series, arguments);
		    }
		});


		/**
		 * A `column` series. If the [type](#series.column.type) option is
		 * not specified, it is inherited from [chart.type](#chart.type).
		 *
		 * @extends   series,plotOptions.column
		 * @excluding connectNulls, dashStyle, dataParser, dataURL, gapSize, gapUnit,
		 *            linecap, lineWidth, marker, connectEnds, step
		 * @product   highcharts highstock
		 * @apioption series.column
		 */

		/**
		 * An array of data points for the series. For the `column` series type,
		 * points can be given in the following ways:
		 *
		 * 1.  An array of numerical values. In this case, the numerical values
		 * will be interpreted as `y` options. The `x` values will be automatically
		 * calculated, either starting at 0 and incremented by 1, or from `pointStart`
		 * and `pointInterval` given in the series options. If the axis has
		 * categories, these will be used. Example:
		 *
		 *  ```js
		 *  data: [0, 5, 3, 5]
		 *  ```
		 *
		 * 2.  An array of arrays with 2 values. In this case, the values correspond
		 * to `x,y`. If the first value is a string, it is applied as the name
		 * of the point, and the `x` value is inferred.
		 *
		 *  ```js
		 *     data: [
		 *         [0, 6],
		 *         [1, 2],
		 *         [2, 6]
		 *     ]
		 *  ```
		 *
		 * 3.  An array of objects with named values. The following snippet shows only a
		 * few settings, see the complete options set below. If the total number of data
		 * points exceeds the series' [turboThreshold](#series.column.turboThreshold),
		 * this option is not available.
		 *
		 *  ```js
		 *     data: [{
		 *         x: 1,
		 *         y: 9,
		 *         name: "Point2",
		 *         color: "#00FF00"
		 *     }, {
		 *         x: 1,
		 *         y: 6,
		 *         name: "Point1",
		 *         color: "#FF00FF"
		 *     }]
		 *  ```
		 *
		 * @sample {highcharts} highcharts/chart/reflow-true/
		 *         Numerical values
		 * @sample {highcharts} highcharts/series/data-array-of-arrays/
		 *         Arrays of numeric x and y
		 * @sample {highcharts} highcharts/series/data-array-of-arrays-datetime/
		 *         Arrays of datetime x and y
		 * @sample {highcharts} highcharts/series/data-array-of-name-value/
		 *         Arrays of point.name and y
		 * @sample {highcharts} highcharts/series/data-array-of-objects/
		 *         Config objects
		 *
		 * @type      {Array<number|Array<number|string|Date>|*>}
		 * @extends   series.line.data
		 * @excluding marker
		 * @product   highcharts highstock
		 * @apioption series.column.data
		 */

		/**
		 * The color of the border surrounding the column or bar.
		 *
		 * In styled mode, the border stroke can be set with the `.highcharts-point`
		 * rule.
		 *
		 * @sample {highcharts} highcharts/plotoptions/column-bordercolor/
		 *         Dark gray border
		 *
		 * @type      {Highcharts.ColorString}
		 * @product   highcharts highstock
		 * @apioption series.column.data.borderColor
		 */

		/**
		 * The width of the border surrounding the column or bar.
		 *
		 * In styled mode, the stroke width can be set with the `.highcharts-point`
		 * rule.
		 *
		 * @sample {highcharts} highcharts/plotoptions/column-borderwidth/
		 *         2px black border
		 *
		 * @type      {number}
		 * @product   highcharts highstock
		 * @apioption series.column.data.borderWidth
		 */

		/**
		 * @excluding halo, lineWidth, lineWidthPlus, marker
		 * @product   highcharts highstock
		 * @apioption series.column.states.hover
		 */

		/**
		 * @excluding halo, lineWidth, lineWidthPlus, marker
		 * @product   highcharts highstock
		 * @apioption series.column.states.select
		 */

	}(Highcharts));
	(function (H) {
		/**
		 * (c) 2010-2018 Torstein Honsi
		 *
		 * License: www.highcharts.com/license
		 */



		var seriesType = H.seriesType;

		/**
		 * Bar series type.
		 *
		 * @private
		 * @class
		 * @name Highcharts.seriesTypes.bar
		 *
		 * @augments Highcharts.Series
		 */
		seriesType('bar', 'column',

		    /**
		     * A bar series is a special type of column series where the columns are
		     * horizontal.
		     *
		     * @sample highcharts/demo/bar-basic/
		     *         Bar chart
		     *
		     * @extends   plotOptions.column
		     * @product   highcharts
		     * @apioption plotOptions.bar
		     */

		    /**
		     * Alignment of the data label relative to the data point.
		     *
		     * @sample {highcharts} highcharts/plotoptions/bar-datalabels-align-inside-bar/
		     *         Data labels inside the bar
		     *
		     * @type      {string}
		     * @default   left
		     * @product   highcharts
		     * @apioption plotOptions.bar.dataLabels.align
		     */

		    /**
		     * The x position of the data label relative to the data point.
		     *
		     * @sample {highcharts} highcharts/plotoptions/bar-datalabels-align-inside-bar/
		     *         Data labels inside the bar
		     *
		     * @type      {number}
		     * @default   5
		     * @product   highcharts
		     * @apioption plotOptions.bar.dataLabels.x
		     */

		    /**
		     * @ignore
		     */
		    null

		, {
		    inverted: true
		});


		/**
		 * A `bar` series. If the [type](#series.bar.type) option is not specified,
		 * it is inherited from [chart.type](#chart.type).
		 *
		 * @extends   series,plotOptions.bar
		 * @excluding connectNulls, dashStyle, dataParser, dataURL, gapSize, gapUnit,
		 *            linecap, lineWidth, marker, connectEnds, step
		 * @product   highcharts
		 * @apioption series.bar
		 */

		/**
		 * An array of data points for the series. For the `bar` series type,
		 * points can be given in the following ways:
		 *
		 * 1.  An array of numerical values. In this case, the numerical values
		 * will be interpreted as `y` options. The `x` values will be automatically
		 * calculated, either starting at 0 and incremented by 1, or from `pointStart`
		 * and `pointInterval` given in the series options. If the axis has
		 * categories, these will be used. Example:
		 *
		 *  ```js
		 *  data: [0, 5, 3, 5]
		 *  ```
		 *
		 * 2.  An array of arrays with 2 values. In this case, the values correspond
		 * to `x,y`. If the first value is a string, it is applied as the name
		 * of the point, and the `x` value is inferred.
		 *
		 *  ```js
		 *     data: [
		 *         [0, 5],
		 *         [1, 10],
		 *         [2, 3]
		 *     ]
		 *  ```
		 *
		 * 3.  An array of objects with named values. The following snippet shows only a
		 * few settings, see the complete options set below. If the total number of data
		 * points exceeds the series' [turboThreshold](#series.bar.turboThreshold),
		 * this option is not available.
		 *
		 *  ```js
		 *     data: [{
		 *         x: 1,
		 *         y: 1,
		 *         name: "Point2",
		 *         color: "#00FF00"
		 *     }, {
		 *         x: 1,
		 *         y: 10,
		 *         name: "Point1",
		 *         color: "#FF00FF"
		 *     }]
		 *  ```
		 *
		 * @sample {highcharts} highcharts/chart/reflow-true/
		 *         Numerical values
		 * @sample {highcharts} highcharts/series/data-array-of-arrays/
		 *         Arrays of numeric x and y
		 * @sample {highcharts} highcharts/series/data-array-of-arrays-datetime/
		 *         Arrays of datetime x and y
		 * @sample {highcharts} highcharts/series/data-array-of-name-value/
		 *         Arrays of point.name and y
		 * @sample {highcharts} highcharts/series/data-array-of-objects/
		 *         Config objects
		 *
		 * @type      {Array<number|Array<number|string|Date>|*>}
		 * @extends   series.column.data
		 * @product   highcharts
		 * @apioption series.bar.data
		 */

		/**
		 * @excluding halo,lineWidth,lineWidthPlus,marker
		 * @product   highcharts highstock
		 * @apioption series.bar.states.hover
		 */

		/**
		 * @excluding halo,lineWidth,lineWidthPlus,marker
		 * @product   highcharts highstock
		 * @apioption series.bar.states.select
		 */

	}(Highcharts));
	(function (H) {
		/**
		 * (c) 2010-2018 Torstein Honsi
		 *
		 * License: www.highcharts.com/license
		 */



		var Series = H.Series,
		    seriesType = H.seriesType;

		/**
		 * Scatter series type.
		 *
		 * @private
		 * @class
		 * @name Highcharts.seriesTypes.scatter
		 *
		 * @augments Highcharts.Series
		 */
		seriesType('scatter', 'line'

		/**
		 * A scatter plot uses cartesian coordinates to display values for two
		 * variables for a set of data.
		 *
		 * @sample {highcharts} highcharts/demo/scatter/
		 *         Scatter plot
		 *
		 * @extends      plotOptions.line
		 * @excluding    pointPlacement, shadow
		 * @product      highcharts highstock
		 * @optionparent plotOptions.scatter
		 */
		, {

		    /**
		     * The width of the line connecting the data points.
		     *
		     * @sample {highcharts} highcharts/plotoptions/scatter-linewidth-none/
		     *         0 by default
		     * @sample {highcharts} highcharts/plotoptions/scatter-linewidth-1/
		     *         1px
		     *
		     * @product highcharts highstock
		     */
		    lineWidth: 0,

		    findNearestPointBy: 'xy',

		    marker: {

		        enabled: true // Overrides auto-enabling in line series (#3647)
		    },

		    /**
		     * Sticky tracking of mouse events. When true, the `mouseOut` event
		     * on a series isn't triggered until the mouse moves over another series,
		     * or out of the plot area. When false, the `mouseOut` event on a series
		     * is triggered when the mouse leaves the area around the series' graph
		     * or markers. This also implies the tooltip. When `stickyTracking`
		     * is false and `tooltip.shared` is false, the tooltip will be hidden
		     * when moving the mouse between series.
		     *
		     * @type      {boolean}
		     * @default   false
		     * @product   highcharts highstock
		     * @apioption plotOptions.scatter.stickyTracking
		     */

		    /**
		     * A configuration object for the tooltip rendering of each single
		     * series. Properties are inherited from [tooltip](#tooltip).
		     * Overridable properties are `headerFormat`, `pointFormat`, `yDecimals`,
		     * `xDateFormat`, `yPrefix` and `ySuffix`. Unlike other series, in
		     * a scatter plot the series.name by default shows in the headerFormat
		     * and point.x and point.y in the pointFormat.
		     *
		     * @product highcharts highstock
		     */
		    tooltip: {



		        /**
		         * @default ● {series.name}
		         */
		        headerFormat:
		            '<span style="color:{point.color}">\u25CF</span> ' +
		            '<span style="font-size: 0.85em"> {series.name}</span><br/>',



		        /**
		         * @default x: {point.x} y: {point.y}
		         */
		        pointFormat: 'x: <b>{point.x}</b><br/>y: <b>{point.y}</b><br/>'
		    }

		// Prototype members
		}, {
		    sorted: false,
		    requireSorting: false,
		    noSharedTooltip: true,
		    trackerGroups: ['group', 'markerGroup', 'dataLabelsGroup'],
		    takeOrdinalPosition: false, // #2342

		    /**
		     * @private
		     * @function Highcharts.seriesTypes.scatter#drawGraph
		     */
		    drawGraph: function () {
		        if (this.options.lineWidth) {
		            Series.prototype.drawGraph.call(this);
		        }
		    }
		});

		/**
		 * A `scatter` series. If the [type](#series.scatter.type) option is
		 * not specified, it is inherited from [chart.type](#chart.type).
		 *
		 * @extends   series,plotOptions.scatter
		 * @excluding dataParser, dataURL
		 * @product   highcharts highstock
		 * @apioption series.scatter
		 */

		/**
		 * An array of data points for the series. For the `scatter` series
		 * type, points can be given in the following ways:
		 *
		 * 1.  An array of numerical values. In this case, the numerical values
		 * will be interpreted as `y` options. The `x` values will be automatically
		 * calculated, either starting at 0 and incremented by 1, or from `pointStart`
		 * and `pointInterval` given in the series options. If the axis has
		 * categories, these will be used. Example:
		 *
		 *  ```js
		 *  data: [0, 5, 3, 5]
		 *  ```
		 *
		 * 2.  An array of arrays with 2 values. In this case, the values correspond
		 * to `x,y`. If the first value is a string, it is applied as the name
		 * of the point, and the `x` value is inferred.
		 *
		 *  ```js
		 *     data: [
		 *         [0, 0],
		 *         [1, 8],
		 *         [2, 9]
		 *     ]
		 *  ```
		 *
		 * 3.  An array of objects with named values. The following snippet shows only a
		 * few settings, see the complete options set below. If the total number of data
		 * points exceeds the series' [turboThreshold](#series.scatter.turboThreshold),
		 * this option is not available.
		 *
		 *  ```js
		 *     data: [{
		 *         x: 1,
		 *         y: 2,
		 *         name: "Point2",
		 *         color: "#00FF00"
		 *     }, {
		 *         x: 1,
		 *         y: 4,
		 *         name: "Point1",
		 *         color: "#FF00FF"
		 *     }]
		 *  ```
		 *
		 * @sample {highcharts} highcharts/chart/reflow-true/
		 *         Numerical values
		 * @sample {highcharts} highcharts/series/data-array-of-arrays/
		 *         Arrays of numeric x and y
		 * @sample {highcharts} highcharts/series/data-array-of-arrays-datetime/
		 *         Arrays of datetime x and y
		 * @sample {highcharts} highcharts/series/data-array-of-name-value/
		 *         Arrays of point.name and y
		 * @sample {highcharts} highcharts/series/data-array-of-objects/
		 *         Config objects
		 *
		 * @type      {Array<number|Array<number>|*>}
		 * @extends   series.line.data
		 * @product   highcharts highstock
		 * @apioption series.scatter.data
		 */

	}(Highcharts));
	(function (H) {
		/**
		 * (c) 2010-2018 Torstein Honsi
		 *
		 * License: www.highcharts.com/license
		 */

		/**
		 * @private
		 * @typedef Highcharts.RadianAngles
		 *
		 * @property {number} start
		 *
		 * @property {number} end
		 */



		var deg2rad = H.deg2rad,
		    isNumber = H.isNumber,
		    pick = H.pick,
		    relativeLength = H.relativeLength;

		/**
		 * @private
		 * @mixin Highcharts.CenteredSeriesMixin
		 */
		H.CenteredSeriesMixin = {

		    /**
		     * Get the center of the pie based on the size and center options relative
		     * to the plot area. Borrowed by the polar and gauge series types.
		     *
		     * @private
		     * @function Highcharts.CenteredSeriesMixin.getCenter
		     *
		     * @return {Array<number>}
		     */
		    getCenter: function () {

		        var options = this.options,
		            chart = this.chart,
		            slicingRoom = 2 * (options.slicedOffset || 0),
		            handleSlicingRoom,
		            plotWidth = chart.plotWidth - 2 * slicingRoom,
		            plotHeight = chart.plotHeight - 2 * slicingRoom,
		            centerOption = options.center,
		            positions = [
		                pick(centerOption[0], '50%'),
		                pick(centerOption[1], '50%'),
		                options.size || '100%',
		                options.innerSize || 0
		            ],
		            smallestSize = Math.min(plotWidth, plotHeight),
		            i,
		            value;

		        for (i = 0; i < 4; ++i) {
		            value = positions[i];
		            handleSlicingRoom = i < 2 || (i === 2 && /%$/.test(value));

		            // i == 0: centerX, relative to width
		            // i == 1: centerY, relative to height
		            // i == 2: size, relative to smallestSize
		            // i == 3: innerSize, relative to size
		            positions[i] = relativeLength(
		                value,
		                [plotWidth, plotHeight, smallestSize, positions[2]][i]
		            ) + (handleSlicingRoom ? slicingRoom : 0);

		        }
		        // innerSize cannot be larger than size (#3632)
		        if (positions[3] > positions[2]) {
		            positions[3] = positions[2];
		        }
		        return positions;
		    },

		    /**
		     * getStartAndEndRadians - Calculates start and end angles in radians.
		     * Used in series types such as pie and sunburst.
		     *
		     * @private
		     * @function Highcharts.CenteredSeriesMixin.getStartAndEndRadians
		     *
		     * @param {number} start
		     *        Start angle in degrees.
		     *
		     * @param {number} end
		     *        Start angle in degrees.
		     *
		     * @return {Highcharts.RadianAngles}
		     *         Returns an object containing start and end angles as radians.
		     */
		    getStartAndEndRadians: function getStartAndEndRadians(start, end) {
		        var startAngle = isNumber(start) ? start : 0, // must be a number
		            endAngle = (
		                (
		                    isNumber(end) && // must be a number
		                    end > startAngle && // must be larger than the start angle
		                    // difference must be less than 360 degrees
		                    (end - startAngle) < 360
		                ) ?
		                end :
		                startAngle + 360
		            ),
		            correction = -90;
		        return {
		            start: deg2rad * (startAngle + correction),
		            end: deg2rad * (endAngle + correction)
		        };
		    }
		};

	}(Highcharts));
	(function (H) {
		/**
		 * (c) 2010-2018 Torstein Honsi
		 *
		 * License: www.highcharts.com/license
		 */



		var addEvent = H.addEvent,
		    CenteredSeriesMixin = H.CenteredSeriesMixin,
		    defined = H.defined,
		    each = H.each,
		    extend = H.extend,
		    getStartAndEndRadians = CenteredSeriesMixin.getStartAndEndRadians,
		    inArray = H.inArray,
		    LegendSymbolMixin = H.LegendSymbolMixin,
		    noop = H.noop,
		    pick = H.pick,
		    Point = H.Point,
		    Series = H.Series,
		    seriesType = H.seriesType,
		    seriesTypes = H.seriesTypes,
		    setAnimation = H.setAnimation;

		/**
		 * Pie series type.
		 *
		 * @private
		 * @class
		 * @name Highcharts.seriesTypes.pie
		 *
		 * @augments Highcharts.Series
		 */
		seriesType('pie', 'line'

		/**
		 * A pie chart is a circular graphic which is divided into slices to illustrate
		 * numerical proportion.
		 *
		 * @sample highcharts/demo/pie-basic/
		 *         Pie chart
		 *
		 * @extends      plotOptions.line
		 * @excluding    animationLimit, boostThreshold, connectEnds, connectNulls,
		 *               cropThreshold, dashStyle, findNearestPointBy,
		 *               getExtremesFromAll, lineWidth, marker, negativeColor,
		 *               pointInterval, pointIntervalUnit, pointPlacement,
		 *               pointStart, softThreshold, stacking, step, threshold,
		 *               turboThreshold, zoneAxis, zones
		 * @product      highcharts
		 * @optionparent plotOptions.pie
		 */
		, {

		    /**
		     * The center of the pie chart relative to the plot area. Can be percentages
		     * or pixel values. The default behaviour (as of 3.0) is to center
		     * the pie so that all slices and data labels are within the plot area.
		     * As a consequence, the pie may actually jump around in a chart with
		     * dynamic values, as the data labels move. In that case, the center
		     * should be explicitly set, for example to `["50%", "50%"]`.
		     *
		     * @sample {highcharts} highcharts/plotoptions/pie-center/
		     *         Centered at 100, 100
		     *
		     * @type    {Array<number|string|null>}
		     * @default [null, null]
		     * @product highcharts
		     */
		    center: [null, null],

		    /**
		     * @product highcharts
		     */
		    clip: false,

		    /**
		     * @ignore
		     */
		    colorByPoint: true, // always true for pies

		    /**
		     * A series specific or series type specific color set to use instead
		     * of the global [colors](#colors).
		     *
		     * @sample {highcharts} highcharts/demo/pie-monochrome/
		     *         Set default colors for all pies
		     *
		     * @type      {Array<Highcharts.ColorString>}
		     * @since     3.0
		     * @product   highcharts
		     * @apioption plotOptions.pie.colors
		     */

		    /**
		     * @extends   plotOptions.series.dataLabels
		     * @excluding align, allowOverlap, staggerLines, step
		     * @product   highcharts
		     */
		    dataLabels: {

		        allowOverlap: true,

		        /**
		         * The color of the line connecting the data label to the pie slice.
		         * The default color is the same as the point's color.
		         *
		         * In styled mode, the connector stroke is given in the
		         * `.highcharts-data-label-connector` class.
		         *
		         * @sample {highcharts} highcharts/plotoptions/pie-datalabels-connectorcolor/
		         *         Blue connectors
		         * @sample {highcharts} highcharts/css/pie-point/
		         *         Styled connectors
		         *
		         * @type      {Highcharts.ColorString}
		         * @since     2.1
		         * @product   highcharts
		         * @apioption plotOptions.pie.dataLabels.connectorColor
		         */

		        /**
		         * The distance from the data label to the connector.
		         *
		         * @sample {highcharts} highcharts/plotoptions/pie-datalabels-connectorpadding/
		         *         No padding
		         *
		         * @type      {number}
		         * @default   5
		         * @since     2.1
		         * @product   highcharts
		         * @apioption plotOptions.pie.dataLabels.connectorPadding
		         */

		        /**
		         * The width of the line connecting the data label to the pie slice.
		         *
		         *
		         * In styled mode, the connector stroke width is given in the
		         * `.highcharts-data-label-connector` class.
		         *
		         * @sample {highcharts} highcharts/plotoptions/pie-datalabels-connectorwidth-disabled/
		         *         Disable the connector
		         * @sample {highcharts} highcharts/css/pie-point/
		         *         Styled connectors
		         *
		         * @type      {number}
		         * @default   1
		         * @since     2.1
		         * @product   highcharts
		         * @apioption plotOptions.pie.dataLabels.connectorWidth
		         */

		        /**
		         * @sample {highcharts} highcharts/plotOptions/pie-datalabels-overflow
		         *         Long labels truncated with an ellipsis
		         * @sample {highcharts} highcharts/plotOptions/pie-datalabels-overflow-wrap
		         *         Long labels are wrapped
		         *
		         * @type      {Highcharts.CSSObject}
		         * @apioption plotOptions.pie.dataLabels.style
		         */

		        /**
		         * The distance of the data label from the pie's edge. Negative numbers
		         * put the data label on top of the pie slices. Connectors are only
		         * shown for data labels outside the pie.
		         *
		         * @sample {highcharts} highcharts/plotoptions/pie-datalabels-distance/
		         *         Data labels on top of the pie
		         *
		         * @since   2.1
		         * @product highcharts
		         */
		        distance: 30,

		        /**
		         * Enable or disable the data labels.
		         *
		         * @since   2.1
		         * @product highcharts
		         */
		        enabled: true,

		        /**
		         * @type      {Highcharts.FormatterCallbackFunction}
		         * @default   function () { return this.point.name; }
		         * @apioption plotOptions.pie.dataLabels.formatter
		         */
		        formatter: function () { // #2945
		            return this.point.isNull ? undefined : this.point.name;
		        },

		        /**
		         * Whether to render the connector as a soft arc or a line with sharp
		         * break.
		         *
		         * @sample {highcharts} highcharts/plotoptions/pie-datalabels-softconnector-true/
		         *         Soft
		         * @sample {highcharts} highcharts/plotoptions/pie-datalabels-softconnector-false/
		         *         Non soft
		         *
		         * @type      {number}
		         * @since     2.1.7
		         * @product   highcharts
		         * @apioption plotOptions.pie.dataLabels.softConnector
		         */

		        x: 0

		    },

		    /**
		     * The end angle of the pie in degrees where 0 is top and 90 is right.
		     * Defaults to `startAngle` plus 360.
		     *
		     * @sample {highcharts} highcharts/demo/pie-semi-circle/
		     *         Semi-circle donut
		     *
		     * @type      {number}
		     * @since     1.3.6
		     * @product   highcharts
		     * @apioption plotOptions.pie.endAngle
		     */

		    /**
		     * Equivalent to [chart.ignoreHiddenSeries](#chart.ignoreHiddenSeries),
		     * this option tells whether the series shall be redrawn as if the
		     * hidden point were `null`.
		     *
		     * The default value changed from `false` to `true` with Highcharts
		     * 3.0.
		     *
		     * @sample {highcharts} highcharts/plotoptions/pie-ignorehiddenpoint/
		     *         True, the hiddden point is ignored
		     *
		     * @since   2.3.0
		     * @product highcharts
		     */
		    ignoreHiddenPoint: true,

		    /**
		     * The size of the inner diameter for the pie. A size greater than 0
		     * renders a donut chart. Can be a percentage or pixel value. Percentages
		     * are relative to the pie size. Pixel values are given as integers.
		     *
		     *
		     * Note: in Highcharts < 4.1.2, the percentage was relative to the plot
		     * area, not the pie size.
		     *
		     * @sample {highcharts} highcharts/plotoptions/pie-innersize-80px/
		     *         80px inner size
		     * @sample {highcharts} highcharts/plotoptions/pie-innersize-50percent/
		     *         50% of the plot area
		     * @sample {highcharts} highcharts/demo/3d-pie-donut/
		     *         3D donut
		     *
		     * @type      {number|string}
		     * @default   0
		     * @since     2.0
		     * @product   highcharts
		     * @apioption plotOptions.pie.innerSize
		     */

		    /**
		     * @ignore
		     */
		    legendType: 'point',

		    /**
		     * @ignore
		     */
		    marker: null, // point options are specified in the base options

		    /**
		     * The minimum size for a pie in response to auto margins. The pie will
		     * try to shrink to make room for data labels in side the plot area,
		     *  but only to this size.
		     *
		     * @type      {number}
		     * @default   80
		     * @since     3.0
		     * @product   highcharts
		     * @apioption plotOptions.pie.minSize
		     */

		    /**
		     * The diameter of the pie relative to the plot area. Can be a percentage
		     * or pixel value. Pixel values are given as integers. The default
		     * behaviour (as of 3.0) is to scale to the plot area and give room
		     * for data labels within the plot area.
		     * [slicedOffset](#plotOptions.pie.slicedOffset) is also included
		     * in the default size calculation. As a consequence, the size
		     * of the pie may vary when points are updated and data labels more
		     * around. In that case it is best to set a fixed value, for example
		     * `"75%"`.
		     *
		     * @sample {highcharts} highcharts/plotoptions/pie-size/
		     *         Smaller pie
		     *
		     * @type    {number|string|null}
		     * @product highcharts
		     */
		    size: null,

		    /**
		     * Whether to display this particular series or series type in the
		     * legend. Since 2.1, pies are not shown in the legend by default.
		     *
		     * @sample {highcharts} highcharts/plotoptions/series-showinlegend/
		     *         One series in the legend, one hidden
		     *
		     * @product highcharts
		     */
		    showInLegend: false,

		    /**
		     * If a point is sliced, moved out from the center, how many pixels
		     * should it be moved?.
		     *
		     * @sample {highcharts} highcharts/plotoptions/pie-slicedoffset-20/
		     *         20px offset
		     *
		     * @product highcharts
		     */
		    slicedOffset: 10,

		    /**
		     * The start angle of the pie slices in degrees where 0 is top and 90
		     * right.
		     *
		     * @sample {highcharts} highcharts/plotoptions/pie-startangle-90/
		     *         Start from right
		     *
		     * @type      {number}
		     * @default   0
		     * @since     2.3.4
		     * @product   highcharts
		     * @apioption plotOptions.pie.startAngle
		     */

		    /**
		     * Sticky tracking of mouse events. When true, the `mouseOut` event
		     * on a series isn't triggered until the mouse moves over another series,
		     * or out of the plot area. When false, the `mouseOut` event on a
		     * series is triggered when the mouse leaves the area around the series'
		     * graph or markers. This also implies the tooltip. When `stickyTracking`
		     * is false and `tooltip.shared` is false, the tooltip will be hidden
		     * when moving the mouse between series.
		     *
		     * @product highcharts
		     */
		    stickyTracking: false,

		    tooltip: {
		        followPointer: true
		    },



		    /**
		     * The color of the border surrounding each slice. When `null`, the
		     * border takes the same color as the slice fill. This can be used
		     * together with a `borderWidth` to fill drawing gaps created by
		     * antialiazing artefacts in borderless pies.
		     *
		     * In styled mode, the border stroke is given in the `.highcharts-point`
		     * class.
		     *
		     * @sample {highcharts} highcharts/plotoptions/pie-bordercolor-black/
		     *         Black border
		     *
		     * @type    {Highcharts.ColorString}
		     * @default #ffffff
		     * @product highcharts
		     */
		    borderColor: '#ffffff',

		    /**
		     * The width of the border surrounding each slice.
		     *
		     * When setting the border width to 0, there may be small gaps between
		     * the slices due to SVG antialiasing artefacts. To work around this,
		     * keep the border width at 0.5 or 1, but set the `borderColor` to
		     * `null` instead.
		     *
		     * In styled mode, the border stroke width is given in the
		     * `.highcharts-point` class.
		     *
		     * @sample {highcharts} highcharts/plotoptions/pie-borderwidth/
		     *         3px border
		     *
		     * @product highcharts
		     */
		    borderWidth: 1,

		    states: {

		        /**
		         * @extends   plotOptions.series.states.hover
		         * @excluding marker, lineWidth, lineWidthPlus
		         * @product   highcharts
		         */
		        hover: {

		            /**
		             * How much to brighten the point on interaction. Requires the main
		             * color to be defined in hex or rgb(a) format.
		             *
		             * In styled mode, the hover brightness is by default replaced
		             * by a fill-opacity given in the `.highcharts-point-hover` class.
		             *
		             * @sample {highcharts} highcharts/plotoptions/pie-states-hover-brightness/
		             *         Brightened by 0.5
		             *
		             * @product highcharts
		             */
		            brightness: 0.1

		        }
		    }



		}, /** @lends seriesTypes.pie.prototype */ {

		    isCartesian: false,
		    requireSorting: false,
		    directTouch: true,
		    noSharedTooltip: true,
		    trackerGroups: ['group', 'dataLabelsGroup'],
		    axisTypes: [],
		    pointAttribs: seriesTypes.column.prototype.pointAttribs,

		    /**
		     * Animate the pies in
		     *
		     * @private
		     * @function Highcharts.seriesTypes.pie#animate
		     *
		     * @param {boolean} [init=false]
		     */
		    animate: function (init) {
		        var series = this,
		            points = series.points,
		            startAngleRad = series.startAngleRad;

		        if (!init) {
		            each(points, function (point) {
		                var graphic = point.graphic,
		                    args = point.shapeArgs;

		                if (graphic) {
		                    // start values
		                    graphic.attr({
		                        // animate from inner radius (#779)
		                        r: point.startR || (series.center[3] / 2),
		                        start: startAngleRad,
		                        end: startAngleRad
		                    });

		                    // animate
		                    graphic.animate({
		                        r: args.r,
		                        start: args.start,
		                        end: args.end
		                    }, series.options.animation);
		                }
		            });

		            // delete this function to allow it only once
		            series.animate = null;
		        }
		    },

		    /**
		     * Recompute total chart sum and update percentages of points.
		     *
		     * @private
		     * @function Highcharts.seriesTypes.pie#updateTotals
		     */
		    updateTotals: function () {
		        var i,
		            total = 0,
		            points = this.points,
		            len = points.length,
		            point,
		            ignoreHiddenPoint = this.options.ignoreHiddenPoint;

		        // Get the total sum
		        for (i = 0; i < len; i++) {
		            point = points[i];
		            total += (ignoreHiddenPoint && !point.visible) ?
		                0 :
		                point.isNull ? 0 : point.y;
		        }
		        this.total = total;

		        // Set each point's properties
		        for (i = 0; i < len; i++) {
		            point = points[i];
		            point.percentage =
		                (total > 0 && (point.visible || !ignoreHiddenPoint)) ?
		                    point.y / total * 100 :
		                    0;
		            point.total = total;
		        }
		    },

		    /**
		     * Extend the generatePoints method by adding total and percentage
		     * properties to each point
		     *
		     * @private
		     * @function Highcharts.seriesTypes.pie#generatePoints
		     */
		    generatePoints: function () {
		        Series.prototype.generatePoints.call(this);
		        this.updateTotals();
		    },

		    /**
		     * Do translation for pie slices
		     *
		     * @private
		     * @function Highcharts.seriesTypes.pie#translate
		     *
		     * @param {Array<number>} positions
		     */
		    translate: function (positions) {
		        this.generatePoints();

		        var series = this,
		            cumulative = 0,
		            precision = 1000, // issue #172
		            options = series.options,
		            slicedOffset = options.slicedOffset,
		            connectorOffset = slicedOffset + (options.borderWidth || 0),
		            finalConnectorOffset,
		            start,
		            end,
		            angle,
		            radians = getStartAndEndRadians(
		                options.startAngle,
		                options.endAngle
		            ),
		            startAngleRad = series.startAngleRad = radians.start,
		            endAngleRad = series.endAngleRad = radians.end,
		            circ = endAngleRad - startAngleRad, // 2 * Math.PI,
		            points = series.points,
		            radiusX, // the x component of the radius vector for a given point
		            radiusY,
		            labelDistance = options.dataLabels.distance,
		            ignoreHiddenPoint = options.ignoreHiddenPoint,
		            i,
		            len = points.length,
		            point;

		        // Get positions - either an integer or a percentage string must be
		        // given. If positions are passed as a parameter, we're in a recursive
		        // loop for adjusting space for data labels.
		        if (!positions) {
		            series.center = positions = series.getCenter();
		        }

		        // Utility for getting the x value from a given y, used for
		        // anticollision logic in data labels. Added point for using specific
		        // points' label distance.
		        series.getX = function (y, left, point) {
		            angle = Math.asin(
		                Math.min(
		                    (
		                        (y - positions[1]) /
		                        (positions[2] / 2 + point.labelDistance)
		                    ),
		                    1
		                )
		            );
		            return positions[0] +
		                (left ? -1 : 1) *
		                (Math.cos(angle) * (positions[2] / 2 + point.labelDistance));
		        };

		        // Calculate the geometry for each point
		        for (i = 0; i < len; i++) {

		            point = points[i];

		            // Used for distance calculation for specific point.
		            point.labelDistance = pick(
		                point.options.dataLabels && point.options.dataLabels.distance,
		                labelDistance
		            );

		            // Saved for later dataLabels distance calculation.
		            series.maxLabelDistance = Math.max(
		                series.maxLabelDistance || 0,
		                point.labelDistance
		            );

		            // set start and end angle
		            start = startAngleRad + (cumulative * circ);
		            if (!ignoreHiddenPoint || point.visible) {
		                cumulative += point.percentage / 100;
		            }
		            end = startAngleRad + (cumulative * circ);

		            // set the shape
		            point.shapeType = 'arc';
		            point.shapeArgs = {
		                x: positions[0],
		                y: positions[1],
		                r: positions[2] / 2,
		                innerR: positions[3] / 2,
		                start: Math.round(start * precision) / precision,
		                end: Math.round(end * precision) / precision
		            };

		            // The angle must stay within -90 and 270 (#2645)
		            angle = (end + start) / 2;
		            if (angle > 1.5 * Math.PI) {
		                angle -= 2 * Math.PI;
		            } else if (angle < -Math.PI / 2) {
		                angle += 2 * Math.PI;
		            }

		            // Center for the sliced out slice
		            point.slicedTranslation = {
		                translateX: Math.round(Math.cos(angle) * slicedOffset),
		                translateY: Math.round(Math.sin(angle) * slicedOffset)
		            };

		            // set the anchor point for tooltips
		            radiusX = Math.cos(angle) * positions[2] / 2;
		            radiusY = Math.sin(angle) * positions[2] / 2;
		            point.tooltipPos = [
		                positions[0] + radiusX * 0.7,
		                positions[1] + radiusY * 0.7
		            ];

		            point.half = angle < -Math.PI / 2 || angle > Math.PI / 2 ? 1 : 0;
		            point.angle = angle;

		            // Set the anchor point for data labels. Use point.labelDistance
		            // instead of labelDistance // #1174
		            // finalConnectorOffset - not override connectorOffset value.
		            finalConnectorOffset = Math.min(
		                connectorOffset,
		                point.labelDistance / 5
		            ); // #1678
		            point.labelPos = [
		                // first break of connector
		                positions[0] + radiusX +
		                    Math.cos(angle) * point.labelDistance,
		                positions[1] + radiusY +
		                    Math.sin(angle) * point.labelDistance,
		                // second break, right outside pie
		                positions[0] + radiusX +
		                    Math.cos(angle) * finalConnectorOffset,
		                positions[1] + radiusY +
		                    Math.sin(angle) * finalConnectorOffset, // a/a
		                positions[0] + radiusX, // landing point for connector
		                positions[1] + radiusY, // a/a
		                point.labelDistance < 0 ? // alignment
		                    'center' :
		                    point.half ? 'right' : 'left', // alignment
		                angle // center angle
		            ];

		        }
		    },

		    /**
		     * @private
		     * @deprecated
		     * @name Highcharts.seriesTypes.pie#drawGraph
		     * @type {null}
		     */
		    drawGraph: null,

		    /**
		     * Draw the data points
		     *
		     * @private
		     * @function Highcharts.seriesTypes.pie#drawPoints
		     */
		    drawPoints: function () {
		        var series = this,
		            chart = series.chart,
		            renderer = chart.renderer,
		            groupTranslation,
		            graphic,
		            pointAttr,
		            shapeArgs;


		        var shadow = series.options.shadow;
		        if (shadow && !series.shadowGroup) {
		            series.shadowGroup = renderer.g('shadow')
		                .add(series.group);
		        }


		        // draw the slices
		        each(series.points, function (point) {
		            graphic = point.graphic;
		            if (!point.isNull) {
		                shapeArgs = point.shapeArgs;


		                // If the point is sliced, use special translation, else use
		                // plot area traslation
		                groupTranslation = point.getTranslate();


		                // Put the shadow behind all points
		                var shadowGroup = point.shadowGroup;
		                if (shadow && !shadowGroup) {
		                    shadowGroup = point.shadowGroup = renderer.g('shadow')
		                        .add(series.shadowGroup);
		                }

		                if (shadowGroup) {
		                    shadowGroup.attr(groupTranslation);
		                }
		                pointAttr = series.pointAttribs(
		                    point,
		                    point.selected && 'select'
		                );


		                // Draw the slice
		                if (graphic) {
		                    graphic
		                        .setRadialReference(series.center)

		                        .attr(pointAttr)

		                        .animate(extend(shapeArgs, groupTranslation));
		                } else {

		                    point.graphic = graphic = renderer[point.shapeType](
		                            shapeArgs
		                        )
		                        .setRadialReference(series.center)
		                        .attr(groupTranslation)
		                        .add(series.group);


		                    graphic
		                        .attr(pointAttr)
		                        .attr({ 'stroke-linejoin': 'round' })
		                        .shadow(shadow, shadowGroup);

		                }

		                graphic.attr({
		                    visibility: point.visible ? 'inherit' : 'hidden'
		                });

		                graphic.addClass(point.getClassName());

		            } else if (graphic) {
		                point.graphic = graphic.destroy();
		            }
		        });

		    },

		    /**
		     * @private
		     * @deprecated
		     * @function Highcharts.seriesTypes.pie#searchPoint
		     */
		    searchPoint: noop,

		    /**
		     * Utility for sorting data labels
		     *
		     * @private
		     * @function Highcharts.seriesTypes.pie#sortByAngle
		     *
		     * @param {Array<Highcharts.Point>} points
		     *
		     * @param {number} sign
		     */
		    sortByAngle: function (points, sign) {
		        points.sort(function (a, b) {
		            return a.angle !== undefined && (b.angle - a.angle) * sign;
		        });
		    },

		    /**
		     * Use a simple symbol from LegendSymbolMixin.
		     *
		     * @private
		     * @borrows Highcharts.LegendSymbolMixin.drawRectangle as Highcharts.seriesTypes.pie#drawLegendSymbol
		     */
		    drawLegendSymbol: LegendSymbolMixin.drawRectangle,

		    /**
		     * Use the getCenter method from drawLegendSymbol.
		     *
		     * @private
		     * @borrows Highcharts.CenteredSeriesMixin.getCenter as Highcharts.seriesTypes.pie#getCenter
		     */
		    getCenter: CenteredSeriesMixin.getCenter,

		    /**
		     * Pies don't have point marker symbols.
		     *
		     * @deprecated
		     * @private
		     * @function Highcharts.seriesTypes.pie#getSymbol
		     */
		    getSymbol: noop


		}, /** @lends seriesTypes.pie.prototype.pointClass.prototype */ {

		    /**
		     * Initiate the pie slice
		     *
		     * @private
		     * @function Highcharts.seriesTypes.pie#pointClass#init
		     *
		     * @return {Highcharts.Point}
		     */
		    init: function () {

		        Point.prototype.init.apply(this, arguments);

		        var point = this,
		            toggleSlice;

		        point.name = pick(point.name, 'Slice');

		        // add event listener for select
		        toggleSlice = function (e) {
		            point.slice(e.type === 'select');
		        };
		        addEvent(point, 'select', toggleSlice);
		        addEvent(point, 'unselect', toggleSlice);

		        return point;
		    },

		    /**
		     * Negative points are not valid (#1530, #3623, #5322)
		     *
		     * @private
		     * @function Highcharts.seriesTypes.pie#pointClass#isValid
		     *
		     * @return {boolean}
		     */
		    isValid: function () {
		        return H.isNumber(this.y, true) && this.y >= 0;
		    },

		    /**
		     * Toggle the visibility of the pie slice
		     *
		     * @private
		     * @function Highcharts.seriesTypes.pie#pointClass#setVisible
		     *
		     * @param {boolean} vis
		     *        Whether to show the slice or not. If undefined, the visibility is
		     *        toggled.
		     *
		     * @param {boolean} [redraw=false]
		     */
		    setVisible: function (vis, redraw) {
		        var point = this,
		            series = point.series,
		            chart = series.chart,
		            ignoreHiddenPoint = series.options.ignoreHiddenPoint;

		        redraw = pick(redraw, ignoreHiddenPoint);

		        if (vis !== point.visible) {

		            // If called without an argument, toggle visibility
		            point.visible = point.options.visible = vis =
		                vis === undefined ? !point.visible : vis;
		            // update userOptions.data
		            series.options.data[inArray(point, series.data)] = point.options;

		            // Show and hide associated elements. This is performed regardless
		            // of redraw or not, because chart.redraw only handles full series.
		            each(
		                ['graphic', 'dataLabel', 'connector', 'shadowGroup'],
		                function (key) {
		                    if (point[key]) {
		                        point[key][vis ? 'show' : 'hide'](true);
		                    }
		                }
		            );

		            if (point.legendItem) {
		                chart.legend.colorizeItem(point, vis);
		            }

		            // #4170, hide halo after hiding point
		            if (!vis && point.state === 'hover') {
		                point.setState('');
		            }

		            // Handle ignore hidden slices
		            if (ignoreHiddenPoint) {
		                series.isDirty = true;
		            }

		            if (redraw) {
		                chart.redraw();
		            }
		        }
		    },

		    /**
		     * Set or toggle whether the slice is cut out from the pie
		     *
		     * @private
		     * @function Highcharts.seriesTypes.pie#pointClass#slice
		     *
		     * @param {boolean} sliced
		     *        When undefined, the slice state is toggled.
		     *
		     * @param {boolean} redraw
		     *        Whether to redraw the chart. True by default.
		     */
		    slice: function (sliced, redraw, animation) {
		        var point = this,
		            series = point.series,
		            chart = series.chart;

		        setAnimation(animation, chart);

		        // redraw is true by default
		        redraw = pick(redraw, true);

		        // if called without an argument, toggle
		        point.sliced = point.options.sliced = sliced =
		            defined(sliced) ? sliced : !point.sliced;
		        // update userOptions.data
		        series.options.data[inArray(point, series.data)] = point.options;

		        point.graphic.animate(this.getTranslate());


		        if (point.shadowGroup) {
		            point.shadowGroup.animate(this.getTranslate());
		        }

		    },

		    /**
		     * @private
		     * @function Highcharts.seriesTypes.pie#pointClass#getTranslate
		     *
		     * @return {*}
		     */
		    getTranslate: function () {
		        return this.sliced ? this.slicedTranslation : {
		            translateX: 0,
		            translateY: 0
		        };
		    },

		    /**
		     * @private
		     * @function Highcharts.seriesTypes.pie#pointClass#haloPath
		     *
		     * @param {number} size
		     *
		     * @return {Highcharts.SVGPathArray}
		     */
		    haloPath: function (size) {
		        var shapeArgs = this.shapeArgs;

		        return this.sliced || !this.visible ?
		            [] :
		            this.series.chart.renderer.symbols.arc(
		                shapeArgs.x,
		                shapeArgs.y,
		                shapeArgs.r + size,
		                shapeArgs.r + size, {
		                    // Substract 1px to ensure the background is not bleeding
		                    // through between the halo and the slice (#7495).
		                    innerR: this.shapeArgs.r - 1,
		                    start: shapeArgs.start,
		                    end: shapeArgs.end
		                }
		            );
		    }
		});

		/**
		 * A `pie` series. If the [type](#series.pie.type) option is not specified,
		 * it is inherited from [chart.type](#chart.type).
		 *
		 * @extends   series,plotOptions.pie
		 * @excluding dataParser, dataURL, stack, xAxis, yAxis
		 * @product   highcharts
		 * @apioption series.pie
		 */

		/**
		 * An array of data points for the series. For the `pie` series type,
		 * points can be given in the following ways:
		 *
		 * 1.  An array of numerical values. In this case, the numerical values
		 * will be interpreted as `y` options. Example:
		 *
		 *  ```js
		 *  data: [0, 5, 3, 5]
		 *  ```
		 *
		 * 2.  An array of objects with named values. The following snippet shows only a
		 * few settings, see the complete options set below. If the total number of data
		 * points exceeds the series' [turboThreshold](#series.pie.turboThreshold),
		 * this option is not available.
		 *
		 *  ```js
		 *     data: [{
		 *     y: 1,
		 *     name: "Point2",
		 *     color: "#00FF00"
		 * }, {
		 *     y: 7,
		 *     name: "Point1",
		 *     color: "#FF00FF"
		 * }]</pre>
		 *
		 * @sample {highcharts} highcharts/chart/reflow-true/
		 *         Numerical values
		 * @sample {highcharts} highcharts/series/data-array-of-arrays/
		 *         Arrays of numeric x and y
		 * @sample {highcharts} highcharts/series/data-array-of-arrays-datetime/
		 *         Arrays of datetime x and y
		 * @sample {highcharts} highcharts/series/data-array-of-name-value/
		 *         Arrays of point.name and y
		 * @sample {highcharts} highcharts/series/data-array-of-objects/
		 *         Config objects
		 *
		 * @type      {Array<number|*>}
		 * @extends   series.line.data
		 * @excluding marker, x
		 * @product   highcharts
		 * @apioption series.pie.data
		 */

		/**
		 * Fires when the checkbox next to the point name in the legend is clicked.
		 * One parameter, event, is passed to the function. The state of the
		 * checkbox is found by event.checked. The checked item is found by
		 * event.item. Return false to prevent the default action which is to
		 * toggle the select state of the series.
		 *
		 * @sample {highcharts} highcharts/plotoptions/series-events-checkboxclick/
		 *         Alert checkbox status
		 *
		 * @type      {Function}
		 * @since     1.2.0
		 * @product   highcharts
		 * @context   Highcharts.Point
		 * @apioption plotOptions.pie.events.checkboxClick
		 */

		/**
		 * Not applicable to pies, as the legend item is per point. See point.
		 * events.
		 *
		 * @type      {Function}
		 * @since     1.2.0
		 * @product   highcharts
		 * @apioption plotOptions.pie.events.legendItemClick
		 */

		/**
		 * The sequential index of the data point in the legend.
		 *
		 * @type      {number}
		 * @product   highcharts
		 * @apioption series.pie.data.legendIndex
		 */

		/**
		 * Fires when the legend item belonging to the pie point (slice) is
		 * clicked. The `this` keyword refers to the point itself. One parameter,
		 * `event`, is passed to the function, containing common event information. The
		 * default action is to toggle the visibility of the point. This can be
		 * prevented by calling `event.preventDefault()`.
		 *
		 * @sample {highcharts} highcharts/plotoptions/pie-point-events-legenditemclick/
		 *         Confirm toggle visibility
		 *
		 * @type      {Function}
		 * @since     1.2.0
		 * @product   highcharts
		 * @apioption plotOptions.pie.point.events.legendItemClick
		 */

		/**
		 * Whether to display a slice offset from the center.
		 *
		 * @sample {highcharts} highcharts/point/sliced/
		 *         One sliced point
		 *
		 * @type      {boolean}
		 * @product   highcharts
		 * @apioption series.pie.data.sliced
		 */

	}(Highcharts));
	(function (H) {
		/**
		 * (c) 2010-2018 Torstein Honsi
		 *
		 * License: www.highcharts.com/license
		 */



		var addEvent = H.addEvent,
		    arrayMax = H.arrayMax,
		    defined = H.defined,
		    each = H.each,
		    extend = H.extend,
		    format = H.format,
		    map = H.map,
		    merge = H.merge,
		    noop = H.noop,
		    pick = H.pick,
		    relativeLength = H.relativeLength,
		    Series = H.Series,
		    seriesTypes = H.seriesTypes,
		    some = H.some,
		    stableSort = H.stableSort,
		    isArray = H.isArray,
		    splat = H.splat;

		/**
		 * General distribution algorithm for distributing labels of differing size
		 * along a confined length in two dimensions. The algorithm takes an array of
		 * objects containing a size, a target and a rank. It will place the labels as
		 * close as possible to their targets, skipping the lowest ranked labels if
		 * necessary.
		 *
		 * @private
		 * @function Highcharts.distribute
		 *
		 * @param {Array<object>} boxes
		 *
		 * @param {number} len
		 *
		 * @param {number} maxDistance
		 */
		H.distribute = function (boxes, len, maxDistance) {

		    var i,
		        overlapping = true,
		        origBoxes = boxes, // Original array will be altered with added .pos
		        restBoxes = [], // The outranked overshoot
		        box,
		        target,
		        total = 0,
		        reducedLen = origBoxes.reducedLen || len;

		    function sortByTarget(a, b) {
		        return a.target - b.target;
		    }

		    // If the total size exceeds the len, remove those boxes with the lowest
		    // rank
		    i = boxes.length;
		    while (i--) {
		        total += boxes[i].size;
		    }

		    // Sort by rank, then slice away overshoot
		    if (total > reducedLen) {
		        stableSort(boxes, function (a, b) {
		            return (b.rank || 0) - (a.rank || 0);
		        });
		        i = 0;
		        total = 0;
		        while (total <= reducedLen) {
		            total += boxes[i].size;
		            i++;
		        }
		        restBoxes = boxes.splice(i - 1, boxes.length);
		    }

		    // Order by target
		    stableSort(boxes, sortByTarget);


		    // So far we have been mutating the original array. Now
		    // create a copy with target arrays
		    boxes = map(boxes, function (box) {
		        return {
		            size: box.size,
		            targets: [box.target],
		            align: pick(box.align, 0.5)
		        };
		    });

		    while (overlapping) {
		        // Initial positions: target centered in box
		        i = boxes.length;
		        while (i--) {
		            box = boxes[i];
		            // Composite box, average of targets
		            target = (
		                Math.min.apply(0, box.targets) +
		                Math.max.apply(0, box.targets)
		            ) / 2;
		            box.pos = Math.min(
		                Math.max(0, target - box.size * box.align),
		                len - box.size
		            );
		        }

		        // Detect overlap and join boxes
		        i = boxes.length;
		        overlapping = false;
		        while (i--) {
		            // Overlap
		            if (i > 0 && boxes[i - 1].pos + boxes[i - 1].size > boxes[i].pos) {
		                // Add this size to the previous box
		                boxes[i - 1].size += boxes[i].size;
		                boxes[i - 1].targets = boxes[i - 1]
		                    .targets
		                    .concat(boxes[i].targets);
		                boxes[i - 1].align = 0.5;

		                // Overlapping right, push left
		                if (boxes[i - 1].pos + boxes[i - 1].size > len) {
		                    boxes[i - 1].pos = len - boxes[i - 1].size;
		                }
		                boxes.splice(i, 1); // Remove this item
		                overlapping = true;
		            }
		        }
		    }

		    // Add the rest (hidden boxes)
		    origBoxes.push.apply(origBoxes, restBoxes);


		    // Now the composite boxes are placed, we need to put the original boxes
		    // within them
		    i = 0;
		    some(boxes, function (box) {
		        var posInCompositeBox = 0;
		        if (some(box.targets, function () {
		            origBoxes[i].pos = box.pos + posInCompositeBox;

		            // If the distance between the position and the target exceeds
		            // maxDistance, abort the loop and decrease the length in increments
		            // of 10% to recursively reduce the  number of visible boxes by
		            // rank. Once all boxes are within the maxDistance, we're good.
		            if (
		                Math.abs(origBoxes[i].pos - origBoxes[i].target) >
		                maxDistance
		            ) {
		                // Reset the positions that are already set
		                each(origBoxes.slice(0, i + 1), function (box) {
		                    delete box.pos;
		                });

		                // Try with a smaller length
		                origBoxes.reducedLen =
		                    (origBoxes.reducedLen || len) - (len * 0.1);

		                // Recurse
		                if (origBoxes.reducedLen > len * 0.1) {
		                    H.distribute(origBoxes, len, maxDistance);
		                }

		                // Exceeded maxDistance => abort
		                return true;
		            }

		            posInCompositeBox += origBoxes[i].size;
		            i++;

		        })) {
		            // Exceeded maxDistance => abort
		            return true;
		        }
		    });

		    // Add the rest (hidden) boxes and sort by target
		    stableSort(origBoxes, sortByTarget);
		};


		/**
		 * Draw the data labels
		 *
		 * @private
		 * @function Highcharts.Series#drawDataLabels
		 *
		 * @fires Highcharts.Series#event:afterDrawDataLabels
		 */
		Series.prototype.drawDataLabels = function () {
		    var series = this,
		        chart = series.chart,
		        seriesOptions = series.options,
		        seriesDlOptions = seriesOptions.dataLabels,
		        points = series.points,
		        pointOptions,
		        hasRendered = series.hasRendered || 0,
		        dataLabelsGroup,
		        defer = pick(seriesDlOptions.defer, !!seriesOptions.animation),
		        renderer = chart.renderer;

		    /*
		     * Handle the dataLabels.filter option.
		     */
		    function applyFilter(point, options) {
		        var filter = options.filter,
		            op,
		            prop,
		            val;
		        if (filter) {
		            op = filter.operator;
		            prop = point[filter.property];
		            val = filter.value;
		            if (
		                (op === '>' && prop > val) ||
		                (op === '<' && prop < val) ||
		                (op === '>=' && prop >= val) ||
		                (op === '<=' && prop <= val) ||
		                (op === '==' && prop == val) || // eslint-disable-line eqeqeq
		                (op === '===' && prop === val)
		            ) {
		                return true;
		            }
		            return false;
		        }
		        return true;
		    }

		    /*
		     * Merge two objects that can be arrays. If one of them is an array, the
		     * other is merged into each element. If both are arrays, each element is
		     * merged by index. If neither are arrays, we use normal merge.
		     */
		    function mergeArrays(one, two) {
		        var res = [],
		            i;
		        if (isArray(one) && !isArray(two)) {
		            res = map(one, function (el) {
		                return merge(el, two);
		            });
		        } else if (isArray(two) && !isArray(one)) {
		            res = map(two, function (el) {
		                return merge(one, el);
		            });
		        } else if (!isArray(one) && !isArray(two)) {
		            res = merge(one, two);
		        } else {
		            i = Math.max(one.length, two.length);
		            while (i--) {
		                res[i] = merge(one[i], two[i]);
		            }
		        }
		        return res;
		    }


		    // Merge in plotOptions.dataLabels for series
		    seriesDlOptions = mergeArrays(
		        mergeArrays(
		            chart.options.plotOptions &&
		            chart.options.plotOptions.series &&
		            chart.options.plotOptions.series.dataLabels,
		            chart.options.plotOptions &&
		            chart.options.plotOptions[series.type] &&
		            chart.options.plotOptions[series.type].dataLabels
		        ),
		        seriesDlOptions
		    );

		    if (
		        isArray(seriesDlOptions) ||
		        seriesDlOptions.enabled ||
		        series._hasPointLabels
		    ) {

		        // Create a separate group for the data labels to avoid rotation
		        dataLabelsGroup = series.plotGroup(
		            'dataLabelsGroup',
		            'data-labels',
		            defer && !hasRendered ? 'hidden' : 'visible', // #5133
		            seriesDlOptions.zIndex || 6
		        );

		        if (defer) {
		            dataLabelsGroup.attr({ opacity: +hasRendered }); // #3300
		            if (!hasRendered) {
		                addEvent(series, 'afterAnimate', function () {
		                    if (series.visible) { // #2597, #3023, #3024
		                        dataLabelsGroup.show(true);
		                    }
		                    dataLabelsGroup[
		                        seriesOptions.animation ? 'animate' : 'attr'
		                    ]({ opacity: 1 }, { duration: 200 });
		                });
		            }
		        }

		        // Make the labels for each point
		        each(points, function (point) {

		            // Merge in series options for the point.
		            // @note dataLabelAttribs (like pointAttribs) would eradicate
		            // the need for dlOptions, and simplify the section below.
		            pointOptions = splat(
		                mergeArrays(
		                    seriesDlOptions,
		                    point.dlOptions || // dlOptions is used in treemaps
		                        (point.options && point.options.dataLabels)
		                )
		            );

		            // Handle each individual data label for this point
		            each(pointOptions, function (labelOptions, i) {
		                // Options for one datalabel
		                var labelEnabled = labelOptions.enabled &&
		                        !point.isNull && // #2282, #4641, #7112
		                        applyFilter(point, labelOptions),
		                    labelConfig,
		                    formatString,
		                    labelText,
		                    style,
		                    rotation,
		                    attr,
		                    dataLabel = point.dataLabels ? point.dataLabels[i] :
		                        point.dataLabel,
		                    connector = point.connectors ? point.connectors[i] :
		                        point.connector,
		                    isNew = !dataLabel;

		                if (labelEnabled) {
		                    // Create individual options structure that can be extended
		                    // without affecting others
		                    labelConfig = point.getLabelConfig();
		                    formatString = (
		                        labelOptions[point.formatPrefix + 'Format'] ||
		                        labelOptions.format
		                    );

		                    labelText = defined(formatString) ?
		                        format(formatString, labelConfig, chart.time) :
		                        (
		                            labelOptions[point.formatPrefix + 'Formatter'] ||
		                            labelOptions.formatter
		                        ).call(labelConfig, labelOptions);

		                    style = labelOptions.style;
		                    rotation = labelOptions.rotation;

		                    // Determine the color
		                    style.color = pick(
		                        labelOptions.color,
		                        style.color,
		                        series.color,
		                        '#000000'
		                    );
		                    // Get automated contrast color
		                    if (style.color === 'contrast') {
		                        point.contrastColor =
		                            renderer.getContrast(point.color || series.color);
		                        style.color = labelOptions.inside ||
		                            pick(
		                                labelOptions.distance,
		                                point.labelDistance
		                            ) < 0 ||
		                            !!seriesOptions.stacking ?
		                                point.contrastColor :
		                                '#000000';
		                    }
		                    if (seriesOptions.cursor) {
		                        style.cursor = seriesOptions.cursor;
		                    }


		                    attr = {

		                        fill: labelOptions.backgroundColor,
		                        stroke: labelOptions.borderColor,
		                        'stroke-width': labelOptions.borderWidth,

		                        r: labelOptions.borderRadius || 0,
		                        rotation: rotation,
		                        padding: labelOptions.padding,
		                        zIndex: 1
		                    };

		                    // Remove unused attributes (#947)
		                    H.objectEach(attr, function (val, name) {
		                        if (val === undefined) {
		                            delete attr[name];
		                        }
		                    });
		                }

		                // If the point is outside the plot area, destroy it. #678, #820
		                if (dataLabel && (!labelEnabled || !defined(labelText))) {
		                    point.dataLabel = point.dataLabel.destroy();
		                    if (point.dataLabels) {
		                        // Remove point.dataLabels if this was the last one
		                        if (point.dataLabels.length === 1) {
		                            delete point.dataLabels;
		                        } else {
		                            delete point.dataLabels[i];
		                        }
		                    }
		                    if (!i) {
		                        delete point.dataLabel;
		                    }
		                    if (connector) {
		                        point.connector = point.connector.destroy();
		                        if (point.connectors) {
		                            // Remove point.connectors if this was the last one
		                            if (point.connectors.length === 1) {
		                                delete point.connectors;
		                            } else {
		                                delete point.connectors[i];
		                            }
		                        }
		                    }

		                // Individual labels are disabled if the are explicitly disabled
		                // in the point options, or if they fall outside the plot area.
		                } else if (labelEnabled && defined(labelText)) {

		                    if (!dataLabel) {
		                        // Create new label element
		                        point.dataLabels = point.dataLabels || [];
		                        dataLabel = point.dataLabels[i] = rotation ?

		                            // Labels don't rotate, use text element
		                            renderer.text(labelText, 0, -9999)
		                                .addClass('highcharts-data-label') :

		                            // We can use label
		                            renderer.label(
		                                labelText,
		                                0,
		                                -9999,
		                                labelOptions.shape,
		                                null,
		                                null,
		                                labelOptions.useHTML,
		                                null,
		                                'data-label'
		                            );

		                        // Store for backwards compatibility
		                        if (!i) {
		                            point.dataLabel = dataLabel;
		                        }

		                        dataLabel.addClass(
		                            ' highcharts-data-label-color-' + point.colorIndex +
		                            ' ' + (labelOptions.className || '') +
		                            (   // #3398
		                                labelOptions.useHTML ?
		                                    ' highcharts-tracker' :
		                                    ''
		                            )
		                        );
		                    } else {
		                        // Use old element and just update text
		                        attr.text = labelText;
		                    }

		                    // Store data label options for later access
		                    dataLabel.options = labelOptions;

		                    dataLabel.attr(attr);

		                    // Styles must be applied before add in order to read text
		                    // bounding box
		                    dataLabel.css(style).shadow(labelOptions.shadow);


		                    if (!dataLabel.added) {
		                        dataLabel.add(dataLabelsGroup);
		                    }

		                    // Now the data label is created and placed at 0,0, so we
		                    // need to align it
		                    series.alignDataLabel(
		                        point, dataLabel, labelOptions, null, isNew
		                    );
		                }
		            });
		        });
		    }

		    H.fireEvent(this, 'afterDrawDataLabels');
		};

		/**
		 * Align each individual data label.
		 *
		 * @private
		 * @function Highcharts.Series#alignDataLabel
		 *
		 * @param {Highcharts.Point} point
		 *
		 * @param {Highcharts.SVGElement} dataLabel
		 *
		 * @param {Highcharts.PlotSeriesDataLabelsOptions} options
		 *
		 * @param {Highcharts.BBoxObject} alignTo
		 *
		 * @param {boolean} isNew
		 */
		Series.prototype.alignDataLabel = function (
		    point,
		    dataLabel,
		    options,
		    alignTo,
		    isNew
		) {
		    var chart = this.chart,
		        inverted = chart.inverted,
		        plotX = pick(point.dlBox && point.dlBox.centerX, point.plotX, -9999),
		        plotY = pick(point.plotY, -9999),
		        bBox = dataLabel.getBBox(),
		        fontSize,
		        baseline,
		        rotation = options.rotation,
		        normRotation,
		        negRotation,
		        align = options.align,
		        rotCorr, // rotation correction
		        // Math.round for rounding errors (#2683), alignTo to allow column
		        // labels (#2700)
		        visible =
		            this.visible &&
		            (
		                point.series.forceDL ||
		                chart.isInsidePlot(plotX, Math.round(plotY), inverted) ||
		                (
		                    alignTo && chart.isInsidePlot(
		                        plotX,
		                        inverted ?
		                            alignTo.x + 1 :
		                            alignTo.y + alignTo.height - 1,
		                        inverted
		                    )
		                )
		            ),
		        alignAttr, // the final position;
		        justify = pick(options.overflow, 'justify') === 'justify';

		    if (visible) {


		        fontSize = options.style.fontSize;


		        baseline = chart.renderer.fontMetrics(fontSize, dataLabel).b;

		        // The alignment box is a singular point
		        alignTo = extend({
		            x: inverted ? this.yAxis.len - plotY : plotX,
		            y: Math.round(inverted ? this.xAxis.len - plotX : plotY),
		            width: 0,
		            height: 0
		        }, alignTo);

		        // Add the text size for alignment calculation
		        extend(options, {
		            width: bBox.width,
		            height: bBox.height
		        });

		        // Allow a hook for changing alignment in the last moment, then do the
		        // alignment
		        if (rotation) {
		            justify = false; // Not supported for rotated text
		            rotCorr = chart.renderer.rotCorr(baseline, rotation); // #3723
		            alignAttr = {
		                x: alignTo.x + options.x + alignTo.width / 2 + rotCorr.x,
		                y: (
		                    alignTo.y +
		                    options.y +
		                    { top: 0, middle: 0.5, bottom: 1 }[options.verticalAlign] *
		                        alignTo.height
		                )
		            };
		            dataLabel[isNew ? 'attr' : 'animate'](alignAttr)
		                .attr({ // #3003
		                    align: align
		                });

		            // Compensate for the rotated label sticking out on the sides
		            normRotation = (rotation + 720) % 360;
		            negRotation = normRotation > 180 && normRotation < 360;

		            if (align === 'left') {
		                alignAttr.y -= negRotation ? bBox.height : 0;
		            } else if (align === 'center') {
		                alignAttr.x -= bBox.width / 2;
		                alignAttr.y -= bBox.height / 2;
		            } else if (align === 'right') {
		                alignAttr.x -= bBox.width;
		                alignAttr.y -= negRotation ? 0 : bBox.height;
		            }
		            dataLabel.placed = true;
		            dataLabel.alignAttr = alignAttr;

		        } else {
		            dataLabel.align(options, null, alignTo);
		            alignAttr = dataLabel.alignAttr;
		        }

		        // Handle justify or crop
		        if (justify && alignTo.height >= 0) { // #8830
		            point.isLabelJustified = this.justifyDataLabel(
		                dataLabel,
		                options,
		                alignAttr,
		                bBox,
		                alignTo,
		                isNew
		            );

		        // Now check that the data label is within the plot area
		        } else if (pick(options.crop, true)) {
		            visible =
		                chart.isInsidePlot(
		                    alignAttr.x,
		                    alignAttr.y
		                ) &&
		                chart.isInsidePlot(
		                    alignAttr.x + bBox.width,
		                    alignAttr.y + bBox.height
		                );
		        }

		        // When we're using a shape, make it possible with a connector or an
		        // arrow pointing to thie point
		        if (options.shape && !rotation) {
		            dataLabel[isNew ? 'attr' : 'animate']({
		                anchorX: inverted ? chart.plotWidth - point.plotY : point.plotX,
		                anchorY: inverted ? chart.plotHeight - point.plotX : point.plotY
		            });
		        }
		    }

		    // Show or hide based on the final aligned position
		    if (!visible) {
		        dataLabel.attr({ y: -9999 });
		        dataLabel.placed = false; // don't animate back in
		    }

		};

		/**
		 * If data labels fall partly outside the plot area, align them back in, in a
		 * way that doesn't hide the point.
		 *
		 * @private
		 * @function Highcharts.Series#justifyDataLabel
		 *
		 * @param {Highcharts.SVGElement} dataLabel
		 *
		 * @param {Highcharts.PlotSeriesDataLabelsOptions} options
		 *
		 * @param {*} alignAttr
		 *
		 * @param {Highcharts.BBoxObject} bBox
		 *
		 * @param {boolean} isNew
		 *
		 * @return {boolean}
		 */
		Series.prototype.justifyDataLabel = function (
		    dataLabel,
		    options,
		    alignAttr,
		    bBox,
		    alignTo,
		    isNew
		) {
		    var chart = this.chart,
		        align = options.align,
		        verticalAlign = options.verticalAlign,
		        off,
		        justified,
		        padding = dataLabel.box ? 0 : (dataLabel.padding || 0);

		    // Off left
		    off = alignAttr.x + padding;
		    if (off < 0) {
		        if (align === 'right') {
		            options.align = 'left';
		        } else {
		            options.x = -off;
		        }
		        justified = true;
		    }

		    // Off right
		    off = alignAttr.x + bBox.width - padding;
		    if (off > chart.plotWidth) {
		        if (align === 'left') {
		            options.align = 'right';
		        } else {
		            options.x = chart.plotWidth - off;
		        }
		        justified = true;
		    }

		    // Off top
		    off = alignAttr.y + padding;
		    if (off < 0) {
		        if (verticalAlign === 'bottom') {
		            options.verticalAlign = 'top';
		        } else {
		            options.y = -off;
		        }
		        justified = true;
		    }

		    // Off bottom
		    off = alignAttr.y + bBox.height - padding;
		    if (off > chart.plotHeight) {
		        if (verticalAlign === 'top') {
		            options.verticalAlign = 'bottom';
		        } else {
		            options.y = chart.plotHeight - off;
		        }
		        justified = true;
		    }

		    if (justified) {
		        dataLabel.placed = !isNew;
		        dataLabel.align(options, null, alignTo);
		    }

		    return justified;
		};

		if (seriesTypes.pie) {
		    /**
		     * Override the base drawDataLabels method by pie specific functionality
		     *
		     * @private
		     * @function Highcharts.seriesTypes.pie#drawDataLabels
		     */
		    seriesTypes.pie.prototype.drawDataLabels = function () {
		        var series = this,
		            data = series.data,
		            point,
		            chart = series.chart,
		            options = series.options.dataLabels,
		            connectorPadding = pick(options.connectorPadding, 10),
		            connectorWidth = pick(options.connectorWidth, 1),
		            plotWidth = chart.plotWidth,
		            plotHeight = chart.plotHeight,
		            maxWidth = Math.round(chart.chartWidth / 3),
		            connector,
		            seriesCenter = series.center,
		            radius = seriesCenter[2] / 2,
		            centerY = seriesCenter[1],
		            dataLabel,
		            dataLabelWidth,
		            labelPos,
		            labelHeight,
		            // divide the points into right and left halves for anti collision
		            halves = [
		                [], // right
		                []  // left
		            ],
		            x,
		            y,
		            visibility,
		            j,
		            overflow = [0, 0, 0, 0]; // top, right, bottom, left

		        // get out if not enabled
		        if (!series.visible || (!options.enabled && !series._hasPointLabels)) {
		            return;
		        }

		        // Reset all labels that have been shortened
		        each(data, function (point) {
		            if (point.dataLabel && point.visible && point.dataLabel.shortened) {
		                point.dataLabel
		                    .attr({
		                        width: 'auto'
		                    }).css({
		                        width: 'auto',
		                        textOverflow: 'clip'
		                    });
		                point.dataLabel.shortened = false;
		            }
		        });


		        // run parent method
		        Series.prototype.drawDataLabels.apply(series);

		        each(data, function (point) {
		            if (point.dataLabel) {

		                if (point.visible) { // #407, #2510

		                    // Arrange points for detection collision
		                    halves[point.half].push(point);

		                    // Reset positions (#4905)
		                    point.dataLabel._pos = null;

		                    // Avoid long labels squeezing the pie size too far down

		                    if (
		                        !defined(options.style.width) &&
		                        !defined(
		                            point.options.dataLabels &&
		                            point.options.dataLabels.style &&
		                            point.options.dataLabels.style.width
		                        )
		                    ) {

		                        if (point.dataLabel.getBBox().width > maxWidth) {
		                            point.dataLabel.css({
		                                // Use a fraction of the maxWidth to avoid
		                                // wrapping close to the end of the string.
		                                width: maxWidth * 0.7
		                            });
		                            point.dataLabel.shortened = true;
		                        }

		                    }

		                } else {
		                    point.dataLabel = point.dataLabel.destroy();
		                    // Workaround to make pies destroy multiple datalabels
		                    // correctly. This logic needs rewriting to support multiple
		                    // datalabels fully.
		                    if (point.dataLabels && point.dataLabels.length === 1) {
		                        delete point.dataLabels;
		                    }
		                }
		            }
		        });

		        /* Loop over the points in each half, starting from the top and bottom
		         * of the pie to detect overlapping labels.
		         */
		        each(halves, function (points, i) {

		            var top,
		                bottom,
		                length = points.length,
		                positions = [],
		                naturalY,
		                sideOverflow,
		                size,
		                distributionLength;

		            if (!length) {
		                return;
		            }

		            // Sort by angle
		            series.sortByAngle(points, i - 0.5);
		            // Only do anti-collision when we have dataLabels outside the pie
		            // and have connectors. (#856)
		            if (series.maxLabelDistance > 0) {
		                top = Math.max(
		                    0,
		                    centerY - radius - series.maxLabelDistance
		                );
		                bottom = Math.min(
		                    centerY + radius + series.maxLabelDistance,
		                    chart.plotHeight
		                );
		                each(points, function (point) {
		                    // check if specific points' label is outside the pie
		                    if (point.labelDistance > 0 && point.dataLabel) {
		                        // point.top depends on point.labelDistance value
		                        // Used for calculation of y value in getX method
		                        point.top = Math.max(
		                            0,
		                            centerY - radius - point.labelDistance
		                        );
		                        point.bottom = Math.min(
		                            centerY + radius + point.labelDistance,
		                            chart.plotHeight
		                        );
		                        size = point.dataLabel.getBBox().height || 21;

		                        // point.positionsIndex is needed for getting index of
		                        // parameter related to specific point inside positions
		                        // array - not every point is in positions array.
		                        point.distributeBox = {
		                            target: point.labelPos[1] - point.top + size / 2,
		                            size: size,
		                            rank: point.y
		                        };
		                        positions.push(point.distributeBox);
		                    }
		                });
		                distributionLength = bottom + size - top;
		                H.distribute(
		                    positions,
		                    distributionLength,
		                    distributionLength / 5
		                );
		            }

		            // Now the used slots are sorted, fill them up sequentially
		            for (j = 0; j < length; j++) {

		                point = points[j];
		                labelPos = point.labelPos;
		                dataLabel = point.dataLabel;
		                visibility = point.visible === false ? 'hidden' : 'inherit';
		                naturalY = labelPos[1];
		                y = naturalY;

		                if (positions && defined(point.distributeBox)) {
		                    if (point.distributeBox.pos === undefined) {
		                        visibility = 'hidden';
		                    } else {
		                        labelHeight = point.distributeBox.size;
		                        y = point.top + point.distributeBox.pos;
		                    }
		                }

		                // It is needed to delete point.positionIndex for
		                // dynamically added points etc.

		                delete point.positionIndex;

		                // get the x - use the natural x position for labels near the
		                // top and bottom, to prevent the top and botton slice
		                // connectors from touching each other on either side
		                if (options.justify) {
		                    x = seriesCenter[0] +
		                        (i ? -1 : 1) * (radius + point.labelDistance);
		                } else {
		                    x = series.getX(
		                        y < point.top + 2 || y > point.bottom - 2 ?
		                            naturalY :
		                            y,
		                        i,
		                        point
		                    );
		                }


		                // Record the placement and visibility
		                dataLabel._attr = {
		                    visibility: visibility,
		                    align: labelPos[6]
		                };
		                dataLabel._pos = {
		                    x: (
		                        x +
		                        options.x +
		                        ({
		                            left: connectorPadding,
		                            right: -connectorPadding
		                        }[labelPos[6]] || 0)
		                    ),

		                    // 10 is for the baseline (label vs text)
		                    y: y + options.y - 10
		                };
		                labelPos.x = x;
		                labelPos.y = y;


		                // Detect overflowing data labels
		                if (pick(options.crop, true)) {
		                    dataLabelWidth = dataLabel.getBBox().width;

		                    sideOverflow = null;
		                    // Overflow left
		                    if (
		                        x - dataLabelWidth < connectorPadding &&
		                        i === 1 // left half
		                    ) {
		                        sideOverflow = Math.round(
		                            dataLabelWidth - x + connectorPadding
		                        );
		                        overflow[3] = Math.max(sideOverflow, overflow[3]);

		                    // Overflow right
		                    } else if (
		                        x + dataLabelWidth > plotWidth - connectorPadding &&
		                        i === 0 // right half
		                    ) {
		                        sideOverflow = Math.round(
		                            x + dataLabelWidth - plotWidth + connectorPadding
		                        );
		                        overflow[1] = Math.max(sideOverflow, overflow[1]);
		                    }

		                    // Overflow top
		                    if (y - labelHeight / 2 < 0) {
		                        overflow[0] = Math.max(
		                            Math.round(-y + labelHeight / 2),
		                            overflow[0]
		                        );

		                    // Overflow left
		                    } else if (y + labelHeight / 2 > plotHeight) {
		                        overflow[2] = Math.max(
		                            Math.round(y + labelHeight / 2 - plotHeight),
		                            overflow[2]
		                        );
		                    }
		                    dataLabel.sideOverflow = sideOverflow;
		                }
		            } // for each point
		        }); // for each half

		        // Do not apply the final placement and draw the connectors until we
		        // have verified that labels are not spilling over.
		        if (
		            arrayMax(overflow) === 0 ||
		            this.verifyDataLabelOverflow(overflow)
		        ) {

		            // Place the labels in the final position
		            this.placeDataLabels();

		            // Draw the connectors
		            if (connectorWidth) {
		                each(this.points, function (point) {
		                    var isNew;

		                    connector = point.connector;
		                    dataLabel = point.dataLabel;

		                    if (
		                        dataLabel &&
		                        dataLabel._pos &&
		                        point.visible &&
		                        point.labelDistance > 0
		                    ) {
		                        visibility = dataLabel._attr.visibility;

		                        isNew = !connector;

		                        if (isNew) {
		                            point.connector = connector = chart.renderer.path()
		                                .addClass('highcharts-data-label-connector ' +
		                                    ' highcharts-color-' + point.colorIndex +
		                                    (
		                                        point.className ?
		                                            ' ' + point.className :
		                                            ''
		                                    )
		                                )
		                                .add(series.dataLabelsGroup);


		                            connector.attr({
		                                'stroke-width': connectorWidth,
		                                'stroke': (
		                                    options.connectorColor ||
		                                    point.color ||
		                                    '#666666'
		                                )
		                            });

		                        }
		                        connector[isNew ? 'attr' : 'animate']({
		                            d: series.connectorPath(point.labelPos)
		                        });
		                        connector.attr('visibility', visibility);

		                    } else if (connector) {
		                        point.connector = connector.destroy();
		                    }
		                });
		            }
		        }
		    };

		    /**
		     * Extendable method for getting the path of the connector between the data
		     * label and the pie slice.
		     *
		     * @private
		     * @function Highcharts.seriesTypes.pie#connectorPath
		     *
		     * @param {*} labelPos
		     *
		     * @return {Highcharts.PathObject}
		     */
		    seriesTypes.pie.prototype.connectorPath = function (labelPos) {
		        var x = labelPos.x,
		            y = labelPos.y;
		        return pick(this.options.dataLabels.softConnector, true) ? [
		            'M',
		            // end of the string at the label
		            x + (labelPos[6] === 'left' ? 5 : -5), y,
		            'C',
		            x, y, // first break, next to the label
		            2 * labelPos[2] - labelPos[4], 2 * labelPos[3] - labelPos[5],
		            labelPos[2], labelPos[3], // second break
		            'L',
		            labelPos[4], labelPos[5] // base
		        ] : [
		            'M',
		            // end of the string at the label
		            x + (labelPos[6] === 'left' ? 5 : -5), y,
		            'L',
		            labelPos[2], labelPos[3], // second break
		            'L',
		            labelPos[4], labelPos[5] // base
		        ];
		    };

		    /**
		     * Perform the final placement of the data labels after we have verified
		     * that they fall within the plot area.
		     *
		     * @private
		     * @function Highcharts.seriesTypes.pie#placeDataLabels
		     */
		    seriesTypes.pie.prototype.placeDataLabels = function () {
		        each(this.points, function (point) {
		            var dataLabel = point.dataLabel,
		                _pos;
		            if (dataLabel && point.visible) {
		                _pos = dataLabel._pos;
		                if (_pos) {

		                    // Shorten data labels with ellipsis if they still overflow
		                    // after the pie has reached minSize (#223).
		                    if (dataLabel.sideOverflow) {
		                        dataLabel._attr.width =
		                            dataLabel.getBBox().width - dataLabel.sideOverflow;

		                        dataLabel.css({
		                            width: dataLabel._attr.width + 'px',
		                            textOverflow: (
		                                (this.options.dataLabels.style || {})
		                                    .textOverflow ||
		                                'ellipsis'
		                            )
		                        });
		                        dataLabel.shortened = true;
		                    }

		                    dataLabel.attr(dataLabel._attr);
		                    dataLabel[dataLabel.moved ? 'animate' : 'attr'](_pos);
		                    dataLabel.moved = true;
		                } else if (dataLabel) {
		                    dataLabel.attr({ y: -9999 });
		                }
		            }
		        }, this);
		    };

		    seriesTypes.pie.prototype.alignDataLabel = noop;

		    /**
		     * Verify whether the data labels are allowed to draw, or we should run more
		     * translation and data label positioning to keep them inside the plot area.
		     * Returns true when data labels are ready to draw.
		     *
		     * @private
		     * @function Highcharts.seriesTypes.pie#verifyDataLabelOverflow
		     *
		     * @param {boolean} overflow
		     *
		     * @return {boolean}
		     */
		    seriesTypes.pie.prototype.verifyDataLabelOverflow = function (overflow) {

		        var center = this.center,
		            options = this.options,
		            centerOption = options.center,
		            minSize = options.minSize || 80,
		            newSize = minSize,
		            // If a size is set, return true and don't try to shrink the pie
		            // to fit the labels.
		            ret = options.size !== null;

		        if (!ret) {
		            // Handle horizontal size and center
		            if (centerOption[0] !== null) { // Fixed center
		                newSize = Math.max(center[2] -
		                    Math.max(overflow[1], overflow[3]), minSize);

		            } else { // Auto center
		                newSize = Math.max(
		                    // horizontal overflow
		                    center[2] - overflow[1] - overflow[3],
		                    minSize
		                );
		                // horizontal center
		                center[0] += (overflow[3] - overflow[1]) / 2;
		            }

		            // Handle vertical size and center
		            if (centerOption[1] !== null) { // Fixed center
		                newSize = Math.max(Math.min(newSize, center[2] -
		                    Math.max(overflow[0], overflow[2])), minSize);

		            } else { // Auto center
		                newSize = Math.max(
		                    Math.min(
		                        newSize,
		                        // vertical overflow
		                        center[2] - overflow[0] - overflow[2]
		                    ),
		                    minSize
		                );
		                // vertical center
		                center[1] += (overflow[0] - overflow[2]) / 2;
		            }

		            // If the size must be decreased, we need to run translate and
		            // drawDataLabels again
		            if (newSize < center[2]) {
		                center[2] = newSize;
		                center[3] = Math.min( // #3632
		                    relativeLength(options.innerSize || 0, newSize),
		                    newSize
		                );
		                this.translate(center);

		                if (this.drawDataLabels) {
		                    this.drawDataLabels();
		                }
		            // Else, return true to indicate that the pie and its labels is
		            // within the plot area
		            } else {
		                ret = true;
		            }
		        }
		        return ret;
		    };
		}

		if (seriesTypes.column) {

		    /**
		     * Override the basic data label alignment by adjusting for the position of
		     * the column.
		     *
		     * @private
		     * @function Highcharts.seriesTypes.column#alignDataLabel
		     *
		     * @param {Highcharts.Point} point
		     *
		     * @param {Highcharts.SVGElement} dataLabel
		     *
		     * @param {Highcharts.PlotSeriesDataLabelsOptions} options
		     *
		     * @param {Highcharts.BBoxObject} alignTo
		     *
		     * @param {boolean} isNew
		     */
		    seriesTypes.column.prototype.alignDataLabel = function (
		        point,
		        dataLabel,
		        options,
		        alignTo,
		        isNew
		    ) {
		        var inverted = this.chart.inverted,
		            series = point.series,
		            // data label box for alignment
		            dlBox = point.dlBox || point.shapeArgs,
		            below = pick(
		                point.below, // range series
		                point.plotY > pick(this.translatedThreshold, series.yAxis.len)
		            ),
		            // draw it inside the box?
		            inside = pick(options.inside, !!this.options.stacking),
		            overshoot;

		        // Align to the column itself, or the top of it
		        if (dlBox) { // Area range uses this method but not alignTo
		            alignTo = merge(dlBox);

		            if (alignTo.y < 0) {
		                alignTo.height += alignTo.y;
		                alignTo.y = 0;
		            }
		            overshoot = alignTo.y + alignTo.height - series.yAxis.len;
		            if (overshoot > 0) {
		                alignTo.height -= overshoot;
		            }

		            if (inverted) {
		                alignTo = {
		                    x: series.yAxis.len - alignTo.y - alignTo.height,
		                    y: series.xAxis.len - alignTo.x - alignTo.width,
		                    width: alignTo.height,
		                    height: alignTo.width
		                };
		            }

		            // Compute the alignment box
		            if (!inside) {
		                if (inverted) {
		                    alignTo.x += below ? 0 : alignTo.width;
		                    alignTo.width = 0;
		                } else {
		                    alignTo.y += below ? alignTo.height : 0;
		                    alignTo.height = 0;
		                }
		            }
		        }


		        // When alignment is undefined (typically columns and bars), display the
		        // individual point below or above the point depending on the threshold
		        options.align = pick(
		            options.align,
		            !inverted || inside ? 'center' : below ? 'right' : 'left'
		        );
		        options.verticalAlign = pick(
		            options.verticalAlign,
		            inverted || inside ? 'middle' : below ? 'top' : 'bottom'
		        );

		        // Call the parent method
		        Series.prototype.alignDataLabel.call(
		            this,
		            point,
		            dataLabel,
		            options,
		            alignTo,
		            isNew
		        );

		        // If label was justified and we have contrast, set it:
		        if (point.isLabelJustified && point.contrastColor) {
		            dataLabel.css({
		                color: point.contrastColor
		            });
		        }
		    };
		}

	}(Highcharts));
	(function (H) {
		/**
		 * (c) 2009-2018 Torstein Honsi
		 *
		 * License: www.highcharts.com/license
		 */



		/*
		 * Highcharts module to hide overlapping data labels. This module is included in
		 * Highcharts.
		 */

		var Chart = H.Chart,
		    each = H.each,
		    isArray = H.isArray,
		    objectEach = H.objectEach,
		    pick = H.pick,
		    addEvent = H.addEvent;

		// Collect potensial overlapping data labels. Stack labels probably don't need
		// to be considered because they are usually accompanied by data labels that lie
		// inside the columns.
		addEvent(Chart, 'render', function collectAndHide() {
		    var labels = [];
		    // Consider external label collectors
		    each(this.labelCollectors || [], function (collector) {
		        labels = labels.concat(collector());
		    });

		    each(this.yAxis || [], function (yAxis) {
		        if (
		            yAxis.options.stackLabels &&
		            !yAxis.options.stackLabels.allowOverlap
		        ) {
		            objectEach(yAxis.stacks, function (stack) {
		                objectEach(stack, function (stackItem) {
		                    labels.push(stackItem.label);
		                });
		            });
		        }
		    });

		    each(this.series || [], function (series) {
		        var dlOptions = series.options.dataLabels;

		        if (
		            series.visible &&
		            !(dlOptions.enabled === false && !series._hasPointLabels)
		        ) { // #3866
		            each(series.points, function (point) {
		                if (point.visible) {
		                    var dataLabels = (
		                        isArray(point.dataLabels) ?
		                        point.dataLabels :
		                        (point.dataLabel ? [point.dataLabel] : [])
		                    );
		                    each(dataLabels, function (label) {
		                        var options = label.options;
		                        label.labelrank = pick(
		                            options.labelrank,
		                            point.labelrank,
		                            point.shapeArgs && point.shapeArgs.height
		                        ); // #4118

		                        if (!options.allowOverlap) {
		                            labels.push(label);
		                        }
		                    });
		                }
		            });
		        }
		    });

		    this.hideOverlappingLabels(labels);
		});

		/**
		 * Hide overlapping labels. Labels are moved and faded in and out on zoom to
		 * provide a smooth visual imression.
		 *
		 * @private
		 * @function Highcharts.Chart#hideOverlappingLabels
		 *
		 * @param {Array<Highcharts.SVGElement>} labels
		 */
		Chart.prototype.hideOverlappingLabels = function (labels) {

		    var len = labels.length,
		        ren = this.renderer,
		        label,
		        i,
		        j,
		        label1,
		        label2,
		        isIntersecting,
		        box1,
		        box2,
		        intersectRect = function (x1, y1, w1, h1, x2, y2, w2, h2) {
		            return !(
		                x2 > x1 + w1 ||
		                x2 + w2 < x1 ||
		                y2 > y1 + h1 ||
		                y2 + h2 < y1
		            );
		        },

		        /**
		         * Get the box with its position inside the chart, as opposed to getBBox
		         * that only reports the position relative to the parent.
		         */
		        getAbsoluteBox = function (label) {
		            var pos,
		                parent,
		                bBox,
		                // Substract the padding if no background or border (#4333)
		                padding = label.box ? 0 : (label.padding || 0),
		                lineHeightCorrection = 0;

		            if (
		                label &&
		                (!label.alignAttr || label.placed)
		            ) {
		                pos = label.alignAttr || {
		                    x: label.attr('x'),
		                    y: label.attr('y')
		                };
		                parent = label.parentGroup;

		                // Get width and height if pure text nodes (stack labels)
		                if (!label.width) {
		                    bBox = label.getBBox();
		                    label.width = bBox.width;
		                    label.height = bBox.height;

		                    // Labels positions are computed from top left corner, so
		                    // we need to substract the text height from text nodes too.
		                    lineHeightCorrection = ren
		                        .fontMetrics(null, label.element).h;
		                }
		                return {
		                    x: pos.x + (parent.translateX || 0) + padding,
		                    y: pos.y + (parent.translateY || 0) + padding -
		                        lineHeightCorrection,
		                    width: label.width - 2 * padding,
		                    height: label.height - 2 * padding
		                };

		            }
		        };

		    for (i = 0; i < len; i++) {
		        label = labels[i];
		        if (label) {

		            // Mark with initial opacity
		            label.oldOpacity = label.opacity;
		            label.newOpacity = 1;

		            label.absoluteBox = getAbsoluteBox(label);

		        }
		    }

		    // Prevent a situation in a gradually rising slope, that each label will
		    // hide the previous one because the previous one always has lower rank.
		    labels.sort(function (a, b) {
		        return (b.labelrank || 0) - (a.labelrank || 0);
		    });

		    // Detect overlapping labels
		    for (i = 0; i < len; i++) {
		        label1 = labels[i];
		        box1 = label1 && label1.absoluteBox;

		        for (j = i + 1; j < len; ++j) {
		            label2 = labels[j];
		            box2 = label2 && label2.absoluteBox;

		            if (
		                box1 &&
		                box2 &&
		                label1 !== label2 && // #6465, polar chart with connectEnds
		                label1.newOpacity !== 0 &&
		                label2.newOpacity !== 0
		            ) {
		                isIntersecting = intersectRect(
		                    box1.x,
		                    box1.y,
		                    box1.width,
		                    box1.height,
		                    box2.x,
		                    box2.y,
		                    box2.width,
		                    box2.height
		                );


		                if (isIntersecting) {
		                    (label1.labelrank < label2.labelrank ? label1 : label2)
		                        .newOpacity = 0;
		                }
		            }
		        }
		    }

		    // Hide or show
		    each(labels, function (label) {
		        var complete,
		            newOpacity;

		        if (label) {
		            newOpacity = label.newOpacity;

		            if (label.oldOpacity !== newOpacity) {

		                // Make sure the label is completely hidden to avoid catching
		                // clicks (#4362)
		                if (label.alignAttr && label.placed) { // data labels
		                    if (newOpacity) {
		                        label.show(true);
		                    } else {
		                        complete = function () {
		                            label.hide();
		                        };
		                    }

		                    // Animate or set the opacity
		                    label.alignAttr.opacity = newOpacity;
		                    label[label.isOld ? 'animate' : 'attr'](
		                        label.alignAttr,
		                        null,
		                        complete
		                    );
		                } else { // other labels, tick labels
		                    label.attr({
		                        opacity: newOpacity
		                    });
		                }

		            }
		            label.isOld = true;
		        }
		    });
		};

	}(Highcharts));
	(function (H) {
		/**
		 * (c) 2010-2018 Torstein Honsi
		 *
		 * License: www.highcharts.com/license
		 */



		var addEvent = H.addEvent,
		    Chart = H.Chart,
		    createElement = H.createElement,
		    css = H.css,
		    defaultOptions = H.defaultOptions,
		    defaultPlotOptions = H.defaultPlotOptions,
		    each = H.each,
		    extend = H.extend,
		    fireEvent = H.fireEvent,
		    hasTouch = H.hasTouch,
		    inArray = H.inArray,
		    isObject = H.isObject,
		    Legend = H.Legend,
		    merge = H.merge,
		    pick = H.pick,
		    Point = H.Point,
		    Series = H.Series,
		    seriesTypes = H.seriesTypes,
		    svg = H.svg,
		    TrackerMixin;

		/**
		 * TrackerMixin for points and graphs.
		 *
		 * @private
		 * @mixin Highcharts.TrackerMixin
		 */
		TrackerMixin = H.TrackerMixin = {

		    /**
		     * Draw the tracker for a point.
		     *
		     * @private
		     * @function Highcharts.TrackerMixin.drawTrackerPoint
		     *
		     * @fires Highcharts.Series#event:afterDrawTracker
		     */
		    drawTrackerPoint: function () {
		        var series = this,
		            chart = series.chart,
		            pointer = chart.pointer,
		            onMouseOver = function (e) {
		                var point = pointer.getPointFromEvent(e);
		                // undefined on graph in scatterchart
		                if (point !== undefined) {
		                    pointer.isDirectTouch = true;
		                    point.onMouseOver(e);
		                }
		            };

		        // Add reference to the point
		        each(series.points, function (point) {
		            if (point.graphic) {
		                point.graphic.element.point = point;
		            }
		            if (point.dataLabel) {
		                if (point.dataLabel.div) {
		                    point.dataLabel.div.point = point;
		                } else {
		                    point.dataLabel.element.point = point;
		                }
		            }
		        });

		        // Add the event listeners, we need to do this only once
		        if (!series._hasTracking) {
		            each(series.trackerGroups, function (key) {
		                if (series[key]) { // we don't always have dataLabelsGroup
		                    series[key]
		                        .addClass('highcharts-tracker')
		                        .on('mouseover', onMouseOver)
		                        .on('mouseout', function (e) {
		                            pointer.onTrackerMouseOut(e);
		                        });
		                    if (hasTouch) {
		                        series[key].on('touchstart', onMouseOver);
		                    }


		                    if (series.options.cursor) {
		                        series[key]
		                            .css(css)
		                            .css({ cursor: series.options.cursor });
		                    }

		                }
		            });
		            series._hasTracking = true;
		        }

		        fireEvent(this, 'afterDrawTracker');
		    },

		    /**
		     * Draw the tracker object that sits above all data labels and markers to
		     * track mouse events on the graph or points. For the line type charts
		     * the tracker uses the same graphPath, but with a greater stroke width
		     * for better control.
		     *
		     * @private
		     * @function Highcharts.TrackerMixin.drawTrackerGraph
		     *
		     * @fires Highcharts.Series#event:afterDrawTracker
		     */
		    drawTrackerGraph: function () {
		        var series = this,
		            options = series.options,
		            trackByArea = options.trackByArea,
		            trackerPath = [].concat(
		                trackByArea ? series.areaPath : series.graphPath
		            ),
		            trackerPathLength = trackerPath.length,
		            chart = series.chart,
		            pointer = chart.pointer,
		            renderer = chart.renderer,
		            snap = chart.options.tooltip.snap,
		            tracker = series.tracker,
		            i,
		            onMouseOver = function () {
		                if (chart.hoverSeries !== series) {
		                    series.onMouseOver();
		                }
		            },
		            /*
		             * Empirical lowest possible opacities for TRACKER_FILL for an
		             * element to stay invisible but clickable
		             * IE6: 0.002
		             * IE7: 0.002
		             * IE8: 0.002
		             * IE9: 0.00000000001 (unlimited)
		             * IE10: 0.0001 (exporting only)
		             * FF: 0.00000000001 (unlimited)
		             * Chrome: 0.000001
		             * Safari: 0.000001
		             * Opera: 0.00000000001 (unlimited)
		             */
		            TRACKER_FILL = 'rgba(192,192,192,' + (svg ? 0.0001 : 0.002) + ')';

		        // Extend end points. A better way would be to use round linecaps,
		        // but those are not clickable in VML.
		        if (trackerPathLength && !trackByArea) {
		            i = trackerPathLength + 1;
		            while (i--) {
		                if (trackerPath[i] === 'M') { // extend left side
		                    trackerPath.splice(
		                        i + 1, 0,
		                        trackerPath[i + 1] - snap,
		                        trackerPath[i + 2],
		                        'L'
		                    );
		                }
		                if (
		                    (i && trackerPath[i] === 'M') ||
		                    i === trackerPathLength
		                ) { // extend right side
		                    trackerPath.splice(
		                        i,
		                        0,
		                        'L',
		                        trackerPath[i - 2] + snap,
		                        trackerPath[i - 1]
		                    );
		                }
		            }
		        }

		        // draw the tracker
		        if (tracker) {
		            tracker.attr({ d: trackerPath });
		        } else if (series.graph) { // create

		            series.tracker = renderer.path(trackerPath)
		            .attr({

		                'stroke-linejoin': 'round', // #1225
		                stroke: TRACKER_FILL,
		                fill: trackByArea ? TRACKER_FILL : 'none',
		                'stroke-width': series.graph.strokeWidth() +
		                    (trackByArea ? 0 : 2 * snap),

		                visibility: series.visible ? 'visible' : 'hidden',
		                zIndex: 2
		            })
		            .addClass(
		                trackByArea ?
		                    'highcharts-tracker-area' :
		                    'highcharts-tracker-line'
		            )
		            .add(series.group);

		            // The tracker is added to the series group, which is clipped, but
		            // is covered by the marker group. So the marker group also needs to
		            // capture events.
		            each([series.tracker, series.markerGroup], function (tracker) {
		                tracker.addClass('highcharts-tracker')
		                    .on('mouseover', onMouseOver)
		                    .on('mouseout', function (e) {
		                        pointer.onTrackerMouseOut(e);
		                    });


		                if (options.cursor) {
		                    tracker.css({ cursor: options.cursor });
		                }


		                if (hasTouch) {
		                    tracker.on('touchstart', onMouseOver);
		                }
		            });
		        }
		        fireEvent(this, 'afterDrawTracker');
		    }
		};
		/* End TrackerMixin */


		/*
		 * Add tracking event listener to the series group, so the point graphics
		 * themselves act as trackers
		 */

		if (seriesTypes.column) {
		    /**
		     * @private
		     * @borrows Highcharts.TrackerMixin.drawTrackerPoint as Highcharts.seriesTypes.column#drawTracker
		     */
		    seriesTypes.column.prototype.drawTracker = TrackerMixin.drawTrackerPoint;
		}

		if (seriesTypes.pie) {
		    /**
		     * @private
		     * @borrows Highcharts.TrackerMixin.drawTrackerPoint as Highcharts.seriesTypes.pie#drawTracker
		     */
		    seriesTypes.pie.prototype.drawTracker = TrackerMixin.drawTrackerPoint;
		}

		if (seriesTypes.scatter) {
		    /**
		     * @private
		     * @borrows Highcharts.TrackerMixin.drawTrackerPoint as Highcharts.seriesTypes.scatter#drawTracker
		     */
		    seriesTypes.scatter.prototype.drawTracker = TrackerMixin.drawTrackerPoint;
		}



		// Add pointer cursor to legend itemstyle in defaultOptions
		/**
		 * @default   'pointer'
		 * @apioption legend.itemStyle.cursor
		 */
		defaultOptions.legend.itemStyle.cursor = 'pointer';



		// Extend Legend for item events.
		extend(Legend.prototype, {

		    /**
		     * @private
		     * @function Highcharts.Legend#setItemEvents
		     *
		     * @param {Highcharts.Point|Highcharts.Series} item
		     *
		     * @param {Highcharts.SVGElement} legendItem
		     *
		     * @param {boolean} [useHTML=false]
		     *
		     * @fires Highcharts.Point#event:legendItemClick
		     * @fires Highcharts.Series#event:legendItemClick
		     */
		    setItemEvents: function (item, legendItem, useHTML) {
		        var legend = this,
		            boxWrapper = legend.chart.renderer.boxWrapper,
		            activeClass = 'highcharts-legend-' +
		                (item instanceof Point ? 'point' : 'series') + '-active';

		        // Set the events on the item group, or in case of useHTML, the item
		        // itself (#1249)
		        (useHTML ? legendItem : item.legendGroup).on('mouseover', function () {
		            item.setState('hover');

		            // A CSS class to dim or hide other than the hovered series
		            boxWrapper.addClass(activeClass);


		            legendItem.css(legend.options.itemHoverStyle);

		        })
		        .on('mouseout', function () {

		            legendItem.css(
		                merge(item.visible ? legend.itemStyle : legend.itemHiddenStyle)
		            );


		            // A CSS class to dim or hide other than the hovered series
		            boxWrapper.removeClass(activeClass);

		            item.setState();
		        })
		        .on('click', function (event) {
		            var strLegendItemClick = 'legendItemClick',
		                fnLegendItemClick = function () {
		                    if (item.setVisible) {
		                        item.setVisible();
		                    }
		                };

		            // A CSS class to dim or hide other than the hovered series. Event
		            // handling in iOS causes the activeClass to be added prior to click
		            // in some cases (#7418).
		            boxWrapper.removeClass(activeClass);

		            // Pass over the click/touch event. #4.
		            event = {
		                browserEvent: event
		            };

		            // click the name or symbol
		            if (item.firePointEvent) { // point
		                item.firePointEvent(
		                    strLegendItemClick,
		                    event,
		                    fnLegendItemClick
		                );
		            } else {
		                fireEvent(item, strLegendItemClick, event, fnLegendItemClick);
		            }
		        });
		    },

		    /**
		     * @private
		     * @function Highcharts.Legend#createCheckboxForItem
		     *
		     * @param {Highcharts.Point|Highcharts.Series} item
		     *
		     * @fires Highcharts.Series#event:checkboxClick
		     */
		    createCheckboxForItem: function (item) {
		        var legend = this;

		        item.checkbox = createElement('input', {
		            type: 'checkbox',
		            className: 'highcharts-legend-checkbox',
		            checked: item.selected,
		            defaultChecked: item.selected // required by IE7
		        }, legend.options.itemCheckboxStyle, legend.chart.container);

		        addEvent(item.checkbox, 'click', function (event) {
		            var target = event.target;
		            fireEvent(
		                item.series || item,
		                'checkboxClick',
		                { // #3712
		                    checked: target.checked,
		                    item: item
		                },
		                function () {
		                    item.select();
		                }
		            );
		        });
		    }
		});

		// Extend the Chart object with interaction.
		extend(Chart.prototype, /** @lends Chart.prototype */ {

		    /**
		     * Display the zoom button.
		     *
		     * @private
		     * @function Highcharts.Chart#showResetZoom
		     *
		     * @fires Highcharts.Chart#event:beforeShowResetZoom
		     */
		    showResetZoom: function () {
		        var chart = this,
		            lang = defaultOptions.lang,
		            btnOptions = chart.options.chart.resetZoomButton,
		            theme = btnOptions.theme,
		            states = theme.states,
		            alignTo = btnOptions.relativeTo === 'chart' ? null : 'plotBox';

		        function zoomOut() {
		            chart.zoomOut();
		        }

		        fireEvent(this, 'beforeShowResetZoom', null, function () {
		            chart.resetZoomButton = chart.renderer.button(
		                    lang.resetZoom,
		                    null,
		                    null,
		                    zoomOut,
		                    theme,
		                    states && states.hover
		                )
		                .attr({
		                    align: btnOptions.position.align,
		                    title: lang.resetZoomTitle
		                })
		                .addClass('highcharts-reset-zoom')
		                .add()
		                .align(btnOptions.position, false, alignTo);
		        });

		    },

		    /**
		     * Zoom the chart out after a user has zoomed in. See also
		     * [Axis.setExtremes](/class-reference/Highcharts.Axis#setExtremes).
		     *
		     * @function Highcharts.Chart#zoomOut
		     *
		     * @fires Highcharts.Chart#event:selection
		     */
		    zoomOut: function () {
		        fireEvent(this, 'selection', { resetSelection: true }, this.zoom);
		    },

		    /**
		     * Zoom into a given portion of the chart given by axis coordinates.
		     *
		     * @private
		     * @function Highcharts.Chart#zoom
		     *
		     * @param {Highcharts.SelectEventObject} event
		     */
		    zoom: function (event) {
		        var chart = this,
		            hasZoomed,
		            pointer = chart.pointer,
		            displayButton = false,
		            resetZoomButton;

		        // If zoom is called with no arguments, reset the axes
		        if (!event || event.resetSelection) {
		            each(chart.axes, function (axis) {
		                hasZoomed = axis.zoom();
		            });
		            pointer.initiated = false; // #6804

		        } else { // else, zoom in on all axes
		            each(event.xAxis.concat(event.yAxis), function (axisData) {
		                var axis = axisData.axis,
		                    isXAxis = axis.isXAxis;

		                // don't zoom more than minRange
		                if (pointer[isXAxis ? 'zoomX' : 'zoomY']) {
		                    hasZoomed = axis.zoom(axisData.min, axisData.max);
		                    if (axis.displayBtn) {
		                        displayButton = true;
		                    }
		                }
		            });
		        }

		        // Show or hide the Reset zoom button
		        resetZoomButton = chart.resetZoomButton;
		        if (displayButton && !resetZoomButton) {
		            chart.showResetZoom();
		        } else if (!displayButton && isObject(resetZoomButton)) {
		            chart.resetZoomButton = resetZoomButton.destroy();
		        }


		        // Redraw
		        if (hasZoomed) {
		            chart.redraw(
		                pick(
		                    chart.options.chart.animation,
		                    event && event.animation,
		                    chart.pointCount < 100
		                )
		            );
		        }
		    },

		    /**
		     * Pan the chart by dragging the mouse across the pane. This function is
		     * called on mouse move, and the distance to pan is computed from chartX
		     * compared to the first chartX position in the dragging operation.
		     *
		     * @private
		     * @function Highcharts.Chart#pan
		     *
		     * @param {Highcharts.PointerEventObject} e
		     *
		     * @param {string} panning
		     */
		    pan: function (e, panning) {

		        var chart = this,
		            hoverPoints = chart.hoverPoints,
		            doRedraw;

		        // remove active points for shared tooltip
		        if (hoverPoints) {
		            each(hoverPoints, function (point) {
		                point.setState();
		            });
		        }

		        // xy is used in maps
		        each(panning === 'xy' ? [1, 0] : [1], function (isX) {
		            var axis = chart[isX ? 'xAxis' : 'yAxis'][0],
		                horiz = axis.horiz,
		                mousePos = e[horiz ? 'chartX' : 'chartY'],
		                mouseDown = horiz ? 'mouseDownX' : 'mouseDownY',
		                startPos = chart[mouseDown],
		                halfPointRange = (axis.pointRange || 0) / 2,
		                pointRangeDirection =
		                    (axis.reversed && !chart.inverted) ||
		                    (!axis.reversed && chart.inverted) ?
		                        -1 :
		                        1,
		                extremes = axis.getExtremes(),
		                panMin = axis.toValue(startPos - mousePos, true) +
		                    halfPointRange * pointRangeDirection,
		                panMax = axis.toValue(startPos + axis.len - mousePos, true) -
		                    halfPointRange * pointRangeDirection,
		                flipped = panMax < panMin,
		                newMin = flipped ? panMax : panMin,
		                newMax = flipped ? panMin : panMax,
		                paddedMin = Math.min(
		                    extremes.dataMin,
		                    halfPointRange ?
		                        extremes.min :
		                        axis.toValue(
		                            axis.toPixels(extremes.min) - axis.minPixelPadding
		                        )
		                ),
		                paddedMax = Math.max(
		                    extremes.dataMax,
		                    halfPointRange ?
		                        extremes.max :
		                        axis.toValue(
		                            axis.toPixels(extremes.max) + axis.minPixelPadding
		                        )
		                ),
		                spill;

		            // If the new range spills over, either to the min or max, adjust
		            // the new range.
		            spill = paddedMin - newMin;
		            if (spill > 0) {
		                newMax += spill;
		                newMin = paddedMin;
		            }
		            spill = newMax - paddedMax;
		            if (spill > 0) {
		                newMax = paddedMax;
		                newMin -= spill;
		            }

		            // Set new extremes if they are actually new
		            if (
		                axis.series.length &&
		                newMin !== extremes.min &&
		                newMax !== extremes.max
		            ) {
		                axis.setExtremes(
		                    newMin,
		                    newMax,
		                    false,
		                    false,
		                    { trigger: 'pan' }
		                );
		                doRedraw = true;
		            }

		            chart[mouseDown] = mousePos; // set new reference for next run
		        });

		        if (doRedraw) {
		            chart.redraw(false);
		        }
		        css(chart.container, { cursor: 'move' });
		    }
		});

		// Extend the Point object with interaction
		extend(Point.prototype, /** @lends Highcharts.Point.prototype */ {

		    /**
		     * Toggle the selection status of a point.
		     *
		     * @see Highcharts.Chart#getSelectedPoints
		     *
		     * @sample highcharts/members/point-select/
		     *         Select a point from a button
		     * @sample highcharts/chart/events-selection-points/
		     *         Select a range of points through a drag selection
		     * @sample maps/series/data-id/
		     *         Select a point in Highmaps
		     *
		     * @function Highcharts.Point#select
		     *
		     * @param {boolean} [selected]
		     *        When `true`, the point is selected. When `false`, the point is
		     *        unselected. When `null` or `undefined`, the selection state is
		     *        toggled.
		     *
		     * @param {boolean} [accumulate=false]
		     *        When `true`, the selection is added to other selected points.
		     *        When `false`, other selected points are deselected. Internally in
		     *        Highcharts, when
		     *        {@link http://api.highcharts.com/highcharts/plotOptions.series.allowPointSelect|allowPointSelect}
		     *        is `true`, selected points are accumulated on Control, Shift or
		     *        Cmd clicking the point.
		     *
		     * @fires Highcharts.Point#event:select
		     * @fires Highcharts.Point#event:unselect
		     */
		    select: function (selected, accumulate) {
		        var point = this,
		            series = point.series,
		            chart = series.chart;

		        selected = pick(selected, !point.selected);

		        // fire the event with the default handler
		        point.firePointEvent(
		            selected ? 'select' : 'unselect',
		            { accumulate: accumulate },
		            function () {

		                /**
		                 * Whether the point is selected or not.
		                 *
		                 * @see Point#select
		                 * @see Chart#getSelectedPoints
		                 *
		                 * @name Highcharts.Point#selected
		                 * @type {boolean}
		                 */
		                point.selected = point.options.selected = selected;
		                series.options.data[inArray(point, series.data)] =
		                    point.options;

		                point.setState(selected && 'select');

		                // unselect all other points unless Ctrl or Cmd + click
		                if (!accumulate) {
		                    each(chart.getSelectedPoints(), function (loopPoint) {
		                        if (loopPoint.selected && loopPoint !== point) {
		                            loopPoint.selected = loopPoint.options.selected =
		                                false;
		                            series.options.data[
		                                inArray(loopPoint, series.data)
		                            ] = loopPoint.options;
		                            loopPoint.setState('');
		                            loopPoint.firePointEvent('unselect');
		                        }
		                    });
		                }
		            }
		        );
		    },

		    /**
		     * Runs on mouse over the point. Called internally from mouse and touch
		     * events.
		     *
		     * @function Highcharts.Point#onMouseOver
		     *
		     * @param {Highcharts.PointerEventObject} e
		     *        The event arguments.
		     */
		    onMouseOver: function (e) {
		        var point = this,
		            series = point.series,
		            chart = series.chart,
		            pointer = chart.pointer;
		        e = e ?
		            pointer.normalize(e) :
		            // In cases where onMouseOver is called directly without an event
		            pointer.getChartCoordinatesFromPoint(point, chart.inverted);
		        pointer.runPointActions(e, point);
		    },

		    /**
		     * Runs on mouse out from the point. Called internally from mouse and touch
		     * events.
		     *
		     * @function Highcharts.Point#onMouseOut
		     *
		     * @fires Highcharts.Point#event:mouseOut
		     */
		    onMouseOut: function () {
		        var point = this,
		            chart = point.series.chart;
		        point.firePointEvent('mouseOut');
		        each(chart.hoverPoints || [], function (p) {
		            p.setState();
		        });
		        chart.hoverPoints = chart.hoverPoint = null;
		    },

		    /**
		     * Import events from the series' and point's options. Only do it on
		     * demand, to save processing time on hovering.
		     *
		     * @private
		     * @function Highcharts.Point#importEvents
		     */
		    importEvents: function () {
		        if (!this.hasImportedEvents) {
		            var point = this,
		                options = merge(point.series.options.point, point.options),
		                events = options.events;

		            point.events = events;

		            H.objectEach(events, function (event, eventType) {
		                addEvent(point, eventType, event);
		            });
		            this.hasImportedEvents = true;

		        }
		    },

		    /**
		     * Set the point's state.
		     *
		     * @function Highcharts.Point#setState
		     *
		     * @param {string} [state]
		     *        The new state, can be one of `''` (an empty string), `hover` or
		     *        `select`.
		     *
		     * @param {boolean} [move]
		     *        State for animation.
		     *
		     * @fires Highcharts.Point#event:afterSetState
		     */
		    setState: function (state, move) {
		        var point = this,
		            plotX = Math.floor(point.plotX), // #4586
		            plotY = point.plotY,
		            series = point.series,
		            stateOptions = series.options.states[state || 'normal'] || {},
		            markerOptions = defaultPlotOptions[series.type].marker &&
		                series.options.marker,
		            normalDisabled = markerOptions && markerOptions.enabled === false,
		            markerStateOptions = (
		                markerOptions &&
		                markerOptions.states &&
		                markerOptions.states[state || 'normal']
		            ) || {},
		            stateDisabled = markerStateOptions.enabled === false,
		            stateMarkerGraphic = series.stateMarkerGraphic,
		            pointMarker = point.marker || {},
		            chart = series.chart,
		            halo = series.halo,
		            haloOptions,
		            markerAttribs,
		            hasMarkers = markerOptions && series.markerAttribs,
		            newSymbol;

		        state = state || ''; // empty string

		        if (
		            // already has this state
		            (state === point.state && !move) ||

		            // selected points don't respond to hover
		            (point.selected && state !== 'select') ||

		            // series' state options is disabled
		            (stateOptions.enabled === false) ||

		            // general point marker's state options is disabled
		            (state && (
		                stateDisabled ||
		                (normalDisabled && markerStateOptions.enabled === false)
		            )) ||

		            // individual point marker's state options is disabled
		            (
		                state &&
		                pointMarker.states &&
		                pointMarker.states[state] &&
		                pointMarker.states[state].enabled === false
		            ) // #1610

		        ) {
		            return;
		        }

		        if (hasMarkers) {
		            markerAttribs = series.markerAttribs(point, state);
		        }

		        // Apply hover styles to the existing point
		        if (point.graphic) {

		            if (point.state) {
		                point.graphic.removeClass('highcharts-point-' + point.state);
		            }
		            if (state) {
		                point.graphic.addClass('highcharts-point-' + state);
		            }


		            point.graphic.animate(
		                series.pointAttribs(point, state),
		                pick(
		                    chart.options.chart.animation,
		                    stateOptions.animation
		                )
		            );


		            if (markerAttribs) {
		                point.graphic.animate(
		                    markerAttribs,
		                    pick(
		                        chart.options.chart.animation, // Turn off globally
		                        markerStateOptions.animation,
		                        markerOptions.animation
		                    )
		                );
		            }

		            // Zooming in from a range with no markers to a range with markers
		            if (stateMarkerGraphic) {
		                stateMarkerGraphic.hide();
		            }
		        } else {
		            // if a graphic is not applied to each point in the normal state,
		            // create a shared graphic for the hover state
		            if (state && markerStateOptions) {
		                newSymbol = pointMarker.symbol || series.symbol;

		                // If the point has another symbol than the previous one, throw
		                // away the state marker graphic and force a new one (#1459)
		                if (
		                    stateMarkerGraphic &&
		                    stateMarkerGraphic.currentSymbol !== newSymbol
		                ) {
		                    stateMarkerGraphic = stateMarkerGraphic.destroy();
		                }

		                // Add a new state marker graphic
		                if (!stateMarkerGraphic) {
		                    if (newSymbol) {
		                        series.stateMarkerGraphic = stateMarkerGraphic =
		                            chart.renderer.symbol(
		                                newSymbol,
		                                markerAttribs.x,
		                                markerAttribs.y,
		                                markerAttribs.width,
		                                markerAttribs.height
		                            )
		                            .add(series.markerGroup);
		                        stateMarkerGraphic.currentSymbol = newSymbol;
		                    }

		                // Move the existing graphic
		                } else {
		                    stateMarkerGraphic[move ? 'animate' : 'attr']({ // #1054
		                        x: markerAttribs.x,
		                        y: markerAttribs.y
		                    });
		                }

		                if (stateMarkerGraphic) {
		                    stateMarkerGraphic.attr(series.pointAttribs(point, state));
		                }

		            }

		            if (stateMarkerGraphic) {
		                stateMarkerGraphic[
		                    state && chart.isInsidePlot(plotX, plotY, chart.inverted) ?
		                        'show' :
		                        'hide'
		                ](); // #2450
		                stateMarkerGraphic.element.point = point; // #4310
		            }
		        }

		        // Show me your halo
		        haloOptions = stateOptions.halo;
		        if (haloOptions && haloOptions.size) {
		            if (!halo) {
		                series.halo = halo = chart.renderer.path()
		                    // #5818, #5903, #6705
		                    .add((point.graphic || stateMarkerGraphic).parentGroup);
		            }
		            halo.show()[move ? 'animate' : 'attr']({
		                d: point.haloPath(haloOptions.size)
		            });
		            halo.attr({
		                'class': 'highcharts-halo highcharts-color-' +
		                    pick(point.colorIndex, series.colorIndex) +
		                    (point.className ? ' ' + point.className : ''),
		                'zIndex': -1 // #4929, #8276
		            });
		            halo.point = point; // #6055


		            halo.attr(extend({
		                'fill': point.color || series.color,
		                'fill-opacity': haloOptions.opacity
		            }, haloOptions.attributes));


		        } else if (halo && halo.point && halo.point.haloPath) {
		            // Animate back to 0 on the current halo point (#6055)
		            halo.animate(
		                { d: halo.point.haloPath(0) },
		                null,
		                // Hide after unhovering. The `complete` callback runs in the
		                // halo's context (#7681).
		                halo.hide
		            );
		        }

		        point.state = state;

		        fireEvent(point, 'afterSetState');
		    },

		    /**
		     * Get the path definition for the halo, which is usually a shadow-like
		     * circle around the currently hovered point.
		     *
		     * @function Highcharts.Point#haloPath
		     *
		     * @param {number} size
		     *        The radius of the circular halo.
		     *
		     * @return {Highcharts.SVGPathArray}
		     *         The path definition.
		     */
		    haloPath: function (size) {
		        var series = this.series,
		            chart = series.chart;

		        return chart.renderer.symbols.circle(
		            Math.floor(this.plotX) - size,
		            this.plotY - size,
		            size * 2,
		            size * 2
		        );
		    }
		});

		// Extend the Series object with interaction
		extend(Series.prototype, /** @lends Highcharts.Series.prototype */ {

		    /**
		     * Runs on mouse over the series graphical items.
		     *
		     * @function Highcharts.Series#onMouseOver
		     *
		     * @fires Highcharts.Series#event:mouseOver
		     */
		    onMouseOver: function () {
		        var series = this,
		            chart = series.chart,
		            hoverSeries = chart.hoverSeries;

		        // set normal state to previous series
		        if (hoverSeries && hoverSeries !== series) {
		            hoverSeries.onMouseOut();
		        }

		        // trigger the event, but to save processing time,
		        // only if defined
		        if (series.options.events.mouseOver) {
		            fireEvent(series, 'mouseOver');
		        }

		        // hover this
		        series.setState('hover');
		        chart.hoverSeries = series;
		    },

		    /**
		     * Runs on mouse out of the series graphical items.
		     *
		     * @function Highcharts.Series#onMouseOut
		     *
		     * @fires Highcharts.Series#event:mouseOut
		     */
		    onMouseOut: function () {
		        // trigger the event only if listeners exist
		        var series = this,
		            options = series.options,
		            chart = series.chart,
		            tooltip = chart.tooltip,
		            hoverPoint = chart.hoverPoint;

		        // #182, set to null before the mouseOut event fires
		        chart.hoverSeries = null;

		        // trigger mouse out on the point, which must be in this series
		        if (hoverPoint) {
		            hoverPoint.onMouseOut();
		        }

		        // fire the mouse out event
		        if (series && options.events.mouseOut) {
		            fireEvent(series, 'mouseOut');
		        }


		        // hide the tooltip
		        if (
		            tooltip &&
		            !series.stickyTracking &&
		            (!tooltip.shared || series.noSharedTooltip)
		        ) {
		            tooltip.hide();
		        }

		        // set normal state
		        series.setState();
		    },

		    /**
		     * Set the state of the series. Called internally on mouse interaction
		     * operations, but it can also be called directly to visually
		     * highlight a series.
		     *
		     * @function Highcharts.Series#setState
		     *
		     * @param {string} [state]
		     *        Can be either `hover` or undefined to set to normal state.
		     */
		    setState: function (state) {
		        var series = this,
		            options = series.options,
		            graph = series.graph,
		            stateOptions = options.states,
		            lineWidth = options.lineWidth,
		            attribs,
		            i = 0;

		        state = state || '';

		        if (series.state !== state) {

		            // Toggle class names
		            each([
		                series.group,
		                series.markerGroup,
		                series.dataLabelsGroup
		            ], function (group) {
		                if (group) {
		                    // Old state
		                    if (series.state) {
		                        group.removeClass('highcharts-series-' + series.state);
		                    }
		                    // New state
		                    if (state) {
		                        group.addClass('highcharts-series-' + state);
		                    }
		                }
		            });

		            series.state = state;



		            if (stateOptions[state] && stateOptions[state].enabled === false) {
		                return;
		            }

		            if (state) {
		                lineWidth = (
		                    stateOptions[state].lineWidth ||
		                    lineWidth + (stateOptions[state].lineWidthPlus || 0)
		                ); // #4035
		            }

		            if (graph && !graph.dashstyle) {
		                attribs = {
		                    'stroke-width': lineWidth
		                };

		                // Animate the graph stroke-width. By default a quick animation
		                // to hover, slower to un-hover.
		                graph.animate(
		                    attribs,
		                    pick(
		                        (
		                            stateOptions[state || 'normal'] &&
		                            stateOptions[state || 'normal'].animation
		                        ),
		                        series.chart.options.chart.animation
		                    )
		                );
		                while (series['zone-graph-' + i]) {
		                    series['zone-graph-' + i].attr(attribs);
		                    i = i + 1;
		                }
		            }



		        }
		    },

		    /**
		     * Show or hide the series.
		     *
		     * @function Highcharts.Series#setVisible
		     *
		     * @param {boolean} [visible]
		     *        True to show the series, false to hide. If undefined, the
		     *        visibility is toggled.
		     *
		     * @param {boolean} [redraw=true]
		     *        Whether to redraw the chart after the series is altered. If doing
		     *        more operations on the chart, it is a good idea to set redraw to
		     *        false and call {@link Chart#redraw|chart.redraw()} after.
		     *
		     * @fires Highcharts.Series#event:hide
		     * @fires Highcharts.Series#event:show
		     */
		    setVisible: function (vis, redraw) {
		        var series = this,
		            chart = series.chart,
		            legendItem = series.legendItem,
		            showOrHide,
		            ignoreHiddenSeries = chart.options.chart.ignoreHiddenSeries,
		            oldVisibility = series.visible;

		        // if called without an argument, toggle visibility
		        series.visible =
		            vis =
		            series.options.visible =
		            series.userOptions.visible =
		            vis === undefined ? !oldVisibility : vis; // #5618
		        showOrHide = vis ? 'show' : 'hide';

		        // show or hide elements
		        each([
		            'group',
		            'dataLabelsGroup',
		            'markerGroup',
		            'tracker',
		            'tt'
		        ], function (key) {
		            if (series[key]) {
		                series[key][showOrHide]();
		            }
		        });


		        // hide tooltip (#1361)
		        if (
		            chart.hoverSeries === series ||
		            (chart.hoverPoint && chart.hoverPoint.series) === series
		        ) {
		            series.onMouseOut();
		        }


		        if (legendItem) {
		            chart.legend.colorizeItem(series, vis);
		        }


		        // rescale or adapt to resized chart
		        series.isDirty = true;
		        // in a stack, all other series are affected
		        if (series.options.stacking) {
		            each(chart.series, function (otherSeries) {
		                if (otherSeries.options.stacking && otherSeries.visible) {
		                    otherSeries.isDirty = true;
		                }
		            });
		        }

		        // show or hide linked series
		        each(series.linkedSeries, function (otherSeries) {
		            otherSeries.setVisible(vis, false);
		        });

		        if (ignoreHiddenSeries) {
		            chart.isDirtyBox = true;
		        }

		        fireEvent(series, showOrHide);

		        if (redraw !== false) {
		            chart.redraw();
		        }
		    },

		    /**
		     * Show the series if hidden.
		     *
		     * @sample highcharts/members/series-hide/
		     *         Toggle visibility from a button
		     *
		     * @function Highcharts.Series#show
		     *
		     * @fires Highcharts.Series#event:show
		     */
		    show: function () {
		        this.setVisible(true);
		    },

		    /**
		     * Hide the series if visible. If the {@link
		     * https://api.highcharts.com/highcharts/chart.ignoreHiddenSeries|
		     * chart.ignoreHiddenSeries} option is true, the chart is redrawn without
		     * this series.
		     *
		     * @sample highcharts/members/series-hide/
		     *         Toggle visibility from a button
		     *
		     * @function Highcharts.Series#hide
		     *
		     * @fires Highcharts.Series#event:hide
		     */
		    hide: function () {
		        this.setVisible(false);
		    },


		    /**
		     * Select or unselect the series. This means its
		     * {@link Highcharts.Series.selected|selected}
		     * property is set, the checkbox in the legend is toggled and when selected,
		     * the series is returned by the
		     * {@link Highcharts.Chart#getSelectedSeries}
		     * function.
		     *
		     * @sample highcharts/members/series-select/
		     *         Select a series from a button
		     *
		     * @function Highcharts.Series#select
		     *
		     * @param {boolean} [selected]
		     *        True to select the series, false to unselect. If undefined, the
		     *        selection state is toggled.
		     *
		     * @fires Highcharts.Series#event:select
		     * @fires Highcharts.Series#event:unselect
		     */
		    select: function (selected) {
		        var series = this;

		        series.selected = selected = (selected === undefined) ?
		            !series.selected :
		            selected;

		        if (series.checkbox) {
		            series.checkbox.checked = selected;
		        }

		        fireEvent(series, selected ? 'select' : 'unselect');
		    },

		    /**
		     * @private
		     * @borrows Highcharts.TrackerMixin.drawTrackerGraph as Highcharts.Series#drawTracker
		     */
		    drawTracker: TrackerMixin.drawTrackerGraph
		});

	}(Highcharts));
	(function (H) {
		/**
		 * (c) 2010-2018 Torstein Honsi
		 *
		 * License: www.highcharts.com/license
		 */

		/**
		 * A callback function to gain complete control on when the responsive rule
		 * applies.
		 *
		 * @callback Highcharts.ResponsiveCallbackFunction
		 *
		 * @return {boolean}
		 *         Return `true` if it applies.
		 */



		var Chart = H.Chart,
		    each = H.each,
		    inArray = H.inArray,
		    isArray = H.isArray,
		    isObject = H.isObject,
		    pick = H.pick,
		    splat = H.splat;

		/**
		 * Allows setting a set of rules to apply for different screen or chart
		 * sizes. Each rule specifies additional chart options.
		 *
		 * @sample {highstock} stock/demo/responsive/
		 *         Stock chart
		 * @sample highcharts/responsive/axis/
		 *         Axis
		 * @sample highcharts/responsive/legend/
		 *         Legend
		 * @sample highcharts/responsive/classname/
		 *         Class name
		 *
		 * @since     5.0.0
		 * @apioption responsive
		 */

		/**
		 * A set of rules for responsive settings. The rules are executed from
		 * the top down.
		 *
		 * @sample {highcharts} highcharts/responsive/axis/
		 *         Axis changes
		 * @sample {highstock} highcharts/responsive/axis/
		 *         Axis changes
		 * @sample {highmaps} highcharts/responsive/axis/
		 *         Axis changes
		 *
		 * @type      {Array<*>}
		 * @since     5.0.0
		 * @apioption responsive.rules
		 */

		/**
		 * A full set of chart options to apply as overrides to the general
		 * chart options. The chart options are applied when the given rule
		 * is active.
		 *
		 * A special case is configuration objects that take arrays, for example
		 * [xAxis](#xAxis), [yAxis](#yAxis) or [series](#series). For these
		 * collections, an `id` option is used to map the new option set to
		 * an existing object. If an existing object of the same id is not found,
		 * the item of the same indexupdated. So for example, setting `chartOptions`
		 * with two series items without an `id`, will cause the existing chart's
		 * two series to be updated with respective options.
		 *
		 * @sample {highstock} stock/demo/responsive/
		 *         Stock chart
		 * @sample highcharts/responsive/axis/
		 *         Axis
		 * @sample highcharts/responsive/legend/
		 *         Legend
		 * @sample highcharts/responsive/classname/
		 *         Class name
		 *
		 * @type      {Highcharts.Options}
		 * @since     5.0.0
		 * @apioption responsive.rules.chartOptions
		 */

		/**
		 * Under which conditions the rule applies.
		 *
		 * @since     5.0.0
		 * @apioption responsive.rules.condition
		 */

		/**
		 * A callback function to gain complete control on when the responsive
		 * rule applies. Return `true` if it applies. This opens for checking
		 * against other metrics than the chart size, or example the document
		 * size or other elements.
		 *
		 * @type      {Highcharts.ResponsiveCallbackFunction}
		 * @since     5.0.0
		 * @context   Highcharts.Chart
		 * @apioption responsive.rules.condition.callback
		 */

		/**
		 * The responsive rule applies if the chart height is less than this.
		 *
		 * @type      {number}
		 * @since     5.0.0
		 * @apioption responsive.rules.condition.maxHeight
		 */

		/**
		 * The responsive rule applies if the chart width is less than this.
		 *
		 * @sample highcharts/responsive/axis/
		 *         Max width is 500
		 *
		 * @type      {number}
		 * @since     5.0.0
		 * @apioption responsive.rules.condition.maxWidth
		 */

		/**
		 * The responsive rule applies if the chart height is greater than this.
		 *
		 * @type      {number}
		 * @default   0
		 * @since     5.0.0
		 * @apioption responsive.rules.condition.minHeight
		 */

		/**
		 * The responsive rule applies if the chart width is greater than this.
		 *
		 * @type      {number}
		 * @default   0
		 * @since     5.0.0
		 * @apioption responsive.rules.condition.minWidth
		 */

		/**
		 * Update the chart based on the current chart/document size and options for
		 * responsiveness.
		 *
		 * @private
		 * @function Highcharts.Chart#setResponsive
		 *
		 * @param {boolean} [redraw=true]
		 */
		Chart.prototype.setResponsive = function (redraw) {
		    var options = this.options.responsive,
		        ruleIds = [],
		        currentResponsive = this.currentResponsive,
		        currentRuleIds;

		    if (options && options.rules) {
		        each(options.rules, function (rule) {
		            if (rule._id === undefined) {
		                rule._id = H.uniqueKey();
		            }

		            this.matchResponsiveRule(rule, ruleIds, redraw);
		        }, this);
		    }

		    // Merge matching rules
		    var mergedOptions = H.merge.apply(0, H.map(ruleIds, function (ruleId) {
		        return H.find(options.rules, function (rule) {
		            return rule._id === ruleId;
		        }).chartOptions;
		    }));

		    // Stringified key for the rules that currently apply.
		    ruleIds = ruleIds.toString() || undefined;
		    currentRuleIds = currentResponsive && currentResponsive.ruleIds;


		    // Changes in what rules apply
		    if (ruleIds !== currentRuleIds) {

		        // Undo previous rules. Before we apply a new set of rules, we need to
		        // roll back completely to base options (#6291).
		        if (currentResponsive) {
		            this.update(currentResponsive.undoOptions, redraw);
		        }

		        if (ruleIds) {
		            // Get undo-options for matching rules
		            this.currentResponsive = {
		                ruleIds: ruleIds,
		                mergedOptions: mergedOptions,
		                undoOptions: this.currentOptions(mergedOptions)
		            };

		            this.update(mergedOptions, redraw);

		        } else {
		            this.currentResponsive = undefined;
		        }
		    }
		};

		/**
		 * Handle a single responsiveness rule.
		 *
		 * @private
		 * @function Highcharts.Chart#matchResponsiveRule
		 *
		 * @param {Highcharts.ResponsiveRulesConditionOptions} rule
		 *
		 * @param {Array<number>} matches
		 */
		Chart.prototype.matchResponsiveRule = function (rule, matches) {

		    var condition = rule.condition,
		        fn = condition.callback || function () {
		            return (
		                this.chartWidth <= pick(condition.maxWidth, Number.MAX_VALUE) &&
		                this.chartHeight <=
		                    pick(condition.maxHeight, Number.MAX_VALUE) &&
		                this.chartWidth >= pick(condition.minWidth, 0) &&
		                this.chartHeight >= pick(condition.minHeight, 0)
		            );
		        };

		    if (fn.call(this)) {
		        matches.push(rule._id);
		    }
		};

		/**
		 * Get the current values for a given set of options. Used before we update
		 * the chart with a new responsiveness rule.
		 * TODO: Restore axis options (by id?)
		 *
		 * @private
		 * @function Highcharts.Chart#currentOptions
		 *
		 * @param {Highcharts.Options} options
		 *
		 * @return {Highcharts.Options}
		 */
		Chart.prototype.currentOptions = function (options) {

		    var ret = {};

		    /**
		     * Recurse over a set of options and its current values,
		     * and store the current values in the ret object.
		     */
		    function getCurrent(options, curr, ret, depth) {
		        var i;
		        H.objectEach(options, function (val, key) {
		            if (!depth && inArray(key, ['series', 'xAxis', 'yAxis']) > -1) {
		                val = splat(val);

		                ret[key] = [];

		                // Iterate over collections like series, xAxis or yAxis and map
		                // the items by index.
		                for (i = 0; i < val.length; i++) {
		                    if (curr[key][i]) { // Item exists in current data (#6347)
		                        ret[key][i] = {};
		                        getCurrent(
		                            val[i],
		                            curr[key][i],
		                            ret[key][i],
		                            depth + 1
		                        );
		                    }
		                }
		            } else if (isObject(val)) {
		                ret[key] = isArray(val) ? [] : {};
		                getCurrent(val, curr[key] || {}, ret[key], depth + 1);
		            } else {
		                ret[key] = curr[key] || null;
		            }
		        });
		    }

		    getCurrent(options, this.options, ret, 0);
		    return ret;
		};

	}(Highcharts));
	return (function (Highcharts) {


		return Highcharts;
	}(Highcharts));
}));
/**
 * jQuery.fn.sortElements
 * --------------
 * @author James Padolsey (http://james.padolsey.com)
 * @version 0.11
 * @updated 18-MAR-2010
 * --------------
 * @param Function comparator:
 *   Exactly the same behaviour as [1,2,3].sort(comparator)
 *
 * @param Function getSortable
 *   A function that should return the element that is
 *   to be sorted. The comparator will run on the
 *   current collection, but you may want the actual
 *   resulting sort to occur on a parent or another
 *   associated element.
 *
 *   E.g. $('td').sortElements(comparator, function(){
 *      return this.parentNode;
 *   })
 *
 *   The <td>'s parent (<tr>) will be sorted instead
 *   of the <td> itself.
 */

jQuery.fn.sortElements = (function(){

    var sort = [].sort;

    return function(comparator, getSortable) {

        getSortable = getSortable || function(){return this;};

        var placements = this.map(function(){

            var sortElement = getSortable.call(this),
                parentNode = sortElement.parentNode,

                // Since the element itself will change position, we have
                // to have some way of storing it's original position in
                // the DOM. The easiest way is to have a 'flag' node:
                nextSibling = parentNode.insertBefore(
                    document.createTextNode(''),
                    sortElement.nextSibling
                );

            return function() {

                if (parentNode === this) {
                    throw new Error(
                        "You can't sort elements if any one is a descendant of another."
                    );
                }

                // Insert before flag:
                parentNode.insertBefore(this, nextSibling);
                // Remove flag:
                parentNode.removeChild(nextSibling);

            };

        });

        return sort.call(this, comparator).each(function(i){
            placements[i].call(getSortable.call(this));
        });

    };

})();
(function() {
  var base,
    bind = function(fn, me){ return function(){ return fn.apply(me, arguments); }; };

  (base = window.Didlogic).Admin || (base.Admin = {});

  Didlogic.Admin.User = (function() {
    function User() {
      this.render = bind(this.render, this);
      this.anyCLID = $('#user_allow_any_clid');
      this.paidCLID = $('.paid_clid');
      this.paymentTopup = $('#payment_topup input[type=checkbox]');
      this.paymentCharge = $('#payment_charge');
      this.privacyHeader = $('#user_allow_privacy');
      this.send_pai_anonymous = $('.send_pai_anonymous');
      this.render();
      this.anyCLID.on('change', this.render);
      this.paymentTopup.on('change', this.render);
      this.privacyHeader.on('change', this.render);
      $('#user_disable_account_levels').on('change', function(e) {
        console.log('ok');
        if (e.target.checked) {
          $('.checkbox-google-pay').val(1);
          return $(".checkbox-google-pay").parent().addClass("checked");
        }
      });
      $('.checkbox-2fa').on('change', function(e) {
        if (!e.target.checked) {
          return $.ajax({
            url: '/admin/users/' + $(e.target).attr('data-user') + '/turn_off_2fa',
            type: 'delete',
            dataType: 'json',
            success: (function(_this) {
              return function() {
                return $(e.target).attr('disabled', true);
              };
            })(this),
            error: (function(_this) {
              return function(data) {
                return console.log('Error!');
              };
            })(this)
          });
        }
      });
      if ($('#telemarketing').is(':checked')) {
        $("#quarantine").prop("disabled", true);
        $("input[name='user[quarantine_enabled]']").first().val(1);
      }
      $('#telemarketing').on('change', function(e) {
        if (e.target.checked) {
          $("#quarantine").prop("checked", true).trigger("change");
          $("#quarantine").prop("disabled", true);
          $("#quarantine").parent().addClass("checked");
          $("input[name='user[quarantine_enabled]']").first().val(1);
          return $('#user_quarantine_period option[value="12"]').attr("selected", "selected");
        } else {
          $("#quarantine").prop("disabled", false);
          return $("input[name='user[quarantine_enabled]']").first().val(0);
        }
      });
    }

    User.prototype.render = function() {
      if (this.anyCLID.is(':checked')) {
        this.paidCLID.show();
        if (this.privacyHeader.is(':checked')) {
          this.send_pai_anonymous.show();
        } else {
          this.send_pai_anonymous.hide();
        }
      } else {
        this.paidCLID.hide();
        this.send_pai_anonymous.hide();
      }
      if (this.paymentTopup.is(':checked')) {
        return this.paymentCharge.show();
      } else {
        return this.paymentCharge.hide();
      }
    };

    return User;

  })();

}).call(this);
System.register("admin/users", ["admin/components/profit-widget", "admin/components/duration-widget", "admin/components/markup-margin-widget"], function (_export) {
  "use strict";

  var ProfitWidget, DurationWidget, MarkupMarginWidget, Spinner, ProfitContent, DurationContent, MarkupMarginContent, UsersApp, Users, toggleReviewLink;

  var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

  var _createClass = (function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; })();

  function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

  return {
    setters: [function (_adminComponentsProfitWidget) {
      ProfitWidget = _adminComponentsProfitWidget["default"];
    }, function (_adminComponentsDurationWidget) {
      DurationWidget = _adminComponentsDurationWidget["default"];
    }, function (_adminComponentsMarkupMarginWidget) {
      MarkupMarginWidget = _adminComponentsMarkupMarginWidget["default"];
    }],
    execute: function () {
      Spinner = function Spinner() {
        return React.createElement(
          "div",
          { className: "loading" },
          React.createElement("i", { className: "fa fa-spinner fa-pulse" })
        );
      };

      ProfitContent = function ProfitContent(_ref) {
        var props = _ref.props;

        var h2Content = undefined;
        if (props.userEmail) {
          h2Content = "Profit for " + props.userEmail;
        } else {
          h2Content = "Total Profit";
        }

        return React.createElement(
          "div",
          { className: "profit-modal" },
          React.createElement(
            "h2",
            { className: "content-title" },
            " ",
            h2Content,
            " "
          ),
          React.createElement(ProfitWidget, { data: props.data, id: props.userID, total: props.total, email: props.userEmail })
        );
      };

      DurationContent = function DurationContent(_ref2) {
        var props = _ref2.props;

        var h2Content = undefined;
        if (props.userEmail) {
          h2Content = "Inbound and Outbound durations for " + props.userEmail;
        } else {
          h2Content = "Total Inbound and Outbound durations";
        }

        return React.createElement(
          "div",
          { className: "duration-modal" },
          props.email ? React.createElement(
            "h2",
            { className: "content-title" },
            " Inbound and Outbound durations for ",
            props.email,
            " "
          ) : React.createElement(
            "h2",
            { className: "content-title" },
            " Total Inbound and Outbound durations "
          ),
          React.createElement(DurationWidget, { data: props.data, id: props.userID, total: props.total, email: props.userEmail })
        );
      };

      MarkupMarginContent = function MarkupMarginContent(_ref3) {
        var props = _ref3.props;

        var h2Content = undefined;
        if (props.userEmail) {
          h2Content = "Markup & Margin for " + props.userEmail;
        } else {
          h2Content = "Total Markup & Margin";
        }

        return React.createElement(
          "div",
          { className: "profit-modal" },
          React.createElement(
            "h2",
            { className: "content-title" },
            " ",
            h2Content,
            " "
          ),
          React.createElement(MarkupMarginWidget, { data: props.data, id: props.userID, total: props.total, email: props.userEmail, callType: props.callType })
        );
      };

      UsersApp = function UsersApp(props) {

        var klass = props.klass;
        var map = {
          "profit": ProfitContent,
          "total-profit": ProfitContent,
          "durations": DurationContent,
          "total-durations": DurationContent,
          "markup-margin": MarkupMarginContent,
          "total-markup-margin": MarkupMarginContent
        };

        var isRenderable = props.data;

        if (!klass) {
          return null;
        }
        var Selection = React.createElement(map[klass], { props: props });

        var style = {
          overlay: {
            zIndex: 1001
          },

          content: {
            top: "50%",
            bottom: "auto",
            transform: "translate(0, -50%)",
            height: "500px"
          }
        };

        return React.createElement(
          "div",
          null,
          React.createElement(
            Modal,
            { isOpen: props.open, style: style, onRequestClose: props.onClose },
            React.createElement(
              "div",
              { className: "profit-modal" },
              isRenderable ? Selection : React.createElement(Spinner, null)
            )
          )
        );
      };

      Users = (function () {
        _createClass(Users, [{
          key: "onClick",
          value: function onClick(e) {
            e.preventDefault();

            var el = $(e.currentTarget);
            var id = el.data("id");
            var email = el.data("email");
            var callType = el.data("call-type");
            var klass = el[0].classList[0];
            var ids = [];
            $('table.metrics a.profit').each(function (index, element) {
              ids.push(element.getAttribute('data-id'));
            });

            this.state = { open: true, userID: id, userEmail: email, data: null, klass: klass };
            this.render();
            this.loadData(id, klass, ids, callType);
          }
        }, {
          key: "onClose",
          value: function onClose() {
            this.state.open = false;
            this.render();
          }
        }, {
          key: "loadData",
          value: function loadData(id, klass, ids, callType) {
            var _this = this;

            var url = undefined;
            switch (klass) {
              case 'profit':
                url = "/admin/profit_graph.json";
                $.get(url, { id: id }).then(function (data) {
                  return _this.state = _.extend(_this.state, data);
                }).then(this.render.bind(this));
                break;
              case 'durations':
                url = "/admin/duration_graph.json";
                $.get(url, { id: id }).then(function (data) {
                  return _this.state = _.extend(_this.state, data);
                }).then(this.render.bind(this));
                break;
              case 'markup-margin':
                url = "/admin/markup_margin_graph.json";
                $.get(url, { id: id, call_type: callType }).then(function (data) {
                  return _this.state = _.extend(_this.state, data);
                }).then(this.render.bind(this));
                break;
              case 'total-durations':
                url = "/admin/duration_graph/totals.json";
                $.get(url).then(function (data) {
                  return _this.state = _.extend(_this.state, data);
                }).then(this.render.bind(this));
                break;
              case 'total-profit':
                url = "/admin/profit_graph/totals.json";
                $.get(url).then(function (data) {
                  return _this.state = _.extend(_this.state, data);
                }).then(this.render.bind(this));
                break;
              case 'total-markup-margin':
                url = "/admin/markup_margin_graph/totals.json";
                $.get(url).then(function (data) {
                  return _this.state = _.extend(_this.state, data);
                }).then(this.render.bind(this));
                break;
            }
          }
        }]);

        function Users() {
          _classCallCheck(this, Users);

          var tableRoot = document.querySelector("table.admin-table");
          $(tableRoot).on("change", "input[name=review-link-toggle]", toggleReviewLink);
          this.state = {};

          this.el = document.getElementById("react-root");
          Modal.setAppElement(this.el);

          $("a.profit").on("click", this.onClick.bind(this));
          $("a.durations").on("click", this.onClick.bind(this));
          $("a.markup-margin").on("click", this.onClick.bind(this));
          $("a.total-profit").on("click", this.onClick.bind(this));
          $("a.total-durations").on("click", this.onClick.bind(this));
          $("a.total-profit").on("click", this.onClick.bind(this));
          $("a.total-markup-margin").on("click", this.onClick.bind(this));

          this.render();
        }

        _createClass(Users, [{
          key: "render",
          value: function render() {
            ReactDOM.render(React.createElement(UsersApp, _extends({ onClose: this.onClose.bind(this) }, this.state)), this.el);
          }
        }]);

        return Users;
      })();

      toggleReviewLink = function toggleReviewLink(event) {
        var target = $(event.target);
        var link = target.siblings("a");
        var url = link.attr("href");

        var isChecked = event.target.checked;
        var notifyValue = isChecked ? "true" : "false";

        var nextUrl = url.replace(/skip_notify=(true|false)/, "skip_notify=" + notifyValue);

        link.attr("href", nextUrl);
      };

      _export("default", Users);
    }
  };
});
System.register("admin/inbox", ["components/dselect"], function (_export) {
  "use strict";

  var DSelect, _Recompose, compose, branch, renderNothing, withProps, _Redux, createStore, applyMiddleware, _ReactRedux, Provider, connect, ID, DEFAULT, SHOW, HIDE, SEND_START, SEND_DONE, SEND_ERROR, ADD_TEMPLATES, CHANGE_TEMPLATE, getToken, makeOptions, show, hide, sendStart, sendDone, sendError, _send, addTemplates, _changeTemplate, reducer, store, hidden, s2p, d2p, withDisableSend, enhance, Form, onClick, init;

  var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

  return {
    setters: [function (_componentsDselect) {
      DSelect = _componentsDselect["default"];
    }],
    execute: function () {
      _Recompose = Recompose;
      compose = _Recompose.compose;
      branch = _Recompose.branch;
      renderNothing = _Recompose.renderNothing;
      withProps = _Recompose.withProps;
      _Redux = Redux;
      createStore = _Redux.createStore;
      applyMiddleware = _Redux.applyMiddleware;
      _ReactRedux = ReactRedux;
      Provider = _ReactRedux.Provider;
      connect = _ReactRedux.connect;
      ID = "manager-mailer";
      DEFAULT = {
        display: false,
        templates: [],
        template: null,
        pending: false
      };
      SHOW = "show";
      HIDE = "hide";
      SEND_START = "send_start";
      SEND_DONE = "send_done";
      SEND_ERROR = "send_error";
      ADD_TEMPLATES = "add_templates";
      CHANGE_TEMPLATE = "change_template";

      getToken = function getToken() {
        return document.querySelector('meta[name="csrf-token"]').attributes["content"].value;
      };

      makeOptions = function makeOptions(templates) {
        return _.map(templates, function (t) {
          return { label: t.name, value: t.id };
        });
      };

      show = function show(payload) {
        return { type: SHOW, payload: payload };
      };

      hide = function hide() {
        return { type: HIDE };
      };

      sendStart = function sendStart() {
        return { type: SEND_START };
      };

      sendDone = function sendDone() {
        return { type: SEND_DONE };
      };

      sendError = function sendError() {
        return { type: SEND_ERROR };
      };

      _send = function _send() {
        return function (dispatch, getState) {
          dispatch(sendStart());

          var _getState = getState();

          var userId = _getState.id;
          var templateId = _getState.template;

          var token = getToken();
          var body = JSON.stringify({ user_id: userId, template_id: templateId });

          var url = "/admin/mail_templates/send_mail.json";
          var headers = {
            "X-CSRF-Token": token,
            Accept: "application/json",
            "Content-Type": "application/json"
          };
          var params = { method: "POST", headers: headers, body: body, credentials: "same-origin" };

          fetch(url, params).then(function () {
            return dispatch(sendDone());
          });
        };
      };

      addTemplates = function addTemplates(payload) {
        return { type: ADD_TEMPLATES, payload: payload };
      };

      _changeTemplate = function _changeTemplate(payload) {
        return { type: CHANGE_TEMPLATE, payload: payload };
      };

      reducer = function reducer(state, action) {
        switch (action.type) {
          case SHOW:
            {
              return _extends({}, state, { display: true }, action.payload);
            }
          case HIDE:
            {
              return _extends({}, state, { display: false, template: null });
            }
          case ADD_TEMPLATES:
            {
              return _extends({}, state, { templates: makeOptions(action.payload) });
            }
          case CHANGE_TEMPLATE:
            {
              return _extends({}, state, { template: action.payload });
            }
          case SEND_START:
            {
              return _extends({}, state, { pending: true });
            }
          case SEND_DONE:
            {
              return _extends({}, state, { display: false, template: null, pending: false });
            }
          case SEND_ERROR:
            {
              return _extends({}, state, { pending: false });
            }
          default:
            {
              return state;
            }
        }
      };

      store = createStore(reducer, DEFAULT, applyMiddleware(ReduxThunk["default"]));
      hidden = branch(function (props) {
        return !props.display;
      }, renderNothing);

      s2p = function s2p(state) {
        return state;
      };

      d2p = function d2p(dispatch) {
        return {
          cancel: function cancel() {
            return dispatch(hide());
          },
          changeTemplate: function changeTemplate(id) {
            return dispatch(_changeTemplate(id));
          },
          send: function send() {
            return dispatch(_send());
          }
        };
      };

      withDisableSend = withProps(function (props) {
        return {
          disableSend: !props.template || props.pending
        };
      });
      enhance = compose(connect(s2p, d2p), hidden, withDisableSend);
      Form = enhance(function (props) {
        return React.createElement(
          "div",
          { className: "modal-overlay" },
          React.createElement(
            "div",
            { className: "modal-root" },
            React.createElement(
              "form",
              { className: "inbox-mail" },
              React.createElement(
                "div",
                { className: "title" },
                "Send email to ",
                props.email
              ),
              React.createElement(
                "div",
                { className: "row" },
                React.createElement(
                  "label",
                  null,
                  "Select template"
                ),
                React.createElement(DSelect, {
                  options: props.templates,
                  float: "none",
                  value: props.template,
                  onChange: props.changeTemplate
                })
              ),
              React.createElement(
                "div",
                { className: "row" },
                React.createElement(
                  "a",
                  { onClick: props.cancel, className: "button-normal" },
                  "Cancel"
                ),
                React.createElement(
                  "a",
                  {
                    onClick: props.disableSend ? null : props.send,
                    className: classNames("button-normal", {
                      disabled: props.disableSend
                    }),
                    disabled: props.disableSend
                  },
                  "Send"
                )
              )
            )
          )
        );
      });

      onClick = function onClick(event) {
        var target = event.target;
        var rel = target.getAttribute("rel");

        if (rel !== "email") {
          return;
        }

        event.preventDefault();
        store.dispatch(show(_extends({}, target.dataset)));
      };

      init = function init() {
        // setup click event
        document.addEventListener("click", onClick);

        // setup react app
        var root = document.getElementById(ID);
        var templates = JSON.parse(root.dataset.templates);
        store.dispatch(addTemplates(templates));

        var App = React.createElement(
          Provider,
          { store: store },
          React.createElement(Form, null)
        );

        ReactDOM.render(App, root);
      };

      _export("default", init);
    }
  };
});
System.register("admin/profit-graph", ["admin/components/profit-widget"], function (_export) {
  "use strict";

  var ProfitWidget, VIEW_ROOT, FORM_ROOT, initView, initForm, init, setup;
  return {
    setters: [function (_adminComponentsProfitWidget) {
      ProfitWidget = _adminComponentsProfitWidget["default"];
    }],
    execute: function () {
      VIEW_ROOT = "profit-graph-view";
      FORM_ROOT = "profit-graph-form";

      initView = function initView() {
        var root = document.getElementById(VIEW_ROOT);

        if (!root) {
          return;
        }

        ReactDOM.render(React.createElement(ProfitWidget, { data: window.profitData, total: window.profitTotal, email: window.email }), root);
      };

      initForm = function initForm() {
        var root = document.getElementById(FORM_ROOT);

        if (!root) {
          return;
        }

        var checkbox = $("#use_interval");
        var months = $("#months");
        var interval = $("#interval");

        var managerSelect = $("#q_manager_id");
        var filterField = $("#q_email_cont");

        var updateInterval = function updateInterval() {
          if (checkbox.is(":checked")) {
            interval.show();
            months.hide();
          } else {
            interval.hide();
            months.show();
          }
        };

        var updateEmail = function updateEmail() {
          var isBlank = managerSelect.val() === "";
          if (isBlank) {
            filterField.attr("disabled", false);
          } else {
            filterField.attr("disabled", true).val("");
          }
        };

        checkbox.on("change", updateInterval);
        updateInterval();

        if (managerSelect.length > 0) {
          managerSelect.on("change", updateEmail);
          updateEmail();
        }
      };

      init = function init() {
        initView();
        initForm();
      };

      setup = function setup() {
        return $(document).ready(init);
      };

      _export("setup", setup);
    }
  };
});
System.register('admin/statistics', ['admin/components/users-widget'], function (_export) {
  'use strict';

  var UsersWidget, init, setup;
  return {
    setters: [function (_adminComponentsUsersWidget) {
      UsersWidget = _adminComponentsUsersWidget['default'];
    }],
    execute: function () {
      init = function init() {
        var el = document.getElementById('react-root-statistics');
        if (el) {
          ReactDOM.render(React.createElement(UsersWidget, { data: window.total_users, dates: window.dates, callback: window.callback }), el);
        }
      };

      setup = function setup() {
        return $(document).ready(init);
      };

      _export('setup', setup);
    }
  };
});
System.register("admin/metrics", [], function (_export) {
  "use strict";

  var init, setup;
  return {
    setters: [],
    execute: function () {
      init = function init() {
        var form = $("form#new_metric");
        var elements = $("ul#compare-secondary, .legend");

        var primary = $('[data-field-name="primary[date]"]');
        var secondary = $('[data-field-name="secondary[date]"]');

        var calendarOriginalX = primary.data("x");

        var toggleVisible = function toggleVisible(e) {
          var checked = $(e.currentTarget).is(":checked");

          form.toggleClass("comparing", checked);

          if (checked) {
            elements.show();
            primary.data("x", 0);
          } else {
            elements.hide().data("x", calendarOriginalX);
          }

          primary.trigger("render");
        };

        var updateDates = function updateDates(e) {
          var checked = e.target.checked;

          var dateA = checked ? moment().subtract(1, "day") : moment();
          var dateB = moment(dateA).subtract(1, "day");

          primary.trigger("setDates", dateA);
          secondary.trigger("setDates", dateB);
        };

        $("input#metric_compare").on("change", toggleVisible).trigger("change").on("change", updateDates);

        $("input#metric_compare").on("change", function (e) {
          return form.submit();
        });
      };

      setup = function setup() {
        return $(document).ready(init);
      };

      _export("setup", setup);
    }
  };
});
System.register('admin/salesman-metrics', [], function (_export) {
  'use strict';

  var submit, init, setup;
  return {
    setters: [],
    execute: function () {
      submit = function submit(form) {
        form.find('.combobox-large').addClass('disabled');
        form.submit();
      };

      init = function init() {
        var form = $('.salesman-metrics-form form');
        form.on('change', 'select', function (e) {
          return submit(form);
        });
      };

      setup = function setup() {
        return $(document).ready(init);
      };

      _export('setup', setup);
    }
  };
});
System.register('admin/subscription-metrics', [], function (_export) {
  'use strict';

  var submit, init, setup;
  return {
    setters: [],
    execute: function () {
      submit = function submit(form) {
        form.find('.combobox-large').addClass('disabled');
        form.submit();
      };

      init = function init() {
        var form = $('.subscription-metrics-form form');
        form.on('change', 'select', function (e) {
          return submit(form);
        });
      };

      setup = function setup() {
        return $(document).ready(init);
      };

      _export('setup', setup);
    }
  };
});
System.register('admin/sortable-table', [], function (_export) {
  'use strict';

  var SortableTable, setup;

  var _createClass = (function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ('value' in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; })();

  function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError('Cannot call a class as a function'); } }

  return {
    setters: [],
    execute: function () {
      SortableTable = (function () {
        function SortableTable(el) {
          _classCallCheck(this, SortableTable);

          this.el = $(el);

          this.el.find('th[data-sortable]').addClass('sortable');
          this.el.on('click', 'th[data-sortable]', this.sort.bind(this));
        }

        _createClass(SortableTable, [{
          key: 'sort',
          value: function sort(e) {
            var _this = this;

            var header = $(e.currentTarget);

            var reverse = !header.data('reverse');
            header.data('reverse', reverse);

            var index = header.index();
            var isNumber = header.data('sortable') == 'number';

            var comparator = this.sortable(index, isNumber, reverse);
            this.el.find('tbody tr').not('.total').sortElements(comparator);

            if (this.el.data('sortableGroup') != undefined) {
              (function () {
                var this_table = _this.el;
                var other_tables = $('table[data-sortable-group="' + _this.el.data('sortableGroup') + '"]').filter(function (index, el) {
                  return !$(el).is(this_table);
                });

                other_tables.each(function (other_table_index, other_table) {
                  var last_el = undefined;
                  this_table.find('tbody tr[data-index]').each(function (index, el) {
                    var element_index = $(el).data('index');
                    var tr = $(other_table).find('tbody tr[data-index=' + element_index + ']');
                    if (last_el == undefined) {
                      tr.prependTo($(other_table).find('tbody'));
                    } else {
                      tr.insertAfter(last_el);
                    }
                    last_el = tr;
                  });
                });
              })();
            }
          }
        }, {
          key: 'comparator',
          value: function comparator(a, b) {
            return a > b ? 1 : -1;
          }
        }, {
          key: 'sortable',
          value: function sortable(index, isNumber, reverse) {
            var _this2 = this;

            var comparator = this.comparator;

            return function (a, b) {
              a = a.children[index].textContent;
              b = b.children[index].textContent;

              if (isNumber) {
                a = _this2._normalizeNumber(a);
                b = _this2._normalizeNumber(b);
              }

              var result = comparator(a, b);

              return reverse ? result * -1 : result;
            };
          }
        }, {
          key: '_normalizeNumber',
          value: function _normalizeNumber() {
            var textValue = arguments.length <= 0 || arguments[0] === undefined ? "" : arguments[0];

            return parseFloat(textValue.replace(/[^-?\d\.]*/g, ''));
          }
        }]);

        return SortableTable;
      })();

      setup = function setup() {
        window.SortableTable = SortableTable;
        $(document).ready(function () {
          _.each($('table[data-sortable]'), function (el) {
            return new SortableTable(el);
          });
        });
      };

      _export('setup', setup);
    }
  };
});
System.register('admin/multitable-hover', [], function (_export) {
  'use strict';

  var MultitableHover, setup;

  var _createClass = (function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ('value' in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; })();

  function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError('Cannot call a class as a function'); } }

  return {
    setters: [],
    execute: function () {
      MultitableHover = (function () {
        function MultitableHover(el) {
          _classCallCheck(this, MultitableHover);

          this.el = $(el);
          this.el.find('tbody tr').hover(this.hover.bind(this), this.unhover.bind(this));
        }

        _createClass(MultitableHover, [{
          key: 'hover',
          value: function hover(e) {
            var row = $(e.currentTarget);
            this.other_tables().each(function (index, table) {
              $(table).find('tr[data-index="' + row.data('index') + '"').addClass('hover');
            });
          }
        }, {
          key: 'unhover',
          value: function unhover(e) {
            var row = $(e.currentTarget);
            this.other_tables().each(function (index, table) {
              $(table).find('tr.hover').removeClass('hover');
            });
          }
        }, {
          key: 'other_tables',
          value: function other_tables() {
            var this_table = this.el;
            var other_tables = $('table[data-hover-group="' + this.el.data('hoverGroup') + '"]').filter(function (index, el) {
              return !$(el).is(this_table);
            });
            return other_tables;
          }
        }]);

        return MultitableHover;
      })();

      setup = function setup() {
        $(document).ready(function () {
          _.each($('table[data-hover-group]'), function (el) {
            return new MultitableHover(el);
          });
        });
      };

      _export('setup', setup);
    }
  };
});
System.register('admin/multitable-compare', [], function (_export) {
  'use strict';

  var MultitableCompare, setup;

  var _createClass = (function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ('value' in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; })();

  function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError('Cannot call a class as a function'); } }

  return {
    setters: [],
    execute: function () {
      MultitableCompare = (function () {
        function MultitableCompare(el) {
          _classCallCheck(this, MultitableCompare);

          this.el = $(el);
          this.el.find('tbody td').hover(this.hover.bind(this), this.unhover.bind(this));
        }

        _createClass(MultitableCompare, [{
          key: 'hover',
          value: function hover(e) {
            var _this = this;

            var cell = $(e.currentTarget);
            var column = cell.parent().children().index(cell) + 1;
            var header = this.el.find('thead tr.headers th:nth-child(' + column + ')');
            var compare_field = header.data('compare');
            if (compare_field != undefined) {
              (function () {
                var row = cell.parent().data('index');
                cell.parent().addClass('faded');
                cell.addClass('colored');

                _this.other_tables().each(function (index, el) {
                  var other_table = $(el);
                  var other_table_row = other_table.find('tr[data-index="' + row + '"]');
                  other_table_row.addClass('faded');
                  var other_table_header = other_table.find('th[data-compare="' + compare_field + '"]');
                  var other_table_index = other_table.find('thead tr.headers').children().index(other_table_header) + 1;
                  other_table_row.find('td:nth-child(' + other_table_index + ')').addClass('colored');
                });
              })();
            }
          }
        }, {
          key: 'unhover',
          value: function unhover(e) {
            var cell = $(e.currentTarget);
            this.el.find('tr').removeClass('faded');
            cell.removeClass('colored');

            this.other_tables().each(function (index, el) {
              var other_table = $(el);
              other_table.find('tr.faded').removeClass('faded');
              other_table.find('td.colored').removeClass('colored');
            });
          }
        }, {
          key: 'other_tables',
          value: function other_tables() {
            var this_table = this.el;
            var other_tables = $('table[data-compare-group="' + this.el.data('compareGroup') + '"]').filter(function (index, el) {
              return !$(el).is(this_table);
            });
            return other_tables;
          }
        }]);

        return MultitableCompare;
      })();

      setup = function setup() {
        $(document).ready(function () {
          _.each($('table[data-compare-group]'), function (el) {
            return new MultitableCompare(el);
          });
        });
      };

      _export('setup', setup);
    }
  };
});
System.register("admin/user-permissions", ["components/dselect"], function (_export) {
  "use strict";

  var DSelect, Form, App, setup;

  var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

  var _createClass = (function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; })();

  var _get = function get(_x, _x2, _x3) { var _again = true; _function: while (_again) { var object = _x, property = _x2, receiver = _x3; _again = false; if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { _x = parent; _x2 = property; _x3 = receiver; _again = true; desc = parent = undefined; continue _function; } } else if ("value" in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } } };

  function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

  function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

  return {
    setters: [function (_componentsDselect) {
      DSelect = _componentsDselect["default"];
    }],
    execute: function () {
      Form = (function (_React$Component) {
        _inherits(Form, _React$Component);

        function Form(props) {
          _classCallCheck(this, Form);

          _get(Object.getPrototypeOf(Form.prototype), "constructor", this).call(this);

          this.loadUsers = function (input, callback) {
            var url = "/admin/users.json";
            var query = { "q[email_cont]": input };

            var ajax = $.ajax({
              url: url,
              type: "GET",
              data: query
            });

            ajax.then(function (json) {
              var options = json.map(function (u) {
                return { value: [u.email, u.id], label: u.email };
              });
              callback(null, { options: options });
            });
          };

          this.state = {
            owner: props.staff[0],
            ownerId: props.staff[0].value,
            user: {},
            userId: null,
            addToReport: false,
            minSpentValue: 0,
            minSpentFridayValue: 0,
            minSpentSatSunValue: 0,
            customerSuccess: false,
            channelManager: false
          };
        }

        _createClass(Form, [{
          key: "addToReportChanged",
          value: function addToReportChanged(checked) {
            var fields = checked ? {} : { customerSuccess: false, channelManager: false };

            this.setState(_extends({ addToReport: checked }, fields));
          }
        }, {
          key: "customerSuccessChanged",
          value: function customerSuccessChanged(value) {
            this.setState({
              customerSuccess: value,
              addToReport: value,
              channelManager: false
            });
          }
        }, {
          key: "channelManagerChanged",
          value: function channelManagerChanged(value) {
            this.setState({
              customerSuccess: false,
              channelManager: value,
              addToReport: value
            });
          }
        }, {
          key: "changeOwner",
          value: function changeOwner(ownerId, option) {
            this.setState({ owner: option[0], ownerId: ownerId });
          }
        }, {
          key: "changeUser",
          value: function changeUser(option) {
            this.setState({
              user: { label: option[0], value: option[1] },
              userId: option[1]
            });
          }
        }, {
          key: "onSubmit",
          value: function onSubmit(e) {
            e.preventDefault();

            var url = "/admin/user_permissions";
            var data = {
              owner_id: this.state.ownerId,
              user_id: this.state.userId,
              add_to_report: this.state.addToReport,
              customer_success: this.state.customerSuccess,
              channel_manager: this.state.channelManager,
              min_spent: this.state.addToReport ? this.state.minSpentValue : 0,
              min_spent_friday: this.state.addToReport ? this.state.minSpentFridayValue : 0,
              min_spent_end_of_week: this.state.addToReport ? this.state.minSpentSatSunValue : 0
            };

            var ajax = $.ajax({
              url: url,
              data: data,
              type: "POST"
            });

            ajax.then(function () {
              return window.location.reload();
            });
            ajax.fail(function () {
              return window.location.reload();
            });
          }
        }, {
          key: "submitButton",
          value: function submitButton() {
            var enabled = this.state.userId && this.state.ownerId;
            return React.createElement(
              "div",
              { className: "add-button" },
              React.createElement(
                "div",
                { className: "field" },
                React.createElement("input", {
                  type: "submit",
                  className: "button-normal",
                  value: "Add",
                  disabled: !enabled,
                  onClick: this.onSubmit.bind(this)
                })
              )
            );
          }
        }, {
          key: "render",
          value: function render() {
            var _this = this;

            return React.createElement(
              "div",
              { className: "add-request-form salesmans-form user-permissions" },
              React.createElement(
                "form",
                null,
                React.createElement(
                  "ul",
                  null,
                  React.createElement(
                    "li",
                    null,
                    React.createElement(
                      "div",
                      { className: "field-title" },
                      React.createElement(
                        "label",
                        { htmlFor: "owner_id" },
                        "Staff member"
                      )
                    ),
                    React.createElement(
                      "div",
                      { className: "field" },
                      React.createElement(DSelect, {
                        width: 200,
                        options: this.props.staff,
                        value: this.state.owner,
                        onChange: this.changeOwner.bind(this)
                      })
                    )
                  ),
                  React.createElement(
                    "li",
                    null,
                    React.createElement(
                      "div",
                      { className: "field-title" },
                      React.createElement(
                        "label",
                        { htmlFor: "user_id" },
                        "User"
                      )
                    ),
                    React.createElement(
                      "div",
                      { className: "field" },
                      React.createElement(DSelect, {
                        width: 200,
                        searchable: true,
                        clearable: true,
                        asyncOptions: this.loadUsers.bind(this),
                        value: this.state.user,
                        onChange: this.changeUser.bind(this)
                      })
                    )
                  )
                ),
                React.createElement("br", { style: { clear: "left" } }),
                React.createElement(
                  "div",
                  { className: "report-options" },
                  React.createElement(
                    "div",
                    { className: "include-to-report" },
                    React.createElement(
                      "div",
                      { className: "field-title" },
                      React.createElement(
                        "label",
                        { htmlFor: "add-to-report" },
                        "Include to report"
                      )
                    ),
                    React.createElement(
                      "div",
                      { className: "field" },
                      React.createElement(
                        "div",
                        null,
                        React.createElement("input", {
                          type: "checkbox",
                          id: "add-to-report",
                          value: "1",
                          checked: this.state.addToReport,
                          onChange: function (e) {
                            return _this.addToReportChanged(e.target.checked);
                          }
                        })
                      )
                    )
                  ),
                  React.createElement(
                    "div",
                    { className: "customer-success" },
                    React.createElement(
                      "div",
                      { className: "field-title" },
                      React.createElement(
                        "label",
                        { htmlFor: "satisfaction-role" },
                        "Customer success manager"
                      )
                    ),
                    React.createElement(
                      "div",
                      { className: "field" },
                      React.createElement(
                        "div",
                        null,
                        React.createElement("input", {
                          type: "checkbox",
                          id: "satisfaction-role",
                          value: "1",
                          checked: this.state.customerSuccess,
                          onChange: function (e) {
                            return _this.customerSuccessChanged(e.target.checked);
                          }
                        })
                      )
                    )
                  ),
                  React.createElement(
                    "div",
                    { className: "channel-manager" },
                    React.createElement(
                      "div",
                      { className: "field-title" },
                      React.createElement(
                        "label",
                        { htmlFor: "channel-role" },
                        "Channel manager"
                      )
                    ),
                    React.createElement(
                      "div",
                      { className: "field" },
                      React.createElement(
                        "div",
                        null,
                        React.createElement("input", {
                          type: "checkbox",
                          id: "channel-role",
                          value: "1",
                          checked: this.state.channelManager,
                          onChange: function (e) {
                            return _this.channelManagerChanged(e.target.checked);
                          }
                        })
                      )
                    )
                  )
                ),
                this.state.addToReport && React.createElement(
                  "div",
                  { className: "min-values" },
                  React.createElement(
                    "div",
                    { className: "value-container" },
                    React.createElement(
                      "div",
                      { className: "field-title" },
                      React.createElement(
                        "label",
                        { htmlFor: "min_spent" },
                        "Min. spent"
                      )
                    ),
                    React.createElement(
                      "div",
                      { className: "field" },
                      React.createElement(
                        "div",
                        { className: "text-field-medium" },
                        React.createElement("input", {
                          type: "number",
                          min: "0",
                          id: "min-spent",
                          defaultValue: "0",
                          onChange: function (e) {
                            return _this.setState({ minSpentValue: e.target.value });
                          },
                          style: { width: "70px" }
                        })
                      )
                    )
                  ),
                  React.createElement(
                    "div",
                    { className: "value-container" },
                    React.createElement(
                      "div",
                      { className: "field-title" },
                      React.createElement(
                        "label",
                        { htmlFor: "min_spent" },
                        "Min. spent Friday"
                      )
                    ),
                    React.createElement(
                      "div",
                      { className: "field" },
                      React.createElement(
                        "div",
                        { className: "text-field-medium" },
                        React.createElement("input", {
                          type: "number",
                          min: "0",
                          id: "min-spent-friday",
                          defaultValue: "0",
                          onChange: function (e) {
                            return _this.setState({ minSpentFridayValue: e.target.value });
                          },
                          style: { width: "70px" }
                        })
                      )
                    )
                  ),
                  React.createElement(
                    "div",
                    { className: "value-container" },
                    React.createElement(
                      "div",
                      { className: "field-title" },
                      React.createElement(
                        "label",
                        { htmlFor: "min_spent" },
                        "Min. spent Sat/Sun"
                      )
                    ),
                    React.createElement(
                      "div",
                      { className: "field" },
                      React.createElement(
                        "div",
                        { className: "text-field-medium" },
                        React.createElement("input", {
                          type: "number",
                          min: "0",
                          id: "min-spent-end-of-week",
                          defaultValue: "0",
                          onChange: function (e) {
                            return _this.setState({ minSpentSatSunValue: e.target.value });
                          },
                          style: { width: "70px" }
                        })
                      )
                    )
                  )
                ),
                this.submitButton()
              )
            );
          }
        }]);

        return Form;
      })(React.Component);

      App = function App(el) {
        _classCallCheck(this, App);

        this.el = $(el);

        var staffEl = this.el.find(".staff");
        var staff = staffEl.data("staff");

        this.staff = _.map(staff, function (u) {
          return { label: u[0], value: u[1] };
        });
        ReactDOM.render(React.createElement(Form, { staff: this.staff }), this.el.get(0));
      };

      setup = function setup() {
        $(document).ready(function () {
          var root = document.getElementById("user-permissions-app");
          root ? new App(root) : null;

          $("#user-permission-table").on("ajax:success", "a", function (e, data) {
            var id = data.id;
            var row = $("tr[data-id=" + id + "]");

            row.remove();
          });
        });
      };

      _export("setup", setup);
    }
  };
});
System.register("admin/mail_template", [], function (_export) {
  "use strict";

  var _ReactDraftWysiwyg, Editor, ContentState, EditorState, draftToHtml, convertToRaw, convertFromHTML, _ReactRedux, Provider, connect, _Redux, createStore, applyMiddleware, _Recompose, withState, withHandlers, compose, branch, renderComponent, INIT_STATE, reducer, SETUP, setup, CHANGE_FIELD, changeField, SAVE_START, SAVE_DONE, SAVE_FAIL, _save, saveStart, saveDone, saveFail, getToken, makeRequest, buildStore, toolbar, s2p, d2p, PlainEditor, stateFromHtml, withEditorState, addHandlers, enhance, VisualEditor, TextEditor, Form, init;

  var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

  function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

  return {
    setters: [],
    execute: function () {
      _ReactDraftWysiwyg = ReactDraftWysiwyg;
      Editor = _ReactDraftWysiwyg.Editor;
      ContentState = _ReactDraftWysiwyg.ContentState;
      EditorState = _ReactDraftWysiwyg.EditorState;
      draftToHtml = _ReactDraftWysiwyg.draftToHtml;
      convertToRaw = _ReactDraftWysiwyg.convertToRaw;
      convertFromHTML = _ReactDraftWysiwyg.convertFromHTML;
      _ReactRedux = ReactRedux;
      Provider = _ReactRedux.Provider;
      connect = _ReactRedux.connect;
      _Redux = Redux;
      createStore = _Redux.createStore;
      applyMiddleware = _Redux.applyMiddleware;
      _Recompose = Recompose;
      withState = _Recompose.withState;
      withHandlers = _Recompose.withHandlers;
      compose = _Recompose.compose;
      branch = _Recompose.branch;
      renderComponent = _Recompose.renderComponent;
      INIT_STATE = { pending: false };

      reducer = function reducer(state, action) {
        switch (action.type) {
          case SETUP:
            {
              var _action$payload = action.payload;
              var id = _action$payload.id;
              var _name = _action$payload.name;
              var title = _action$payload.title;
              var subject = _action$payload.subject;
              var raw_html = _action$payload.raw_html;
              var add_header = _action$payload.add_header;
              var text = _action$payload.text;

              return _extends({}, state, {
                id: id,
                name: _name || "",
                title: title || "",
                subject: subject || "",
                rawHTML: raw_html === undefined ? false : raw_html,
                addHeader: add_header === undefined ? false : add_header,
                text: text || ""
              });
            }

          case CHANGE_FIELD:
            {
              var _action$payload2 = action.payload;
              var field = _action$payload2.field;
              var value = _action$payload2.value;

              return _extends({}, state, _defineProperty({}, field, value));
            }

          case SAVE_START:
            {
              return _extends({}, state, { pending: true });
            }

          case SAVE_FAIL:
            {
              return _extends({}, state, { pending: false });
            }

          default:
            {
              return state;
            }
        }
      };

      SETUP = "SETUP";

      setup = function setup(payload) {
        return { type: SETUP, payload: payload };
      };

      CHANGE_FIELD = "CHANGE_FIELD";

      changeField = function changeField(payload) {
        return { type: CHANGE_FIELD, payload: payload };
      };

      SAVE_START = "SAVE_START";
      SAVE_DONE = "SAVE_DONE";
      SAVE_FAIL = "SAVE_FAIL";

      _save = function _save(dispatch, getState) {
        dispatch(saveStart());
        var req = makeRequest(getState());
        req.then(function (res) {
          if (res.status === 200) {
            window.location = "/admin/mail_templates";
          } else {
            dispatch(saveFail());
          }
        });
      };

      saveStart = function saveStart() {
        return { type: SAVE_START };
      };

      saveDone = function saveDone() {
        return { type: SAVE_DONE };
      };

      saveFail = function saveFail() {
        return { type: SAVE_FAIL };
      };

      getToken = function getToken() {
        return document.querySelector('meta[name="csrf-token"]').attributes["content"].value;
      };

      makeRequest = function makeRequest(props) {
        var token = getToken();
        var url = props.id ? "/admin/mail_templates/" + props.id : "/admin/mail_templates";

        var method = props.id ? "PUT" : "POST";

        var values = {
          name: props.name,
          subject: props.subject,
          text: props.text,
          raw_html: props.rawHTML,
          add_header: props.addHeader,
          title: props.title
        };

        var body = JSON.stringify({ mail_template: values });
        var headers = {
          "X-CSRF-Token": token,
          Accept: "application/json",
          "Content-Type": "application/json"
        };

        var params = { method: method, headers: headers, body: body, credentials: "same-origin" };
        return fetch(url, params);
      };

      buildStore = function buildStore() {
        return createStore(reducer, INIT_STATE, Redux.compose(applyMiddleware(ReduxThunk["default"]), window.devToolsExtension ? window.devToolsExtension({ name: "MailTemplate" }) : function (f) {
          return f;
        }));
      };

      toolbar = {
        options: ["inline", "link", "history"]
      };

      s2p = function s2p(state) {
        return state;
      };

      d2p = function d2p(dispatch) {
        return {
          change: function change(field) {
            return function (e) {
              return dispatch(changeField({ field: field, value: e.target.value }));
            };
          },
          changeRaw: function changeRaw(field) {
            return function (value) {
              return dispatch(changeField({ field: field, value: value }));
            };
          },
          changeBool: function changeBool(field) {
            return function (e) {
              return dispatch(changeField({ field: field, value: e.target.checked }));
            };
          },
          save: function save() {
            return dispatch(_save);
          }
        };
      };

      PlainEditor = function PlainEditor(props) {
        return React.createElement("textarea", {
          value: props.value,
          onChange: function (e) {
            return props.onChange(e.target.value);
          },
          rows: 20
        });
      };

      stateFromHtml = function stateFromHtml(html) {
        var blocks = convertFromHTML(html);
        var contentState = ContentState.createFromBlockArray(blocks);

        return EditorState.createWithContent(contentState);
      };

      withEditorState = withState("editorState", "changeEditorState", function (props) {
        return stateFromHtml(props.value);
      });
      addHandlers = withHandlers({
        setContent: function setContent(props) {
          return function (editorState) {
            var raw = convertToRaw(editorState.getCurrentContent());
            var html = draftToHtml(raw);

            props.changeEditorState(editorState);

            if (props.onChange) {
              props.onChange(html);
            }
          };
        }
      });
      enhance = compose(withEditorState, addHandlers);
      VisualEditor = enhance(function (props) {
        return React.createElement(Editor, {
          editorClassName: "html-editor",
          editorState: props.editorState,
          onEditorStateChange: props.setContent,
          toolbar: toolbar
        });
      });
      TextEditor = branch(function (props) {
        return props.raw;
      }, renderComponent(PlainEditor), renderComponent(VisualEditor))();
      Form = connect(s2p, d2p)(function (props) {
        return React.createElement(
          "form",
          { className: "mail-template" },
          React.createElement(
            "div",
            { className: "row" },
            React.createElement(
              "label",
              { htmlFor: "mail_template_name" },
              "Name"
            ),
            React.createElement(
              "div",
              { className: "text-field-medium" },
              React.createElement("input", {
                id: "mail_template_name",
                size: "30",
                value: props.name,
                onChange: props.change("name")
              })
            )
          ),
          React.createElement(
            "div",
            { className: "row" },
            React.createElement(
              "label",
              { htmlFor: "mail_template_subject" },
              "Subject"
            ),
            React.createElement(
              "div",
              { className: "text-field-medium" },
              React.createElement("input", {
                id: "mail_template_subject",
                size: "30",
                value: props.subject,
                onChange: props.change("subject")
              })
            )
          ),
          React.createElement(
            "div",
            { className: "row" },
            React.createElement(
              "label",
              null,
              React.createElement("input", {
                type: "checkbox",
                checked: props.rawHTML,
                onChange: props.changeBool("rawHTML")
              }),
              "raw HTML"
            )
          ),
          !props.rawHTML && React.createElement(
            "div",
            { className: "row" },
            React.createElement(
              "label",
              null,
              React.createElement("input", {
                type: "checkbox",
                checked: props.addHeader,
                onChange: props.changeBool("addHeader")
              }),
              "Include header"
            )
          ),
          !props.rawHTML && React.createElement(
            "div",
            { className: "row" },
            React.createElement(
              "label",
              { htmlFor: "mail_template_title" },
              "Custom title"
            ),
            React.createElement(
              "div",
              { className: "text-field-medium" },
              React.createElement("input", {
                id: "mail_template_title",
                size: "30",
                disabled: !props.addHeader,
                value: props.addHeader ? props.title : "",
                onChange: props.change("title")
              })
            )
          ),
          React.createElement(
            "div",
            { className: "row" },
            React.createElement(
              "label",
              null,
              "Text"
            ),
            React.createElement(
              "div",
              { className: "text-field-medium" },
              React.createElement(TextEditor, {
                raw: props.rawHTML,
                value: props.text,
                onChange: props.changeRaw("text")
              })
            )
          ),
          React.createElement(
            "div",
            { className: "row" },
            React.createElement(
              "a",
              {
                onClick: props.pending ? null : props.save,
                disabled: props.pending,
                className: "button-normal"
              },
              "Save"
            )
          )
        );
      });

      init = function init(data) {
        var store = buildStore();
        store.dispatch(setup(data));

        var root = document.getElementById("app_root");
        ReactDOM.render(React.createElement(
          Provider,
          { store: store },
          React.createElement(Form, null)
        ), root);
      };

      _export("default", init);
    }
  };
});
System.register("admin/user_select", ["components/dselect"], function (_export) {
  "use strict";

  var DSelect, loadUsers, SCOPE, UserSelect, init;

  var _slicedToArray = (function () { function sliceIterator(arr, i) { var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"]) _i["return"](); } finally { if (_d) throw _e; } } return _arr; } return function (arr, i) { if (Array.isArray(arr)) { return arr; } else if (Symbol.iterator in Object(arr)) { return sliceIterator(arr, i); } else { throw new TypeError("Invalid attempt to destructure non-iterable instance"); } }; })();

  return {
    setters: [function (_componentsDselect) {
      DSelect = _componentsDselect["default"];
    }],
    execute: function () {
      loadUsers = function loadUsers(input, callback) {
        var url = "/admin/users.json";
        var query = { "q[email_cont]": input };

        var ajax = $.ajax({
          url: url,
          type: "GET",
          data: query
        });

        ajax.then(function (json) {
          var options = json.map(function (u) {
            return { value: [u.email, u.id], label: u.email };
          });

          callback(null, { options: options });
        });
      };

      SCOPE = "input[rel=user-select]";

      UserSelect = function UserSelect(_ref) {
        var onChange = _ref.onChange;
        return React.createElement(DSelect, {
          width: 200,
          searchable: true,
          clearable: true,
          asyncOptions: loadUsers,
          onChange: onChange
        });
      };

      init = function init() {
        var list = document.querySelectorAll(SCOPE);
        list.forEach(function (element) {
          var root = document.createElement("div");
          var onChange = function onChange(_ref2) {
            var _ref22 = _slicedToArray(_ref2, 2);

            var email = _ref22[0];
            var id = _ref22[1];
            return element.value = id || "";
          };
          element.parentElement.insertBefore(root, element);

          ReactDOM.render(React.createElement(UserSelect, { onChange: onChange }), root);
        });
      };

      _export("default", init);
    }
  };
});
System.register('admin/did_destinations', [], function (_export) {
  'use strict';

  var init, setup;
  return {
    setters: [],
    execute: function () {
      init = function init() {

        var sorted = function sorted() {
          var items = $.map($('.destination-list li'), function (e) {
            return $(e).attr('rel');
          });
          var url = '/admin/dids/' + window.did_id + '/did_destinations/sort';

          $.ajax({
            url: url,
            type: 'post',
            dataType: 'json',
            data: {
              did_destinations: items
            }
          });
        };

        var toggle = function toggle(e) {
          var id = $(e.target).parents('li').attr('rel');
          var url = '/admin/dids/' + window.did_id + '/did_destinations/' + id + '/toggle';

          $.post(url);
        };

        var srtp_toggle = function srtp_toggle(e) {
          var id = $(e.target).parents('li').attr('rel');
          var url = '/admin/dids/' + window.did_id + '/did_destinations/' + id + '/srtp_toggle';

          $.post(url);
        };

        var callhunt_toggle = function callhunt_toggle(e) {
          var id = $(e.target).parents('li').attr('rel');
          var url = '/admin/dids/' + window.did_id + '/did_destinations/' + id + '/callhunt';

          $.post(url);
        };

        var destroy = function destroy(e) {
          var id = $(e.target).parents('li').attr('rel');
          var url = '/admin/dids/' + window.did_id + '/did_destinations/' + id;

          $.post(url, { _method: 'delete' });
        };

        var changed_transport = function changed_transport() {
          if ($('#did_destination_transport').val() === '5') {
            $('#did_destination_destination').hide();
            $('#did_destination_destination_account').show();
          } else {
            $('#did_destination_destination').show();
            $('#did_destination_destination_account').hide();
          }
        };

        $('.destination-list').sortable({ axis: 'y', update: sorted, handle: '.handle' });
        $('.destination-list li a.enabled').live('click', toggle);
        $('.destination-list li a.srtp').live('click', srtp_toggle);
        $('.destination-list li a.call-type').live('click', callhunt_toggle);
        $('.destination-list li a.remove').live('click', destroy);

        $('#did_destination_transport').on('change', changed_transport);
        $('#did_destination_destination_account').hide();
      };

      setup = function setup() {
        return $(document).ready(init);
      };

      _export('setup', setup);
    }
  };
});
function setClipboardEvents() {
  $('#copy_new_dids').click(function() {
    $('#new_dids').select()
    document.execCommand("copy")
  })

  $('#copy_attended_dids').click(function() {
    $('#attended_dids').select()
    document.execCommand("copy")
  })
}
;
System.register('admin/components/duration-widget', [], function (_export) {
  'use strict';

  var DurationGraph, DurationTable, DurationWidget;

  var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

  var _createClass = (function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ('value' in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; })();

  var _get = function get(_x, _x2, _x3) { var _again = true; _function: while (_again) { var object = _x, property = _x2, receiver = _x3; _again = false; if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { _x = parent; _x2 = property; _x3 = receiver; _again = true; desc = parent = undefined; continue _function; } } else if ('value' in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } } };

  function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError('Cannot call a class as a function'); } }

  function _inherits(subClass, superClass) { if (typeof superClass !== 'function' && superClass !== null) { throw new TypeError('Super expression must either be null or a function, not ' + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

  return {
    setters: [],
    execute: function () {
      DurationGraph = (function (_React$Component) {
        _inherits(DurationGraph, _React$Component);

        function DurationGraph() {
          _classCallCheck(this, DurationGraph);

          _get(Object.getPrototypeOf(DurationGraph.prototype), 'constructor', this).apply(this, arguments);
        }

        _createClass(DurationGraph, [{
          key: 'setHidden',
          value: function setHidden(name) {
            var storage = window.localStorage;
            if (!storage) {
              return;
            }

            var json = storage['durationGraph'];
            var data = json ? JSON.parse(json) : {};

            data[name] = true;
            storage['durationGraph'] = JSON.stringify(data);
          }
        }, {
          key: 'setVisible',
          value: function setVisible(name) {
            var storage = window.localStorage;
            if (!storage) {
              return;
            }

            var json = storage['durationGraph'];
            var data = json ? JSON.parse(json) : {};

            delete data[name];
            storage['durationGraph'] = JSON.stringify(data);
          }
        }, {
          key: 'isVisible',
          value: function isVisible(name) {
            var storage = window.localStorage;
            if (!storage) {
              return true;
            }

            var json = storage['durationGraph'];
            var data = json ? JSON.parse(json) : {};

            return !data[name];
          }
        }, {
          key: 'componentDidMount',
          value: function componentDidMount() {
            var _this = this;

            var el = ReactDOM.findDOMNode(this);
            if (!this.props.data) {
              return;
            }

            var series = this.props.data.map(function (s) {
              return _extends({}, s, { visible: _this.isVisible(s.name) });
            });

            var self = this;

            var options = {
              chart: {
                renderTo: el
              },

              plotOptions: {
                line: {
                  events: {
                    show: function show() {
                      self.setVisible(this.name);
                    },
                    hide: function hide() {
                      self.setHidden(this.name);
                    }
                  }
                },
                series: {
                  point: {
                    events: {
                      click: function click(e) {
                        if (!self.props.email) {
                          return;
                        }
                        var date = moment(e.point.x).format("YYYY-MM-DD");
                        var url = "/admin/destination_metrics?primary[user_email_contains]=" + self.props.email + '&primary[date][from]=' + date + '&primary[date][to]=' + date;
                        window.open(url, '_blank');
                      }
                    }
                  }
                }
              },
              title: {
                text: 'Inbound and Outbound durations'
              },
              xAxis: {
                type: 'datetime'
              },
              yAxis: {
                title: {
                  text: 'Duration'
                },
                min: 0
              },
              legend: {
                labelFormatter: function labelFormatter() {
                  return this.name.replace(self.props.email + "-", '');
                }
              },
              tooltip: {
                useHTML: true,
                formatter: function formatter() {

                  //boom\

                  var tooltip = [];
                  tooltip.push(moment(this.x).format("ddd, MMM D, YYYY"));
                  tooltip.push('----------------');
                  var inbound_tooltip = [];
                  var outbound_tooltip = [];
                  var sum_tooltip = [];

                  var all_points = [];

                  for (var serie_index in series) {
                    var serie_obj = series[serie_index];

                    var point = serie_obj.data[this.point.index];
                    var tooltip_row = '';

                    var serie_name = serie_obj.name.replace(self.props.email + "-", '');

                    if (self.props.email) {
                      tooltip_row = serie_obj.name.replace(self.props.email + "-", '') + ': ' + point[1].toFixed(2);
                    } else {
                      tooltip_row = serie_obj.name + ': ' + point[1].toFixed(2);
                    }
                    if (serie_obj.name == this.series.name) {
                      tooltip_row = '<b>' + tooltip_row + '</b>';
                    }

                    switch (serie_obj.name) {
                      case 'Inbound duration':
                        inbound_tooltip.push(tooltip_row);
                        break;
                      case 'Outbound duration':
                        outbound_tooltip.push(tooltip_row);
                        break;
                      case 'Total duration':
                        sum_tooltip.push(tooltip_row);
                        break;
                    }

                    all_points[serie_name] = point[1];
                  }

                  var sort_function = function sort_function(a, b) {
                    if (a.match('<b>')) {
                      return -1;
                    }
                    if (b.match('<b>')) {
                      return 1;
                    }
                    return 0;
                  };

                  outbound_tooltip = outbound_tooltip.sort(sort_function);
                  inbound_tooltip = inbound_tooltip.sort(sort_function);
                  sum_tooltip = sum_tooltip.sort(sort_function);

                  var points_tooltip = [];

                  points_tooltip.push(outbound_tooltip.join('<br />'));
                  points_tooltip.push(inbound_tooltip.join('<br />'));
                  points_tooltip.push(sum_tooltip.join('<br />'));

                  tooltip.push(points_tooltip.sort(sort_function).join('<br />----------------<br />'));

                  return tooltip.join('<br />');
                }
              },
              series: series
            };

            new Highcharts.Chart(options);
          }
        }, {
          key: 'render',
          value: function render() {
            return React.createElement('div', { className: 'graph' });
          }
        }]);

        return DurationGraph;
      })(React.Component);

      DurationTable = function DurationTable(_ref) {
        var data = _ref.data;
        var email = _ref.email;
        return React.createElement(
          'table',
          { className: 'duration-table' },
          React.createElement(
            'thead',
            null,
            React.createElement(
              'tr',
              null,
              React.createElement('th', null),
              React.createElement(
                'th',
                null,
                'Inbound'
              ),
              React.createElement(
                'th',
                null,
                'Outbound'
              ),
              React.createElement(
                'th',
                null,
                'Total'
              )
            )
          ),
          React.createElement(
            'tbody',
            null,
            React.createElement(
              'tr',
              { className: 'total' },
              React.createElement(
                'td',
                null,
                email
              ),
              React.createElement(
                'td',
                null,
                data.inbound.toFixed(2)
              ),
              React.createElement(
                'td',
                null,
                data.outbound.toFixed(2)
              ),
              React.createElement(
                'td',
                null,
                (data.inbound + data.outbound).toFixed(2)
              )
            )
          )
        );
      };

      DurationWidget = function DurationWidget(props) {
        return React.createElement(
          'div',
          null,
          React.createElement(DurationGraph, { data: props.data, user: props.id, email: props.email }),
          React.createElement(DurationTable, { data: props.total, email: props.email })
        );
      };

      _export('default', DurationWidget);
    }
  };
});
System.register('admin/components/markup-margin-widget', [], function (_export) {
  'use strict';

  var MarkupMarginGraph, MarkupMarginTable, MarkupMarginWidget;

  var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

  var _createClass = (function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ('value' in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; })();

  var _get = function get(_x, _x2, _x3) { var _again = true; _function: while (_again) { var object = _x, property = _x2, receiver = _x3; _again = false; if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { _x = parent; _x2 = property; _x3 = receiver; _again = true; desc = parent = undefined; continue _function; } } else if ('value' in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } } };

  function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError('Cannot call a class as a function'); } }

  function _inherits(subClass, superClass) { if (typeof superClass !== 'function' && superClass !== null) { throw new TypeError('Super expression must either be null or a function, not ' + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

  return {
    setters: [],
    execute: function () {
      MarkupMarginGraph = (function (_React$Component) {
        _inherits(MarkupMarginGraph, _React$Component);

        function MarkupMarginGraph() {
          _classCallCheck(this, MarkupMarginGraph);

          _get(Object.getPrototypeOf(MarkupMarginGraph.prototype), 'constructor', this).apply(this, arguments);
        }

        _createClass(MarkupMarginGraph, [{
          key: 'setHidden',
          value: function setHidden(name) {
            var storage = window.localStorage;
            if (!storage) {
              return;
            }

            var json = storage['profitGraph'];
            var data = json ? JSON.parse(json) : {};

            data[name] = true;
            storage['profitGraph'] = JSON.stringify(data);
          }
        }, {
          key: 'setVisible',
          value: function setVisible(name) {
            var storage = window.localStorage;
            if (!storage) {
              return;
            }

            var json = storage['profitGraph'];
            var data = json ? JSON.parse(json) : {};

            delete data[name];
            storage['profitGraph'] = JSON.stringify(data);
          }
        }, {
          key: 'isVisible',
          value: function isVisible(name) {
            var storage = window.localStorage;
            if (!storage) {
              return true;
            }

            var json = storage['profitGraph'];
            var data = json ? JSON.parse(json) : {};

            return !data[name];
          }
        }, {
          key: 'componentDidMount',
          value: function componentDidMount() {
            var _this = this;

            var el = ReactDOM.findDOMNode(this);
            if (!this.props.data) {
              return;
            }

            var series = this.props.data.map(function (s) {
              return _extends({}, s, { visible: _this.isVisible(s.name) });
            });

            var self = this;

            var options = {
              chart: {
                renderTo: el
              },

              plotOptions: {
                line: {
                  events: {
                    show: function show() {
                      self.setVisible(this.name);
                    },
                    hide: function hide() {
                      self.setHidden(this.name);
                    }
                  }
                },
                series: {
                  point: {
                    events: {
                      click: function click(e) {
                        if (!_this.props.email) {
                          return;
                        }
                        var date = moment(e.point.x).format("YYYY-MM-DD");
                        var url = "/admin/destination_metrics?primary[user_email_cont]=" + _this.props.email + '&primary[date][from]=' + date + '&primary[date][to]=' + date;
                        window.open(url, '_blank');
                      }
                    }
                  }
                }
              },
              title: {
                text: 'Markup and margin'
              },
              xAxis: {
                type: 'datetime'
              },
              yAxis: {
                title: {
                  text: '%'
                }
              },
              legend: {
                labelFormatter: function labelFormatter() {
                  return this.name.replace(self.props.email + "-", '');
                }
              },
              tooltip: {
                useHTML: true,
                formatter: function formatter() {

                  //boom\

                  var tooltip = [];
                  tooltip.push(moment(this.x).format("ddd, MMM D, YYYY"));
                  tooltip.push('----------------');
                  var inbound_tooltip = [];
                  var outbound_tooltip = [];

                  var all_points = [];

                  for (var serie_index in series) {
                    var serie_obj = series[serie_index];

                    var point = serie_obj.data[this.point.index];
                    var tooltip_row = '';

                    var serie_name = serie_obj.name.replace(self.props.email + "-", '');

                    if (self.props.email) {
                      tooltip_row = serie_obj.name.replace(self.props.email + "-", '') + ": " + $.sprintf('%.2f%', point[1]);
                    } else {
                      tooltip_row = serie_obj.name + ": " + $.sprintf('%.2f%', point[1]);
                    }

                    if (serie_obj.name == this.series.name) {
                      tooltip_row = '<b>' + tooltip_row + '</b>';
                    }

                    if (serie_obj.name.match('Inbound')) {
                      inbound_tooltip.push(tooltip_row);
                    } else {
                      outbound_tooltip.push(tooltip_row);
                    }
                    all_points[serie_name] = point[1];
                  }

                  if (self.props.email) {

                    var outbound_markup = all_points['Outbound markup'];
                    var inbound_markup = all_points['Inbound markup'];
                    var outbound_margin = all_points['Outbound margin'];
                    var inbound_margin = all_points['Inbound margin'];

                    if (outbound_markup != 0) {
                      outbound_tooltip.push($.sprintf('Markup: %.2f%', outbound_markup));
                    }

                    if (outbound_margin != 0) {
                      outbound_tooltip.push($.sprintf('Margin: %.2f%', outbound_margin));
                    }

                    if (inbound_margin != 0) {
                      inbound_tooltip.push($.sprintf('Markup: %.2f%', inbound_markup));
                    }

                    if (inbound_margin != 0) {
                      inbound_tooltip.push($.sprintf('Margin: %.2f%', inbound_margin));
                    }
                  }

                  var sort_function = function sort_function(a, b) {
                    if (a.match('<b>')) {
                      return -1;
                    }
                    if (b.match('<b>')) {
                      return 1;
                    }
                    return 0;
                  };

                  outbound_tooltip = outbound_tooltip.sort(sort_function);
                  inbound_tooltip = inbound_tooltip.sort(sort_function);

                  var points_tooltip = [];
                  points_tooltip.push(outbound_tooltip.join('<br />'));
                  points_tooltip.push(inbound_tooltip.join('<br />'));

                  tooltip.push(points_tooltip.sort(sort_function).join('<br />----------------<br />'));

                  return tooltip.join('<br />');
                }
              },
              series: series
            };
            new Highcharts.Chart(options);
          }
        }, {
          key: 'render',
          value: function render() {
            return React.createElement('div', { className: 'graph' });
          }
        }]);

        return MarkupMarginGraph;
      })(React.Component);

      MarkupMarginTable = function MarkupMarginTable(_ref) {
        var data = _ref.data;
        return React.createElement(
          'table',
          { className: 'markup-margin-table' },
          React.createElement(
            'thead',
            null,
            React.createElement(
              'tr',
              null,
              React.createElement('th', null),
              React.createElement(
                'th',
                null,
                'Markup'
              ),
              React.createElement(
                'th',
                null,
                'Margin'
              )
            )
          ),
          React.createElement(
            'tbody',
            null,
            _.map(data, function (values, email) {
              return React.createElement(
                'tr',
                { key: email },
                React.createElement(
                  'td',
                  null,
                  email
                ),
                React.createElement(
                  'td',
                  null,
                  $.sprintf('%.2f%', values.markup)
                ),
                React.createElement(
                  'td',
                  null,
                  $.sprintf('%.2f%', values.margin)
                )
              );
            }),
            data && data.length > 1 && React.createElement(
              'tr',
              { className: 'total' },
              React.createElement(
                'td',
                null,
                'Total:'
              ),
              React.createElement(
                'td',
                null,
                accounting.formatMoney(_.sum(_.map(data, function (values, email) {
                  return values.spent / (values.profit - values.spent - 1);
                })) * 100, '%', 0)
              ),
              React.createElement(
                'td',
                null,
                accounting.formatMoney(_.sum(_.map(data, function (values, email) {
                  return values.profit / values.spent;
                })) * 100, '%', 0)
              )
            )
          )
        );
      };

      MarkupMarginWidget = function MarkupMarginWidget(props) {
        return React.createElement(
          'div',
          null,
          React.createElement(MarkupMarginGraph, { data: props.data, user: props.id, email: props.email }),
          React.createElement(MarkupMarginTable, { data: props.total })
        );
      };

      _export('default', MarkupMarginWidget);
    }
  };
});
System.register('admin/components/profit-widget', [], function (_export) {
  'use strict';

  var ProfitGraph, ProfitTable, ProfitWidget;

  var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

  var _createClass = (function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ('value' in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; })();

  var _get = function get(_x, _x2, _x3) { var _again = true; _function: while (_again) { var object = _x, property = _x2, receiver = _x3; _again = false; if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { _x = parent; _x2 = property; _x3 = receiver; _again = true; desc = parent = undefined; continue _function; } } else if ('value' in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } } };

  function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError('Cannot call a class as a function'); } }

  function _inherits(subClass, superClass) { if (typeof superClass !== 'function' && superClass !== null) { throw new TypeError('Super expression must either be null or a function, not ' + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

  return {
    setters: [],
    execute: function () {
      ProfitGraph = (function (_React$Component) {
        _inherits(ProfitGraph, _React$Component);

        function ProfitGraph() {
          _classCallCheck(this, ProfitGraph);

          _get(Object.getPrototypeOf(ProfitGraph.prototype), 'constructor', this).apply(this, arguments);
        }

        _createClass(ProfitGraph, [{
          key: 'setHidden',
          value: function setHidden(name) {
            var storage = window.localStorage;
            if (!storage) {
              return;
            }

            var json = storage['profitGraph'];
            var data = json ? JSON.parse(json) : {};

            data[name] = true;
            storage['profitGraph'] = JSON.stringify(data);
          }
        }, {
          key: 'setVisible',
          value: function setVisible(name) {
            var storage = window.localStorage;
            if (!storage) {
              return;
            }

            var json = storage['profitGraph'];
            var data = json ? JSON.parse(json) : {};

            delete data[name];
            storage['profitGraph'] = JSON.stringify(data);
          }
        }, {
          key: 'isVisible',
          value: function isVisible(name) {
            var storage = window.localStorage;
            if (!storage) {
              return true;
            }

            var json = storage['profitGraph'];
            var data = json ? JSON.parse(json) : {};

            return !data[name];
          }
        }, {
          key: 'componentDidMount',
          value: function componentDidMount() {
            var _this = this;

            var el = ReactDOM.findDOMNode(this);
            if (!this.props.data) {
              return;
            }

            var series = this.props.data.map(function (s) {
              return _extends({}, s, { visible: _this.isVisible(s.name) });
            });

            var self = this;

            var options = {
              chart: {
                renderTo: el
              },

              plotOptions: {
                line: {
                  events: {
                    show: function show() {
                      self.setVisible(this.name);
                    },
                    hide: function hide() {
                      self.setHidden(this.name);
                    }
                  }
                },
                series: {
                  point: {
                    events: {
                      click: function click(e) {
                        if (!self.props.email) {
                          return;
                        }
                        var date = moment(e.point.x).format("YYYY-MM-DD");
                        var url = "/admin/destination_metrics?primary[user_email_cont]=" + self.props.email + '&primary[date][from]=' + date + '&primary[date][to]=' + date;
                        window.open(url, '_blank');
                      }
                    }
                  }
                }
              },
              title: {
                text: 'Profit and spent'
              },
              xAxis: {
                type: 'datetime'
              },
              yAxis: {
                title: {
                  text: 'Profit'
                },
                min: 0
              },
              legend: {
                labelFormatter: function labelFormatter() {
                  return this.name.replace(self.props.email + "-", '');
                }
              },
              tooltip: {
                useHTML: true,
                formatter: function formatter() {

                  //boom\

                  var tooltip = [];
                  tooltip.push(moment(this.x).format("ddd, MMM D, YYYY"));
                  tooltip.push('----------------');
                  var inbound_tooltip = [];
                  var outbound_tooltip = [];

                  var all_points = [];

                  for (var serie_index in series) {
                    var serie_obj = series[serie_index];

                    var point = serie_obj.data[this.point.index];
                    var tooltip_row = '';

                    var serie_name = serie_obj.name.replace(self.props.email + "-", '');

                    if (self.props.email) {
                      tooltip_row = serie_obj.name.replace(self.props.email + "-", '') + ": $" + point[1];
                    } else {
                      tooltip_row = serie_obj.name + ": $" + point[1];
                    }
                    if (serie_obj.name == this.series.name) {
                      tooltip_row = '<b>' + tooltip_row + '</b>';
                    }

                    if (serie_obj.name.match('Inbound')) {
                      inbound_tooltip.push(tooltip_row);
                    } else {
                      outbound_tooltip.push(tooltip_row);
                    }

                    all_points[serie_name] = point[1];
                  }

                  if (self.props.email) {
                    var outbound_markup = 0;
                    if (all_points['Outbound spent'] - all_points['Outbound profit'] != 0) {
                      outbound_markup = all_points['Outbound profit'] / (all_points['Outbound spent'] - all_points['Outbound profit']);
                    }

                    var inbound_markup = 0;
                    if (all_points['Inbound spent'] - all_points['Inbound profit'] != 0) {
                      inbound_markup = all_points['Inbound profit'] / (all_points['Inbound spent'] - all_points['Inbound profit']);
                    }

                    if (outbound_markup != 0) {
                      outbound_tooltip.push($.sprintf('Markup: %.2f%', outbound_markup * 100));
                    }

                    if (inbound_markup != 0) {
                      inbound_tooltip.push($.sprintf('Markup: %.2f%', inbound_markup * 100));
                    }
                  }

                  var sort_function = function sort_function(a, b) {
                    if (a.match('<b>')) {
                      return -1;
                    }
                    if (b.match('<b>')) {
                      return 1;
                    }
                    return 0;
                  };

                  outbound_tooltip = outbound_tooltip.sort(sort_function);
                  inbound_tooltip = inbound_tooltip.sort(sort_function);

                  var points_tooltip = [];

                  points_tooltip.push(outbound_tooltip.join('<br />'));
                  points_tooltip.push(inbound_tooltip.join('<br />'));

                  tooltip.push(points_tooltip.sort(sort_function).join('<br />----------------<br />'));

                  return tooltip.join('<br />');
                }
              },
              series: series
            };

            new Highcharts.Chart(options);
          }
        }, {
          key: 'render',
          value: function render() {
            return React.createElement('div', { className: 'graph' });
          }
        }]);

        return ProfitGraph;
      })(React.Component);

      ProfitTable = function ProfitTable(_ref) {
        var data = _ref.data;
        return React.createElement(
          'table',
          { className: 'profit-table' },
          React.createElement(
            'thead',
            null,
            React.createElement(
              'tr',
              null,
              React.createElement('th', null),
              React.createElement(
                'th',
                null,
                'Spent'
              ),
              React.createElement(
                'th',
                null,
                'Profit'
              )
            )
          ),
          React.createElement(
            'tbody',
            null,
            _.map(data, function (values, email) {
              return React.createElement(
                'tr',
                { key: email },
                React.createElement(
                  'td',
                  null,
                  email
                ),
                React.createElement(
                  'td',
                  null,
                  accounting.formatMoney(values.spent / 100, '$', 0)
                ),
                React.createElement(
                  'td',
                  null,
                  accounting.formatMoney(values.profit / 100, '$', 0)
                )
              );
            }),
            data && data.length > 1 && React.createElement(
              'tr',
              { className: 'total' },
              React.createElement(
                'td',
                null,
                'Total:'
              ),
              React.createElement(
                'td',
                null,
                accounting.formatMoney(_.sum(_.map(data, function (values, email) {
                  return values.spent;
                })) / 100, '$', 0)
              ),
              React.createElement(
                'td',
                null,
                accounting.formatMoney(_.sum(_.map(data, function (values, email) {
                  return values.profit;
                })) / 100, '$', 0)
              )
            )
          )
        );
      };

      ProfitWidget = function ProfitWidget(props) {
        return React.createElement(
          'div',
          null,
          React.createElement(ProfitGraph, { data: props.data, user: props.id, email: props.email }),
          React.createElement(ProfitTable, { data: props.total })
        );
      };

      _export('default', ProfitWidget);
    }
  };
});
System.register('admin/components/users-widget', ['components/shared/calendar'], function (_export) {
  'use strict';

  var Calendar, UsersGraph, UsersWidget;

  var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

  var _createClass = (function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ('value' in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; })();

  var _get = function get(_x, _x2, _x3) { var _again = true; _function: while (_again) { var object = _x, property = _x2, receiver = _x3; _again = false; if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { _x = parent; _x2 = property; _x3 = receiver; _again = true; desc = parent = undefined; continue _function; } } else if ('value' in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } } };

  function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError('Cannot call a class as a function'); } }

  function _inherits(subClass, superClass) { if (typeof superClass !== 'function' && superClass !== null) { throw new TypeError('Super expression must either be null or a function, not ' + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

  return {
    setters: [function (_componentsSharedCalendar) {
      Calendar = _componentsSharedCalendar['default'];
    }],
    execute: function () {
      UsersGraph = (function (_React$Component) {
        _inherits(UsersGraph, _React$Component);

        function UsersGraph() {
          _classCallCheck(this, UsersGraph);

          _get(Object.getPrototypeOf(UsersGraph.prototype), 'constructor', this).apply(this, arguments);
        }

        _createClass(UsersGraph, [{
          key: 'componentDidMount',
          value: function componentDidMount() {
            var el = ReactDOM.findDOMNode(this);

            if (!this.props.data) {
              return;
            }

            var series = this.props.data.map(function (s) {
              return _extends({}, s);
            });

            var self = this;

            var options = {
              chart: {
                renderTo: el
              },

              plotOptions: {
                visible: false
              },

              title: {
                text: 'New registrations'
              },

              xAxis: {
                type: 'datetime'
              },

              yAxis: {
                title: {
                  text: 'Users'
                },
                min: 0
              },
              series: series
            };

            new Highcharts.Chart(options);
          }
        }, {
          key: 'render',
          value: function render() {
            return React.createElement('div', { className: 'graph' });
          }
        }]);

        return UsersGraph;
      })(React.Component);

      UsersWidget = function UsersWidget(props) {
        return React.createElement(
          'div',
          null,
          React.createElement(Calendar, { dates: props.dates, onChange: props.callback }),
          React.createElement(UsersGraph, { data: props.data })
        );
      };

      _export('default', UsersWidget);
    }
  };
});
System.register("did-exact-prices/client_select", ["components/dselect"], function (_export) {
  "use strict";

  var DSelect, loadUsers, SCOPE, ClientSelect, init;

  var _slicedToArray = (function () { function sliceIterator(arr, i) { var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"]) _i["return"](); } finally { if (_d) throw _e; } } return _arr; } return function (arr, i) { if (Array.isArray(arr)) { return arr; } else if (Symbol.iterator in Object(arr)) { return sliceIterator(arr, i); } else { throw new TypeError("Invalid attempt to destructure non-iterable instance"); } }; })();

  return {
    setters: [function (_componentsDselect) {
      DSelect = _componentsDselect["default"];
    }],
    execute: function () {
      loadUsers = function loadUsers(input, callback) {
        var url = "did_exact_prices/clients_with_exact_prices.json";
        var query = { "q[email_cont]": input };

        var ajax = $.ajax({
          url: url,
          type: "GET",
          data: query
        });

        ajax.then(function (json) {
          console.log(options);
          var options = json.map(function (u) {
            return { value: [u.email, u.id], label: u.email };
          });

          callback(null, { options: options });
        });
      };

      SCOPE = "input[rel=client-select]";

      ClientSelect = function ClientSelect(_ref) {
        var onChange = _ref.onChange;
        return React.createElement(DSelect, {
          width: 200,
          searchable: true,
          clearable: true,
          asyncOptions: loadUsers,
          onChange: onChange
        });
      };

      init = function init() {
        var list = document.querySelectorAll(SCOPE);
        list.forEach(function (element) {
          var root = document.createElement("div");
          var onChange = function onChange(_ref2) {
            var _ref22 = _slicedToArray(_ref2, 2);

            var email = _ref22[0];
            var id = _ref22[1];
            return element.value = id || "";
          };
          element.parentElement.insertBefore(root, element);

          ReactDOM.render(React.createElement(ClientSelect, { onChange: onChange }), root);
        });
      };

      _export("default", init);
    }
  };
});
var ReactDraftWysiwyg=function(t){function e(r){if(n[r])return n[r].exports;var o=n[r]={i:r,l:!1,exports:{}};return t[r].call(o.exports,o,o.exports,e),o.l=!0,o.exports}var n={};return e.m=t,e.c=n,e.d=function(t,n,r){e.o(t,n)||Object.defineProperty(t,n,{configurable:!1,enumerable:!0,get:r})},e.n=function(t){var n=t&&t.__esModule?function(){return t.default}:function(){return t};return e.d(n,"a",n),n},e.o=function(t,e){return Object.prototype.hasOwnProperty.call(t,e)},e.p="",e(e.s=72)}([function(t,e){t.exports=React},function(t,e,n){"use strict";"function"==typeof Symbol&&Symbol.iterator;t.exports=n(75)()},function(t,e,n){"use strict";function r(t,e,n,r,i,a,s,u){if(o(e),!t){var c;if(void 0===e)c=new Error("Minified exception occurred; use the non-minified dev environment for the full error message and additional helpful warnings.");else{var l=[n,r,i,a,s,u],f=0;c=new Error(e.replace(/%s/g,function(){return l[f++]})),c.name="Invariant Violation"}throw c.framesToPop=1,c}}var o=function(t){};t.exports=r},function(t,e,n){"use strict";function r(t,e){if(!(t instanceof e))throw new TypeError("Cannot call a class as a function")}function o(t,e,n){return C.set(t,{selection:e,forceSelection:n,nativelyRenderedContent:null,inlineStyleOverride:null})}function i(t,e){return t.getBlockMap().map(function(n){return g.generate(t,n,e)}).toOrderedMap()}function a(t,e,n,r){var o=t.getCurrentContent().set("entityMap",n),i=o.getBlockMap();return t.getImmutable().get("treeMap").merge(e.toSeq().filter(function(t,e){return t!==i.get(e)}).map(function(t){return g.generate(o,t,r)}))}function s(t,e,n,r,o){return n.merge(e.toSeq().filter(function(e){return r.getDecorations(e,t)!==o.getDecorations(e,t)}).map(function(e){return g.generate(t,e,r)}))}function u(t,e){return e!==t.getLastChangeType()||"insert-characters"!==e&&"backspace-character"!==e&&"delete-character"!==e}function c(t,e){var n=e.getStartKey(),r=e.getStartOffset(),o=t.getBlockForKey(n);return r>0?o.getInlineStyleAt(r-1):o.getLength()?o.getInlineStyleAt(0):f(t,n)}function l(t,e){var n=e.getStartKey(),r=e.getStartOffset(),o=t.getBlockForKey(n);return r<o.getLength()?o.getInlineStyleAt(r):r>0?o.getInlineStyleAt(r-1):f(t,n)}function f(t,e){for(var n,r=t.getBlockBefore(e);r;){if(n=r.getLength())return r.getInlineStyleAt(n-1);r=t.getBlockBefore(r.getKey())}return I()}var p=n(18),d=p||function(t){for(var e=1;e<arguments.length;e++){var n=arguments[e];for(var r in n)Object.prototype.hasOwnProperty.call(n,r)&&(t[r]=n[r])}return t},g=n(47),M=n(32),h=n(89),y=n(4),m=n(22),I=y.OrderedSet,w=y.Record,D=y.Stack,N={allowUndo:!0,currentContent:null,decorator:null,directionMap:null,forceSelection:!1,inCompositionMode:!1,inlineStyleOverride:null,lastChangeType:null,nativelyRenderedContent:null,redoStack:D(),selection:null,treeMap:null,undoStack:D()},v=w(N),C=function(){function t(e){r(this,t),this._immutable=e}return t.createEmpty=function(e){return t.createWithContent(M.createFromText(""),e)},t.createWithContent=function(e,n){var r=e.getBlockMap().first().getKey();return t.create({currentContent:e,undoStack:D(),redoStack:D(),decorator:n||null,selection:m.createEmpty(r)})},t.create=function(e){var n=e.currentContent,r=e.decorator,o=d({},e,{treeMap:i(n,r),directionMap:h.getDirectionMap(n)});return new t(new v(o))},t.set=function(e,n){return new t(e.getImmutable().withMutations(function(t){var r=t.get("decorator"),o=r;null===n.decorator?o=null:n.decorator&&(o=n.decorator);var u=n.currentContent||e.getCurrentContent();if(o!==r){var c,l=t.get("treeMap");return c=o&&r?s(u,u.getBlockMap(),l,o,r):i(u,o),void t.merge({decorator:o,treeMap:c,nativelyRenderedContent:null})}u!==e.getCurrentContent()&&t.set("treeMap",a(e,u.getBlockMap(),u.getEntityMap(),o)),t.merge(n)}))},t.prototype.toJS=function(){return this.getImmutable().toJS()},t.prototype.getAllowUndo=function(){return this.getImmutable().get("allowUndo")},t.prototype.getCurrentContent=function(){return this.getImmutable().get("currentContent")},t.prototype.getUndoStack=function(){return this.getImmutable().get("undoStack")},t.prototype.getRedoStack=function(){return this.getImmutable().get("redoStack")},t.prototype.getSelection=function(){return this.getImmutable().get("selection")},t.prototype.getDecorator=function(){return this.getImmutable().get("decorator")},t.prototype.isInCompositionMode=function(){return this.getImmutable().get("inCompositionMode")},t.prototype.mustForceSelection=function(){return this.getImmutable().get("forceSelection")},t.prototype.getNativelyRenderedContent=function(){return this.getImmutable().get("nativelyRenderedContent")},t.prototype.getLastChangeType=function(){return this.getImmutable().get("lastChangeType")},t.prototype.getInlineStyleOverride=function(){return this.getImmutable().get("inlineStyleOverride")},t.setInlineStyleOverride=function(e,n){return t.set(e,{inlineStyleOverride:n})},t.prototype.getCurrentInlineStyle=function(){var t=this.getInlineStyleOverride();if(null!=t)return t;var e=this.getCurrentContent(),n=this.getSelection();return n.isCollapsed()?c(e,n):l(e,n)},t.prototype.getBlockTree=function(t){return this.getImmutable().getIn(["treeMap",t])},t.prototype.isSelectionAtStartOfContent=function(){var t=this.getCurrentContent().getBlockMap().first().getKey();return this.getSelection().hasEdgeWithin(t,0,0)},t.prototype.isSelectionAtEndOfContent=function(){var t=this.getCurrentContent(),e=t.getBlockMap(),n=e.last(),r=n.getLength();return this.getSelection().hasEdgeWithin(n.getKey(),r,r)},t.prototype.getDirectionMap=function(){return this.getImmutable().get("directionMap")},t.acceptSelection=function(t,e){return o(t,e,!1)},t.forceSelection=function(t,e){return e.getHasFocus()||(e=e.set("hasFocus",!0)),o(t,e,!0)},t.moveSelectionToEnd=function(e){var n=e.getCurrentContent(),r=n.getLastBlock(),o=r.getKey(),i=r.getLength();return t.acceptSelection(e,new m({anchorKey:o,anchorOffset:i,focusKey:o,focusOffset:i,isBackward:!1}))},t.moveFocusToEnd=function(e){var n=t.moveSelectionToEnd(e);return t.forceSelection(n,n.getSelection())},t.push=function(e,n,r){if(e.getCurrentContent()===n)return e;var o="insert-characters"!==r,i=h.getDirectionMap(n,e.getDirectionMap());if(!e.getAllowUndo())return t.set(e,{currentContent:n,directionMap:i,lastChangeType:r,selection:n.getSelectionAfter(),forceSelection:o,inlineStyleOverride:null});var a=e.getSelection(),s=e.getCurrentContent(),c=e.getUndoStack(),l=n;a!==s.getSelectionAfter()||u(e,r)?(c=c.push(s),l=l.set("selectionBefore",a)):"insert-characters"!==r&&"backspace-character"!==r&&"delete-character"!==r||(l=l.set("selectionBefore",s.getSelectionBefore()));var f=e.getInlineStyleOverride();-1===["adjust-depth","change-block-type","split-block"].indexOf(r)&&(f=null);var p={currentContent:l,directionMap:i,undoStack:c,redoStack:D(),lastChangeType:r,selection:n.getSelectionAfter(),forceSelection:o,inlineStyleOverride:f};return t.set(e,p)},t.undo=function(e){if(!e.getAllowUndo())return e;var n=e.getUndoStack(),r=n.peek();if(!r)return e;var o=e.getCurrentContent(),i=h.getDirectionMap(r,e.getDirectionMap());return t.set(e,{currentContent:r,directionMap:i,undoStack:n.shift(),redoStack:e.getRedoStack().push(o),forceSelection:!0,inlineStyleOverride:null,lastChangeType:"undo",nativelyRenderedContent:null,selection:o.getSelectionBefore()})},t.redo=function(e){if(!e.getAllowUndo())return e;var n=e.getRedoStack(),r=n.peek();if(!r)return e;var o=e.getCurrentContent(),i=h.getDirectionMap(r,e.getDirectionMap());return t.set(e,{currentContent:r,directionMap:i,undoStack:e.getUndoStack().push(o),redoStack:n.shift(),forceSelection:!0,inlineStyleOverride:null,lastChangeType:"redo",nativelyRenderedContent:null,selection:r.getSelectionAfter()})},t.prototype.getImmutable=function(){return this._immutable},t}();t.exports=C},function(t,e,n){!function(e,n){t.exports=n()}(0,function(){"use strict";function t(t,e){e&&(t.prototype=Object.create(e.prototype)),t.prototype.constructor=t}function e(t){return i(t)?t:E(t)}function n(t){return a(t)?t:S(t)}function r(t){return s(t)?t:b(t)}function o(t){return i(t)&&!u(t)?t:x(t)}function i(t){return!(!t||!t[cn])}function a(t){return!(!t||!t[ln])}function s(t){return!(!t||!t[fn])}function u(t){return a(t)||s(t)}function c(t){return!(!t||!t[pn])}function l(t){return t.value=!1,t}function f(t){t&&(t.value=!0)}function p(){}function d(t,e){e=e||0;for(var n=Math.max(0,t.length-e),r=new Array(n),o=0;o<n;o++)r[o]=t[o+e];return r}function g(t){return void 0===t.size&&(t.size=t.__iterate(h)),t.size}function M(t,e){if("number"!=typeof e){var n=e>>>0;if(""+n!==e||4294967295===n)return NaN;e=n}return e<0?g(t)+e:e}function h(){return!0}function y(t,e,n){return(0===t||void 0!==n&&t<=-n)&&(void 0===e||void 0!==n&&e>=n)}function m(t,e){return w(t,e,0)}function I(t,e){return w(t,e,e)}function w(t,e,n){return void 0===t?n:t<0?Math.max(0,e+t):void 0===e?t:Math.min(e,t)}function D(t){this.next=t}function N(t,e,n,r){var o=0===t?e:1===t?n:[e,n];return r?r.value=o:r={value:o,done:!1},r}function v(){return{value:void 0,done:!0}}function C(t){return!!T(t)}function j(t){return t&&"function"==typeof t.next}function z(t){var e=T(t);return e&&e.call(t)}function T(t){var e=t&&(Nn&&t[Nn]||t[vn]);if("function"==typeof e)return e}function A(t){return t&&"number"==typeof t.length}function E(t){return null===t||void 0===t?Q():i(t)?t.toSeq():P(t)}function S(t){return null===t||void 0===t?Q().toKeyedSeq():i(t)?a(t)?t.toSeq():t.fromEntrySeq():Y(t)}function b(t){return null===t||void 0===t?Q():i(t)?a(t)?t.entrySeq():t.toIndexedSeq():B(t)}function x(t){return(null===t||void 0===t?Q():i(t)?a(t)?t.entrySeq():t:B(t)).toSetSeq()}function O(t){this._array=t,this.size=t.length}function _(t){var e=Object.keys(t);this._object=t,this._keys=e,this.size=e.length}function k(t){this._iterable=t,this.size=t.length||t.size}function L(t){this._iterator=t,this._iteratorCache=[]}function U(t){return!(!t||!t[jn])}function Q(){return zn||(zn=new O([]))}function Y(t){var e=Array.isArray(t)?new O(t).fromEntrySeq():j(t)?new L(t).fromEntrySeq():C(t)?new k(t).fromEntrySeq():"object"==typeof t?new _(t):void 0;if(!e)throw new TypeError("Expected Array or iterable object of [k, v] entries, or keyed object: "+t);return e}function B(t){var e=R(t);if(!e)throw new TypeError("Expected Array or iterable object of values: "+t);return e}function P(t){var e=R(t)||"object"==typeof t&&new _(t);if(!e)throw new TypeError("Expected Array or iterable object of values, or keyed object: "+t);return e}function R(t){return A(t)?new O(t):j(t)?new L(t):C(t)?new k(t):void 0}function Z(t,e,n,r){var o=t._cache;if(o){for(var i=o.length-1,a=0;a<=i;a++){var s=o[n?i-a:a];if(!1===e(s[1],r?s[0]:a,t))return a+1}return a}return t.__iterateUncached(e,n)}function G(t,e,n,r){var o=t._cache;if(o){var i=o.length-1,a=0;return new D(function(){var t=o[n?i-a:a];return a++>i?v():N(e,r?t[0]:a-1,t[1])})}return t.__iteratorUncached(e,n)}function W(t,e){return e?F(e,t,"",{"":t}):H(t)}function F(t,e,n,r){return Array.isArray(e)?t.call(r,n,b(e).map(function(n,r){return F(t,n,r,e)})):K(e)?t.call(r,n,S(e).map(function(n,r){return F(t,n,r,e)})):e}function H(t){return Array.isArray(t)?b(t).map(H).toList():K(t)?S(t).map(H).toMap():t}function K(t){return t&&(t.constructor===Object||void 0===t.constructor)}function J(t,e){if(t===e||t!==t&&e!==e)return!0;if(!t||!e)return!1;if("function"==typeof t.valueOf&&"function"==typeof e.valueOf){if(t=t.valueOf(),e=e.valueOf(),t===e||t!==t&&e!==e)return!0;if(!t||!e)return!1}return!("function"!=typeof t.equals||"function"!=typeof e.equals||!t.equals(e))}function q(t,e){if(t===e)return!0;if(!i(e)||void 0!==t.size&&void 0!==e.size&&t.size!==e.size||void 0!==t.__hash&&void 0!==e.__hash&&t.__hash!==e.__hash||a(t)!==a(e)||s(t)!==s(e)||c(t)!==c(e))return!1;if(0===t.size&&0===e.size)return!0;var n=!u(t);if(c(t)){var r=t.entries();return e.every(function(t,e){var o=r.next().value;return o&&J(o[1],t)&&(n||J(o[0],e))})&&r.next().done}var o=!1;if(void 0===t.size)if(void 0===e.size)"function"==typeof t.cacheResult&&t.cacheResult();else{o=!0;var l=t;t=e,e=l}var f=!0,p=e.__iterate(function(e,r){if(n?!t.has(e):o?!J(e,t.get(r,hn)):!J(t.get(r,hn),e))return f=!1,!1});return f&&t.size===p}function V(t,e){if(!(this instanceof V))return new V(t,e);if(this._value=t,this.size=void 0===e?1/0:Math.max(0,e),0===this.size){if(Tn)return Tn;Tn=this}}function X(t,e){if(!t)throw new Error(e)}function $(t,e,n){if(!(this instanceof $))return new $(t,e,n);if(X(0!==n,"Cannot step a Range by 0"),t=t||0,void 0===e&&(e=1/0),n=void 0===n?1:Math.abs(n),e<t&&(n=-n),this._start=t,this._end=e,this._step=n,this.size=Math.max(0,Math.ceil((e-t)/n-1)+1),0===this.size){if(An)return An;An=this}}function tt(){throw TypeError("Abstract")}function et(){}function nt(){}function rt(){}function ot(t){return t>>>1&1073741824|3221225471&t}function it(t){if(!1===t||null===t||void 0===t)return 0;if("function"==typeof t.valueOf&&(!1===(t=t.valueOf())||null===t||void 0===t))return 0;if(!0===t)return 1;var e=typeof t;if("number"===e){var n=0|t;for(n!==t&&(n^=4294967295*t);t>4294967295;)t/=4294967295,n^=t;return ot(n)}if("string"===e)return t.length>Ln?at(t):st(t);if("function"==typeof t.hashCode)return t.hashCode();if("object"===e)return ut(t);if("function"==typeof t.toString)return st(t.toString());throw new Error("Value type "+e+" cannot be hashed.")}function at(t){var e=Yn[t];return void 0===e&&(e=st(t),Qn===Un&&(Qn=0,Yn={}),Qn++,Yn[t]=e),e}function st(t){for(var e=0,n=0;n<t.length;n++)e=31*e+t.charCodeAt(n)|0;return ot(e)}function ut(t){var e;if(On&&void 0!==(e=En.get(t)))return e;if(void 0!==(e=t[kn]))return e;if(!xn){if(void 0!==(e=t.propertyIsEnumerable&&t.propertyIsEnumerable[kn]))return e;if(void 0!==(e=ct(t)))return e}if(e=++_n,1073741824&_n&&(_n=0),On)En.set(t,e);else{if(void 0!==bn&&!1===bn(t))throw new Error("Non-extensible objects are not allowed as keys.");if(xn)Object.defineProperty(t,kn,{enumerable:!1,configurable:!1,writable:!1,value:e});else if(void 0!==t.propertyIsEnumerable&&t.propertyIsEnumerable===t.constructor.prototype.propertyIsEnumerable)t.propertyIsEnumerable=function(){return this.constructor.prototype.propertyIsEnumerable.apply(this,arguments)},t.propertyIsEnumerable[kn]=e;else{if(void 0===t.nodeType)throw new Error("Unable to set a non-enumerable property on object.");t[kn]=e}}return e}function ct(t){if(t&&t.nodeType>0)switch(t.nodeType){case 1:return t.uniqueID;case 9:return t.documentElement&&t.documentElement.uniqueID}}function lt(t){X(t!==1/0,"Cannot perform this action with an infinite size.")}function ft(t){return null===t||void 0===t?Nt():pt(t)&&!c(t)?t:Nt().withMutations(function(e){var r=n(t);lt(r.size),r.forEach(function(t,n){return e.set(n,t)})})}function pt(t){return!(!t||!t[Bn])}function dt(t,e){this.ownerID=t,this.entries=e}function gt(t,e,n){this.ownerID=t,this.bitmap=e,this.nodes=n}function Mt(t,e,n){this.ownerID=t,this.count=e,this.nodes=n}function ht(t,e,n){this.ownerID=t,this.keyHash=e,this.entries=n}function yt(t,e,n){this.ownerID=t,this.keyHash=e,this.entry=n}function mt(t,e,n){this._type=e,this._reverse=n,this._stack=t._root&&wt(t._root)}function It(t,e){return N(t,e[0],e[1])}function wt(t,e){return{node:t,index:0,__prev:e}}function Dt(t,e,n,r){var o=Object.create(Pn);return o.size=t,o._root=e,o.__ownerID=n,o.__hash=r,o.__altered=!1,o}function Nt(){return Rn||(Rn=Dt(0))}function vt(t,e,n){var r,o;if(t._root){var i=l(yn),a=l(mn);if(r=Ct(t._root,t.__ownerID,0,void 0,e,n,i,a),!a.value)return t;o=t.size+(i.value?n===hn?-1:1:0)}else{if(n===hn)return t;o=1,r=new dt(t.__ownerID,[[e,n]])}return t.__ownerID?(t.size=o,t._root=r,t.__hash=void 0,t.__altered=!0,t):r?Dt(o,r):Nt()}function Ct(t,e,n,r,o,i,a,s){return t?t.update(e,n,r,o,i,a,s):i===hn?t:(f(s),f(a),new yt(e,r,[o,i]))}function jt(t){return t.constructor===yt||t.constructor===ht}function zt(t,e,n,r,o){if(t.keyHash===r)return new ht(e,r,[t.entry,o]);var i,a=(0===n?t.keyHash:t.keyHash>>>n)&Mn,s=(0===n?r:r>>>n)&Mn;return new gt(e,1<<a|1<<s,a===s?[zt(t,e,n+dn,r,o)]:(i=new yt(e,r,o),a<s?[t,i]:[i,t]))}function Tt(t,e,n,r){t||(t=new p);for(var o=new yt(t,it(n),[n,r]),i=0;i<e.length;i++){var a=e[i];o=o.update(t,0,void 0,a[0],a[1])}return o}function At(t,e,n,r){for(var o=0,i=0,a=new Array(n),s=0,u=1,c=e.length;s<c;s++,u<<=1){var l=e[s];void 0!==l&&s!==r&&(o|=u,a[i++]=l)}return new gt(t,o,a)}function Et(t,e,n,r,o){for(var i=0,a=new Array(gn),s=0;0!==n;s++,n>>>=1)a[s]=1&n?e[i++]:void 0;return a[r]=o,new Mt(t,i+1,a)}function St(t,e,r){for(var o=[],a=0;a<r.length;a++){var s=r[a],u=n(s);i(s)||(u=u.map(function(t){return W(t)})),o.push(u)}return Ot(t,e,o)}function bt(t,e,n){return t&&t.mergeDeep&&i(e)?t.mergeDeep(e):J(t,e)?t:e}function xt(t){return function(e,n,r){if(e&&e.mergeDeepWith&&i(n))return e.mergeDeepWith(t,n);var o=t(e,n,r);return J(e,o)?e:o}}function Ot(t,e,n){return n=n.filter(function(t){return 0!==t.size}),0===n.length?t:0!==t.size||t.__ownerID||1!==n.length?t.withMutations(function(t){for(var r=e?function(n,r){t.update(r,hn,function(t){return t===hn?n:e(t,n,r)})}:function(e,n){t.set(n,e)},o=0;o<n.length;o++)n[o].forEach(r)}):t.constructor(n[0])}function _t(t,e,n,r){var o=t===hn,i=e.next();if(i.done){var a=o?n:t,s=r(a);return s===a?t:s}X(o||t&&t.set,"invalid keyPath");var u=i.value,c=o?hn:t.get(u,hn),l=_t(c,e,n,r);return l===c?t:l===hn?t.remove(u):(o?Nt():t).set(u,l)}function kt(t){return t-=t>>1&1431655765,t=(858993459&t)+(t>>2&858993459),t=t+(t>>4)&252645135,t+=t>>8,127&(t+=t>>16)}function Lt(t,e,n,r){var o=r?t:d(t);return o[e]=n,o}function Ut(t,e,n,r){var o=t.length+1;if(r&&e+1===o)return t[e]=n,t;for(var i=new Array(o),a=0,s=0;s<o;s++)s===e?(i[s]=n,a=-1):i[s]=t[s+a];return i}function Qt(t,e,n){var r=t.length-1;if(n&&e===r)return t.pop(),t;for(var o=new Array(r),i=0,a=0;a<r;a++)a===e&&(i=1),o[a]=t[a+i];return o}function Yt(t){var e=Gt();if(null===t||void 0===t)return e;if(Bt(t))return t;var n=r(t),o=n.size;return 0===o?e:(lt(o),o>0&&o<gn?Zt(0,o,dn,null,new Pt(n.toArray())):e.withMutations(function(t){t.setSize(o),n.forEach(function(e,n){return t.set(n,e)})}))}function Bt(t){return!(!t||!t[Fn])}function Pt(t,e){this.array=t,this.ownerID=e}function Rt(t,e){function n(t,e,n){return 0===e?r(t,n):o(t,e,n)}function r(t,n){var r=n===s?u&&u.array:t&&t.array,o=n>i?0:i-n,c=a-n;return c>gn&&(c=gn),function(){if(o===c)return Jn;var t=e?--c:o++;return r&&r[t]}}function o(t,r,o){var s,u=t&&t.array,c=o>i?0:i-o>>r,l=1+(a-o>>r);return l>gn&&(l=gn),function(){for(;;){if(s){var t=s();if(t!==Jn)return t;s=null}if(c===l)return Jn;var i=e?--l:c++;s=n(u&&u[i],r-dn,o+(i<<r))}}}var i=t._origin,a=t._capacity,s=Vt(a),u=t._tail;return n(t._root,t._level,0)}function Zt(t,e,n,r,o,i,a){var s=Object.create(Hn);return s.size=e-t,s._origin=t,s._capacity=e,s._level=n,s._root=r,s._tail=o,s.__ownerID=i,s.__hash=a,s.__altered=!1,s}function Gt(){return Kn||(Kn=Zt(0,0,dn))}function Wt(t,e,n){if((e=M(t,e))!==e)return t;if(e>=t.size||e<0)return t.withMutations(function(t){e<0?Jt(t,e).set(0,n):Jt(t,0,e+1).set(e,n)});e+=t._origin;var r=t._tail,o=t._root,i=l(mn);return e>=Vt(t._capacity)?r=Ft(r,t.__ownerID,0,e,n,i):o=Ft(o,t.__ownerID,t._level,e,n,i),i.value?t.__ownerID?(t._root=o,t._tail=r,t.__hash=void 0,t.__altered=!0,t):Zt(t._origin,t._capacity,t._level,o,r):t}function Ft(t,e,n,r,o,i){var a=r>>>n&Mn,s=t&&a<t.array.length;if(!s&&void 0===o)return t;var u;if(n>0){var c=t&&t.array[a],l=Ft(c,e,n-dn,r,o,i);return l===c?t:(u=Ht(t,e),u.array[a]=l,u)}return s&&t.array[a]===o?t:(f(i),u=Ht(t,e),void 0===o&&a===u.array.length-1?u.array.pop():u.array[a]=o,u)}function Ht(t,e){return e&&t&&e===t.ownerID?t:new Pt(t?t.array.slice():[],e)}function Kt(t,e){if(e>=Vt(t._capacity))return t._tail;if(e<1<<t._level+dn){for(var n=t._root,r=t._level;n&&r>0;)n=n.array[e>>>r&Mn],r-=dn;return n}}function Jt(t,e,n){void 0!==e&&(e|=0),void 0!==n&&(n|=0);var r=t.__ownerID||new p,o=t._origin,i=t._capacity,a=o+e,s=void 0===n?i:n<0?i+n:o+n;if(a===o&&s===i)return t;if(a>=s)return t.clear();for(var u=t._level,c=t._root,l=0;a+l<0;)c=new Pt(c&&c.array.length?[void 0,c]:[],r),u+=dn,l+=1<<u;l&&(a+=l,o+=l,s+=l,i+=l);for(var f=Vt(i),d=Vt(s);d>=1<<u+dn;)c=new Pt(c&&c.array.length?[c]:[],r),u+=dn;var g=t._tail,M=d<f?Kt(t,s-1):d>f?new Pt([],r):g;if(g&&d>f&&a<i&&g.array.length){c=Ht(c,r);for(var h=c,y=u;y>dn;y-=dn){var m=f>>>y&Mn;h=h.array[m]=Ht(h.array[m],r)}h.array[f>>>dn&Mn]=g}if(s<i&&(M=M&&M.removeAfter(r,0,s)),a>=d)a-=d,s-=d,u=dn,c=null,M=M&&M.removeBefore(r,0,a);else if(a>o||d<f){for(l=0;c;){var I=a>>>u&Mn;if(I!==d>>>u&Mn)break;I&&(l+=(1<<u)*I),u-=dn,c=c.array[I]}c&&a>o&&(c=c.removeBefore(r,u,a-l)),c&&d<f&&(c=c.removeAfter(r,u,d-l)),l&&(a-=l,s-=l)}return t.__ownerID?(t.size=s-a,t._origin=a,t._capacity=s,t._level=u,t._root=c,t._tail=M,t.__hash=void 0,t.__altered=!0,t):Zt(a,s,u,c,M)}function qt(t,e,n){for(var o=[],a=0,s=0;s<n.length;s++){var u=n[s],c=r(u);c.size>a&&(a=c.size),i(u)||(c=c.map(function(t){return W(t)})),o.push(c)}return a>t.size&&(t=t.setSize(a)),Ot(t,e,o)}function Vt(t){return t<gn?0:t-1>>>dn<<dn}function Xt(t){return null===t||void 0===t?ee():$t(t)?t:ee().withMutations(function(e){var r=n(t);lt(r.size),r.forEach(function(t,n){return e.set(n,t)})})}function $t(t){return pt(t)&&c(t)}function te(t,e,n,r){var o=Object.create(Xt.prototype);return o.size=t?t.size:0,o._map=t,o._list=e,o.__ownerID=n,o.__hash=r,o}function ee(){return qn||(qn=te(Nt(),Gt()))}function ne(t,e,n){var r,o,i=t._map,a=t._list,s=i.get(e),u=void 0!==s;if(n===hn){if(!u)return t;a.size>=gn&&a.size>=2*i.size?(o=a.filter(function(t,e){return void 0!==t&&s!==e}),r=o.toKeyedSeq().map(function(t){return t[0]}).flip().toMap(),t.__ownerID&&(r.__ownerID=o.__ownerID=t.__ownerID)):(r=i.remove(e),o=s===a.size-1?a.pop():a.set(s,void 0))}else if(u){if(n===a.get(s)[1])return t;r=i,o=a.set(s,[e,n])}else r=i.set(e,a.size),o=a.set(a.size,[e,n]);return t.__ownerID?(t.size=r.size,t._map=r,t._list=o,t.__hash=void 0,t):te(r,o)}function re(t,e){this._iter=t,this._useKeys=e,this.size=t.size}function oe(t){this._iter=t,this.size=t.size}function ie(t){this._iter=t,this.size=t.size}function ae(t){this._iter=t,this.size=t.size}function se(t){var e=Ae(t);return e._iter=t,e.size=t.size,e.flip=function(){return t},e.reverse=function(){var e=t.reverse.apply(this);return e.flip=function(){return t.reverse()},e},e.has=function(e){return t.includes(e)},e.includes=function(e){return t.has(e)},e.cacheResult=Ee,e.__iterateUncached=function(e,n){var r=this;return t.__iterate(function(t,n){return!1!==e(n,t,r)},n)},e.__iteratorUncached=function(e,n){if(e===Dn){var r=t.__iterator(e,n);return new D(function(){var t=r.next();if(!t.done){var e=t.value[0];t.value[0]=t.value[1],t.value[1]=e}return t})}return t.__iterator(e===wn?In:wn,n)},e}function ue(t,e,n){var r=Ae(t);return r.size=t.size,r.has=function(e){return t.has(e)},r.get=function(r,o){var i=t.get(r,hn);return i===hn?o:e.call(n,i,r,t)},r.__iterateUncached=function(r,o){var i=this;return t.__iterate(function(t,o,a){return!1!==r(e.call(n,t,o,a),o,i)},o)},r.__iteratorUncached=function(r,o){var i=t.__iterator(Dn,o);return new D(function(){var o=i.next();if(o.done)return o;var a=o.value,s=a[0];return N(r,s,e.call(n,a[1],s,t),o)})},r}function ce(t,e){var n=Ae(t);return n._iter=t,n.size=t.size,n.reverse=function(){return t},t.flip&&(n.flip=function(){var e=se(t);return e.reverse=function(){return t.flip()},e}),n.get=function(n,r){return t.get(e?n:-1-n,r)},n.has=function(n){return t.has(e?n:-1-n)},n.includes=function(e){return t.includes(e)},n.cacheResult=Ee,n.__iterate=function(e,n){var r=this;return t.__iterate(function(t,n){return e(t,n,r)},!n)},n.__iterator=function(e,n){return t.__iterator(e,!n)},n}function le(t,e,n,r){var o=Ae(t);return r&&(o.has=function(r){var o=t.get(r,hn);return o!==hn&&!!e.call(n,o,r,t)},o.get=function(r,o){var i=t.get(r,hn);return i!==hn&&e.call(n,i,r,t)?i:o}),o.__iterateUncached=function(o,i){var a=this,s=0;return t.__iterate(function(t,i,u){if(e.call(n,t,i,u))return s++,o(t,r?i:s-1,a)},i),s},o.__iteratorUncached=function(o,i){var a=t.__iterator(Dn,i),s=0;return new D(function(){for(;;){var i=a.next();if(i.done)return i;var u=i.value,c=u[0],l=u[1];if(e.call(n,l,c,t))return N(o,r?c:s++,l,i)}})},o}function fe(t,e,n){var r=ft().asMutable();return t.__iterate(function(o,i){r.update(e.call(n,o,i,t),0,function(t){return t+1})}),r.asImmutable()}function pe(t,e,n){var r=a(t),o=(c(t)?Xt():ft()).asMutable();t.__iterate(function(i,a){o.update(e.call(n,i,a,t),function(t){return t=t||[],t.push(r?[a,i]:i),t})});var i=Te(t);return o.map(function(e){return Ce(t,i(e))})}function de(t,e,n,r){var o=t.size;if(void 0!==e&&(e|=0),void 0!==n&&(n|=0),y(e,n,o))return t;var i=m(e,o),a=I(n,o);if(i!==i||a!==a)return de(t.toSeq().cacheResult(),e,n,r);var s,u=a-i;u===u&&(s=u<0?0:u);var c=Ae(t);return c.size=0===s?s:t.size&&s||void 0,!r&&U(t)&&s>=0&&(c.get=function(e,n){return e=M(this,e),e>=0&&e<s?t.get(e+i,n):n}),c.__iterateUncached=function(e,n){var o=this;if(0===s)return 0;if(n)return this.cacheResult().__iterate(e,n);var a=0,u=!0,c=0;return t.__iterate(function(t,n){if(!u||!(u=a++<i))return c++,!1!==e(t,r?n:c-1,o)&&c!==s}),c},c.__iteratorUncached=function(e,n){if(0!==s&&n)return this.cacheResult().__iterator(e,n);var o=0!==s&&t.__iterator(e,n),a=0,u=0;return new D(function(){for(;a++<i;)o.next();if(++u>s)return v();var t=o.next();return r||e===wn?t:e===In?N(e,u-1,void 0,t):N(e,u-1,t.value[1],t)})},c}function ge(t,e,n){var r=Ae(t);return r.__iterateUncached=function(r,o){var i=this;if(o)return this.cacheResult().__iterate(r,o);var a=0;return t.__iterate(function(t,o,s){return e.call(n,t,o,s)&&++a&&r(t,o,i)}),a},r.__iteratorUncached=function(r,o){var i=this;if(o)return this.cacheResult().__iterator(r,o);var a=t.__iterator(Dn,o),s=!0;return new D(function(){if(!s)return v();var t=a.next();if(t.done)return t;var o=t.value,u=o[0],c=o[1];return e.call(n,c,u,i)?r===Dn?t:N(r,u,c,t):(s=!1,v())})},r}function Me(t,e,n,r){var o=Ae(t);return o.__iterateUncached=function(o,i){var a=this;if(i)return this.cacheResult().__iterate(o,i);var s=!0,u=0;return t.__iterate(function(t,i,c){if(!s||!(s=e.call(n,t,i,c)))return u++,o(t,r?i:u-1,a)}),u},o.__iteratorUncached=function(o,i){var a=this;if(i)return this.cacheResult().__iterator(o,i);var s=t.__iterator(Dn,i),u=!0,c=0;return new D(function(){var t,i,l;do{if(t=s.next(),t.done)return r||o===wn?t:o===In?N(o,c++,void 0,t):N(o,c++,t.value[1],t);var f=t.value;i=f[0],l=f[1],u&&(u=e.call(n,l,i,a))}while(u);return o===Dn?t:N(o,i,l,t)})},o}function he(t,e){var r=a(t),o=[t].concat(e).map(function(t){return i(t)?r&&(t=n(t)):t=r?Y(t):B(Array.isArray(t)?t:[t]),t}).filter(function(t){return 0!==t.size});if(0===o.length)return t;if(1===o.length){var u=o[0];if(u===t||r&&a(u)||s(t)&&s(u))return u}var c=new O(o);return r?c=c.toKeyedSeq():s(t)||(c=c.toSetSeq()),c=c.flatten(!0),c.size=o.reduce(function(t,e){if(void 0!==t){var n=e.size;if(void 0!==n)return t+n}},0),c}function ye(t,e,n){var r=Ae(t);return r.__iterateUncached=function(r,o){function a(t,c){var l=this;t.__iterate(function(t,o){return(!e||c<e)&&i(t)?a(t,c+1):!1===r(t,n?o:s++,l)&&(u=!0),!u},o)}var s=0,u=!1;return a(t,0),s},r.__iteratorUncached=function(r,o){var a=t.__iterator(r,o),s=[],u=0;return new D(function(){for(;a;){var t=a.next();if(!1===t.done){var c=t.value;if(r===Dn&&(c=c[1]),e&&!(s.length<e)||!i(c))return n?t:N(r,u++,c,t);s.push(a),a=c.__iterator(r,o)}else a=s.pop()}return v()})},r}function me(t,e,n){var r=Te(t);return t.toSeq().map(function(o,i){return r(e.call(n,o,i,t))}).flatten(!0)}function Ie(t,e){var n=Ae(t);return n.size=t.size&&2*t.size-1,n.__iterateUncached=function(n,r){var o=this,i=0;return t.__iterate(function(t,r){return(!i||!1!==n(e,i++,o))&&!1!==n(t,i++,o)},r),i},n.__iteratorUncached=function(n,r){var o,i=t.__iterator(wn,r),a=0;return new D(function(){return(!o||a%2)&&(o=i.next(),o.done)?o:a%2?N(n,a++,e):N(n,a++,o.value,o)})},n}function we(t,e,n){e||(e=Se);var r=a(t),o=0,i=t.toSeq().map(function(e,r){return[r,e,o++,n?n(e,r,t):e]}).toArray();return i.sort(function(t,n){return e(t[3],n[3])||t[2]-n[2]}).forEach(r?function(t,e){i[e].length=2}:function(t,e){i[e]=t[1]}),r?S(i):s(t)?b(i):x(i)}function De(t,e,n){if(e||(e=Se),n){var r=t.toSeq().map(function(e,r){return[e,n(e,r,t)]}).reduce(function(t,n){return Ne(e,t[1],n[1])?n:t});return r&&r[0]}return t.reduce(function(t,n){return Ne(e,t,n)?n:t})}function Ne(t,e,n){var r=t(n,e);return 0===r&&n!==e&&(void 0===n||null===n||n!==n)||r>0}function ve(t,n,r){var o=Ae(t);return o.size=new O(r).map(function(t){return t.size}).min(),o.__iterate=function(t,e){for(var n,r=this.__iterator(wn,e),o=0;!(n=r.next()).done&&!1!==t(n.value,o++,this););return o},o.__iteratorUncached=function(t,o){var i=r.map(function(t){return t=e(t),z(o?t.reverse():t)}),a=0,s=!1;return new D(function(){var e;return s||(e=i.map(function(t){return t.next()}),s=e.some(function(t){return t.done})),s?v():N(t,a++,n.apply(null,e.map(function(t){return t.value})))})},o}function Ce(t,e){return U(t)?e:t.constructor(e)}function je(t){if(t!==Object(t))throw new TypeError("Expected [K, V] tuple: "+t)}function ze(t){return lt(t.size),g(t)}function Te(t){return a(t)?n:s(t)?r:o}function Ae(t){return Object.create((a(t)?S:s(t)?b:x).prototype)}function Ee(){return this._iter.cacheResult?(this._iter.cacheResult(),this.size=this._iter.size,this):E.prototype.cacheResult.call(this)}function Se(t,e){return t>e?1:t<e?-1:0}function be(t){var n=z(t);if(!n){if(!A(t))throw new TypeError("Expected iterable or array-like: "+t);n=z(e(t))}return n}function xe(t,e){var n,r=function(i){if(i instanceof r)return i;if(!(this instanceof r))return new r(i);if(!n){n=!0;var a=Object.keys(t);ke(o,a),o.size=a.length,o._name=e,o._keys=a,o._defaultValues=t}this._map=ft(i)},o=r.prototype=Object.create(Vn);return o.constructor=r,r}function Oe(t,e,n){var r=Object.create(Object.getPrototypeOf(t));return r._map=e,r.__ownerID=n,r}function _e(t){return t._name||t.constructor.name||"Record"}function ke(t,e){try{e.forEach(Le.bind(void 0,t))}catch(t){}}function Le(t,e){Object.defineProperty(t,e,{get:function(){return this.get(e)},set:function(t){X(this.__ownerID,"Cannot set on an immutable record."),this.set(e,t)}})}function Ue(t){return null===t||void 0===t?Pe():Qe(t)&&!c(t)?t:Pe().withMutations(function(e){var n=o(t);lt(n.size),n.forEach(function(t){return e.add(t)})})}function Qe(t){return!(!t||!t[Xn])}function Ye(t,e){return t.__ownerID?(t.size=e.size,t._map=e,t):e===t._map?t:0===e.size?t.__empty():t.__make(e)}function Be(t,e){var n=Object.create($n);return n.size=t?t.size:0,n._map=t,n.__ownerID=e,n}function Pe(){return tr||(tr=Be(Nt()))}function Re(t){return null===t||void 0===t?We():Ze(t)?t:We().withMutations(function(e){var n=o(t);lt(n.size),n.forEach(function(t){return e.add(t)})})}function Ze(t){return Qe(t)&&c(t)}function Ge(t,e){var n=Object.create(er);return n.size=t?t.size:0,n._map=t,n.__ownerID=e,n}function We(){return nr||(nr=Ge(ee()))}function Fe(t){return null===t||void 0===t?Je():He(t)?t:Je().unshiftAll(t)}function He(t){return!(!t||!t[rr])}function Ke(t,e,n,r){var o=Object.create(or);return o.size=t,o._head=e,o.__ownerID=n,o.__hash=r,o.__altered=!1,o}function Je(){return ir||(ir=Ke(0))}function qe(t,e){var n=function(n){t.prototype[n]=e[n]};return Object.keys(e).forEach(n),Object.getOwnPropertySymbols&&Object.getOwnPropertySymbols(e).forEach(n),t}function Ve(t,e){return e}function Xe(t,e){return[e,t]}function $e(t){return function(){return!t.apply(this,arguments)}}function tn(t){return function(){return-t.apply(this,arguments)}}function en(t){return"string"==typeof t?JSON.stringify(t):t}function nn(){return d(arguments)}function rn(t,e){return t<e?1:t>e?-1:0}function on(t){if(t.size===1/0)return 0;var e=c(t),n=a(t),r=e?1:0;return an(t.__iterate(n?e?function(t,e){r=31*r+sn(it(t),it(e))|0}:function(t,e){r=r+sn(it(t),it(e))|0}:e?function(t){r=31*r+it(t)|0}:function(t){r=r+it(t)|0}),r)}function an(t,e){return e=Sn(e,3432918353),e=Sn(e<<15|e>>>-15,461845907),e=Sn(e<<13|e>>>-13,5),e=(e+3864292196|0)^t,e=Sn(e^e>>>16,2246822507),e=Sn(e^e>>>13,3266489909),e=ot(e^e>>>16)}function sn(t,e){return t^e+2654435769+(t<<6)+(t>>2)|0}var un=Array.prototype.slice;t(n,e),t(r,e),t(o,e),e.isIterable=i,e.isKeyed=a,e.isIndexed=s,e.isAssociative=u,e.isOrdered=c,e.Keyed=n,e.Indexed=r,e.Set=o;var cn="@@__IMMUTABLE_ITERABLE__@@",ln="@@__IMMUTABLE_KEYED__@@",fn="@@__IMMUTABLE_INDEXED__@@",pn="@@__IMMUTABLE_ORDERED__@@",dn=5,gn=1<<dn,Mn=gn-1,hn={},yn={value:!1},mn={value:!1},In=0,wn=1,Dn=2,Nn="function"==typeof Symbol&&Symbol.iterator,vn="@@iterator",Cn=Nn||vn;D.prototype.toString=function(){return"[Iterator]"},D.KEYS=In,D.VALUES=wn,D.ENTRIES=Dn,D.prototype.inspect=D.prototype.toSource=function(){return this.toString()},D.prototype[Cn]=function(){return this},t(E,e),E.of=function(){return E(arguments)},E.prototype.toSeq=function(){return this},E.prototype.toString=function(){return this.__toString("Seq {","}")},E.prototype.cacheResult=function(){return!this._cache&&this.__iterateUncached&&(this._cache=this.entrySeq().toArray(),this.size=this._cache.length),this},E.prototype.__iterate=function(t,e){return Z(this,t,e,!0)},E.prototype.__iterator=function(t,e){return G(this,t,e,!0)},t(S,E),S.prototype.toKeyedSeq=function(){return this},t(b,E),b.of=function(){return b(arguments)},b.prototype.toIndexedSeq=function(){return this},b.prototype.toString=function(){return this.__toString("Seq [","]")},b.prototype.__iterate=function(t,e){return Z(this,t,e,!1)},b.prototype.__iterator=function(t,e){return G(this,t,e,!1)},t(x,E),x.of=function(){return x(arguments)},x.prototype.toSetSeq=function(){return this},E.isSeq=U,E.Keyed=S,E.Set=x,E.Indexed=b;var jn="@@__IMMUTABLE_SEQ__@@";E.prototype[jn]=!0,t(O,b),O.prototype.get=function(t,e){return this.has(t)?this._array[M(this,t)]:e},O.prototype.__iterate=function(t,e){for(var n=this._array,r=n.length-1,o=0;o<=r;o++)if(!1===t(n[e?r-o:o],o,this))return o+1;return o},O.prototype.__iterator=function(t,e){var n=this._array,r=n.length-1,o=0;return new D(function(){return o>r?v():N(t,o,n[e?r-o++:o++])})},t(_,S),_.prototype.get=function(t,e){return void 0===e||this.has(t)?this._object[t]:e},_.prototype.has=function(t){return this._object.hasOwnProperty(t)},_.prototype.__iterate=function(t,e){for(var n=this._object,r=this._keys,o=r.length-1,i=0;i<=o;i++){var a=r[e?o-i:i];if(!1===t(n[a],a,this))return i+1}return i},_.prototype.__iterator=function(t,e){var n=this._object,r=this._keys,o=r.length-1,i=0;return new D(function(){var a=r[e?o-i:i];return i++>o?v():N(t,a,n[a])})},_.prototype[pn]=!0,t(k,b),k.prototype.__iterateUncached=function(t,e){if(e)return this.cacheResult().__iterate(t,e);var n=this._iterable,r=z(n),o=0;if(j(r))for(var i;!(i=r.next()).done&&!1!==t(i.value,o++,this););return o},k.prototype.__iteratorUncached=function(t,e){if(e)return this.cacheResult().__iterator(t,e);var n=this._iterable,r=z(n);if(!j(r))return new D(v);var o=0;return new D(function(){var e=r.next();return e.done?e:N(t,o++,e.value)})},t(L,b),L.prototype.__iterateUncached=function(t,e){if(e)return this.cacheResult().__iterate(t,e);for(var n=this._iterator,r=this._iteratorCache,o=0;o<r.length;)if(!1===t(r[o],o++,this))return o;for(var i;!(i=n.next()).done;){var a=i.value;if(r[o]=a,!1===t(a,o++,this))break}return o},L.prototype.__iteratorUncached=function(t,e){if(e)return this.cacheResult().__iterator(t,e);var n=this._iterator,r=this._iteratorCache,o=0;return new D(function(){if(o>=r.length){var e=n.next();if(e.done)return e;r[o]=e.value}return N(t,o,r[o++])})};var zn;t(V,b),V.prototype.toString=function(){return 0===this.size?"Repeat []":"Repeat [ "+this._value+" "+this.size+" times ]"},V.prototype.get=function(t,e){return this.has(t)?this._value:e},V.prototype.includes=function(t){return J(this._value,t)},V.prototype.slice=function(t,e){var n=this.size;return y(t,e,n)?this:new V(this._value,I(e,n)-m(t,n))},V.prototype.reverse=function(){return this},V.prototype.indexOf=function(t){return J(this._value,t)?0:-1},V.prototype.lastIndexOf=function(t){return J(this._value,t)?this.size:-1},V.prototype.__iterate=function(t,e){for(var n=0;n<this.size;n++)if(!1===t(this._value,n,this))return n+1;return n},V.prototype.__iterator=function(t,e){var n=this,r=0;return new D(function(){return r<n.size?N(t,r++,n._value):v()})},V.prototype.equals=function(t){return t instanceof V?J(this._value,t._value):q(t)};var Tn;t($,b),$.prototype.toString=function(){return 0===this.size?"Range []":"Range [ "+this._start+"..."+this._end+(this._step>1?" by "+this._step:"")+" ]"},$.prototype.get=function(t,e){return this.has(t)?this._start+M(this,t)*this._step:e},$.prototype.includes=function(t){var e=(t-this._start)/this._step;return e>=0&&e<this.size&&e===Math.floor(e)},$.prototype.slice=function(t,e){return y(t,e,this.size)?this:(t=m(t,this.size),e=I(e,this.size),e<=t?new $(0,0):new $(this.get(t,this._end),this.get(e,this._end),this._step))},$.prototype.indexOf=function(t){var e=t-this._start;if(e%this._step==0){var n=e/this._step;if(n>=0&&n<this.size)return n}return-1},$.prototype.lastIndexOf=function(t){return this.indexOf(t)},$.prototype.__iterate=function(t,e){for(var n=this.size-1,r=this._step,o=e?this._start+n*r:this._start,i=0;i<=n;i++){if(!1===t(o,i,this))return i+1;o+=e?-r:r}return i},$.prototype.__iterator=function(t,e){var n=this.size-1,r=this._step,o=e?this._start+n*r:this._start,i=0;return new D(function(){var a=o;return o+=e?-r:r,i>n?v():N(t,i++,a)})},$.prototype.equals=function(t){return t instanceof $?this._start===t._start&&this._end===t._end&&this._step===t._step:q(this,t)};var An;t(tt,e),t(et,tt),t(nt,tt),t(rt,tt),tt.Keyed=et,tt.Indexed=nt,tt.Set=rt;var En,Sn="function"==typeof Math.imul&&-2===Math.imul(4294967295,2)?Math.imul:function(t,e){t|=0,e|=0;var n=65535&t,r=65535&e;return n*r+((t>>>16)*r+n*(e>>>16)<<16>>>0)|0},bn=Object.isExtensible,xn=function(){try{return Object.defineProperty({},"@",{}),!0}catch(t){return!1}}(),On="function"==typeof WeakMap;On&&(En=new WeakMap);var _n=0,kn="__immutablehash__";"function"==typeof Symbol&&(kn=Symbol(kn));var Ln=16,Un=255,Qn=0,Yn={};t(ft,et),ft.prototype.toString=function(){return this.__toString("Map {","}")},ft.prototype.get=function(t,e){return this._root?this._root.get(0,void 0,t,e):e},ft.prototype.set=function(t,e){return vt(this,t,e)},ft.prototype.setIn=function(t,e){return this.updateIn(t,hn,function(){return e})},ft.prototype.remove=function(t){return vt(this,t,hn)},ft.prototype.deleteIn=function(t){return this.updateIn(t,function(){return hn})},ft.prototype.update=function(t,e,n){return 1===arguments.length?t(this):this.updateIn([t],e,n)},ft.prototype.updateIn=function(t,e,n){n||(n=e,e=void 0);var r=_t(this,be(t),e,n);return r===hn?void 0:r},ft.prototype.clear=function(){return 0===this.size?this:this.__ownerID?(this.size=0,this._root=null,this.__hash=void 0,this.__altered=!0,this):Nt()},ft.prototype.merge=function(){return St(this,void 0,arguments)},ft.prototype.mergeWith=function(t){return St(this,t,un.call(arguments,1))},ft.prototype.mergeIn=function(t){var e=un.call(arguments,1);return this.updateIn(t,Nt(),function(t){return"function"==typeof t.merge?t.merge.apply(t,e):e[e.length-1]})},ft.prototype.mergeDeep=function(){return St(this,bt,arguments)},ft.prototype.mergeDeepWith=function(t){var e=un.call(arguments,1);return St(this,xt(t),e)},ft.prototype.mergeDeepIn=function(t){var e=un.call(arguments,1);return this.updateIn(t,Nt(),function(t){return"function"==typeof t.mergeDeep?t.mergeDeep.apply(t,e):e[e.length-1]})},ft.prototype.sort=function(t){return Xt(we(this,t))},ft.prototype.sortBy=function(t,e){return Xt(we(this,e,t))},ft.prototype.withMutations=function(t){var e=this.asMutable();return t(e),e.wasAltered()?e.__ensureOwner(this.__ownerID):this},ft.prototype.asMutable=function(){return this.__ownerID?this:this.__ensureOwner(new p)},ft.prototype.asImmutable=function(){return this.__ensureOwner()},ft.prototype.wasAltered=function(){return this.__altered},ft.prototype.__iterator=function(t,e){return new mt(this,t,e)},ft.prototype.__iterate=function(t,e){var n=this,r=0;return this._root&&this._root.iterate(function(e){return r++,t(e[1],e[0],n)},e),r},ft.prototype.__ensureOwner=function(t){return t===this.__ownerID?this:t?Dt(this.size,this._root,t,this.__hash):(this.__ownerID=t,this.__altered=!1,this)},ft.isMap=pt;var Bn="@@__IMMUTABLE_MAP__@@",Pn=ft.prototype;Pn[Bn]=!0,Pn.delete=Pn.remove,Pn.removeIn=Pn.deleteIn,dt.prototype.get=function(t,e,n,r){for(var o=this.entries,i=0,a=o.length;i<a;i++)if(J(n,o[i][0]))return o[i][1];return r},dt.prototype.update=function(t,e,n,r,o,i,a){for(var s=o===hn,u=this.entries,c=0,l=u.length;c<l&&!J(r,u[c][0]);c++);var p=c<l;if(p?u[c][1]===o:s)return this;if(f(a),(s||!p)&&f(i),!s||1!==u.length){if(!p&&!s&&u.length>=Zn)return Tt(t,u,r,o);var g=t&&t===this.ownerID,M=g?u:d(u);return p?s?c===l-1?M.pop():M[c]=M.pop():M[c]=[r,o]:M.push([r,o]),g?(this.entries=M,this):new dt(t,M)}},gt.prototype.get=function(t,e,n,r){void 0===e&&(e=it(n));var o=1<<((0===t?e:e>>>t)&Mn),i=this.bitmap;return 0==(i&o)?r:this.nodes[kt(i&o-1)].get(t+dn,e,n,r)},gt.prototype.update=function(t,e,n,r,o,i,a){void 0===n&&(n=it(r));var s=(0===e?n:n>>>e)&Mn,u=1<<s,c=this.bitmap,l=0!=(c&u);if(!l&&o===hn)return this;var f=kt(c&u-1),p=this.nodes,d=l?p[f]:void 0,g=Ct(d,t,e+dn,n,r,o,i,a);if(g===d)return this;if(!l&&g&&p.length>=Gn)return Et(t,p,c,s,g);if(l&&!g&&2===p.length&&jt(p[1^f]))return p[1^f];if(l&&g&&1===p.length&&jt(g))return g;var M=t&&t===this.ownerID,h=l?g?c:c^u:c|u,y=l?g?Lt(p,f,g,M):Qt(p,f,M):Ut(p,f,g,M);return M?(this.bitmap=h,this.nodes=y,this):new gt(t,h,y)},Mt.prototype.get=function(t,e,n,r){void 0===e&&(e=it(n));var o=(0===t?e:e>>>t)&Mn,i=this.nodes[o];return i?i.get(t+dn,e,n,r):r},Mt.prototype.update=function(t,e,n,r,o,i,a){void 0===n&&(n=it(r));var s=(0===e?n:n>>>e)&Mn,u=o===hn,c=this.nodes,l=c[s];if(u&&!l)return this;var f=Ct(l,t,e+dn,n,r,o,i,a);if(f===l)return this;var p=this.count;if(l){if(!f&&--p<Wn)return At(t,c,p,s)}else p++;var d=t&&t===this.ownerID,g=Lt(c,s,f,d);return d?(this.count=p,this.nodes=g,this):new Mt(t,p,g)},ht.prototype.get=function(t,e,n,r){for(var o=this.entries,i=0,a=o.length;i<a;i++)if(J(n,o[i][0]))return o[i][1];return r},ht.prototype.update=function(t,e,n,r,o,i,a){void 0===n&&(n=it(r));var s=o===hn;if(n!==this.keyHash)return s?this:(f(a),f(i),zt(this,t,e,n,[r,o]));for(var u=this.entries,c=0,l=u.length;c<l&&!J(r,u[c][0]);c++);var p=c<l;if(p?u[c][1]===o:s)return this;if(f(a),(s||!p)&&f(i),s&&2===l)return new yt(t,this.keyHash,u[1^c]);var g=t&&t===this.ownerID,M=g?u:d(u);return p?s?c===l-1?M.pop():M[c]=M.pop():M[c]=[r,o]:M.push([r,o]),g?(this.entries=M,this):new ht(t,this.keyHash,M)},yt.prototype.get=function(t,e,n,r){return J(n,this.entry[0])?this.entry[1]:r},yt.prototype.update=function(t,e,n,r,o,i,a){var s=o===hn,u=J(r,this.entry[0]);return(u?o===this.entry[1]:s)?this:(f(a),s?void f(i):u?t&&t===this.ownerID?(this.entry[1]=o,this):new yt(t,this.keyHash,[r,o]):(f(i),zt(this,t,e,it(r),[r,o])))},dt.prototype.iterate=ht.prototype.iterate=function(t,e){for(var n=this.entries,r=0,o=n.length-1;r<=o;r++)if(!1===t(n[e?o-r:r]))return!1},gt.prototype.iterate=Mt.prototype.iterate=function(t,e){for(var n=this.nodes,r=0,o=n.length-1;r<=o;r++){var i=n[e?o-r:r];if(i&&!1===i.iterate(t,e))return!1}},yt.prototype.iterate=function(t,e){return t(this.entry)},t(mt,D),mt.prototype.next=function(){for(var t=this._type,e=this._stack;e;){var n,r=e.node,o=e.index++;if(r.entry){if(0===o)return It(t,r.entry)}else if(r.entries){if(n=r.entries.length-1,o<=n)return It(t,r.entries[this._reverse?n-o:o])}else if(n=r.nodes.length-1,o<=n){var i=r.nodes[this._reverse?n-o:o];if(i){if(i.entry)return It(t,i.entry);e=this._stack=wt(i,e)}continue}e=this._stack=this._stack.__prev}return v()};var Rn,Zn=gn/4,Gn=gn/2,Wn=gn/4;t(Yt,nt),Yt.of=function(){return this(arguments)},Yt.prototype.toString=function(){return this.__toString("List [","]")},Yt.prototype.get=function(t,e){if((t=M(this,t))>=0&&t<this.size){t+=this._origin;var n=Kt(this,t);return n&&n.array[t&Mn]}return e},Yt.prototype.set=function(t,e){return Wt(this,t,e)},Yt.prototype.remove=function(t){return this.has(t)?0===t?this.shift():t===this.size-1?this.pop():this.splice(t,1):this},Yt.prototype.insert=function(t,e){return this.splice(t,0,e)},Yt.prototype.clear=function(){return 0===this.size?this:this.__ownerID?(this.size=this._origin=this._capacity=0,this._level=dn,this._root=this._tail=null,this.__hash=void 0,this.__altered=!0,this):Gt()},Yt.prototype.push=function(){var t=arguments,e=this.size;return this.withMutations(function(n){Jt(n,0,e+t.length);for(var r=0;r<t.length;r++)n.set(e+r,t[r])})},Yt.prototype.pop=function(){return Jt(this,0,-1)},Yt.prototype.unshift=function(){var t=arguments;return this.withMutations(function(e){Jt(e,-t.length);for(var n=0;n<t.length;n++)e.set(n,t[n])})},Yt.prototype.shift=function(){return Jt(this,1)},Yt.prototype.merge=function(){return qt(this,void 0,arguments)},Yt.prototype.mergeWith=function(t){return qt(this,t,un.call(arguments,1))},Yt.prototype.mergeDeep=function(){return qt(this,bt,arguments)},Yt.prototype.mergeDeepWith=function(t){var e=un.call(arguments,1);return qt(this,xt(t),e)},Yt.prototype.setSize=function(t){return Jt(this,0,t)},Yt.prototype.slice=function(t,e){var n=this.size;return y(t,e,n)?this:Jt(this,m(t,n),I(e,n))},Yt.prototype.__iterator=function(t,e){var n=0,r=Rt(this,e);return new D(function(){var e=r();return e===Jn?v():N(t,n++,e)})},Yt.prototype.__iterate=function(t,e){for(var n,r=0,o=Rt(this,e);(n=o())!==Jn&&!1!==t(n,r++,this););return r},Yt.prototype.__ensureOwner=function(t){return t===this.__ownerID?this:t?Zt(this._origin,this._capacity,this._level,this._root,this._tail,t,this.__hash):(this.__ownerID=t,this)},Yt.isList=Bt;var Fn="@@__IMMUTABLE_LIST__@@",Hn=Yt.prototype;Hn[Fn]=!0,Hn.delete=Hn.remove,Hn.setIn=Pn.setIn,Hn.deleteIn=Hn.removeIn=Pn.removeIn,Hn.update=Pn.update,Hn.updateIn=Pn.updateIn,Hn.mergeIn=Pn.mergeIn,Hn.mergeDeepIn=Pn.mergeDeepIn,Hn.withMutations=Pn.withMutations,Hn.asMutable=Pn.asMutable,Hn.asImmutable=Pn.asImmutable,Hn.wasAltered=Pn.wasAltered,Pt.prototype.removeBefore=function(t,e,n){if(n===e?1<<e:0===this.array.length)return this;var r=n>>>e&Mn;if(r>=this.array.length)return new Pt([],t);var o,i=0===r;if(e>0){var a=this.array[r];if((o=a&&a.removeBefore(t,e-dn,n))===a&&i)return this}if(i&&!o)return this;var s=Ht(this,t);if(!i)for(var u=0;u<r;u++)s.array[u]=void 0;return o&&(s.array[r]=o),s},Pt.prototype.removeAfter=function(t,e,n){if(n===(e?1<<e:0)||0===this.array.length)return this;var r=n-1>>>e&Mn;if(r>=this.array.length)return this;var o;if(e>0){var i=this.array[r];if((o=i&&i.removeAfter(t,e-dn,n))===i&&r===this.array.length-1)return this}var a=Ht(this,t);return a.array.splice(r+1),o&&(a.array[r]=o),a};var Kn,Jn={};t(Xt,ft),Xt.of=function(){return this(arguments)},Xt.prototype.toString=function(){return this.__toString("OrderedMap {","}")},Xt.prototype.get=function(t,e){var n=this._map.get(t);return void 0!==n?this._list.get(n)[1]:e},Xt.prototype.clear=function(){return 0===this.size?this:this.__ownerID?(this.size=0,this._map.clear(),this._list.clear(),this):ee()},Xt.prototype.set=function(t,e){return ne(this,t,e)},Xt.prototype.remove=function(t){return ne(this,t,hn)},Xt.prototype.wasAltered=function(){return this._map.wasAltered()||this._list.wasAltered()},Xt.prototype.__iterate=function(t,e){var n=this;return this._list.__iterate(function(e){return e&&t(e[1],e[0],n)},e)},Xt.prototype.__iterator=function(t,e){return this._list.fromEntrySeq().__iterator(t,e)},Xt.prototype.__ensureOwner=function(t){if(t===this.__ownerID)return this;var e=this._map.__ensureOwner(t),n=this._list.__ensureOwner(t);return t?te(e,n,t,this.__hash):(this.__ownerID=t,this._map=e,this._list=n,this)},Xt.isOrderedMap=$t,Xt.prototype[pn]=!0,Xt.prototype.delete=Xt.prototype.remove;var qn;t(re,S),re.prototype.get=function(t,e){return this._iter.get(t,e)},re.prototype.has=function(t){return this._iter.has(t)},re.prototype.valueSeq=function(){return this._iter.valueSeq()},re.prototype.reverse=function(){var t=this,e=ce(this,!0);return this._useKeys||(e.valueSeq=function(){return t._iter.toSeq().reverse()}),e},re.prototype.map=function(t,e){var n=this,r=ue(this,t,e);return this._useKeys||(r.valueSeq=function(){return n._iter.toSeq().map(t,e)}),r},re.prototype.__iterate=function(t,e){var n,r=this;return this._iter.__iterate(this._useKeys?function(e,n){return t(e,n,r)}:(n=e?ze(this):0,function(o){return t(o,e?--n:n++,r)}),e)},re.prototype.__iterator=function(t,e){if(this._useKeys)return this._iter.__iterator(t,e);var n=this._iter.__iterator(wn,e),r=e?ze(this):0;return new D(function(){var o=n.next();return o.done?o:N(t,e?--r:r++,o.value,o)})},re.prototype[pn]=!0,t(oe,b),oe.prototype.includes=function(t){return this._iter.includes(t)},oe.prototype.__iterate=function(t,e){var n=this,r=0;return this._iter.__iterate(function(e){return t(e,r++,n)},e)},oe.prototype.__iterator=function(t,e){var n=this._iter.__iterator(wn,e),r=0;return new D(function(){var e=n.next();return e.done?e:N(t,r++,e.value,e)})},t(ie,x),ie.prototype.has=function(t){return this._iter.includes(t)},ie.prototype.__iterate=function(t,e){var n=this;return this._iter.__iterate(function(e){return t(e,e,n)},e)},ie.prototype.__iterator=function(t,e){var n=this._iter.__iterator(wn,e);return new D(function(){var e=n.next();return e.done?e:N(t,e.value,e.value,e)})},t(ae,S),ae.prototype.entrySeq=function(){return this._iter.toSeq()},ae.prototype.__iterate=function(t,e){var n=this;return this._iter.__iterate(function(e){if(e){je(e);var r=i(e);return t(r?e.get(1):e[1],r?e.get(0):e[0],n)}},e)},ae.prototype.__iterator=function(t,e){var n=this._iter.__iterator(wn,e);return new D(function(){for(;;){var e=n.next();if(e.done)return e;var r=e.value;if(r){je(r);var o=i(r);return N(t,o?r.get(0):r[0],o?r.get(1):r[1],e)}}})},oe.prototype.cacheResult=re.prototype.cacheResult=ie.prototype.cacheResult=ae.prototype.cacheResult=Ee,t(xe,et),xe.prototype.toString=function(){return this.__toString(_e(this)+" {","}")},xe.prototype.has=function(t){return this._defaultValues.hasOwnProperty(t)},xe.prototype.get=function(t,e){if(!this.has(t))return e;var n=this._defaultValues[t];return this._map?this._map.get(t,n):n},xe.prototype.clear=function(){if(this.__ownerID)return this._map&&this._map.clear(),this;var t=this.constructor;return t._empty||(t._empty=Oe(this,Nt()))},xe.prototype.set=function(t,e){if(!this.has(t))throw new Error('Cannot set unknown key "'+t+'" on '+_e(this));var n=this._map&&this._map.set(t,e);return this.__ownerID||n===this._map?this:Oe(this,n)},xe.prototype.remove=function(t){if(!this.has(t))return this;var e=this._map&&this._map.remove(t);return this.__ownerID||e===this._map?this:Oe(this,e)},xe.prototype.wasAltered=function(){return this._map.wasAltered()},xe.prototype.__iterator=function(t,e){var r=this;return n(this._defaultValues).map(function(t,e){return r.get(e)}).__iterator(t,e)},xe.prototype.__iterate=function(t,e){var r=this;return n(this._defaultValues).map(function(t,e){return r.get(e)}).__iterate(t,e)},xe.prototype.__ensureOwner=function(t){if(t===this.__ownerID)return this;var e=this._map&&this._map.__ensureOwner(t);return t?Oe(this,e,t):(this.__ownerID=t,this._map=e,this)};var Vn=xe.prototype;Vn.delete=Vn.remove,Vn.deleteIn=Vn.removeIn=Pn.removeIn,Vn.merge=Pn.merge,Vn.mergeWith=Pn.mergeWith,Vn.mergeIn=Pn.mergeIn,Vn.mergeDeep=Pn.mergeDeep,Vn.mergeDeepWith=Pn.mergeDeepWith,Vn.mergeDeepIn=Pn.mergeDeepIn,Vn.setIn=Pn.setIn,Vn.update=Pn.update,Vn.updateIn=Pn.updateIn,Vn.withMutations=Pn.withMutations,Vn.asMutable=Pn.asMutable,Vn.asImmutable=Pn.asImmutable,t(Ue,rt),Ue.of=function(){return this(arguments)},Ue.fromKeys=function(t){return this(n(t).keySeq())},Ue.prototype.toString=function(){return this.__toString("Set {","}")},Ue.prototype.has=function(t){return this._map.has(t)},Ue.prototype.add=function(t){return Ye(this,this._map.set(t,!0))},Ue.prototype.remove=function(t){return Ye(this,this._map.remove(t))},Ue.prototype.clear=function(){return Ye(this,this._map.clear())},Ue.prototype.union=function(){var t=un.call(arguments,0);return t=t.filter(function(t){return 0!==t.size}),0===t.length?this:0!==this.size||this.__ownerID||1!==t.length?this.withMutations(function(e){for(var n=0;n<t.length;n++)o(t[n]).forEach(function(t){return e.add(t)})}):this.constructor(t[0])},Ue.prototype.intersect=function(){var t=un.call(arguments,0);if(0===t.length)return this;t=t.map(function(t){return o(t)});var e=this;return this.withMutations(function(n){e.forEach(function(e){t.every(function(t){return t.includes(e)})||n.remove(e)})})},Ue.prototype.subtract=function(){var t=un.call(arguments,0);if(0===t.length)return this;t=t.map(function(t){return o(t)});var e=this;return this.withMutations(function(n){e.forEach(function(e){t.some(function(t){return t.includes(e)})&&n.remove(e)})})},Ue.prototype.merge=function(){return this.union.apply(this,arguments)},Ue.prototype.mergeWith=function(t){var e=un.call(arguments,1);return this.union.apply(this,e)},Ue.prototype.sort=function(t){return Re(we(this,t))},Ue.prototype.sortBy=function(t,e){return Re(we(this,e,t))},Ue.prototype.wasAltered=function(){return this._map.wasAltered()},Ue.prototype.__iterate=function(t,e){var n=this;return this._map.__iterate(function(e,r){return t(r,r,n)},e)},Ue.prototype.__iterator=function(t,e){return this._map.map(function(t,e){return e}).__iterator(t,e)},Ue.prototype.__ensureOwner=function(t){if(t===this.__ownerID)return this;var e=this._map.__ensureOwner(t);return t?this.__make(e,t):(this.__ownerID=t,this._map=e,this)},Ue.isSet=Qe;var Xn="@@__IMMUTABLE_SET__@@",$n=Ue.prototype;$n[Xn]=!0,$n.delete=$n.remove,$n.mergeDeep=$n.merge,$n.mergeDeepWith=$n.mergeWith,$n.withMutations=Pn.withMutations,$n.asMutable=Pn.asMutable,$n.asImmutable=Pn.asImmutable,$n.__empty=Pe,$n.__make=Be;var tr;t(Re,Ue),Re.of=function(){return this(arguments)},Re.fromKeys=function(t){return this(n(t).keySeq())},Re.prototype.toString=function(){return this.__toString("OrderedSet {","}")},Re.isOrderedSet=Ze;var er=Re.prototype;er[pn]=!0,er.__empty=We,er.__make=Ge;var nr;t(Fe,nt),Fe.of=function(){return this(arguments)},Fe.prototype.toString=function(){return this.__toString("Stack [","]")},Fe.prototype.get=function(t,e){var n=this._head;for(t=M(this,t);n&&t--;)n=n.next;return n?n.value:e},Fe.prototype.peek=function(){return this._head&&this._head.value},Fe.prototype.push=function(){if(0===arguments.length)return this;for(var t=this.size+arguments.length,e=this._head,n=arguments.length-1;n>=0;n--)e={value:arguments[n],next:e};return this.__ownerID?(this.size=t,this._head=e,this.__hash=void 0,this.__altered=!0,this):Ke(t,e)},Fe.prototype.pushAll=function(t){if(t=r(t),0===t.size)return this;lt(t.size);var e=this.size,n=this._head;return t.reverse().forEach(function(t){e++,n={value:t,next:n}}),this.__ownerID?(this.size=e,this._head=n,this.__hash=void 0,this.__altered=!0,this):Ke(e,n)},Fe.prototype.pop=function(){return this.slice(1)},Fe.prototype.unshift=function(){return this.push.apply(this,arguments)},Fe.prototype.unshiftAll=function(t){return this.pushAll(t)},Fe.prototype.shift=function(){return this.pop.apply(this,arguments)},Fe.prototype.clear=function(){return 0===this.size?this:this.__ownerID?(this.size=0,this._head=void 0,this.__hash=void 0,this.__altered=!0,this):Je()},Fe.prototype.slice=function(t,e){if(y(t,e,this.size))return this;var n=m(t,this.size);if(I(e,this.size)!==this.size)return nt.prototype.slice.call(this,t,e);for(var r=this.size-n,o=this._head;n--;)o=o.next;return this.__ownerID?(this.size=r,this._head=o,this.__hash=void 0,this.__altered=!0,this):Ke(r,o)},Fe.prototype.__ensureOwner=function(t){return t===this.__ownerID?this:t?Ke(this.size,this._head,t,this.__hash):(this.__ownerID=t,this.__altered=!1,this)},Fe.prototype.__iterate=function(t,e){if(e)return this.reverse().__iterate(t);for(var n=0,r=this._head;r&&!1!==t(r.value,n++,this);)r=r.next;return n},Fe.prototype.__iterator=function(t,e){if(e)return this.reverse().__iterator(t);var n=0,r=this._head;return new D(function(){if(r){var e=r.value;return r=r.next,N(t,n++,e)}return v()})},Fe.isStack=He;var rr="@@__IMMUTABLE_STACK__@@",or=Fe.prototype;or[rr]=!0,or.withMutations=Pn.withMutations,or.asMutable=Pn.asMutable,or.asImmutable=Pn.asImmutable,or.wasAltered=Pn.wasAltered;var ir;e.Iterator=D,qe(e,{toArray:function(){lt(this.size);var t=new Array(this.size||0);return this.valueSeq().__iterate(function(e,n){t[n]=e}),t},toIndexedSeq:function(){return new oe(this)},toJS:function(){return this.toSeq().map(function(t){return t&&"function"==typeof t.toJS?t.toJS():t}).__toJS()},toJSON:function(){return this.toSeq().map(function(t){return t&&"function"==typeof t.toJSON?t.toJSON():t}).__toJS()},toKeyedSeq:function(){return new re(this,!0)},toMap:function(){return ft(this.toKeyedSeq())},toObject:function(){lt(this.size);var t={};return this.__iterate(function(e,n){t[n]=e}),t},toOrderedMap:function(){return Xt(this.toKeyedSeq())},toOrderedSet:function(){return Re(a(this)?this.valueSeq():this)},toSet:function(){return Ue(a(this)?this.valueSeq():this)},toSetSeq:function(){return new ie(this)},toSeq:function(){return s(this)?this.toIndexedSeq():a(this)?this.toKeyedSeq():this.toSetSeq()},toStack:function(){return Fe(a(this)?this.valueSeq():this)},toList:function(){return Yt(a(this)?this.valueSeq():this)},toString:function(){return"[Iterable]"},__toString:function(t,e){return 0===this.size?t+e:t+" "+this.toSeq().map(this.__toStringMapper).join(", ")+" "+e},concat:function(){return Ce(this,he(this,un.call(arguments,0)))},includes:function(t){return this.some(function(e){return J(e,t)})},entries:function(){return this.__iterator(Dn)},every:function(t,e){lt(this.size);var n=!0;return this.__iterate(function(r,o,i){if(!t.call(e,r,o,i))return n=!1,!1}),n},filter:function(t,e){return Ce(this,le(this,t,e,!0))},find:function(t,e,n){var r=this.findEntry(t,e);return r?r[1]:n},findEntry:function(t,e){var n;return this.__iterate(function(r,o,i){if(t.call(e,r,o,i))return n=[o,r],!1}),n},findLastEntry:function(t,e){return this.toSeq().reverse().findEntry(t,e)},forEach:function(t,e){return lt(this.size),this.__iterate(e?t.bind(e):t)},join:function(t){lt(this.size),t=void 0!==t?""+t:",";var e="",n=!0;return this.__iterate(function(r){n?n=!1:e+=t,e+=null!==r&&void 0!==r?r.toString():""}),e},keys:function(){return this.__iterator(In)},map:function(t,e){return Ce(this,ue(this,t,e))},reduce:function(t,e,n){lt(this.size);var r,o;return arguments.length<2?o=!0:r=e,this.__iterate(function(e,i,a){o?(o=!1,r=e):r=t.call(n,r,e,i,a)}),r},reduceRight:function(t,e,n){var r=this.toKeyedSeq().reverse();return r.reduce.apply(r,arguments)},reverse:function(){return Ce(this,ce(this,!0))},slice:function(t,e){return Ce(this,de(this,t,e,!0))},some:function(t,e){return!this.every($e(t),e)},sort:function(t){return Ce(this,we(this,t))},values:function(){return this.__iterator(wn)},butLast:function(){return this.slice(0,-1)},isEmpty:function(){return void 0!==this.size?0===this.size:!this.some(function(){return!0})},count:function(t,e){return g(t?this.toSeq().filter(t,e):this)},countBy:function(t,e){return fe(this,t,e)},equals:function(t){return q(this,t)},entrySeq:function(){var t=this;if(t._cache)return new O(t._cache);var e=t.toSeq().map(Xe).toIndexedSeq();return e.fromEntrySeq=function(){return t.toSeq()},e},filterNot:function(t,e){return this.filter($e(t),e)},findLast:function(t,e,n){return this.toKeyedSeq().reverse().find(t,e,n)},first:function(){return this.find(h)},flatMap:function(t,e){return Ce(this,me(this,t,e))},flatten:function(t){return Ce(this,ye(this,t,!0))},fromEntrySeq:function(){return new ae(this)},get:function(t,e){return this.find(function(e,n){return J(n,t)},void 0,e)},getIn:function(t,e){for(var n,r=this,o=be(t);!(n=o.next()).done;){var i=n.value;if((r=r&&r.get?r.get(i,hn):hn)===hn)return e}return r},groupBy:function(t,e){return pe(this,t,e)},has:function(t){return this.get(t,hn)!==hn},hasIn:function(t){return this.getIn(t,hn)!==hn},isSubset:function(t){return t="function"==typeof t.includes?t:e(t),this.every(function(e){return t.includes(e)})},isSuperset:function(t){return t="function"==typeof t.isSubset?t:e(t),t.isSubset(this)},keySeq:function(){return this.toSeq().map(Ve).toIndexedSeq()},last:function(){return this.toSeq().reverse().first()},max:function(t){return De(this,t)},maxBy:function(t,e){return De(this,e,t)},min:function(t){return De(this,t?tn(t):rn)},minBy:function(t,e){return De(this,e?tn(e):rn,t)},rest:function(){return this.slice(1)},skip:function(t){return this.slice(Math.max(0,t))},skipLast:function(t){return Ce(this,this.toSeq().reverse().skip(t).reverse())},skipWhile:function(t,e){return Ce(this,Me(this,t,e,!0))},skipUntil:function(t,e){return this.skipWhile($e(t),e)},sortBy:function(t,e){return Ce(this,we(this,e,t))},take:function(t){return this.slice(0,Math.max(0,t))},takeLast:function(t){return Ce(this,this.toSeq().reverse().take(t).reverse())},takeWhile:function(t,e){return Ce(this,ge(this,t,e))},takeUntil:function(t,e){return this.takeWhile($e(t),e)},valueSeq:function(){return this.toIndexedSeq()},hashCode:function(){return this.__hash||(this.__hash=on(this))}});var ar=e.prototype;ar[cn]=!0,ar[Cn]=ar.values,ar.__toJS=ar.toArray,ar.__toStringMapper=en,ar.inspect=ar.toSource=function(){return this.toString()},ar.chain=ar.flatMap,ar.contains=ar.includes,function(){try{Object.defineProperty(ar,"length",{get:function(){if(!e.noLengthWarning){var t;try{throw new Error}catch(e){t=e.stack}if(-1===t.indexOf("_wrapObject"))return console&&console.warn&&console.warn("iterable.length has been deprecated, use iterable.size or iterable.count(). This warning will become a silent error in a future version. "+t),this.size}}})}catch(t){}}(),qe(n,{flip:function(){return Ce(this,se(this))},findKey:function(t,e){var n=this.findEntry(t,e);return n&&n[0]},findLastKey:function(t,e){return this.toSeq().reverse().findKey(t,e)},keyOf:function(t){return this.findKey(function(e){return J(e,t)})},lastKeyOf:function(t){return this.findLastKey(function(e){return J(e,t)})},mapEntries:function(t,e){var n=this,r=0;return Ce(this,this.toSeq().map(function(o,i){return t.call(e,[i,o],r++,n)}).fromEntrySeq())},mapKeys:function(t,e){var n=this;return Ce(this,this.toSeq().flip().map(function(r,o){return t.call(e,r,o,n)}).flip())}});var sr=n.prototype;return sr[ln]=!0,sr[Cn]=ar.entries,sr.__toJS=ar.toObject,sr.__toStringMapper=function(t,e){return JSON.stringify(e)+": "+en(t)},qe(r,{toKeyedSeq:function(){return new re(this,!1)},filter:function(t,e){return Ce(this,le(this,t,e,!1))},findIndex:function(t,e){var n=this.findEntry(t,e);return n?n[0]:-1},indexOf:function(t){var e=this.toKeyedSeq().keyOf(t);return void 0===e?-1:e},lastIndexOf:function(t){var e=this.toKeyedSeq().reverse().keyOf(t);return void 0===e?-1:e},reverse:function(){return Ce(this,ce(this,!1))},slice:function(t,e){return Ce(this,de(this,t,e,!1))},splice:function(t,e){var n=arguments.length;if(e=Math.max(0|e,0),0===n||2===n&&!e)return this;t=m(t,t<0?this.count():this.size);var r=this.slice(0,t);return Ce(this,1===n?r:r.concat(d(arguments,2),this.slice(t+e)))},findLastIndex:function(t,e){var n=this.toKeyedSeq().findLastKey(t,e);return void 0===n?-1:n},first:function(){return this.get(0)},flatten:function(t){return Ce(this,ye(this,t,!1))},get:function(t,e){return t=M(this,t),t<0||this.size===1/0||void 0!==this.size&&t>this.size?e:this.find(function(e,n){return n===t},void 0,e)},has:function(t){return(t=M(this,t))>=0&&(void 0!==this.size?this.size===1/0||t<this.size:-1!==this.indexOf(t))},interpose:function(t){return Ce(this,Ie(this,t))},interleave:function(){var t=[this].concat(d(arguments)),e=ve(this.toSeq(),b.of,t),n=e.flatten(!0);return e.size&&(n.size=e.size*t.length),Ce(this,n)},last:function(){return this.get(-1)},skipWhile:function(t,e){return Ce(this,Me(this,t,e,!1))},zip:function(){return Ce(this,ve(this,nn,[this].concat(d(arguments))))},zipWith:function(t){var e=d(arguments);return e[0]=this,Ce(this,ve(this,t,e))}}),r.prototype[fn]=!0,r.prototype[pn]=!0,qe(o,{get:function(t,e){return this.has(t)?t:e},includes:function(t){return this.has(t)},keySeq:function(){return this.valueSeq()}}),o.prototype.has=ar.includes,qe(S,n.prototype),qe(b,r.prototype),qe(x,o.prototype),qe(et,n.prototype),qe(nt,r.prototype),qe(rt,o.prototype),{Iterable:e,Seq:E,Collection:tt,Map:ft,OrderedMap:Xt,List:Yt,Stack:Fe,Set:Ue,OrderedSet:Re,Record:xe,Range:$,Repeat:V,is:J,fromJS:W}})},function(t,e,n){"use strict";var r,o,i="function"==typeof Symbol&&"symbol"==typeof Symbol.iterator?function(t){return typeof t}:function(t){return t&&"function"==typeof Symbol&&t.constructor===Symbol&&t!==Symbol.prototype?"symbol":typeof t};/*!
  Copyright (c) 2016 Jed Watson.
  Licensed under the MIT License (MIT), see
  http://jedwatson.github.io/classnames
*/
!function(){function a(){for(var t=[],e=0;e<arguments.length;e++){var n=arguments[e];if(n){var r=void 0===n?"undefined":i(n);if("string"===r||"number"===r)t.push(n);else if(Array.isArray(n))t.push(a.apply(null,n));else if("object"===r)for(var o in n)s.call(n,o)&&n[o]&&t.push(o)}}return t.join(" ")}var s={}.hasOwnProperty;void 0!==t&&t.exports?t.exports=a:"object"===i(n(38))&&n(38)?(r=[],void 0!==(o=function(){return a}.apply(e,r))&&(t.exports=o)):window.classNames=a}()},function(t,e,n){"use strict";var r=n(77),o=n(21),i=n(11),a=n(92),s=n(17),u=n(32),c=n(35),l=n(50),f=n(93),p=n(52),d=n(29),g=n(7),M=n(48),h=n(3),y=n(42),m=n(155),I=n(22),w=n(157),D=n(65),N=n(160),v=n(12),C=n(67),j=n(164),z={Editor:f,EditorBlock:p,EditorState:h,CompositeDecorator:a,Entity:d,EntityInstance:M,BlockMapBuilder:o,CharacterMetadata:i,ContentBlock:s,ContentState:u,SelectionState:I,AtomicBlockUtils:r,KeyBindingUtil:y,Modifier:g,RichUtils:m,DefaultDraftBlockRenderMap:c,DefaultDraftInlineStyle:l,convertFromHTML:D,convertFromRaw:N,convertToRaw:w,genKey:v,getDefaultKeyBinding:C,getVisibleSelectionRect:j};t.exports=z},function(t,e,n){"use strict";var r=n(11),o=n(78),i=n(44),a=n(4),s=n(79),u=n(81),c=n(28),l=n(84),f=n(85),p=n(2),d=n(86),g=n(45),M=n(87),h=n(88),y=a.OrderedSet,m={replaceText:function(t,e,n,o,i){var a=g(t,e),s=M(a,e),u=r.create({style:o||y(),entity:i||null});return f(s,s.getSelectionAfter(),n,u)},insertText:function(t,e,n,r,o){return e.isCollapsed()||p(!1),m.replaceText(t,e,n,r,o)},moveText:function(t,e,n){var r=c(t,e),o=m.removeRange(t,e,"backward");return m.replaceWithFragment(o,n,r)},replaceWithFragment:function(t,e,n){var r=g(t,e),o=M(r,e);return l(o,o.getSelectionAfter(),n)},removeRange:function(t,e,n){var r=void 0,o=void 0,a=void 0,s=void 0;e.getIsBackward()&&(e=e.merge({anchorKey:e.getFocusKey(),anchorOffset:e.getFocusOffset(),focusKey:e.getAnchorKey(),focusOffset:e.getAnchorOffset(),isBackward:!1})),r=e.getAnchorKey(),o=e.getFocusKey(),a=t.getBlockForKey(r),s=t.getBlockForKey(o);var c=e.getStartOffset(),l=e.getEndOffset(),f=a.getEntityAt(c),p=s.getEntityAt(l-1);if(r===o&&f&&f===p){var d=u(t.getEntityMap(),a,s,e,n);return M(t,d)}var h=e;i.draft_segmented_entities_behavior&&(h=u(t.getEntityMap(),a,s,e,n));var y=g(t,h);return M(y,h)},splitBlock:function(t,e){var n=g(t,e),r=M(n,e);return h(r,r.getSelectionAfter())},applyInlineStyle:function(t,e,n){return o.add(t,e,n)},removeInlineStyle:function(t,e,n){return o.remove(t,e,n)},setBlockType:function(t,e,n){return d(t,e,function(t){return t.merge({type:n,depth:0})})},setBlockData:function(t,e,n){return d(t,e,function(t){return t.merge({data:n})})},mergeBlockData:function(t,e,n){return d(t,e,function(t){return t.merge({data:t.getData().merge(n)})})},applyEntity:function(t,e,n){var r=g(t,e);return s(r,e,n)}};t.exports=m},function(t,e,n){"use strict";var r=function(t){if(null!=t)return t;throw new Error("Got unexpected null or undefined")};t.exports=r},function(t,e,n){t.exports=function(t){function e(r){if(n[r])return n[r].exports;var o=n[r]={i:r,l:!1,exports:{}};return t[r].call(o.exports,o,o.exports,e),o.l=!0,o.exports}var n={};return e.m=t,e.c=n,e.d=function(t,n,r){e.o(t,n)||Object.defineProperty(t,n,{configurable:!1,enumerable:!0,get:r})},e.n=function(t){var n=t&&t.__esModule?function(){return t.default}:function(){return t};return e.d(n,"a",n),n},e.o=function(t,e){return Object.prototype.hasOwnProperty.call(t,e)},e.p="",e(e.s=3)}([function(t,e){t.exports=n(6)},function(t,e,n){"use strict";function r(t){var e=t.getSelection(),n=t.getCurrentContent(),r=e.getStartKey(),o=e.getEndKey(),i=n.getBlockMap();return i.toSeq().skipUntil(function(t,e){return e===r}).takeUntil(function(t,e){return e===o}).concat([[o,i.get(o)]])}function o(t){return r(t).toList()}function i(t){if(t)return o(t).get(0)}function a(t){if(t){var e=i(t),n=t.getCurrentContent(),r=n.getBlockMap().toSeq().toList(),o=0;if(r.forEach(function(t,n){t.get("key")===e.get("key")&&(o=n-1)}),o>-1)return r.get(o)}}function s(t){return t?t.getCurrentContent().getBlockMap().toList():new y.List}function u(t){var e=o(t);if(!e.some(function(t){return t.type!==e.get(0).type}))return e.get(0).type}function c(t){var e=h.RichUtils.tryToRemoveBlockStyle(t);return h.EditorState.push(t,e,"change-block-type")}function l(t){var e="",n=t.getSelection(),r=n.getAnchorOffset(),i=n.getFocusOffset(),a=o(t);if(a.size>0){if(n.getIsBackward()){var s=r;r=i,i=s}for(var u=0;u<a.size;u+=1){var c=0===u?r:0,l=u===a.size-1?i:a.get(u).getText().length;e+=a.get(u).getText().slice(c,l)}}return e}function f(t){var e=t.getCurrentContent(),n=t.getSelection(),r=h.Modifier.removeRange(e,n,"forward"),o=r.getSelectionAfter(),i=r.getBlockForKey(o.getStartKey());return r=h.Modifier.insertText(r,o,"\n",i.getInlineStyleAt(o.getStartOffset()),null),h.EditorState.push(t,r,"insert-fragment")}function p(t){var e=h.Modifier.splitBlock(t.getCurrentContent(),t.getSelection());return c(h.EditorState.push(t,e,"split-block"))}function d(t){var e=t.getCurrentContent().getBlockMap().toList(),n=t.getSelection().merge({anchorKey:e.first().get("key"),anchorOffset:0,focusKey:e.last().get("key"),focusOffset:e.last().getLength()}),r=h.Modifier.removeRange(t.getCurrentContent(),n,"forward");return h.EditorState.push(t,r,"remove-range")}function g(t,e){var n=h.Modifier.setBlockData(t.getCurrentContent(),t.getSelection(),e);return h.EditorState.push(t,n,"change-block-data")}function M(t){var e=new y.Map({}),n=o(t);if(n&&n.size>0)for(var r=0;r<n.size;r+=1){var i=function(t){var r=n.get(t).getData();if(!r||0===r.size)return e=e.clear(),"break";if(0===t)e=r;else if(e.forEach(function(t,n){r.get(n)&&r.get(n)===t||(e=e.delete(n))}),0===e.size)return e=e.clear(),"break"}(r);if("break"===i)break}return e}Object.defineProperty(e,"__esModule",{value:!0}),e.blockRenderMap=void 0,e.getSelectedBlocksMap=r,e.getSelectedBlocksList=o,e.getSelectedBlock=i,e.getBlockBeforeSelectedBlock=a,e.getAllBlocks=s,e.getSelectedBlocksType=u,e.removeSelectedBlocksStyle=c,e.getSelectionText=l,e.addLineBreakRemovingSelection=f,e.insertNewUnstyledBlock=p,e.clearEditorContent=d,e.setBlockData=g,e.getSelectedBlocksMetadata=M;var h=n(0),y=n(6),m=(0,y.Map)({code:{element:"pre"}});e.blockRenderMap=h.DefaultDraftBlockRenderMap.merge(m)},function(t,e,n){"use strict";function r(t){if(t){var e=t.getType();return"unordered-list-item"===e||"ordered-list-item"===e}return!1}function o(t,e,n){var r=t.getSelection(),o=t.getCurrentContent(),i=o.getBlockMap(),a=(0,s.getSelectedBlocksMap)(t).map(function(t){var r=t.getDepth()+e;return r=Math.max(0,Math.min(r,n)),t.set("depth",r)});return i=i.merge(a),o.merge({blockMap:i,selectionBefore:r,selectionAfter:r})}function i(t,e,n){var r=t.getSelection(),i=void 0;i=r.getIsBackward()?r.getFocusKey():r.getAnchorKey();var s=t.getCurrentContent(),u=s.getBlockForKey(i),c=u.getType();if("unordered-list-item"!==c&&"ordered-list-item"!==c)return t;var l=s.getBlockBefore(i);if(!l)return t;if(l.getType()!==c)return t;var f=u.getDepth();if(1===e&&f===n)return t;var p=Math.min(l.getDepth()+1,n),d=o(t,e,p);return a.EditorState.push(t,d,"adjust-depth")}Object.defineProperty(e,"__esModule",{value:!0}),e.isListBlock=r,e.changeDepth=i;var a=n(0),s=n(1)},function(t,e,n){t.exports=n(4)},function(t,e,n){"use strict";var r=n(5),o=n(1),i=n(7),a=function(t){return t&&t.__esModule?t:{default:t}}(i),s=n(2);t.exports={getSelectedBlocksMap:o.getSelectedBlocksMap,getSelectedBlocksList:o.getSelectedBlocksList,getSelectedBlock:o.getSelectedBlock,getBlockBeforeSelectedBlock:o.getBlockBeforeSelectedBlock,getAllBlocks:o.getAllBlocks,getSelectedBlocksType:o.getSelectedBlocksType,removeSelectedBlocksStyle:o.removeSelectedBlocksStyle,getSelectionText:o.getSelectionText,addLineBreakRemovingSelection:o.addLineBreakRemovingSelection,insertNewUnstyledBlock:o.insertNewUnstyledBlock,clearEditorContent:o.clearEditorContent,setBlockData:o.setBlockData,getSelectedBlocksMetadata:o.getSelectedBlocksMetadata,blockRenderMap:o.blockRenderMap,getEntityRange:r.getEntityRange,getCustomStyleMap:r.getCustomStyleMap,toggleCustomInlineStyle:r.toggleCustomInlineStyle,getSelectionEntity:r.getSelectionEntity,extractInlineStyle:r.extractInlineStyle,removeAllInlineStyles:r.removeAllInlineStyles,getSelectionInlineStyle:r.getSelectionInlineStyle,getSelectionCustomInlineStyle:r.getSelectionCustomInlineStyle,handleNewLine:a.default,isListBlock:s.isListBlock,changeDepth:s.changeDepth}},function(t,e,n){"use strict";function r(t,e,n){return e in t?Object.defineProperty(t,e,{value:n,enumerable:!0,configurable:!0,writable:!0}):t[e]=n,t}function o(t){var e=t.getSelection();if(e.isCollapsed){var n={},r=t.getCurrentInlineStyle().toList().toJS();if(r)return["BOLD","ITALIC","UNDERLINE","STRIKETHROUGH","CODE","SUPERSCRIPT","SUBSCRIPT"].forEach(function(t){n[t]=r.indexOf(t)>=0}),n}var o=e.getStartOffset(),i=e.getEndOffset(),a=(0,h.getSelectedBlocksList)(t);if(a.size>0){var s=function(){for(var t={BOLD:!0,ITALIC:!0,UNDERLINE:!0,STRIKETHROUGH:!0,CODE:!0,SUPERSCRIPT:!0,SUBSCRIPT:!0},e=0;e<a.size;e+=1){var n=0===e?o:0,r=e===a.size-1?i:a.get(e).getText().length;n===r&&0===n?(n=1,r=2):n===r&&(n-=1);for(var s=n;s<r;s+=1)!function(n){var r=a.get(e).getInlineStyleAt(n);["BOLD","ITALIC","UNDERLINE","STRIKETHROUGH","CODE","SUPERSCRIPT","SUBSCRIPT"].forEach(function(e){t[e]=t[e]&&r.get(e)===e})}(s)}return{v:t}}();if("object"===(void 0===s?"undefined":g(s)))return s.v}return{}}function i(t){var e=void 0,n=t.getSelection(),r=n.getStartOffset(),o=n.getEndOffset();r===o&&0===r?o=1:r===o&&(r-=1);for(var i=(0,h.getSelectedBlock)(t),a=r;a<o;a+=1){var s=i.getEntityAt(a);if(!s){e=void 0;break}if(a===r)e=s;else if(e!==s){e=void 0;break}}return e}function a(t,e){var n=(0,h.getSelectedBlock)(t),r=void 0;return n.findEntityRanges(function(t){return t.get("entity")===e},function(t,e){r={start:t,end:e,text:n.get("text").slice(t,e)}}),r}function s(t,e,n){var r=t.getSelection(),o=Object.keys(y[e]).reduce(function(t,e){return M.Modifier.removeInlineStyle(t,r,e)},t.getCurrentContent()),i=M.EditorState.push(t,o,"changeinline-style"),a=t.getCurrentInlineStyle();if(r.isCollapsed()&&(i=a.reduce(function(t,e){return M.RichUtils.toggleInlineStyle(t,e)},i)),"SUPERSCRIPT"===e||"SUBSCRIPT"==e)a.has(n)||(i=M.RichUtils.toggleInlineStyle(i,n));else{var s="bgcolor"===e?"backgroundColor":e;a.has(s+"-"+n)||(i=M.RichUtils.toggleInlineStyle(i,e.toLowerCase()+"-"+n),m(e,s,n))}return i}function u(t){t&&t.getCurrentContent().getBlockMap().map(function(t){return t.get("characterList")}).toList().flatten().forEach(function(t){t&&0===t.indexOf("color-")?m("color","color",t.substr(6)):t&&0===t.indexOf("bgcolor-")?m("bgcolor","backgroundColor",t.substr(8)):t&&0===t.indexOf("fontsize-")?m("fontSize","fontSize",+t.substr(9)):t&&0===t.indexOf("fontfamily-")&&m("fontFamily","fontFamily",t.substr(11))})}function c(t,e,n){var r=t.getInlineStyleAt(n).toList(),o=r.filter(function(t){return t.startsWith(e.toLowerCase())});if(o&&o.size>0)return o.get(0)}function l(t,e){var n=t.getCurrentInlineStyle().toList(),r=n.filter(function(t){return t.startsWith(e.toLowerCase())});if(r&&r.size>0)return r.get(0)}function f(t,e){if(t&&e&&e.length>0){var n=function(){var n=t.getSelection(),r={};if(n.isCollapsed)return e.forEach(function(e){r[e]=l(t,e)}),{v:r};var o=n.getStartOffset(),i=n.getEndOffset(),a=(0,h.getSelectedBlocksList)(t);if(a.size>0){for(var s=0;s<a.size;s+=1)!function(t){var n=0===t?o:0,s=t===a.size-1?i:a.get(t).getText().length;n===s&&0===n?(n=1,s=2):n===s&&(n-=1);for(var u=n;u<s;u+=1)!function(o){o===n?e.forEach(function(e){r[e]=c(a.get(t),e,o)}):e.forEach(function(e){r[e]&&r[e]!==c(a.get(t),e,o)&&(r[e]=void 0)})}(u)}(s);return{v:r}}}();if("object"===(void 0===n?"undefined":g(n)))return n.v}return{}}function p(t){var e=t.getCurrentInlineStyle(),n=t.getCurrentContent();return e.forEach(function(e){n=M.Modifier.removeInlineStyle(n,t.getSelection(),e)}),M.EditorState.push(t,n,"change-inline-style")}Object.defineProperty(e,"__esModule",{value:!0}),e.getCustomStyleMap=e.customInlineStylesMap=void 0;var d=Object.assign||function(t){for(var e=1;e<arguments.length;e++){var n=arguments[e];for(var r in n)Object.prototype.hasOwnProperty.call(n,r)&&(t[r]=n[r])}return t},g="function"==typeof Symbol&&"symbol"==typeof Symbol.iterator?function(t){return typeof t}:function(t){return t&&"function"==typeof Symbol&&t.constructor===Symbol&&t!==Symbol.prototype?"symbol":typeof t};e.getSelectionInlineStyle=o,e.getSelectionEntity=i,e.getEntityRange=a,e.toggleCustomInlineStyle=s,e.extractInlineStyle=u,e.getSelectionCustomInlineStyle=f,e.removeAllInlineStyles=p;var M=n(0),h=n(1),y=e.customInlineStylesMap={color:{},bgcolor:{},fontSize:{},fontFamily:{},CODE:{fontFamily:"monospace",wordWrap:"break-word",background:"#f1f1f1",borderRadius:3,padding:"1px 3px"},SUPERSCRIPT:{fontSize:11,position:"relative",top:-8,display:"inline-flex"},SUBSCRIPT:{fontSize:11,position:"relative",bottom:-8,display:"inline-flex"}},m=function(t,e,n){y[t][t.toLowerCase()+"-"+n]=r({},""+e,n)};e.getCustomStyleMap=function(){return d({},y.color,y.bgcolor,y.fontSize,y.fontFamily,{CODE:y.CODE,SUPERSCRIPT:y.SUPERSCRIPT,SUBSCRIPT:y.SUBSCRIPT})}},function(t,e){t.exports=n(69)},function(t,e,n){"use strict";function r(t){var e=t.getSelection();if(e.isCollapsed()){var n=t.getCurrentContent(),r=e.getStartKey(),o=n.getBlockForKey(r);if(!(0,u.isListBlock)(o)&&"unstyled"!==o.getType()&&o.getLength()===e.getStartOffset())return(0,s.insertNewUnstyledBlock)(t);if((0,u.isListBlock)(o)&&0===o.getLength()){var i=o.getDepth();if(0===i)return(0,s.removeSelectedBlocksStyle)(t);if(i>0)return(0,u.changeDepth)(t,-1,i)}}}function o(t){return 13===t.which&&(t.getModifierState("Shift")||t.getModifierState("Alt")||t.getModifierState("Control"))}function i(t,e){return o(e)?t.getSelection().isCollapsed()?a.RichUtils.insertSoftNewline(t):(0,s.addLineBreakRemovingSelection)(t):r(t)}Object.defineProperty(e,"__esModule",{value:!0}),e.default=i;var a=n(0),s=n(1),u=n(2)}])},function(t,e,n){"use strict";function r(t){return t&&t.__esModule?t:{default:t}}function o(t,e,n){return e in t?Object.defineProperty(t,e,{value:n,enumerable:!0,configurable:!0,writable:!0}):t[e]=n,t}function i(t,e){if(!(t instanceof e))throw new TypeError("Cannot call a class as a function")}function a(t,e){if(!t)throw new ReferenceError("this hasn't been initialised - super() hasn't been called");return!e||"object"!=typeof e&&"function"!=typeof e?t:e}function s(t,e){if("function"!=typeof e&&null!==e)throw new TypeError("Super expression must either be null or a function, not "+typeof e);t.prototype=Object.create(e&&e.prototype,{constructor:{value:t,enumerable:!1,writable:!0,configurable:!0}}),e&&(Object.setPrototypeOf?Object.setPrototypeOf(t,e):t.__proto__=e)}Object.defineProperty(e,"__esModule",{value:!0});var u=function(){function t(t,e){for(var n=0;n<e.length;n++){var r=e[n];r.enumerable=r.enumerable||!1,r.configurable=!0,"value"in r&&(r.writable=!0),Object.defineProperty(t,r.key,r)}}return function(e,n,r){return n&&t(e.prototype,n),r&&t(e,r),e}}(),c=n(0),l=r(c),f=n(1),p=r(f),d=n(5),g=r(d);n(174);var M=function(t){function e(){var t,n,r,o;i(this,e);for(var s=arguments.length,u=Array(s),c=0;c<s;c++)u[c]=arguments[c];return n=r=a(this,(t=e.__proto__||Object.getPrototypeOf(e)).call.apply(t,[this].concat(u))),r.onClick=function(){var t=r.props,e=t.disabled,n=t.onClick,o=t.value;e||n(o)},o=n,a(r,o)}return s(e,t),u(e,[{key:"render",value:function(){var t,e=this.props,n=e.children,r=e.className,i=e.activeClassName,a=e.active,s=e.disabled,u=e.title;return l.default.createElement("div",{className:(0,g.default)("rdw-option-wrapper",r,(t={},o(t,"rdw-option-active "+i,a),o(t,"rdw-option-disabled",s),t)),onClick:this.onClick,"aria-selected":a,title:u},n)}}]),e}(c.Component);M.propTypes={onClick:p.default.func.isRequired,children:p.default.any,value:p.default.string,className:p.default.string,activeClassName:p.default.string,active:p.default.bool,disabled:p.default.bool,title:p.default.string},e.default=M},function(t,e,n){"use strict";function r(t,e){if(!(t instanceof e))throw new TypeError("Cannot call a class as a function")}function o(t,e){if(!t)throw new ReferenceError("this hasn't been initialised - super() hasn't been called");return!e||"object"!==(void 0===e?"undefined":a(e))&&"function"!=typeof e?t:e}function i(t,e){if("function"!=typeof e&&null!==e)throw new TypeError("Super expression must either be null or a function, not "+(void 0===e?"undefined":a(e)));t.prototype=Object.create(e&&e.prototype,{constructor:{value:t,enumerable:!1,writable:!0,configurable:!0}}),e&&(Object.setPrototypeOf?Object.setPrototypeOf(t,e):t.__proto__=e)}var a="function"==typeof Symbol&&"symbol"==typeof Symbol.iterator?function(t){return typeof t}:function(t){return t&&"function"==typeof Symbol&&t.constructor===Symbol&&t!==Symbol.prototype?"symbol":typeof t},s=n(4),u=s.Map,c=s.OrderedSet,l=s.Record,f=c(),p={style:f,entity:null},d=l(p),g=function(t){function e(){return r(this,e),o(this,t.apply(this,arguments))}return i(e,t),e.prototype.getStyle=function(){return this.get("style")},e.prototype.getEntity=function(){return this.get("entity")},e.prototype.hasStyle=function(t){return this.getStyle().includes(t)},e.applyStyle=function(t,n){var r=t.set("style",t.getStyle().add(n));return e.create(r)},e.removeStyle=function(t,n){var r=t.set("style",t.getStyle().remove(n));return e.create(r)},e.applyEntity=function(t,n){var r=t.getEntity()===n?t:t.set("entity",n);return e.create(r)},e.create=function(t){if(!t)return M;var n={style:f,entity:null},r=u(n).merge(t),o=h.get(r);if(o)return o;var i=new e(r);return h=h.set(r,i),i},e}(d),M=new g,h=u([[u(p),M]]);g.EMPTY=M,t.exports=g},function(t,e,n){"use strict";function r(){for(var t=void 0;void 0===t||o.hasOwnProperty(t)||!isNaN(+t);)t=Math.floor(Math.random()*i).toString(32);return o[t]=!0,t}var o={},i=Math.pow(2,24);t.exports=r},function(t,e,n){"use strict";function r(t,e,n,r){if(t===n)return!0;if(!n.startsWith(t))return!1;var o=n.slice(t.length);return!!e&&(o=r?r(o):o,a.contains(o,e))}function o(t){return"Windows"===i.platformName?t.replace(/^\s*NT/,""):t}var i=n(98),a=n(102),s=n(103),u=n(104),c={isBrowser:function(t){return r(i.browserName,i.browserFullVersion,t)},isBrowserArchitecture:function(t){return r(i.browserArchitecture,null,t)},isDevice:function(t){return r(i.deviceName,null,t)},isEngine:function(t){return r(i.engineName,i.engineVersion,t)},isPlatform:function(t){return r(i.platformName,i.platformFullVersion,t,o)},isPlatformArchitecture:function(t){return r(i.platformArchitecture,null,t)}};t.exports=s(c,u)},function(t,e,n){"use strict";function r(t,e){if(t)for(var n in t)({}).hasOwnProperty.call(t,n)&&e(n,t[n])}function o(t,e){var n=!1;if(t)for(var r in t)if({}.hasOwnProperty.call(t,r)&&e===r){n=!0;break}return n}function i(t){return!t||!t.trim()}function a(t){return"[object Object]"===Object.prototype.toString.call(t)}function s(t,e){var n=Object.keys(t).filter(function(t){return e.indexOf(t)<0}),r={};return n&&n.length>0&&n.forEach(function(e){r[e]=t[e]}),r}function u(t){t.stopPropagation()}Object.defineProperty(e,"__esModule",{value:!0}),e.forEach=r,e.hasProperty=o,e.isEmptyString=i,e.isMap=a,e.filter=s,e.stopPropagation=u},function(t,e,n){"use strict";var r,o="function"==typeof Symbol&&"symbol"==typeof Symbol.iterator?function(t){return typeof t}:function(t){return t&&"function"==typeof Symbol&&t.constructor===Symbol&&t!==Symbol.prototype?"symbol":typeof t};r=function(){return this}();try{r=r||Function("return this")()||(0,eval)("this")}catch(t){"object"===("undefined"==typeof window?"undefined":o(window))&&(r=window)}t.exports=r},function(t,e,n){"use strict";function r(t){return t&&t.__esModule?t:{default:t}}var o=n(175),i=r(o),a=n(177),s=r(a);t.exports={Dropdown:i.default,DropdownOption:s.default}},function(t,e,n){"use strict";function r(t,e){if(!(t instanceof e))throw new TypeError("Cannot call a class as a function")}function o(t,e){if(!t)throw new ReferenceError("this hasn't been initialised - super() hasn't been called");return!e||"object"!==(void 0===e?"undefined":u(e))&&"function"!=typeof e?t:e}function i(t,e){if("function"!=typeof e&&null!==e)throw new TypeError("Super expression must either be null or a function, not "+(void 0===e?"undefined":u(e)));t.prototype=Object.create(e&&e.prototype,{constructor:{value:t,enumerable:!1,writable:!0,configurable:!0}}),e&&(Object.setPrototypeOf?Object.setPrototypeOf(t,e):t.__proto__=e)}function a(t,e){return t.getStyle()===e.getStyle()}function s(t,e){return t.getEntity()===e.getEntity()}var u="function"==typeof Symbol&&"symbol"==typeof Symbol.iterator?function(t){return typeof t}:function(t){return t&&"function"==typeof Symbol&&t.constructor===Symbol&&t!==Symbol.prototype?"symbol":typeof t},c=n(4),l=n(27),f=c.List,p=c.Map,d=c.OrderedSet,g=c.Record,M=d(),h={key:"",type:"unstyled",text:"",characterList:f(),depth:0,data:p()},y=g(h),m=function(t){function e(){return r(this,e),o(this,t.apply(this,arguments))}return i(e,t),e.prototype.getKey=function(){return this.get("key")},e.prototype.getType=function(){return this.get("type")},e.prototype.getText=function(){return this.get("text")},e.prototype.getCharacterList=function(){return this.get("characterList")},e.prototype.getLength=function(){return this.getText().length},e.prototype.getDepth=function(){return this.get("depth")},e.prototype.getData=function(){return this.get("data")},e.prototype.getInlineStyleAt=function(t){var e=this.getCharacterList().get(t);return e?e.getStyle():M},e.prototype.getEntityAt=function(t){var e=this.getCharacterList().get(t);return e?e.getEntity():null},e.prototype.findStyleRanges=function(t,e){l(this.getCharacterList(),a,t,e)},e.prototype.findEntityRanges=function(t,e){l(this.getCharacterList(),s,t,e)},e}(y);t.exports=m},function(t,e,n){"use strict";function r(t){if(null===t||void 0===t)throw new TypeError("Object.assign cannot be called with null or undefined");return Object(t)}/*
object-assign
(c) Sindre Sorhus
@license MIT
*/
var o=Object.getOwnPropertySymbols,i=Object.prototype.hasOwnProperty,a=Object.prototype.propertyIsEnumerable;t.exports=function(){try{if(!Object.assign)return!1;var t=new String("abc");if(t[5]="de","5"===Object.getOwnPropertyNames(t)[0])return!1;for(var e={},n=0;n<10;n++)e["_"+String.fromCharCode(n)]=n;if("0123456789"!==Object.getOwnPropertyNames(e).map(function(t){return e[t]}).join(""))return!1;var r={};return"abcdefghijklmnopqrst".split("").forEach(function(t){r[t]=t}),"abcdefghijklmnopqrst"===Object.keys(Object.assign({},r)).join("")}catch(t){return!1}}()?Object.assign:function(t,e){for(var n,s,u=r(t),c=1;c<arguments.length;c++){n=Object(arguments[c]);for(var l in n)i.call(n,l)&&(u[l]=n[l]);if(o){s=o(n);for(var f=0;f<s.length;f++)a.call(n,s[f])&&(u[s[f]]=n[s[f]])}}return u}},function(t,e,n){"use strict";function r(t){return p<=t&&t<=M}function o(t,e){if(0<=e&&e<t.length||f(!1),e+1===t.length)return!1;var n=t.charCodeAt(e),r=t.charCodeAt(e+1);return p<=n&&n<=d&&g<=r&&r<=M}function i(t){return h.test(t)}function a(t,e){return 1+r(t.charCodeAt(e))}function s(t){if(!i(t))return t.length;for(var e=0,n=0;n<t.length;n+=a(t,n))e++;return e}function u(t,e,n){if(e=e||0,n=void 0===n?1/0:n||0,!i(t))return t.substr(e,n);var r=t.length;if(r<=0||e>r||n<=0)return"";var o=0;if(e>0){for(;e>0&&o<r;e--)o+=a(t,o);if(o>=r)return""}else if(e<0){for(o=r;e<0&&0<o;e++)o-=a(t,o-1);o<0&&(o=0)}var s=r;if(n<r)for(s=o;n>0&&s<r;n--)s+=a(t,s);return t.substring(o,s)}function c(t,e,n){e=e||0,n=void 0===n?1/0:n||0,e<0&&(e=0),n<0&&(n=0);var r=Math.abs(n-e);return e=e<n?e:n,u(t,e,r)}function l(t){for(var e=[],n=0;n<t.length;n+=a(t,n))e.push(t.codePointAt(n));return e}var f=n(2),p=55296,d=56319,g=56320,M=57343,h=/[\uD800-\uDFFF]/,y={getCodePoints:l,getUTF16Length:a,hasSurrogateUnit:i,isCodeUnitInSurrogateRange:r,isSurrogatePair:o,strlen:s,substring:c,substr:u};t.exports=y},function(t,e,n){"use strict";var r=n(14),o=function(t){return t[t.options[0]].icon},i=function t(e,n){if(e&&void 0===n)return e;var o={};return(0,r.forEach)(e,function(e,i){(0,r.isMap)(i)?o[e]=t(i,n[e]):o[e]=void 0!==n[e]?n[e]:i}),o};t.exports={getFirstIcon:o,mergeRecursive:i}},function(t,e,n){"use strict";var r=n(4),o=r.OrderedMap,i={createFromArray:function(t){return o(t.map(function(t){return[t.getKey(),t]}))}};t.exports=i},function(t,e,n){"use strict";function r(t,e){if(!(t instanceof e))throw new TypeError("Cannot call a class as a function")}function o(t,e){if(!t)throw new ReferenceError("this hasn't been initialised - super() hasn't been called");return!e||"object"!==(void 0===e?"undefined":a(e))&&"function"!=typeof e?t:e}function i(t,e){if("function"!=typeof e&&null!==e)throw new TypeError("Super expression must either be null or a function, not "+(void 0===e?"undefined":a(e)));t.prototype=Object.create(e&&e.prototype,{constructor:{value:t,enumerable:!1,writable:!0,configurable:!0}}),e&&(Object.setPrototypeOf?Object.setPrototypeOf(t,e):t.__proto__=e)}var a="function"==typeof Symbol&&"symbol"==typeof Symbol.iterator?function(t){return typeof t}:function(t){return t&&"function"==typeof Symbol&&t.constructor===Symbol&&t!==Symbol.prototype?"symbol":typeof t},s=n(4),u=s.Record,c={anchorKey:"",anchorOffset:0,focusKey:"",focusOffset:0,isBackward:!1,hasFocus:!1},l=u(c),f=function(t){function e(){return r(this,e),o(this,t.apply(this,arguments))}return i(e,t),e.prototype.serialize=function(){return"Anchor: "+this.getAnchorKey()+":"+this.getAnchorOffset()+", Focus: "+this.getFocusKey()+":"+this.getFocusOffset()+", Is Backward: "+String(this.getIsBackward())+", Has Focus: "+String(this.getHasFocus())},e.prototype.getAnchorKey=function(){return this.get("anchorKey")},e.prototype.getAnchorOffset=function(){return this.get("anchorOffset")},e.prototype.getFocusKey=function(){return this.get("focusKey")},e.prototype.getFocusOffset=function(){return this.get("focusOffset")},e.prototype.getIsBackward=function(){return this.get("isBackward")},e.prototype.getHasFocus=function(){return this.get("hasFocus")},e.prototype.hasEdgeWithin=function(t,e,n){var r=this.getAnchorKey(),o=this.getFocusKey();if(r===o&&r===t){var i=this.getStartOffset();return e<=this.getEndOffset()&&i<=n}if(t!==r&&t!==o)return!1;var a=t===r?this.getAnchorOffset():this.getFocusOffset();return e<=a&&n>=a},e.prototype.isCollapsed=function(){return this.getAnchorKey()===this.getFocusKey()&&this.getAnchorOffset()===this.getFocusOffset()},e.prototype.getStartKey=function(){return this.getIsBackward()?this.getFocusKey():this.getAnchorKey()},e.prototype.getStartOffset=function(){return this.getIsBackward()?this.getFocusOffset():this.getAnchorOffset()},e.prototype.getEndKey=function(){return this.getIsBackward()?this.getAnchorKey():this.getFocusKey()},e.prototype.getEndOffset=function(){return this.getIsBackward()?this.getAnchorOffset():this.getFocusOffset()},e.createEmpty=function(t){return new e({anchorKey:t,anchorOffset:0,focusKey:t,focusOffset:0,isBackward:!1,hasFocus:!1})},e}(l);t.exports=f},function(t,e,n){"use strict";function r(t){return"object"==(void 0===t?"undefined":i(t))?Object.keys(t).filter(function(e){return t[e]}).map(o).join(" "):Array.prototype.map.call(arguments,o).join(" ")}function o(t){return t.replace(/\//g,"-")}var i="function"==typeof Symbol&&"symbol"==typeof Symbol.iterator?function(t){return typeof t}:function(t){return t&&"function"==typeof Symbol&&t.constructor===Symbol&&t!==Symbol.prototype?"symbol":typeof t};t.exports=r},function(t,e){t.exports=ReactDOM},function(t,e,n){"use strict";function r(t,e,n){var r=t.getSelection(),i=t.getCurrentContent(),a=r;if(r.isCollapsed()){if("forward"===n){if(t.isSelectionAtEndOfContent())return i}else if(t.isSelectionAtStartOfContent())return i;if((a=e(t))===r)return i}return o.removeRange(i,a,n)}var o=n(7);t.exports=r},function(t,e,n){"use strict";function r(t){return function(){return t}}var o=function(){};o.thatReturns=r,o.thatReturnsFalse=r(!1),o.thatReturnsTrue=r(!0),o.thatReturnsNull=r(null),o.thatReturnsThis=function(){return this},o.thatReturnsArgument=function(t){return t},t.exports=o},function(t,e,n){"use strict";function r(t,e,n,r){if(t.size){var o=0;t.reduce(function(t,i,a){return e(t,i)||(n(t)&&r(o,a),o=a),i}),n(t.last())&&r(o,t.count())}}t.exports=r},function(t,e,n){"use strict";function r(t,e){var n=e.getStartKey(),r=e.getStartOffset(),a=e.getEndKey(),s=e.getEndOffset(),u=i(t,e),c=u.getBlockMap(),l=c.keySeq(),f=l.indexOf(n),p=l.indexOf(a)+1;return c.slice(f,p).map(function(t,e){var i=o(),u=t.getText(),c=t.getCharacterList();return n===a?t.merge({key:i,text:u.slice(r,s),characterList:c.slice(r,s)}):e===n?t.merge({key:i,text:u.slice(r),characterList:c.slice(r)}):e===a?t.merge({key:i,text:u.slice(0,s),characterList:c.slice(0,s)}):t.set("key",i)}).toOrderedMap()}var o=n(12),i=n(45);t.exports=r},function(t,e,n){"use strict";function r(t,e){console.warn("WARNING: "+t+' will be deprecated soon!\nPlease use "'+e+'" instead.')}var o=n(18),i=o||function(t){for(var e=1;e<arguments.length;e++){var n=arguments[e];for(var r in n)Object.prototype.hasOwnProperty.call(n,r)&&(t[r]=n[r])}return t},a=n(48),s=n(4),u=n(2),c=s.Map,l=c(),f=0,p={getLastCreatedEntityKey:function(){return r("DraftEntity.getLastCreatedEntityKey","contentState.getLastCreatedEntityKey"),p.__getLastCreatedEntityKey()},create:function(t,e,n){return r("DraftEntity.create","contentState.createEntity"),p.__create(t,e,n)},add:function(t){return r("DraftEntity.add","contentState.addEntity"),p.__add(t)},get:function(t){return r("DraftEntity.get","contentState.getEntity"),p.__get(t)},mergeData:function(t,e){return r("DraftEntity.mergeData","contentState.mergeEntityData"),p.__mergeData(t,e)},replaceData:function(t,e){return r("DraftEntity.replaceData","contentState.replaceEntityData"),p.__replaceData(t,e)},__getLastCreatedEntityKey:function(){return""+f},__create:function(t,e,n){return p.__add(new a({type:t,mutability:e,data:n||{}}))},__add:function(t){var e=""+ ++f;return l=l.set(e,t),e},__get:function(t){var e=l.get(t);return e||u(!1),e},__mergeData:function(t,e){var n=p.__get(t),r=i({},n.getData(),e),o=n.set("data",r);return l=l.set(t,o),o},__replaceData:function(t,e){var n=p.__get(t),r=n.set("data",e);return l=l.set(t,r),r}};t.exports=p},function(t,e,n){"use strict";var r={encode:function(t,e,n){return t+"-"+e+"-"+n},decode:function(t){var e=t.split("-"),n=e[0],r=e[1],o=e[2];return{blockKey:n,decoratorKey:parseInt(r,10),leafKey:parseInt(o,10)}}};t.exports=r},function(t,e,n){"use strict";function r(t){return"handled"===t||!0===t}t.exports=r},function(t,e,n){"use strict";function r(t,e){if(!(t instanceof e))throw new TypeError("Cannot call a class as a function")}function o(t,e){if(!t)throw new ReferenceError("this hasn't been initialised - super() hasn't been called");return!e||"object"!==(void 0===e?"undefined":a(e))&&"function"!=typeof e?t:e}function i(t,e){if("function"!=typeof e&&null!==e)throw new TypeError("Super expression must either be null or a function, not "+(void 0===e?"undefined":a(e)));t.prototype=Object.create(e&&e.prototype,{constructor:{value:t,enumerable:!1,writable:!0,configurable:!0}}),e&&(Object.setPrototypeOf?Object.setPrototypeOf(t,e):t.__proto__=e)}var a="function"==typeof Symbol&&"symbol"==typeof Symbol.iterator?function(t){return typeof t}:function(t){return t&&"function"==typeof Symbol&&t.constructor===Symbol&&t!==Symbol.prototype?"symbol":typeof t},s=n(21),u=n(11),c=n(17),l=n(29),f=n(4),p=n(22),d=n(12),g=n(33),M=f.List,h=f.Record,y=f.Repeat,m={entityMap:null,blockMap:null,selectionBefore:null,selectionAfter:null},I=h(m),w=function(t){function e(){return r(this,e),o(this,t.apply(this,arguments))}return i(e,t),e.prototype.getEntityMap=function(){return l},e.prototype.getBlockMap=function(){return this.get("blockMap")},e.prototype.getSelectionBefore=function(){return this.get("selectionBefore")},e.prototype.getSelectionAfter=function(){return this.get("selectionAfter")},e.prototype.getBlockForKey=function(t){return this.getBlockMap().get(t)},e.prototype.getKeyBefore=function(t){return this.getBlockMap().reverse().keySeq().skipUntil(function(e){return e===t}).skip(1).first()},e.prototype.getKeyAfter=function(t){return this.getBlockMap().keySeq().skipUntil(function(e){return e===t}).skip(1).first()},e.prototype.getBlockAfter=function(t){return this.getBlockMap().skipUntil(function(e,n){return n===t}).skip(1).first()},e.prototype.getBlockBefore=function(t){return this.getBlockMap().reverse().skipUntil(function(e,n){return n===t}).skip(1).first()},e.prototype.getBlocksAsArray=function(){return this.getBlockMap().toArray()},e.prototype.getFirstBlock=function(){return this.getBlockMap().first()},e.prototype.getLastBlock=function(){return this.getBlockMap().last()},e.prototype.getPlainText=function(t){return this.getBlockMap().map(function(t){return t?t.getText():""}).join(t||"\n")},e.prototype.getLastCreatedEntityKey=function(){return l.__getLastCreatedEntityKey()},e.prototype.hasText=function(){var t=this.getBlockMap();return t.size>1||t.first().getLength()>0},e.prototype.createEntity=function(t,e,n){return l.__create(t,e,n),this},e.prototype.mergeEntityData=function(t,e){return l.__mergeData(t,e),this},e.prototype.replaceEntityData=function(t,e){return l.__replaceData(t,e),this},e.prototype.addEntity=function(t){return l.__add(t),this},e.prototype.getEntity=function(t){return l.__get(t)},e.createFromBlockArray=function(t,n){var r=Array.isArray(t)?t:t.contentBlocks,o=s.createFromArray(r),i=o.isEmpty()?new p:p.createEmpty(o.first().getKey());return new e({blockMap:o,entityMap:n||l,selectionBefore:i,selectionAfter:i})},e.createFromText=function(t){var n=arguments.length<=1||void 0===arguments[1]?/\r\n?|\n/g:arguments[1],r=t.split(n),o=r.map(function(t){return t=g(t),new c({key:d(),text:t,type:"unstyled",characterList:M(y(u.EMPTY,t.length))})});return e.createFromBlockArray(o)},e}(I);t.exports=w},function(t,e,n){"use strict";function r(t){return t.replace(o,"")}var o=new RegExp("\r","g");t.exports=r},function(t,e,n){"use strict";function r(t){return t===l||t===f}function o(t){return r(t)||c(!1),t===l?"ltr":"rtl"}function i(t,e){return r(t)||c(!1),r(e)||c(!1),t===e?null:o(t)}function a(t){p=t}function s(){a(l)}function u(){return p||this.initGlobalDir(),p||c(!1),p}var c=n(2),l="LTR",f="RTL",p=null,d={NEUTRAL:"NEUTRAL",LTR:l,RTL:f,isStrong:r,getHTMLDir:o,getHTMLDirIfDifferent:i,setGlobalDir:a,initGlobalDir:s,getGlobalDir:u};t.exports=d},function(t,e,n){"use strict";var r=n(4),o=r.Map,i=n(0),a=n(23),s=i.createElement("ul",{className:a("public/DraftStyleDefault/ul")}),u=i.createElement("ol",{className:a("public/DraftStyleDefault/ol")}),c=i.createElement("pre",{className:a("public/DraftStyleDefault/pre")}),l=o({"header-one":{element:"h1"},"header-two":{element:"h2"},"header-three":{element:"h3"},"header-four":{element:"h4"},"header-five":{element:"h5"},"header-six":{element:"h6"},"unordered-list-item":{element:"li",wrapper:s},"ordered-list-item":{element:"li",wrapper:u},blockquote:{element:"blockquote"},atomic:{element:"figure"},"code-block":{element:"pre",wrapper:c},unstyled:{element:"div",aliasedElements:["p"]}});t.exports=l},function(t,e,n){"use strict";t.exports={BACKSPACE:8,TAB:9,RETURN:13,ALT:18,ESC:27,SPACE:32,PAGE_UP:33,PAGE_DOWN:34,END:35,HOME:36,LEFT:37,UP:38,RIGHT:39,DOWN:40,DELETE:46,COMMA:188,PERIOD:190,A:65,Z:90,ZERO:48,NUMPAD_0:96,NUMPAD_9:105}},function(t,e,n){"use strict";function r(t,e){var n;if(e.isCollapsed()){var r=e.getAnchorKey(),i=e.getAnchorOffset();return i>0?(n=t.getBlockForKey(r).getEntityAt(i-1),o(t.getEntityMap(),n)):null}var a=e.getStartKey(),s=e.getStartOffset(),u=t.getBlockForKey(a);return n=s===u.getLength()?null:u.getEntityAt(s),o(t.getEntityMap(),n)}function o(t,e){if(e){return"MUTABLE"===t.__get(e).getMutability()?e:null}return null}t.exports=r},function(t,e){(function(e){t.exports=e}).call(e,{})},function(t,e,n){"use strict";function r(t,e){var n=i.get(t,e);return"auto"===n||"scroll"===n}var o=n(109),i={get:o,getScrollParent:function(t){if(!t)return null;for(var e=t.ownerDocument;t&&t!==e.body;){if(r(t,"overflow")||r(t,"overflowY")||r(t,"overflowX"))return t;t=t.parentNode}return e.defaultView||e.parentWindow}};t.exports=i},function(t,e,n){"use strict";function r(t){var e=o(t.ownerDocument||t.document);t.Window&&t instanceof t.Window&&(t=e);var n=i(t),r=t===e?t.ownerDocument.documentElement:t,a=t.scrollWidth-r.clientWidth,s=t.scrollHeight-r.clientHeight;return n.x=Math.max(0,Math.min(n.x,a)),n.y=Math.max(0,Math.min(n.y,s)),n}var o=n(114),i=n(115);t.exports=r},function(t,e,n){"use strict";function r(t){for(var e=t;e&&e!==document.documentElement;){var n=o(e);if(null!=n)return n;e=e.parentNode}return null}var o=n(57);t.exports=r},function(t,e,n){"use strict";var r=n(13),o=r.isPlatform("Mac OS X"),i={isCtrlKeyCommand:function(t){return!!t.ctrlKey&&!t.altKey},isOptionKeyCommand:function(t){return o&&t.altKey},hasCommandModifier:function(t){return o?!!t.metaKey&&!t.altKey:i.isCtrlKeyCommand(t)}};t.exports=i},function(t,e,n){"use strict";function r(t,e){var n=t.getSelection(),r=t.getCurrentContent(),o=n.getStartKey(),i=n.getStartOffset(),a=o,s=0;if(e>i){var u=r.getKeyBefore(o);if(null==u)a=o;else{a=u;s=r.getBlockForKey(u).getText().length}}else s=i-e;return n.merge({focusKey:a,focusOffset:s,isBackward:!0})}t.exports=r},function(t,e,n){"use strict";var r={draft_killswitch_allow_nontextnodes:!1,draft_segmented_entities_behavior:!1};t.exports=r},function(t,e,n){"use strict";function r(t,e){var n=t.getBlockMap(),r=t.getEntityMap(),o={},a=e.getStartKey(),s=e.getStartOffset(),u=n.get(a),c=i(r,u,s);c!==u&&(o[a]=c);var l=e.getEndKey(),f=e.getEndOffset(),p=n.get(l);a===l&&(p=c);var d=i(r,p,f);return d!==p&&(o[l]=d),Object.keys(o).length?t.merge({blockMap:n.merge(o),selectionAfter:e}):t.set("selectionAfter",e)}function o(t,e,n){var r;return u(t,function(t,e){return t.getEntity()===e.getEntity()},function(t){return t.getEntity()===e},function(t,e){t<=n&&e>=n&&(r={start:t,end:e})}),"object"!==(void 0===r?"undefined":a(r))&&c(!1),r}function i(t,e,n){var r=e.getCharacterList(),i=n>0?r.get(n-1):void 0,a=n<r.count()?r.get(n):void 0,u=i?i.getEntity():void 0,c=a?a.getEntity():void 0;if(c&&c===u){if("MUTABLE"!==t.__get(c).getMutability()){for(var l,f=o(r,c,n),p=f.start,d=f.end;p<d;)l=r.get(p),r=r.set(p,s.applyEntity(l,null)),p++;return e.set("characterList",r)}}return e}var a="function"==typeof Symbol&&"symbol"==typeof Symbol.iterator?function(t){return typeof t}:function(t){return t&&"function"==typeof Symbol&&t.constructor===Symbol&&t!==Symbol.prototype?"symbol":typeof t},s=n(11),u=n(27),c=n(2);t.exports=r},function(t,e,n){"use strict";function r(t,e,n){if(n===t.count())e.forEach(function(e){t=t.push(e)});else if(0===n)e.reverse().forEach(function(e){t=t.unshift(e)});else{var r=t.slice(0,n),o=t.slice(n);t=r.concat(e,o).toList()}return t}t.exports=r},function(t,e,n){"use strict";function r(t,e){var n=[],r=t.map(function(t){return t.getStyle()}).toList();return s(r,o,f,function(t,r){n.push(new d({start:t+e,end:r+e}))}),u(n)}function o(t,e){return t===e}var i=n(4),a=n(26),s=n(27),u=i.List,c=i.Repeat,l=i.Record,f=a.thatReturnsTrue,p={start:null,end:null},d=l(p),g={start:null,end:null,decoratorKey:null,leaves:null},M=l(g),h={generate:function(t,e,n){var i=e.getLength();if(!i)return u.of(new M({start:0,end:0,decoratorKey:null,leaves:u.of(new d({start:0,end:0}))}));var a=[],l=n?n.getDecorations(e,t):u(c(null,i)),p=e.getCharacterList();return s(l,o,f,function(t,e){a.push(new M({start:t,end:e,decoratorKey:l.get(t),leaves:r(p.slice(t,e).toList(),t)}))}),u(a)},getFingerprint:function(t){return t.map(function(t){var e=t.get("decoratorKey");return(null!==e?e+"."+(t.get("end")-t.get("start")):"")+"."+t.get("leaves").size}).join("-")}};t.exports=h},function(t,e,n){"use strict";function r(t,e){if(!(t instanceof e))throw new TypeError("Cannot call a class as a function")}function o(t,e){if(!t)throw new ReferenceError("this hasn't been initialised - super() hasn't been called");return!e||"object"!==(void 0===e?"undefined":a(e))&&"function"!=typeof e?t:e}function i(t,e){if("function"!=typeof e&&null!==e)throw new TypeError("Super expression must either be null or a function, not "+(void 0===e?"undefined":a(e)));t.prototype=Object.create(e&&e.prototype,{constructor:{value:t,enumerable:!1,writable:!0,configurable:!0}}),e&&(Object.setPrototypeOf?Object.setPrototypeOf(t,e):t.__proto__=e)}var a="function"==typeof Symbol&&"symbol"==typeof Symbol.iterator?function(t){return typeof t}:function(t){return t&&"function"==typeof Symbol&&t.constructor===Symbol&&t!==Symbol.prototype?"symbol":typeof t},s=n(4),u=s.Record,c=u({type:"TOKEN",mutability:"IMMUTABLE",data:Object}),l=function(t){function e(){return r(this,e),o(this,t.apply(this,arguments))}return i(e,t),e.prototype.getType=function(){return this.get("type")},e.prototype.getMutability=function(){return this.get("mutability")},e.prototype.getData=function(){return this.get("data")},e}(c);t.exports=l},function(t,e,n){"use strict";function r(t){var e=p.exec(t);return null==e?null:e[0]}function o(t){var e=r(t);return null==e?c.NEUTRAL:d.exec(e)?c.RTL:c.LTR}function i(t,e){if(e=e||c.NEUTRAL,!t.length)return e;var n=o(t);return n===c.NEUTRAL?e:n}function a(t,e){return e||(e=c.getGlobalDir()),c.isStrong(e)||l(!1),i(t,e)}function s(t,e){return a(t,e)===c.LTR}function u(t,e){return a(t,e)===c.RTL}var c=n(34),l=n(2),f={L:"A-Za-zªµºÀ-ÖØ-öø-ƺƻƼ-ƿǀ-ǃǄ-ʓʔʕ-ʯʰ-ʸʻ-ˁː-ˑˠ-ˤˮͰ-ͳͶ-ͷͺͻ-ͽͿΆΈ-ΊΌΎ-ΡΣ-ϵϷ-ҁ҂Ҋ-ԯԱ-Ֆՙ՚-՟ա-և։ःऄ-हऻऽा-ीॉ-ौॎ-ॏॐक़-ॡ।-॥०-९॰ॱॲ-ঀং-ঃঅ-ঌএ-ঐও-নপ-রলশ-হঽা-ীে-ৈো-ৌৎৗড়-ঢ়য়-ৡ০-৯ৰ-ৱ৴-৹৺ਃਅ-ਊਏ-ਐਓ-ਨਪ-ਰਲ-ਲ਼ਵ-ਸ਼ਸ-ਹਾ-ੀਖ਼-ੜਫ਼੦-੯ੲ-ੴઃઅ-ઍએ-ઑઓ-નપ-રલ-ળવ-હઽા-ીૉો-ૌૐૠ-ૡ૦-૯૰ଂ-ଃଅ-ଌଏ-ଐଓ-ନପ-ରଲ-ଳଵ-ହଽାୀେ-ୈୋ-ୌୗଡ଼-ଢ଼ୟ-ୡ୦-୯୰ୱ୲-୷ஃஅ-ஊஎ-ஐஒ-கங-சஜஞ-டண-தந-பம-ஹா-ிு-ூெ-ைொ-ௌௐௗ௦-௯௰-௲ఁ-ఃఅ-ఌఎ-ఐఒ-నప-హఽు-ౄౘ-ౙౠ-ౡ౦-౯౿ಂ-ಃಅ-ಌಎ-ಐಒ-ನಪ-ಳವ-ಹಽಾಿೀ-ೄೆೇ-ೈೊ-ೋೕ-ೖೞೠ-ೡ೦-೯ೱ-ೲം-ഃഅ-ഌഎ-ഐഒ-ഺഽാ-ീെ-ൈൊ-ൌൎൗൠ-ൡ൦-൯൰-൵൹ൺ-ൿං-ඃඅ-ඖක-නඳ-රලව-ෆා-ෑෘ-ෟ෦-෯ෲ-ෳ෴ก-ะา-ำเ-ๅๆ๏๐-๙๚-๛ກ-ຂຄງ-ຈຊຍດ-ທນ-ຟມ-ຣລວສ-ຫອ-ະາ-ຳຽເ-ໄໆ໐-໙ໜ-ໟༀ༁-༃༄-༒༓༔༕-༗༚-༟༠-༩༪-༳༴༶༸༾-༿ཀ-ཇཉ-ཬཿ྅ྈ-ྌ྾-࿅࿇-࿌࿎-࿏࿐-࿔࿕-࿘࿙-࿚က-ဪါ-ာေးျ-ြဿ၀-၉၊-၏ၐ-ၕၖ-ၗၚ-ၝၡၢ-ၤၥ-ၦၧ-ၭၮ-ၰၵ-ႁႃ-ႄႇ-ႌႎႏ႐-႙ႚ-ႜ႞-႟Ⴀ-ჅჇჍა-ჺ჻ჼჽ-ቈቊ-ቍቐ-ቖቘቚ-ቝበ-ኈኊ-ኍነ-ኰኲ-ኵኸ-ኾዀዂ-ዅወ-ዖዘ-ጐጒ-ጕጘ-ፚ፠-፨፩-፼ᎀ-ᎏᎠ-Ᏼᐁ-ᙬ᙭-᙮ᙯ-ᙿᚁ-ᚚᚠ-ᛪ᛫-᛭ᛮ-ᛰᛱ-ᛸᜀ-ᜌᜎ-ᜑᜠ-ᜱ᜵-᜶ᝀ-ᝑᝠ-ᝬᝮ-ᝰក-ឳាើ-ៅះ-ៈ។-៖ៗ៘-៚ៜ០-៩᠐-᠙ᠠ-ᡂᡃᡄ-ᡷᢀ-ᢨᢪᢰ-ᣵᤀ-ᤞᤣ-ᤦᤩ-ᤫᤰ-ᤱᤳ-ᤸ᥆-᥏ᥐ-ᥭᥰ-ᥴᦀ-ᦫᦰ-ᧀᧁ-ᧇᧈ-ᧉ᧐-᧙᧚ᨀ-ᨖᨙ-ᨚ᨞-᨟ᨠ-ᩔᩕᩗᩡᩣ-ᩤᩭ-ᩲ᪀-᪉᪐-᪙᪠-᪦ᪧ᪨-᪭ᬄᬅ-ᬳᬵᬻᬽ-ᭁᭃ-᭄ᭅ-ᭋ᭐-᭙᭚-᭠᭡-᭪᭴-᭼ᮂᮃ-ᮠᮡᮦ-ᮧ᮪ᮮ-ᮯ᮰-᮹ᮺ-ᯥᯧᯪ-ᯬᯮ᯲-᯳᯼-᯿ᰀ-ᰣᰤ-ᰫᰴ-ᰵ᰻-᰿᱀-᱉ᱍ-ᱏ᱐-᱙ᱚ-ᱷᱸ-ᱽ᱾-᱿᳀-᳇᳓᳡ᳩ-ᳬᳮ-ᳱᳲ-ᳳᳵ-ᳶᴀ-ᴫᴬ-ᵪᵫ-ᵷᵸᵹ-ᶚᶛ-ᶿḀ-ἕἘ-Ἕἠ-ὅὈ-Ὅὐ-ὗὙὛὝὟ-ώᾀ-ᾴᾶ-ᾼιῂ-ῄῆ-ῌῐ-ΐῖ-Ίῠ-Ῥῲ-ῴῶ-ῼ‎ⁱⁿₐ-ₜℂℇℊ-ℓℕℙ-ℝℤΩℨK-ℭℯ-ℴℵ-ℸℹℼ-ℿⅅ-ⅉⅎ⅏Ⅰ-ↂↃ-ↄↅ-ↈ⌶-⍺⎕⒜-ⓩ⚬⠀-⣿Ⰰ-Ⱞⰰ-ⱞⱠ-ⱻⱼ-ⱽⱾ-ⳤⳫ-ⳮⳲ-ⳳⴀ-ⴥⴧⴭⴰ-ⵧⵯ⵰ⶀ-ⶖⶠ-ⶦⶨ-ⶮⶰ-ⶶⶸ-ⶾⷀ-ⷆⷈ-ⷎⷐ-ⷖⷘ-ⷞ々〆〇〡-〩〮-〯〱-〵〸-〺〻〼ぁ-ゖゝ-ゞゟァ-ヺー-ヾヿㄅ-ㄭㄱ-ㆎ㆐-㆑㆒-㆕㆖-㆟ㆠ-ㆺㇰ-ㇿ㈀-㈜㈠-㈩㈪-㉇㉈-㉏㉠-㉻㉿㊀-㊉㊊-㊰㋀-㋋㋐-㋾㌀-㍶㍻-㏝㏠-㏾㐀-䶵一-鿌ꀀ-ꀔꀕꀖ-ꒌꓐ-ꓷꓸ-ꓽ꓾-꓿ꔀ-ꘋꘌꘐ-ꘟ꘠-꘩ꘪ-ꘫꙀ-ꙭꙮꚀ-ꚛꚜ-ꚝꚠ-ꛥꛦ-ꛯ꛲-꛷Ꜣ-ꝯꝰꝱ-ꞇ꞉-꞊Ꞌ-ꞎꞐ-ꞭꞰ-Ʇꟷꟸ-ꟹꟺꟻ-ꠁꠃ-ꠅꠇ-ꠊꠌ-ꠢꠣ-ꠤꠧ꠰-꠵꠶-꠷ꡀ-ꡳꢀ-ꢁꢂ-ꢳꢴ-ꣃ꣎-꣏꣐-꣙ꣲ-ꣷ꣸-꣺ꣻ꤀-꤉ꤊ-ꤥ꤮-꤯ꤰ-ꥆꥒ-꥓꥟ꥠ-ꥼꦃꦄ-ꦲꦴ-ꦵꦺ-ꦻꦽ-꧀꧁-꧍ꧏ꧐-꧙꧞-꧟ꧠ-ꧤꧦꧧ-ꧯ꧰-꧹ꧺ-ꧾꨀ-ꨨꨯ-ꨰꨳ-ꨴꩀ-ꩂꩄ-ꩋꩍ꩐-꩙꩜-꩟ꩠ-ꩯꩰꩱ-ꩶ꩷-꩹ꩺꩻꩽꩾ-ꪯꪱꪵ-ꪶꪹ-ꪽꫀꫂꫛ-ꫜꫝ꫞-꫟ꫠ-ꫪꫫꫮ-ꫯ꫰-꫱ꫲꫳ-ꫴꫵꬁ-ꬆꬉ-ꬎꬑ-ꬖꬠ-ꬦꬨ-ꬮꬰ-ꭚ꭛ꭜ-ꭟꭤ-ꭥꯀ-ꯢꯣ-ꯤꯦ-ꯧꯩ-ꯪ꯫꯬꯰-꯹가-힣ힰ-ퟆퟋ-ퟻ-豈-舘並-龎ﬀ-ﬆﬓ-ﬗＡ-Ｚａ-ｚｦ-ｯｰｱ-ﾝﾞ-ﾟﾠ-ﾾￂ-ￇￊ-ￏￒ-ￗￚ-ￜ",R:"֐־׀׃׆׈-׏א-ת׫-ׯװ-ײ׳-״׵-׿߀-߉ߊ-ߪߴ-ߵߺ߻-߿ࠀ-ࠕࠚࠤࠨ࠮-࠯࠰-࠾࠿ࡀ-ࡘ࡜-࡝࡞࡟-࢟‏יִײַ-ﬨשׁ-זּ﬷טּ-לּ﬽מּ﬿נּ-סּ﭂ףּ-פּ﭅צּ-ﭏ",AL:"؈؋؍؛؜؝؞-؟ؠ-ؿـف-ي٭ٮ-ٯٱ-ۓ۔ەۥ-ۦۮ-ۯۺ-ۼ۽-۾ۿ܀-܍܎܏ܐܒ-ܯ݋-݌ݍ-ޥޱ޲-޿ࢠ-ࢲࢳ-ࣣﭐ-ﮱ﮲-﯁﯂-﯒ﯓ-ﴽ﵀-﵏ﵐ-ﶏ﶐-﶑ﶒ-ﷇ﷈-﷏ﷰ-ﷻ﷼﷾-﷿ﹰ-ﹴ﹵ﹶ-ﻼ﻽-﻾"},p=new RegExp("["+f.L+f.R+f.AL+"]"),d=new RegExp("["+f.R+f.AL+"]"),g={firstStrongChar:r,firstStrongCharDir:o,resolveBlockDir:i,getDirection:a,isDirectionLTR:s,isDirectionRTL:u};t.exports=g},function(t,e,n){"use strict";t.exports={BOLD:{fontWeight:"bold"},CODE:{fontFamily:"monospace",wordWrap:"break-word"},ITALIC:{fontStyle:"italic"},STRIKETHROUGH:{textDecoration:"line-through"},UNDERLINE:{textDecoration:"underline"}}},function(t,e,n){"use strict";function r(t){var e=t.getSelection(),n=e.getAnchorKey(),r=t.getBlockTree(n),o=e.getStartOffset(),i=!1;return r.some(function(t){return o===t.get("start")?(i=!0,!0):o<t.get("end")&&t.get("leaves").some(function(t){var e=t.get("start");return o===e&&(i=!0,!0)})}),i}t.exports=r},function(t,e,n){"use strict";function r(t,e){if(!(t instanceof e))throw new TypeError("Cannot call a class as a function")}function o(t,e){if(!t)throw new ReferenceError("this hasn't been initialised - super() hasn't been called");return!e||"object"!==(void 0===e?"undefined":s(e))&&"function"!=typeof e?t:e}function i(t,e){if("function"!=typeof e&&null!==e)throw new TypeError("Super expression must either be null or a function, not "+(void 0===e?"undefined":s(e)));t.prototype=Object.create(e&&e.prototype,{constructor:{value:t,enumerable:!1,writable:!0,configurable:!0}}),e&&(Object.setPrototypeOf?Object.setPrototypeOf(t,e):t.__proto__=e)}function a(t,e){return t.getAnchorKey()===e||t.getFocusKey()===e}var s="function"==typeof Symbol&&"symbol"==typeof Symbol.iterator?function(t){return typeof t}:function(t){return t&&"function"==typeof Symbol&&t.constructor===Symbol&&t!==Symbol.prototype?"symbol":typeof t},u=n(18),c=u||function(t){for(var e=1;e<arguments.length;e++){var n=arguments[e];for(var r in n)Object.prototype.hasOwnProperty.call(n,r)&&(t[r]=n[r])}return t},l=n(96),f=n(30),p=n(0),d=n(24),g=n(55),M=n(39),h=n(49),y=n(34),m=n(23),I=n(112),w=n(40),D=n(116),N=n(2),v=n(8),C=function(t){function e(){return r(this,e),o(this,t.apply(this,arguments))}return i(e,t),e.prototype.shouldComponentUpdate=function(t){return this.props.block!==t.block||this.props.tree!==t.tree||this.props.direction!==t.direction||a(t.selection,t.block.getKey())&&t.forceSelection},e.prototype.componentDidMount=function(){var t=this.props.selection,e=t.getEndKey();if(t.getHasFocus()&&e===this.props.block.getKey()){var n,r=d.findDOMNode(this),o=M.getScrollParent(r),i=w(o);if(o===window){var a=I(r);n=a.y+a.height-D().height,n>0&&window.scrollTo(i.x,i.y+n+10)}else{r instanceof HTMLElement||N(!1);n=r.offsetHeight+r.offsetTop-(o.offsetHeight+i.y),n>0&&g.setTop(o,g.getTop(o)+n+10)}}},e.prototype._renderChildren=function(){var t=this,e=this.props.block,n=e.getKey(),r=e.getText(),o=this.props.tree.size-1,i=a(this.props.selection,n);return this.props.tree.map(function(a,s){var u=a.get("leaves"),d=u.size-1,g=u.map(function(a,u){var c=f.encode(n,s,u),g=a.get("start"),M=a.get("end");return p.createElement(l,{key:c,offsetKey:c,block:e,start:g,selection:i?t.props.selection:void 0,forceSelection:t.props.forceSelection,text:r.slice(g,M),styleSet:e.getInlineStyleAt(g),customStyleMap:t.props.customStyleMap,customStyleFn:t.props.customStyleFn,isLast:s===o&&u===d})}).toArray(),M=a.get("decoratorKey");if(null==M)return g;if(!t.props.decorator)return g;var m=v(t.props.decorator),I=m.getComponentForKey(M);if(!I)return g;var w=m.getPropsForKey(M),D=f.encode(n,s,0),N=r.slice(u.first().get("start"),u.last().get("end")),C=y.getHTMLDirIfDifferent(h.getDirection(N),t.props.direction);return p.createElement(I,c({},w,{contentState:t.props.contentState,decoratedText:N,dir:C,key:D,entityKey:e.getEntityAt(a.get("start")),offsetKey:D}),g)}).toArray()},e.prototype.render=function(){var t=this.props,e=t.direction,n=t.offsetKey,r=m({"public/DraftStyleDefault/block":!0,"public/DraftStyleDefault/ltr":"LTR"===e,"public/DraftStyleDefault/rtl":"RTL"===e});return p.createElement("div",{"data-offset-key":n,className:r},this._renderChildren())},e}(p.Component);t.exports=C},function(t,e,n){"use strict";function r(t,e){return!(!t||!e)&&(t===e||!o(t)&&(o(e)?r(t,e.parentNode):"contains"in t?t.contains(e):!!t.compareDocumentPosition&&!!(16&t.compareDocumentPosition(e))))}var o=n(107);t.exports=r},function(t,e,n){"use strict";function r(t){if(void 0===(t=t||("undefined"!=typeof document?document:void 0)))return null;try{return t.activeElement||t.body}catch(e){return t.body}}t.exports=r},function(t,e,n){"use strict";function r(t,e){return!!e&&(t===e.documentElement||t===e.body)}var o={getTop:function(t){var e=t.ownerDocument;return r(t,e)?e.body.scrollTop||e.documentElement.scrollTop:t.scrollTop},setTop:function(t,e){var n=t.ownerDocument;r(t,n)?n.body.scrollTop=n.documentElement.scrollTop=e:t.scrollTop=e},getLeft:function(t){var e=t.ownerDocument;return r(t,e)?e.body.scrollLeft||e.documentElement.scrollLeft:t.scrollLeft},setLeft:function(t,e){var n=t.ownerDocument;r(t,n)?n.body.scrollLeft=n.documentElement.scrollLeft=e:t.scrollLeft=e}};t.exports=o},function(t,e,n){"use strict";function r(t,e){if(!(t instanceof e))throw new TypeError("Cannot call a class as a function")}function o(t){if("file"==t.kind)return t.getAsFile()}var i=n(119),a=n(120),s=n(26),u=new RegExp("\r\n","g"),c={"text/rtf":1,"text/html":1},l=function(){function t(e){r(this,t),this.data=e,this.types=e.types?a(e.types):[]}return t.prototype.isRichText=function(){return!(!this.getHTML()||!this.getText())||!this.isImage()&&this.types.some(function(t){return c[t]})},t.prototype.getText=function(){var t;return this.data.getData&&(this.types.length?-1!=this.types.indexOf("text/plain")&&(t=this.data.getData("text/plain")):t=this.data.getData("Text")),t?t.replace(u,"\n"):null},t.prototype.getHTML=function(){if(this.data.getData){if(!this.types.length)return this.data.getData("Text");if(-1!=this.types.indexOf("text/html"))return this.data.getData("text/html")}},t.prototype.isLink=function(){return this.types.some(function(t){return-1!=t.indexOf("Url")||-1!=t.indexOf("text/uri-list")||t.indexOf("text/x-moz-url")})},t.prototype.getLink=function(){if(this.data.getData){if(-1!=this.types.indexOf("text/x-moz-url")){return this.data.getData("text/x-moz-url").split("\n")[0]}return-1!=this.types.indexOf("text/uri-list")?this.data.getData("text/uri-list"):this.data.getData("url")}return null},t.prototype.isImage=function(){if(this.types.some(function(t){return-1!=t.indexOf("application/x-moz-file")}))return!0;for(var t=this.getFiles(),e=0;e<t.length;e++){var n=t[e].type;if(!i.isImage(n))return!1}return!0},t.prototype.getCount=function(){return this.data.hasOwnProperty("items")?this.data.items.length:this.data.hasOwnProperty("mozItemCount")?this.data.mozItemCount:this.data.files?this.data.files.length:null},t.prototype.getFiles=function(){return this.data.items?Array.prototype.slice.call(this.data.items).map(o).filter(s.thatReturnsArgument):this.data.files?Array.prototype.slice.call(this.data.files):[]},t.prototype.hasFiles=function(){return this.getFiles().length>0},t}();t.exports=l},function(t,e,n){"use strict";function r(t){if(t instanceof Element){var e=t.getAttribute("data-offset-key");if(e)return e;for(var n=0;n<t.childNodes.length;n++){var o=r(t.childNodes[n]);if(o)return o}}return null}t.exports=r},function(t,e,n){"use strict";(function(e){function n(t,e){var n=0,o=[];t.forEach(function(i){r(i,function(r){n++,r&&o.push(r.slice(0,a)),n==t.length&&e(o.join("\r"))})})}function r(t,n){if(!e.FileReader||t.type&&!(t.type in i))return void n("");if(""===t.type){var r="";return o.test(t.name)&&(r=t.name.replace(o,"")),void n(r)}var a=new FileReader;a.onload=function(){n(a.result)},a.onerror=function(){n("")},a.readAsText(t)}var o=/\.textClipping$/,i={"text/plain":!0,"text/html":!0,"text/rtf":!0},a=5e3;t.exports=n}).call(e,n(15))},function(t,e,n){"use strict";function r(t,e,n,r,a){var s=i(t.getSelection()),u=o.decode(e),c=u.blockKey,l=t.getBlockTree(c).getIn([u.decoratorKey,"leaves",u.leafKey]),f=o.decode(r),p=f.blockKey,d=t.getBlockTree(p).getIn([f.decoratorKey,"leaves",f.leafKey]),g=l.get("start"),M=d.get("start"),h=l?g+n:null,y=d?M+a:null;if(s.getAnchorKey()===c&&s.getAnchorOffset()===h&&s.getFocusKey()===p&&s.getFocusOffset()===y)return s;var m=!1;if(c===p){var I=l.get("end"),w=d.get("end");m=M===g&&w===I?a<n:M<g}else{m=t.getCurrentContent().getBlockMap().keySeq().skipUntil(function(t){return t===c||t===p}).first()===p}return s.merge({anchorKey:c,anchorOffset:h,focusKey:p,focusOffset:y,isBackward:m})}var o=n(30),i=n(8);t.exports=r},function(t,e,n){"use strict";function r(t){var e=t.getSelection();return e.isCollapsed()?null:o(t.getCurrentContent(),e)}var o=n(28);t.exports=r},function(t,e,n){"use strict";function r(t){for(var e=t.cloneRange(),n=[],r=t.endContainer;null!=r;r=r.parentNode){var o=r===t.commonAncestorContainer;o?e.setStart(t.startContainer,t.startOffset):e.setStart(e.endContainer,0);var a=Array.from(e.getClientRects());if(n.push(a),o){var s;return n.reverse(),(s=[]).concat.apply(s,n)}e.setEndBefore(r)}i(!1)}var o=n(13),i=n(2),a=o.isBrowser("Chrome"),s=a?r:function(t){return Array.from(t.getClientRects())};t.exports=s},function(t,e,n){"use strict";function r(t,e,n,r,o,i){var s=n.nodeType===Node.TEXT_NODE,c=o.nodeType===Node.TEXT_NODE;if(s&&c)return{selectionState:l(t,p(u(n)),r,p(u(o)),i),needsRecovery:!1};var f=null,d=null,g=!0;return s?(f={key:p(u(n)),offset:r},d=a(e,o,i)):c?(d={key:p(u(o)),offset:i},f=a(e,n,r)):(f=a(e,n,r),d=a(e,o,i),n===o&&r===i&&(g=!!n.firstChild&&"BR"!==n.firstChild.nodeName)),{selectionState:l(t,f.key,f.offset,d.key,d.offset),needsRecovery:g}}function o(t){for(;t.firstChild&&c(t.firstChild);)t=t.firstChild;return t}function i(t){for(;t.lastChild&&c(t.lastChild);)t=t.lastChild;return t}function a(t,e,n){var r=e,a=u(r);if(null!=a||t&&(t===r||t.firstChild===r)||f(!1),t===r&&(r=r.firstChild,r instanceof Element&&"true"===r.getAttribute("data-contents")||f(!1),n>0&&(n=r.childNodes.length)),0===n){var l=null;if(null!=a)l=a;else{var d=o(r);l=p(c(d))}return{key:l,offset:0}}var g=r.childNodes[n-1],M=null,h=null;if(c(g)){var y=i(g);M=p(c(y)),h=s(y)}else M=p(a),h=s(g);return{key:M,offset:h}}function s(t){var e=t.textContent;return"\n"===e?0:e.length}var u=n(41),c=n(57),l=n(59),f=n(2),p=n(8);t.exports=r},function(t,e,n){"use strict";function r(t,e){var n=e?l.exec(t):u.exec(t);return n?n[0]:t}var o=n(139),i=o.getPunctuation(),a="\\s|(?![_])"+i,s="^(?:"+a+")*(?:['‘’]|(?!"+a+").)*(?:(?!"+a+").)",u=new RegExp(s),c="(?:(?!"+a+").)(?:['‘’]|(?!"+a+").)*(?:"+a+")*$",l=new RegExp(c),f={getBackward:function(t){return r(t,!0)},getForward:function(t){return r(t,!1)}};t.exports=f},function(t,e,n){"use strict";function r(t,e){var n,r=t.getSelection(),o=r.getStartKey(),i=r.getStartOffset(),a=t.getCurrentContent(),s=o;return e>a.getBlockForKey(o).getText().length-i?(s=a.getKeyAfter(o),n=0):n=i+e,r.merge({focusKey:s,focusOffset:n})}t.exports=r},function(t,e,n){"use strict";function r(){return{text:"",inlines:[],entities:[],blocks:[]}}function o(t){var e=new Array(1);return t&&(e[0]=t),{text:_,inlines:[O()],entities:e,blocks:[]}}function i(){return{text:"\n",inlines:[O()],entities:new Array(1),blocks:[]}}function a(t,e){return{text:"\r",inlines:[O()],entities:new Array(1),blocks:[{type:t,depth:Math.max(0,Math.min(k,e))}]}}function s(t,e){return"li"===t?"ol"===e?"ordered-list-item":"unordered-list-item":null}function u(t){var e=t.get("unstyled").element,n=new b([]);return t.forEach(function(t){t.aliasedElements&&t.aliasedElements.forEach(function(t){n=n.add(t)}),n=n.add(t.element)}),n.filter(function(t){return t&&t!==e}).toArray().sort()}function c(t,e,n){for(var r=0;r<n.length;r++){var o=n[r](t,e);if(o)return o}return null}function l(t,e,n){var r=n.filter(function(e){return e.element===t||e.wrapper===t||e.aliasedElements&&e.aliasedElements.some(function(e){return e===t})}).keySeq().toSet().toArray().sort();switch(r.length){case 0:return"unstyled";case 1:return r[0];default:return c(t,e,[s])||"unstyled"}}function f(t,e,n){var r=Z[t];return r?n=n.add(r).toOrderedSet():e instanceof HTMLElement&&function(){var t=e;n=n.withMutations(function(e){var n=t.style.fontWeight,r=t.style.fontStyle,o=t.style.textDecoration;P.indexOf(n)>=0?e.add("BOLD"):R.indexOf(n)>=0&&e.remove("BOLD"),"italic"===r?e.add("ITALIC"):"normal"===r&&e.remove("ITALIC"),"underline"===o&&e.add("UNDERLINE"),"line-through"===o&&e.add("STRIKETHROUGH"),"none"===o&&(e.remove("UNDERLINE"),e.remove("STRIKETHROUGH"))}).toOrderedSet()}(),n}function p(t,e){var n=t.text.slice(-1),r=e.text.slice(0,1);if("\r"===n&&"\r"===r&&(t.text=t.text.slice(0,-1),t.inlines.pop(),t.entities.pop(),t.blocks.pop()),"\r"===n){if(e.text===_||"\n"===e.text)return t;r!==_&&"\n"!==r||(e.text=e.text.slice(1),e.inlines.shift(),e.entities.shift())}return{text:t.text+e.text,inlines:t.inlines.concat(e.inlines),entities:t.entities.concat(e.entities),blocks:t.blocks.concat(e.blocks)}}function d(t,e){return e.some(function(e){return-1!==t.indexOf("<"+e)})}function g(t){t instanceof HTMLAnchorElement||T(!1);var e=t.protocol;return"http:"===e||"https:"===e||"mailto:"===e}function M(t,e,n,s,u,c,d,h,y){var I=e.nodeName.toLowerCase(),w=!1,D="unstyled",v=m,j=t;if("#text"===I){var z=e.textContent;return""===z.trim()&&"pre"!==u?{chunk:o(y),entityMap:t}:("pre"!==u&&(z=z.replace(U,_)),m=I,{chunk:{text:z,inlines:Array(z.length).fill(n),entities:Array(z.length).fill(y),blocks:[]},entityMap:t})}if(m=I,"br"===I)return"br"!==v||u&&"unstyled"!==l(u,s,h)?{chunk:i(),entityMap:t}:{chunk:a("unstyled",d),entityMap:t};"img"===I&&e instanceof HTMLImageElement&&e.attributes.getNamedItem("src")&&e.attributes.getNamedItem("src").value&&function(){var t=e,n={};W.forEach(function(e){var r=t.getAttribute(e);r&&(n[e]=r)});var r=new C(n.src).toString();e.textContent=r,y=N.__create("IMAGE","MUTABLE",n||{})}();var T=r(),A=null;n=f(I,e,n),"ul"!==I&&"ol"!==I||(s&&(d+=1),s=I),u||-1===c.indexOf(I)?s&&"li"===u&&"li"===I&&(T=a(l(I,s,h),d),u=I,w=!0,D="ul"===s?"unordered-list-item":"ordered-list-item"):(T=a(l(I,s,h),d),u=I,w=!0);var E=e.firstChild;null!=E&&(I=E.nodeName.toLowerCase());for(var S=null;E;){E instanceof HTMLAnchorElement&&E.href&&g(E)?function(){var t=E,e={};G.forEach(function(n){var r=t.getAttribute(n);r&&(e[n]=r)}),e.url=new C(t.href).toString(),S=N.__create("LINK","MUTABLE",e||{})}():S=void 0;var b=M(j,E,n,s,u,c,d,h,S||y),x=b.chunk,O=b.entityMap;A=x,j=O,T=p(T,A);var k=E.nextSibling;k&&c.indexOf(I)>=0&&u&&(T=p(T,i())),k&&(I=k.nodeName.toLowerCase()),E=k}return w&&(T=p(T,a(D,d))),{chunk:T,entityMap:j}}function h(t,e,n,r){t=t.trim().replace(L,"").replace(Q,_).replace(Y,"").replace(B,"");var o=u(n),i=e(t);if(!i)return null;m=null;var a=d(t,o)?o:["div"],s=M(r,i,O(),"ul",null,a,-1,n),c=s.chunk,l=s.entityMap;return 0===c.text.indexOf("\r")&&(c={text:c.text.slice(1),inlines:c.inlines.slice(1),entities:c.entities.slice(1),blocks:c.blocks}),"\r"===c.text.slice(-1)&&(c.text=c.text.slice(0,-1),c.inlines=c.inlines.slice(0,-1),c.entities=c.entities.slice(0,-1),c.blocks.pop()),0===c.blocks.length&&c.blocks.push({type:"unstyled",depth:0}),c.text.split("\r").length===c.blocks.length+1&&c.blocks.unshift({type:"unstyled",depth:0}),{chunk:c,entityMap:l}}function y(t){var e=arguments.length<=1||void 0===arguments[1]?z:arguments[1],n=arguments.length<=2||void 0===arguments[2]?D:arguments[2],r=h(t,e,n,N);if(null==r)return null;var o=r.chunk,i=r.entityMap,a=0;return{contentBlocks:o.text.split("\r").map(function(t,e){t=E(t);var n=a+t.length,r=A(o).inlines.slice(a,n),i=A(o).entities.slice(a,n),s=x(r.map(function(t,e){var n={style:t,entity:null};return i[e]&&(n.entity=i[e]),I.create(n)}));return a=n+1,new w({key:j(),type:A(o).blocks[e].type,depth:A(o).blocks[e].depth,text:t,characterList:s})}),entityMap:i}}var m,I=n(11),w=n(17),D=n(35),N=n(29),v=n(4),C=n(150),j=n(12),z=n(66),T=n(2),A=n(8),E=n(33),S=n(4),b=S.Set,x=v.List,O=v.OrderedSet,_=" ",k=4,L=new RegExp("\r","g"),U=new RegExp("\n","g"),Q=new RegExp("&nbsp;","g"),Y=new RegExp("&#13;?","g"),B=new RegExp("&#8203;?","g"),P=["bold","bolder","500","600","700","800","900"],R=["light","lighter","100","200","300","400"],Z={b:"BOLD",code:"CODE",del:"STRIKETHROUGH",em:"ITALIC",i:"ITALIC",s:"STRIKETHROUGH",strike:"STRIKETHROUGH",strong:"BOLD",u:"UNDERLINE"},G=["className","href","rel","target","title"],W=["alt","className","height","src","width"];t.exports=y},function(t,e,n){"use strict";function r(t){var e,n=null;return!a&&document.implementation&&document.implementation.createHTMLDocument&&(e=document.implementation.createHTMLDocument("foo"),e.documentElement||i(!1),e.documentElement.innerHTML=t,n=e.getElementsByTagName("body")[0]),n}var o=n(13),i=n(2),a=o.isBrowser("IE <= 9");t.exports=r},function(t,e,n){"use strict";function r(t){return f&&t.altKey||M(t)}function o(t){return g(t)?t.shiftKey?"redo":"undo":null}function i(t){return p&&t.shiftKey?null:r(t)?"delete-word":"delete"}function a(t){return g(t)&&f?"backspace-to-start-of-line":r(t)?"backspace-word":"backspace"}function s(t){switch(t.keyCode){case 66:return g(t)?"bold":null;case 68:return M(t)?"delete":null;case 72:return M(t)?"backspace":null;case 73:return g(t)?"italic":null;case 74:return g(t)?"code":null;case 75:return!p&&M(t)?"secondary-cut":null;case 77:case 79:return M(t)?"split-block":null;case 84:return f&&M(t)?"transpose-characters":null;case 85:return g(t)?"underline":null;case 87:return f&&M(t)?"backspace-word":null;case 89:return M(t)?p?"redo":"secondary-paste":null;case 90:return o(t)||null;case c.RETURN:return"split-block";case c.DELETE:return i(t);case c.BACKSPACE:return a(t);case c.LEFT:return d&&g(t)?"move-selection-to-start-of-block":null;case c.RIGHT:return d&&g(t)?"move-selection-to-end-of-block":null;default:return null}}var u=n(42),c=n(36),l=n(13),f=l.isPlatform("Mac OS X"),p=l.isPlatform("Windows"),d=f&&l.isBrowser("Firefox < 29"),g=u.hasCommandModifier,M=u.isCtrlKeyCommand;t.exports=s},function(t,e,n){"use strict";var r={stringify:function(t){return"_"+String(t)},unstringify:function(t){return t.slice(1)}};t.exports=r},function(t,e,n){!function(t,n){n(e)}(0,function(t){"use strict";function e(t){return t.value=!1,t}function n(t){t&&(t.value=!0)}function r(){}function o(t,e){e=e||0;for(var n=Math.max(0,t.length-e),r=new Array(n),o=0;o<n;o++)r[o]=t[o+e];return r}function i(t){return void 0===t.size&&(t.size=t.__iterate(s)),t.size}function a(t,e){if("number"!=typeof e){var n=e>>>0;if(""+n!==e||4294967295===n)return NaN;e=n}return e<0?i(t)+e:e}function s(){return!0}function u(t,e,n){return(0===t||void 0!==n&&t<=-n)&&(void 0===e||void 0!==n&&e>=n)}function c(t,e){return f(t,e,0)}function l(t,e){return f(t,e,e)}function f(t,e,n){return void 0===t?n:t<0?e===1/0?e:0|Math.max(0,e+t):void 0===e||e===t?t:0|Math.min(e,t)}function p(t){return(d(t)||m(t))&&!t.__ownerID}function d(t){return!(!t||!t[xe])}function g(t){return!(!t||!t[Oe])}function M(t){return!(!t||!t[_e])}function h(t){return g(t)||M(t)}function y(t){return!(!t||!t[ke])}function m(t){return!(!t||!t[Le])}function I(t){return!(!t||"function"!=typeof t.equals||"function"!=typeof t.hashCode)}function w(t,e,n,r){var o=0===t?e:1===t?n:[e,n];return r?r.value=o:r={value:o,done:!1},r}function D(){return{value:void 0,done:!0}}function N(t){return!!j(t)}function v(t){return t&&"function"==typeof t.next}function C(t){var e=j(t);return e&&e.call(t)}function j(t){var e=t&&(Ge&&t[Ge]||t[We]);if("function"==typeof e)return e}function z(t){return t&&"number"==typeof t.length}function T(t){return!(!t||!t[Xe])}function A(){return en||(en=new $e([]))}function E(t){var e=Array.isArray(t)?new $e(t):v(t)?new on(t):N(t)?new rn(t):void 0;if(e)return e.fromEntrySeq();if("object"==typeof t)return new tn(t);throw new TypeError("Expected Array or collection object of [k, v] entries, or keyed object: "+t)}function S(t){var e=x(t);if(e)return e;throw new TypeError("Expected Array or collection object of values: "+t)}function b(t){var e=x(t);if(e)return e;if("object"==typeof t)return new tn(t);throw new TypeError("Expected Array or collection object of values, or keyed object: "+t)}function x(t){return z(t)?new $e(t):v(t)?new on(t):N(t)?new rn(t):void 0}function O(t,e){if(t===e||t!==t&&e!==e)return!0;if(!t||!e)return!1;if("function"==typeof t.valueOf&&"function"==typeof e.valueOf){if(t=t.valueOf(),e=e.valueOf(),t===e||t!==t&&e!==e)return!0;if(!t||!e)return!1}return!!(I(t)&&I(e)&&t.equals(e))}function _(t,e){return k([],e||L,t,"",e&&e.length>2?[]:void 0,{"":t})}function k(t,e,n,r,o,i){var a=Array.isArray(n)?qe:U(n)?Je:null;if(a){if(~t.indexOf(n))throw new TypeError("Cannot convert circular structure to Immutable");t.push(n),o&&""!==r&&o.push(r);var s=e.call(i,r,a(n).map(function(r,i){return k(t,e,r,i,o,n)}),o&&o.slice());return t.pop(),o&&o.pop(),s}return n}function L(t,e){return g(e)?e.toMap():e.toList()}function U(t){return t&&(t.constructor===Object||void 0===t.constructor)}function Q(t){return t>>>1&1073741824|3221225471&t}function Y(t){if(!1===t||null===t||void 0===t)return 0;if("function"==typeof t.valueOf&&(!1===(t=t.valueOf())||null===t||void 0===t))return 0;if(!0===t)return 1;var e=typeof t;if("number"===e){if(t!==t||t===1/0)return 0;var n=0|t;for(n!==t&&(n^=4294967295*t);t>4294967295;)t/=4294967295,n^=t;return Q(n)}if("string"===e)return t.length>pn?B(t):P(t);if("function"==typeof t.hashCode)return t.hashCode();if("object"===e)return R(t);if("function"==typeof t.toString)return P(t.toString());throw new Error("Value type "+e+" cannot be hashed.")}function B(t){var e=Mn[t];return void 0===e&&(e=P(t),gn===dn&&(gn=0,Mn={}),gn++,Mn[t]=e),e}function P(t){for(var e=0,n=0;n<t.length;n++)e=31*e+t.charCodeAt(n)|0;return Q(e)}function R(t){var e;if(cn&&void 0!==(e=nn.get(t)))return e;if(void 0!==(e=t[fn]))return e;if(!un){if(void 0!==(e=t.propertyIsEnumerable&&t.propertyIsEnumerable[fn]))return e;if(void 0!==(e=Z(t)))return e}if(e=++ln,1073741824&ln&&(ln=0),cn)nn.set(t,e);else{if(void 0!==sn&&!1===sn(t))throw new Error("Non-extensible objects are not allowed as keys.");if(un)Object.defineProperty(t,fn,{enumerable:!1,configurable:!1,writable:!1,value:e});else if(void 0!==t.propertyIsEnumerable&&t.propertyIsEnumerable===t.constructor.prototype.propertyIsEnumerable)t.propertyIsEnumerable=function(){return this.constructor.prototype.propertyIsEnumerable.apply(this,arguments)},t.propertyIsEnumerable[fn]=e;else{if(void 0===t.nodeType)throw new Error("Unable to set a non-enumerable property on object.");t[fn]=e}}return e}function Z(t){if(t&&t.nodeType>0)switch(t.nodeType){case 1:return t.uniqueID;case 9:return t.documentElement&&t.documentElement.uniqueID}}function G(t){var e=lt(t);return e._iter=t,e.size=t.size,e.flip=function(){return t},e.reverse=function(){var e=t.reverse.apply(this);return e.flip=function(){return t.reverse()},e},e.has=function(e){return t.includes(e)},e.includes=function(e){return t.has(e)},e.cacheResult=ft,e.__iterateUncached=function(e,n){var r=this;return t.__iterate(function(t,n){return!1!==e(n,t,r)},n)},e.__iteratorUncached=function(e,n){if(e===Ze){var r=t.__iterator(e,n);return new He(function(){var t=r.next();if(!t.done){var e=t.value[0];t.value[0]=t.value[1],t.value[1]=e}return t})}return t.__iterator(e===Re?Pe:Re,n)},e}function W(t,e,n){var r=lt(t);return r.size=t.size,r.has=function(e){return t.has(e)},r.get=function(r,o){var i=t.get(r,Ee);return i===Ee?o:e.call(n,i,r,t)},r.__iterateUncached=function(r,o){var i=this;return t.__iterate(function(t,o,a){return!1!==r(e.call(n,t,o,a),o,i)},o)},r.__iteratorUncached=function(r,o){var i=t.__iterator(Ze,o);return new He(function(){var o=i.next();if(o.done)return o;var a=o.value,s=a[0];return w(r,s,e.call(n,a[1],s,t),o)})},r}function F(t,e){var n=this,r=lt(t);return r._iter=t,r.size=t.size,r.reverse=function(){return t},t.flip&&(r.flip=function(){var e=G(t);return e.reverse=function(){return t.flip()},e}),r.get=function(n,r){return t.get(e?n:-1-n,r)},r.has=function(n){return t.has(e?n:-1-n)},r.includes=function(e){return t.includes(e)},r.cacheResult=ft,r.__iterate=function(n,r){var o=this,a=0;return r&&i(t),t.__iterate(function(t,i){return n(t,e?i:r?o.size-++a:a++,o)},!r)},r.__iterator=function(r,o){var a=0;o&&i(t);var s=t.__iterator(Ze,!o);return new He(function(){var t=s.next();if(t.done)return t;var i=t.value;return w(r,e?i[0]:o?n.size-++a:a++,i[1],t)})},r}function H(t,e,n,r){var o=lt(t);return r&&(o.has=function(r){var o=t.get(r,Ee);return o!==Ee&&!!e.call(n,o,r,t)},o.get=function(r,o){var i=t.get(r,Ee);return i!==Ee&&e.call(n,i,r,t)?i:o}),o.__iterateUncached=function(o,i){var a=this,s=0;return t.__iterate(function(t,i,u){if(e.call(n,t,i,u))return o(t,r?i:s++,a)},i),s},o.__iteratorUncached=function(o,i){var a=t.__iterator(Ze,i),s=0;return new He(function(){for(;;){var i=a.next();if(i.done)return i;var u=i.value,c=u[0],l=u[1];if(e.call(n,l,c,t))return w(o,r?c:s++,l,i)}})},o}function K(t,e,n){var r=wn().asMutable();return t.__iterate(function(o,i){r.update(e.call(n,o,i,t),0,function(t){return t+1})}),r.asImmutable()}function J(t,e,n){var r=g(t),o=(y(t)?Yn():wn()).asMutable();t.__iterate(function(i,a){o.update(e.call(n,i,a,t),function(t){return t=t||[],t.push(r?[a,i]:i),t})});var i=ct(t);return o.map(function(e){return st(t,i(e))})}function q(t,e,n,r){var o=t.size;if(u(e,n,o))return t;var i=c(e,o),s=l(n,o);if(i!==i||s!==s)return q(t.toSeq().cacheResult(),e,n,r);var f,p=s-i;p===p&&(f=p<0?0:p);var d=lt(t);return d.size=0===f?f:t.size&&f||void 0,!r&&T(t)&&f>=0&&(d.get=function(e,n){return e=a(this,e),e>=0&&e<f?t.get(e+i,n):n}),d.__iterateUncached=function(e,n){var o=this;if(0===f)return 0;if(n)return this.cacheResult().__iterate(e,n);var a=0,s=!0,u=0;return t.__iterate(function(t,n){if(!s||!(s=a++<i))return u++,!1!==e(t,r?n:u-1,o)&&u!==f}),u},d.__iteratorUncached=function(e,n){if(0!==f&&n)return this.cacheResult().__iterator(e,n);var o=0!==f&&t.__iterator(e,n),a=0,s=0;return new He(function(){for(;a++<i;)o.next();if(++s>f)return D();var t=o.next();return r||e===Re?t:e===Pe?w(e,s-1,void 0,t):w(e,s-1,t.value[1],t)})},d}function V(t,e,n){var r=lt(t);return r.__iterateUncached=function(r,o){var i=this;if(o)return this.cacheResult().__iterate(r,o);var a=0;return t.__iterate(function(t,o,s){return e.call(n,t,o,s)&&++a&&r(t,o,i)}),a},r.__iteratorUncached=function(r,o){var i=this;if(o)return this.cacheResult().__iterator(r,o);var a=t.__iterator(Ze,o),s=!0;return new He(function(){if(!s)return D();var t=a.next();if(t.done)return t;var o=t.value,u=o[0],c=o[1];return e.call(n,c,u,i)?r===Ze?t:w(r,u,c,t):(s=!1,D())})},r}function X(t,e,n,r){var o=lt(t);return o.__iterateUncached=function(o,i){var a=this;if(i)return this.cacheResult().__iterate(o,i);var s=!0,u=0;return t.__iterate(function(t,i,c){if(!s||!(s=e.call(n,t,i,c)))return u++,o(t,r?i:u-1,a)}),u},o.__iteratorUncached=function(o,i){var a=this;if(i)return this.cacheResult().__iterator(o,i);var s=t.__iterator(Ze,i),u=!0,c=0;return new He(function(){var t,i,l;do{if(t=s.next(),t.done)return r||o===Re?t:o===Pe?w(o,c++,void 0,t):w(o,c++,t.value[1],t);var f=t.value;i=f[0],l=f[1],u&&(u=e.call(n,l,i,a))}while(u);return o===Ze?t:w(o,i,l,t)})},o}function $(t,e){var n=g(t),r=[t].concat(e).map(function(t){return d(t)?n&&(t=Qe(t)):t=n?E(t):S(Array.isArray(t)?t:[t]),t}).filter(function(t){return 0!==t.size});if(0===r.length)return t;if(1===r.length){var o=r[0];if(o===t||n&&g(o)||M(t)&&M(o))return o}var i=new $e(r);return n?i=i.toKeyedSeq():M(t)||(i=i.toSetSeq()),i=i.flatten(!0),i.size=r.reduce(function(t,e){if(void 0!==t){var n=e.size;if(void 0!==n)return t+n}},0),i}function tt(t,e,n){var r=lt(t);return r.__iterateUncached=function(o,i){function a(t,c){t.__iterate(function(t,i){return(!e||c<e)&&d(t)?a(t,c+1):!1===o(t,n?i:s++,r)&&(u=!0),!u},i)}if(i)return this.cacheResult().__iterate(o,i);var s=0,u=!1;return a(t,0),s},r.__iteratorUncached=function(r,o){if(o)return this.cacheResult().__iterator(r,o);var i=t.__iterator(r,o),a=[],s=0;return new He(function(){for(;i;){var t=i.next();if(!1===t.done){var u=t.value;if(r===Ze&&(u=u[1]),e&&!(a.length<e)||!d(u))return n?t:w(r,s++,u,t);a.push(i),i=u.__iterator(r,o)}else i=a.pop()}return D()})},r}function et(t,e,n){var r=ct(t);return t.toSeq().map(function(o,i){return r(e.call(n,o,i,t))}).flatten(!0)}function nt(t,e){var n=lt(t);return n.size=t.size&&2*t.size-1,n.__iterateUncached=function(n,r){var o=this,i=0;return t.__iterate(function(t){return(!i||!1!==n(e,i++,o))&&!1!==n(t,i++,o)},r),i},n.__iteratorUncached=function(n,r){var o,i=t.__iterator(Re,r),a=0;return new He(function(){return(!o||a%2)&&(o=i.next(),o.done)?o:a%2?w(n,a++,e):w(n,a++,o.value,o)})},n}function rt(t,e,n){e||(e=pt);var r=g(t),o=0,i=t.toSeq().map(function(e,r){return[r,e,o++,n?n(e,r,t):e]}).toArray();return i.sort(function(t,n){return e(t[3],n[3])||t[2]-n[2]}).forEach(r?function(t,e){i[e].length=2}:function(t,e){i[e]=t[1]}),r?Je(i):M(t)?qe(i):Ve(i)}function ot(t,e,n){if(e||(e=pt),n){var r=t.toSeq().map(function(e,r){return[e,n(e,r,t)]}).reduce(function(t,n){return it(e,t[1],n[1])?n:t});return r&&r[0]}return t.reduce(function(t,n){return it(e,t,n)?n:t})}function it(t,e,n){var r=t(n,e);return 0===r&&n!==e&&(void 0===n||null===n||n!==n)||r>0}function at(t,e,n){var r=lt(t);return r.size=new $e(n).map(function(t){return t.size}).min(),r.__iterate=function(t,e){for(var n,r=this,o=this.__iterator(Re,e),i=0;!(n=o.next()).done&&!1!==t(n.value,i++,r););return i},r.__iteratorUncached=function(t,r){var o=n.map(function(t){return t=Ue(t),C(r?t.reverse():t)}),i=0,a=!1;return new He(function(){var n;return a||(n=o.map(function(t){return t.next()}),a=n.some(function(t){return t.done})),a?D():w(t,i++,e.apply(null,n.map(function(t){return t.value})))})},r}function st(t,e){return t===e?t:T(t)?e:t.constructor(e)}function ut(t){if(t!==Object(t))throw new TypeError("Expected [K, V] tuple: "+t)}function ct(t){return g(t)?Qe:M(t)?Ye:Be}function lt(t){return Object.create((g(t)?Je:M(t)?qe:Ve).prototype)}function ft(){return this._iter.cacheResult?(this._iter.cacheResult(),this.size=this._iter.size,this):Ke.prototype.cacheResult.call(this)}function pt(t,e){return void 0===t&&void 0===e?0:void 0===t?1:void 0===e?-1:t>e?1:t<e?-1:0}function dt(t){if(z(t)&&"string"!=typeof t)return t;if(y(t))return t.toArray();throw new TypeError("Invalid keyPath: expected Ordered Collection or Array: "+t)}function gt(t,e){if(!t)throw new Error(e)}function Mt(t){gt(t!==1/0,"Cannot perform this action with an infinite size.")}function ht(t){return"string"==typeof t?JSON.stringify(t):String(t)}function yt(t){return!(!t||!t[Dn])}function mt(t,e){return w(t,e[0],e[1])}function It(t,e){return{node:t,index:0,__prev:e}}function wt(t,e,n,r){var o=Object.create(Nn);return o.size=t,o._root=e,o.__ownerID=n,o.__hash=r,o.__altered=!1,o}function Dt(){return An||(An=wt(0))}function Nt(t,n,r){var o,i;if(t._root){var a=e(Se),s=e(be);if(o=vt(t._root,t.__ownerID,0,void 0,n,r,a,s),!s.value)return t;i=t.size+(a.value?r===Ee?-1:1:0)}else{if(r===Ee)return t;i=1,o=new vn(t.__ownerID,[[n,r]])}return t.__ownerID?(t.size=i,t._root=o,t.__hash=void 0,t.__altered=!0,t):o?wt(i,o):Dt()}function vt(t,e,r,o,i,a,s,u){return t?t.update(e,r,o,i,a,s,u):a===Ee?t:(n(u),n(s),new Tn(e,o,[i,a]))}function Ct(t){return t.constructor===Tn||t.constructor===zn}function jt(t,e,n,r,o){if(t.keyHash===r)return new zn(e,r,[t.entry,o]);var i,a=(0===n?t.keyHash:t.keyHash>>>n)&Ae,s=(0===n?r:r>>>n)&Ae,u=a===s?[jt(t,e,n+ze,r,o)]:(i=new Tn(e,r,o),a<s?[t,i]:[i,t]);return new Cn(e,1<<a|1<<s,u)}function zt(t,e,n,o){t||(t=new r);for(var i=new Tn(t,Y(n),[n,o]),a=0;a<e.length;a++){var s=e[a];i=i.update(t,0,void 0,s[0],s[1])}return i}function Tt(t,e,n,r){for(var o=0,i=0,a=new Array(n),s=0,u=1,c=e.length;s<c;s++,u<<=1){var l=e[s];void 0!==l&&s!==r&&(o|=u,a[i++]=l)}return new Cn(t,o,a)}function At(t,e,n,r,o){for(var i=0,a=new Array(Te),s=0;0!==n;s++,n>>>=1)a[s]=1&n?e[i++]:void 0;return a[r]=o,new jn(t,i+1,a)}function Et(t,e,n){for(var r=[],o=0;o<n.length;o++){var i=n[o],a=Qe(i);d(i)||(a=a.map(function(t){return _(t)})),r.push(a)}return xt(t,e,r)}function St(t,e){return t&&t.mergeDeep&&d(e)?t.mergeDeep(e):O(t,e)?t:e}function bt(t){return function(e,n,r){if(e&&e.mergeDeepWith&&d(n))return e.mergeDeepWith(t,n);var o=t(e,n,r);return O(e,o)?e:o}}function xt(t,e,n){return n=n.filter(function(t){return 0!==t.size}),0===n.length?t:0!==t.size||t.__ownerID||1!==n.length?t.withMutations(function(t){for(var r=e?function(n,r){t.update(r,Ee,function(t){return t===Ee?n:e(t,n,r)})}:function(e,n){t.set(n,e)},o=0;o<n.length;o++)n[o].forEach(r)}):t.constructor(n[0])}function Ot(t,e,n,r,o){var i=t===Ee;if(n===e.length){var a=i?r:t,s=o(a);return s===a?t:s}if(!(i||t&&t.set))throw new TypeError("Invalid keyPath: Value at ["+e.slice(0,n).map(ht)+"] does not have a .set() method and cannot be updated: "+t);var u=e[n],c=i?Ee:t.get(u,Ee),l=Ot(c,e,n+1,r,o);return l===c?t:l===Ee?t.remove(u):(i?Dt():t).set(u,l)}function _t(t){return t-=t>>1&1431655765,t=(858993459&t)+(t>>2&858993459),t=t+(t>>4)&252645135,t+=t>>8,127&(t+=t>>16)}function kt(t,e,n,r){var i=r?t:o(t);return i[e]=n,i}function Lt(t,e,n,r){var o=t.length+1;if(r&&e+1===o)return t[e]=n,t;for(var i=new Array(o),a=0,s=0;s<o;s++)s===e?(i[s]=n,a=-1):i[s]=t[s+a];return i}function Ut(t,e,n){var r=t.length-1;if(n&&e===r)return t.pop(),t;for(var o=new Array(r),i=0,a=0;a<r;a++)a===e&&(i=1),o[a]=t[a+i];return o}function Qt(t){return!(!t||!t[_n])}function Yt(t,e){function n(t,e,n){return 0===e?r(t,n):o(t,e,n)}function r(t,n){var r=n===s?u&&u.array:t&&t.array,o=n>i?0:i-n,c=a-n;return c>Te&&(c=Te),function(){if(o===c)return Qn;var t=e?--c:o++;return r&&r[t]}}function o(t,r,o){var s,u=t&&t.array,c=o>i?0:i-o>>r,l=1+(a-o>>r);return l>Te&&(l=Te),function(){for(;;){if(s){var t=s();if(t!==Qn)return t;s=null}if(c===l)return Qn;var i=e?--l:c++;s=n(u&&u[i],r-ze,o+(i<<r))}}}var i=t._origin,a=t._capacity,s=Kt(a),u=t._tail;return n(t._root,t._level,0)}function Bt(t,e,n,r,o,i,a){var s=Object.create(kn);return s.size=e-t,s._origin=t,s._capacity=e,s._level=n,s._root=r,s._tail=o,s.__ownerID=i,s.__hash=a,s.__altered=!1,s}function Pt(){return Un||(Un=Bt(0,0,ze))}function Rt(t,n,r){if((n=a(t,n))!==n)return t;if(n>=t.size||n<0)return t.withMutations(function(t){n<0?Ft(t,n).set(0,r):Ft(t,0,n+1).set(n,r)});n+=t._origin;var o=t._tail,i=t._root,s=e(be);return n>=Kt(t._capacity)?o=Zt(o,t.__ownerID,0,n,r,s):i=Zt(i,t.__ownerID,t._level,n,r,s),s.value?t.__ownerID?(t._root=i,t._tail=o,t.__hash=void 0,t.__altered=!0,t):Bt(t._origin,t._capacity,t._level,i,o):t}function Zt(t,e,r,o,i,a){var s=o>>>r&Ae,u=t&&s<t.array.length;if(!u&&void 0===i)return t;var c;if(r>0){var l=t&&t.array[s],f=Zt(l,e,r-ze,o,i,a);return f===l?t:(c=Gt(t,e),c.array[s]=f,c)}return u&&t.array[s]===i?t:(n(a),c=Gt(t,e),void 0===i&&s===c.array.length-1?c.array.pop():c.array[s]=i,c)}function Gt(t,e){return e&&t&&e===t.ownerID?t:new Ln(t?t.array.slice():[],e)}function Wt(t,e){if(e>=Kt(t._capacity))return t._tail;if(e<1<<t._level+ze){for(var n=t._root,r=t._level;n&&r>0;)n=n.array[e>>>r&Ae],r-=ze;return n}}function Ft(t,e,n){void 0!==e&&(e|=0),void 0!==n&&(n|=0);var o=t.__ownerID||new r,i=t._origin,a=t._capacity,s=i+e,u=void 0===n?a:n<0?a+n:i+n;if(s===i&&u===a)return t;if(s>=u)return t.clear();for(var c=t._level,l=t._root,f=0;s+f<0;)l=new Ln(l&&l.array.length?[void 0,l]:[],o),c+=ze,f+=1<<c;f&&(s+=f,i+=f,u+=f,a+=f);for(var p=Kt(a),d=Kt(u);d>=1<<c+ze;)l=new Ln(l&&l.array.length?[l]:[],o),c+=ze;var g=t._tail,M=d<p?Wt(t,u-1):d>p?new Ln([],o):g;if(g&&d>p&&s<a&&g.array.length){l=Gt(l,o);for(var h=l,y=c;y>ze;y-=ze){var m=p>>>y&Ae;h=h.array[m]=Gt(h.array[m],o)}h.array[p>>>ze&Ae]=g}if(u<a&&(M=M&&M.removeAfter(o,0,u)),s>=d)s-=d,u-=d,c=ze,l=null,M=M&&M.removeBefore(o,0,s);else if(s>i||d<p){for(f=0;l;){var I=s>>>c&Ae;if(I!==d>>>c&Ae)break;I&&(f+=(1<<c)*I),c-=ze,l=l.array[I]}l&&s>i&&(l=l.removeBefore(o,c,s-f)),l&&d<p&&(l=l.removeAfter(o,c,d-f)),f&&(s-=f,u-=f)}return t.__ownerID?(t.size=u-s,t._origin=s,t._capacity=u,t._level=c,t._root=l,t._tail=M,t.__hash=void 0,t.__altered=!0,t):Bt(s,u,c,l,M)}function Ht(t,e,n){for(var r=[],o=0,i=0;i<n.length;i++){var a=n[i],s=Ye(a);s.size>o&&(o=s.size),d(a)||(s=s.map(function(t){return _(t)})),r.push(s)}return o>t.size&&(t=t.setSize(o)),xt(t,e,r)}function Kt(t){return t<Te?0:t-1>>>ze<<ze}function Jt(t){return yt(t)&&y(t)}function qt(t,e,n,r){var o=Object.create(Yn.prototype);return o.size=t?t.size:0,o._map=t,o._list=e,o.__ownerID=n,o.__hash=r,o}function Vt(){return Bn||(Bn=qt(Dt(),Pt()))}function Xt(t,e,n){var r,o,i=t._map,a=t._list,s=i.get(e),u=void 0!==s;if(n===Ee){if(!u)return t;a.size>=Te&&a.size>=2*i.size?(o=a.filter(function(t,e){return void 0!==t&&s!==e}),r=o.toKeyedSeq().map(function(t){return t[0]}).flip().toMap(),t.__ownerID&&(r.__ownerID=o.__ownerID=t.__ownerID)):(r=i.remove(e),o=s===a.size-1?a.pop():a.set(s,void 0))}else if(u){if(n===a.get(s)[1])return t;r=i,o=a.set(s,[e,n])}else r=i.set(e,a.size),o=a.set(a.size,[e,n]);return t.__ownerID?(t.size=r.size,t._map=r,t._list=o,t.__hash=void 0,t):qt(r,o)}function $t(t){return!(!t||!t[Rn])}function te(t,e,n,r){var o=Object.create(Zn);return o.size=t,o._head=e,o.__ownerID=n,o.__hash=r,o.__altered=!1,o}function ee(){return Gn||(Gn=te(0))}function ne(t,e){if(t===e)return!0;if(!d(e)||void 0!==t.size&&void 0!==e.size&&t.size!==e.size||void 0!==t.__hash&&void 0!==e.__hash&&t.__hash!==e.__hash||g(t)!==g(e)||M(t)!==M(e)||y(t)!==y(e))return!1;if(0===t.size&&0===e.size)return!0;var n=!h(t);if(y(t)){var r=t.entries();return e.every(function(t,e){var o=r.next().value;return o&&O(o[1],t)&&(n||O(o[0],e))})&&r.next().done}var o=!1;if(void 0===t.size)if(void 0===e.size)"function"==typeof t.cacheResult&&t.cacheResult();else{o=!0;var i=t;t=e,e=i}var a=!0,s=e.__iterate(function(e,r){if(n?!t.has(e):o?!O(e,t.get(r,Ee)):!O(t.get(r,Ee),e))return a=!1,!1});return a&&t.size===s}function re(t,e){var n=function(n){t.prototype[n]=e[n]};return Object.keys(e).forEach(n),Object.getOwnPropertySymbols&&Object.getOwnPropertySymbols(e).forEach(n),t}function oe(t){return!(!t||!t[Fn])}function ie(t,e){return t.__ownerID?(t.size=e.size,t._map=e,t):e===t._map?t:0===e.size?t.__empty():t.__make(e)}function ae(t,e){var n=Object.create(Hn);return n.size=t?t.size:0,n._map=t,n.__ownerID=e,n}function se(){return Kn||(Kn=ae(Dt()))}function ue(t,e,n,r,o,i){return Mt(t.size),t.__iterate(function(t,i,a){o?(o=!1,n=t):n=e.call(r,n,t,i,a)},i),n}function ce(t,e){return e}function le(t,e){return[e,t]}function fe(t){return t&&"function"==typeof t.toJS?t.toJS():t}function pe(t){return function(){return!t.apply(this,arguments)}}function de(t){return function(){return-t.apply(this,arguments)}}function ge(){return o(arguments)}function Me(t,e){return t<e?1:t>e?-1:0}function he(t){if(t.size===1/0)return 0;var e=y(t),n=g(t),r=e?1:0;return ye(t.__iterate(n?e?function(t,e){r=31*r+me(Y(t),Y(e))|0}:function(t,e){r=r+me(Y(t),Y(e))|0}:e?function(t){r=31*r+Y(t)|0}:function(t){r=r+Y(t)|0}),r)}function ye(t,e){return e=an(e,3432918353),e=an(e<<15|e>>>-15,461845907),e=an(e<<13|e>>>-13,5),e=(e+3864292196|0)^t,e=an(e^e>>>16,2246822507),e=an(e^e>>>13,3266489909),e=Q(e^e>>>16)}function me(t,e){return t^e+2654435769+(t<<6)+(t>>2)|0}function Ie(t){return oe(t)&&y(t)}function we(t,e){var n=Object.create(er);return n.size=t?t.size:0,n._map=t,n.__ownerID=e,n}function De(){return nr||(nr=we(Vt()))}function Ne(t,e,n){var r=Object.create(Object.getPrototypeOf(t));return r._values=e,r.__ownerID=n,r}function ve(t){return t._name||t.constructor.name||"Record"}function Ce(t){return E(t._keys.map(function(e){return[e,t.get(e)]}))}function je(t,e){try{Object.defineProperty(t,e,{get:function(){return this.get(e)},set:function(t){gt(this.__ownerID,"Cannot set on an immutable record."),this.set(e,t)}})}catch(t){}}var ze=5,Te=1<<ze,Ae=Te-1,Ee={},Se={value:!1},be={value:!1},xe="@@__IMMUTABLE_ITERABLE__@@",Oe="@@__IMMUTABLE_KEYED__@@",_e="@@__IMMUTABLE_INDEXED__@@",ke="@@__IMMUTABLE_ORDERED__@@",Le="@@__IMMUTABLE_RECORD__@@",Ue=function(t){return d(t)?t:Ke(t)},Qe=function(t){function e(t){return g(t)?t:Je(t)}return t&&(e.__proto__=t),e.prototype=Object.create(t&&t.prototype),e.prototype.constructor=e,e}(Ue),Ye=function(t){function e(t){return M(t)?t:qe(t)}return t&&(e.__proto__=t),e.prototype=Object.create(t&&t.prototype),e.prototype.constructor=e,e}(Ue),Be=function(t){function e(t){return d(t)&&!h(t)?t:Ve(t)}return t&&(e.__proto__=t),e.prototype=Object.create(t&&t.prototype),e.prototype.constructor=e,e}(Ue);Ue.Keyed=Qe,Ue.Indexed=Ye,Ue.Set=Be;var Pe=0,Re=1,Ze=2,Ge="function"==typeof Symbol&&Symbol.iterator,We="@@iterator",Fe=Ge||We,He=function(t){this.next=t};He.prototype.toString=function(){return"[Iterator]"},He.KEYS=Pe,He.VALUES=Re,He.ENTRIES=Ze,He.prototype.inspect=He.prototype.toSource=function(){return this.toString()},He.prototype[Fe]=function(){return this};var Ke=function(t){function e(t){return null===t||void 0===t?A():d(t)||m(t)?t.toSeq():b(t)}return t&&(e.__proto__=t),e.prototype=Object.create(t&&t.prototype),e.prototype.constructor=e,e.of=function(){return e(arguments)},e.prototype.toSeq=function(){return this},e.prototype.toString=function(){return this.__toString("Seq {","}")},e.prototype.cacheResult=function(){return!this._cache&&this.__iterateUncached&&(this._cache=this.entrySeq().toArray(),this.size=this._cache.length),this},e.prototype.__iterate=function(t,e){var n=this,r=this._cache;if(r){for(var o=r.length,i=0;i!==o;){var a=r[e?o-++i:i++];if(!1===t(a[1],a[0],n))break}return i}return this.__iterateUncached(t,e)},e.prototype.__iterator=function(t,e){var n=this._cache;if(n){var r=n.length,o=0;return new He(function(){if(o===r)return D();var i=n[e?r-++o:o++];return w(t,i[0],i[1])})}return this.__iteratorUncached(t,e)},e}(Ue),Je=function(t){function e(t){return null===t||void 0===t?A().toKeyedSeq():d(t)?g(t)?t.toSeq():t.fromEntrySeq():m(t)?t.toSeq():E(t)}return t&&(e.__proto__=t),e.prototype=Object.create(t&&t.prototype),e.prototype.constructor=e,e.prototype.toKeyedSeq=function(){return this},e}(Ke),qe=function(t){function e(t){return null===t||void 0===t?A():d(t)?g(t)?t.entrySeq():t.toIndexedSeq():m(t)?t.toSeq().entrySeq():S(t)}return t&&(e.__proto__=t),e.prototype=Object.create(t&&t.prototype),e.prototype.constructor=e,e.of=function(){return e(arguments)},e.prototype.toIndexedSeq=function(){return this},e.prototype.toString=function(){return this.__toString("Seq [","]")},e}(Ke),Ve=function(t){function e(t){return(d(t)&&!h(t)?t:qe(t)).toSetSeq()}return t&&(e.__proto__=t),e.prototype=Object.create(t&&t.prototype),e.prototype.constructor=e,e.of=function(){return e(arguments)},e.prototype.toSetSeq=function(){return this},e}(Ke);Ke.isSeq=T,Ke.Keyed=Je,Ke.Set=Ve,Ke.Indexed=qe;var Xe="@@__IMMUTABLE_SEQ__@@";Ke.prototype[Xe]=!0;var $e=function(t){function e(t){this._array=t,this.size=t.length}return t&&(e.__proto__=t),e.prototype=Object.create(t&&t.prototype),e.prototype.constructor=e,e.prototype.get=function(t,e){return this.has(t)?this._array[a(this,t)]:e},e.prototype.__iterate=function(t,e){for(var n=this,r=this._array,o=r.length,i=0;i!==o;){var a=e?o-++i:i++;if(!1===t(r[a],a,n))break}return i},e.prototype.__iterator=function(t,e){var n=this._array,r=n.length,o=0;return new He(function(){if(o===r)return D();var i=e?r-++o:o++;return w(t,i,n[i])})},e}(qe),tn=function(t){function e(t){var e=Object.keys(t);this._object=t,this._keys=e,this.size=e.length}return t&&(e.__proto__=t),e.prototype=Object.create(t&&t.prototype),e.prototype.constructor=e,e.prototype.get=function(t,e){return void 0===e||this.has(t)?this._object[t]:e},e.prototype.has=function(t){return this._object.hasOwnProperty(t)},e.prototype.__iterate=function(t,e){for(var n=this,r=this._object,o=this._keys,i=o.length,a=0;a!==i;){var s=o[e?i-++a:a++];if(!1===t(r[s],s,n))break}return a},e.prototype.__iterator=function(t,e){var n=this._object,r=this._keys,o=r.length,i=0;return new He(function(){if(i===o)return D();var a=r[e?o-++i:i++];return w(t,a,n[a])})},e}(Je);tn.prototype[ke]=!0;var en,nn,rn=function(t){function e(t){this._collection=t,this.size=t.length||t.size}return t&&(e.__proto__=t),e.prototype=Object.create(t&&t.prototype),e.prototype.constructor=e,e.prototype.__iterateUncached=function(t,e){var n=this;if(e)return this.cacheResult().__iterate(t,e);var r=this._collection,o=C(r),i=0;if(v(o))for(var a;!(a=o.next()).done&&!1!==t(a.value,i++,n););return i},e.prototype.__iteratorUncached=function(t,e){if(e)return this.cacheResult().__iterator(t,e);var n=this._collection,r=C(n);if(!v(r))return new He(D);var o=0;return new He(function(){var e=r.next();return e.done?e:w(t,o++,e.value)})},e}(qe),on=function(t){function e(t){this._iterator=t,this._iteratorCache=[]}return t&&(e.__proto__=t),e.prototype=Object.create(t&&t.prototype),e.prototype.constructor=e,e.prototype.__iterateUncached=function(t,e){var n=this;if(e)return this.cacheResult().__iterate(t,e);for(var r=this._iterator,o=this._iteratorCache,i=0;i<o.length;)if(!1===t(o[i],i++,n))return i;for(var a;!(a=r.next()).done;){var s=a.value;if(o[i]=s,!1===t(s,i++,n))break}return i},e.prototype.__iteratorUncached=function(t,e){if(e)return this.cacheResult().__iterator(t,e);var n=this._iterator,r=this._iteratorCache,o=0;return new He(function(){if(o>=r.length){var e=n.next();if(e.done)return e;r[o]=e.value}return w(t,o,r[o++])})},e}(qe),an="function"==typeof Math.imul&&-2===Math.imul(4294967295,2)?Math.imul:function(t,e){t|=0,e|=0;var n=65535&t,r=65535&e;return n*r+((t>>>16)*r+n*(e>>>16)<<16>>>0)|0},sn=Object.isExtensible,un=function(){try{return Object.defineProperty({},"@",{}),!0}catch(t){return!1}}(),cn="function"==typeof WeakMap;cn&&(nn=new WeakMap);var ln=0,fn="__immutablehash__";"function"==typeof Symbol&&(fn=Symbol(fn));var pn=16,dn=255,gn=0,Mn={},hn=function(t){function e(t,e){this._iter=t,this._useKeys=e,this.size=t.size}return t&&(e.__proto__=t),e.prototype=Object.create(t&&t.prototype),e.prototype.constructor=e,e.prototype.get=function(t,e){return this._iter.get(t,e)},e.prototype.has=function(t){return this._iter.has(t)},e.prototype.valueSeq=function(){return this._iter.valueSeq()},e.prototype.reverse=function(){var t=this,e=F(this,!0);return this._useKeys||(e.valueSeq=function(){return t._iter.toSeq().reverse()}),e},e.prototype.map=function(t,e){var n=this,r=W(this,t,e);return this._useKeys||(r.valueSeq=function(){return n._iter.toSeq().map(t,e)}),r},e.prototype.__iterate=function(t,e){var n=this;return this._iter.__iterate(function(e,r){return t(e,r,n)},e)},e.prototype.__iterator=function(t,e){return this._iter.__iterator(t,e)},e}(Je);hn.prototype[ke]=!0;var yn=function(t){function e(t){this._iter=t,this.size=t.size}return t&&(e.__proto__=t),e.prototype=Object.create(t&&t.prototype),e.prototype.constructor=e,e.prototype.includes=function(t){return this._iter.includes(t)},e.prototype.__iterate=function(t,e){var n=this,r=0;return e&&i(this),this._iter.__iterate(function(o){return t(o,e?n.size-++r:r++,n)},e)},e.prototype.__iterator=function(t,e){var n=this,r=this._iter.__iterator(Re,e),o=0;return e&&i(this),new He(function(){var i=r.next();return i.done?i:w(t,e?n.size-++o:o++,i.value,i)})},e}(qe),mn=function(t){function e(t){this._iter=t,this.size=t.size}return t&&(e.__proto__=t),e.prototype=Object.create(t&&t.prototype),e.prototype.constructor=e,e.prototype.has=function(t){return this._iter.includes(t)},e.prototype.__iterate=function(t,e){var n=this;return this._iter.__iterate(function(e){return t(e,e,n)},e)},e.prototype.__iterator=function(t,e){var n=this._iter.__iterator(Re,e);return new He(function(){var e=n.next();return e.done?e:w(t,e.value,e.value,e)})},e}(Ve),In=function(t){function e(t){this._iter=t,this.size=t.size}return t&&(e.__proto__=t),e.prototype=Object.create(t&&t.prototype),e.prototype.constructor=e,e.prototype.entrySeq=function(){return this._iter.toSeq()},e.prototype.__iterate=function(t,e){var n=this;return this._iter.__iterate(function(e){if(e){ut(e);var r=d(e);return t(r?e.get(1):e[1],r?e.get(0):e[0],n)}},e)},e.prototype.__iterator=function(t,e){var n=this._iter.__iterator(Re,e);return new He(function(){for(;;){var e=n.next();if(e.done)return e;var r=e.value;if(r){ut(r);var o=d(r);return w(t,o?r.get(0):r[0],o?r.get(1):r[1],e)}}})},e}(Je);yn.prototype.cacheResult=hn.prototype.cacheResult=mn.prototype.cacheResult=In.prototype.cacheResult=ft;var wn=function(t){function e(e){return null===e||void 0===e?Dt():yt(e)&&!y(e)?e:Dt().withMutations(function(n){var r=t(e);Mt(r.size),r.forEach(function(t,e){return n.set(e,t)})})}return t&&(e.__proto__=t),e.prototype=Object.create(t&&t.prototype),e.prototype.constructor=e,e.of=function(){for(var t=[],e=arguments.length;e--;)t[e]=arguments[e];return Dt().withMutations(function(e){for(var n=0;n<t.length;n+=2){if(n+1>=t.length)throw new Error("Missing value for key: "+t[n]);e.set(t[n],t[n+1])}})},e.prototype.toString=function(){return this.__toString("Map {","}")},e.prototype.get=function(t,e){return this._root?this._root.get(0,void 0,t,e):e},e.prototype.set=function(t,e){return Nt(this,t,e)},e.prototype.setIn=function(t,e){return this.updateIn(t,Ee,function(){return e})},e.prototype.remove=function(t){return Nt(this,t,Ee)},e.prototype.deleteIn=function(t){if(t=[].concat(dt(t)),t.length){var e=t.pop();return this.updateIn(t,function(t){return t&&t.remove(e)})}},e.prototype.deleteAll=function(t){var e=Ue(t);return 0===e.size?this:this.withMutations(function(t){e.forEach(function(e){return t.remove(e)})})},e.prototype.update=function(t,e,n){return 1===arguments.length?t(this):this.updateIn([t],e,n)},e.prototype.updateIn=function(t,e,n){n||(n=e,e=void 0);var r=Ot(this,dt(t),0,e,n);return r===Ee?e:r},e.prototype.clear=function(){return 0===this.size?this:this.__ownerID?(this.size=0,this._root=null,this.__hash=void 0,this.__altered=!0,this):Dt()},e.prototype.merge=function(){return Et(this,void 0,arguments)},e.prototype.mergeWith=function(t){for(var e=[],n=arguments.length-1;n-- >0;)e[n]=arguments[n+1];return Et(this,t,e)},e.prototype.mergeIn=function(t){for(var e=[],n=arguments.length-1;n-- >0;)e[n]=arguments[n+1];return this.updateIn(t,Dt(),function(t){return"function"==typeof t.merge?t.merge.apply(t,e):e[e.length-1]})},e.prototype.mergeDeep=function(){return Et(this,St,arguments)},e.prototype.mergeDeepWith=function(t){for(var e=[],n=arguments.length-1;n-- >0;)e[n]=arguments[n+1];return Et(this,bt(t),e)},e.prototype.mergeDeepIn=function(t){for(var e=[],n=arguments.length-1;n-- >0;)e[n]=arguments[n+1];return this.updateIn(t,Dt(),function(t){return"function"==typeof t.mergeDeep?t.mergeDeep.apply(t,e):e[e.length-1]})},e.prototype.sort=function(t){return Yn(rt(this,t))},e.prototype.sortBy=function(t,e){return Yn(rt(this,e,t))},e.prototype.withMutations=function(t){var e=this.asMutable();return t(e),e.wasAltered()?e.__ensureOwner(this.__ownerID):this},e.prototype.asMutable=function(){return this.__ownerID?this:this.__ensureOwner(new r)},e.prototype.asImmutable=function(){return this.__ensureOwner()},e.prototype.wasAltered=function(){return this.__altered},e.prototype.__iterator=function(t,e){return new En(this,t,e)},e.prototype.__iterate=function(t,e){var n=this,r=0;return this._root&&this._root.iterate(function(e){return r++,t(e[1],e[0],n)},e),r},e.prototype.__ensureOwner=function(t){return t===this.__ownerID?this:t?wt(this.size,this._root,t,this.__hash):0===this.size?Dt():(this.__ownerID=t,this.__altered=!1,this)},e}(Qe);wn.isMap=yt;var Dn="@@__IMMUTABLE_MAP__@@",Nn=wn.prototype;Nn[Dn]=!0,Nn.delete=Nn.remove,Nn.removeIn=Nn.deleteIn,Nn.removeAll=Nn.deleteAll;var vn=function(t,e){this.ownerID=t,this.entries=e};vn.prototype.get=function(t,e,n,r){for(var o=this.entries,i=0,a=o.length;i<a;i++)if(O(n,o[i][0]))return o[i][1];return r},vn.prototype.update=function(t,e,r,i,a,s,u){for(var c=a===Ee,l=this.entries,f=0,p=l.length;f<p&&!O(i,l[f][0]);f++);var d=f<p;if(d?l[f][1]===a:c)return this;if(n(u),(c||!d)&&n(s),!c||1!==l.length){if(!d&&!c&&l.length>=Sn)return zt(t,l,i,a);var g=t&&t===this.ownerID,M=g?l:o(l);return d?c?f===p-1?M.pop():M[f]=M.pop():M[f]=[i,a]:M.push([i,a]),g?(this.entries=M,this):new vn(t,M)}};var Cn=function(t,e,n){this.ownerID=t,this.bitmap=e,this.nodes=n};Cn.prototype.get=function(t,e,n,r){void 0===e&&(e=Y(n));var o=1<<((0===t?e:e>>>t)&Ae),i=this.bitmap;return 0==(i&o)?r:this.nodes[_t(i&o-1)].get(t+ze,e,n,r)},Cn.prototype.update=function(t,e,n,r,o,i,a){void 0===n&&(n=Y(r));var s=(0===e?n:n>>>e)&Ae,u=1<<s,c=this.bitmap,l=0!=(c&u);if(!l&&o===Ee)return this;var f=_t(c&u-1),p=this.nodes,d=l?p[f]:void 0,g=vt(d,t,e+ze,n,r,o,i,a);if(g===d)return this;if(!l&&g&&p.length>=bn)return At(t,p,c,s,g);if(l&&!g&&2===p.length&&Ct(p[1^f]))return p[1^f];if(l&&g&&1===p.length&&Ct(g))return g;var M=t&&t===this.ownerID,h=l?g?c:c^u:c|u,y=l?g?kt(p,f,g,M):Ut(p,f,M):Lt(p,f,g,M);return M?(this.bitmap=h,this.nodes=y,this):new Cn(t,h,y)};var jn=function(t,e,n){this.ownerID=t,this.count=e,this.nodes=n};jn.prototype.get=function(t,e,n,r){void 0===e&&(e=Y(n));var o=(0===t?e:e>>>t)&Ae,i=this.nodes[o];return i?i.get(t+ze,e,n,r):r},jn.prototype.update=function(t,e,n,r,o,i,a){void 0===n&&(n=Y(r));var s=(0===e?n:n>>>e)&Ae,u=o===Ee,c=this.nodes,l=c[s];if(u&&!l)return this;var f=vt(l,t,e+ze,n,r,o,i,a);if(f===l)return this;var p=this.count;if(l){if(!f&&--p<xn)return Tt(t,c,p,s)}else p++;var d=t&&t===this.ownerID,g=kt(c,s,f,d);return d?(this.count=p,this.nodes=g,this):new jn(t,p,g)};var zn=function(t,e,n){this.ownerID=t,this.keyHash=e,this.entries=n};zn.prototype.get=function(t,e,n,r){for(var o=this.entries,i=0,a=o.length;i<a;i++)if(O(n,o[i][0]))return o[i][1];return r},zn.prototype.update=function(t,e,r,i,a,s,u){void 0===r&&(r=Y(i));var c=a===Ee;if(r!==this.keyHash)return c?this:(n(u),n(s),jt(this,t,e,r,[i,a]));for(var l=this.entries,f=0,p=l.length;f<p&&!O(i,l[f][0]);f++);var d=f<p;if(d?l[f][1]===a:c)return this;if(n(u),(c||!d)&&n(s),c&&2===p)return new Tn(t,this.keyHash,l[1^f]);var g=t&&t===this.ownerID,M=g?l:o(l);return d?c?f===p-1?M.pop():M[f]=M.pop():M[f]=[i,a]:M.push([i,a]),g?(this.entries=M,this):new zn(t,this.keyHash,M)};var Tn=function(t,e,n){this.ownerID=t,this.keyHash=e,this.entry=n};Tn.prototype.get=function(t,e,n,r){return O(n,this.entry[0])?this.entry[1]:r},Tn.prototype.update=function(t,e,r,o,i,a,s){var u=i===Ee,c=O(o,this.entry[0]);return(c?i===this.entry[1]:u)?this:(n(s),u?void n(a):c?t&&t===this.ownerID?(this.entry[1]=i,this):new Tn(t,this.keyHash,[o,i]):(n(a),jt(this,t,e,Y(o),[o,i])))},vn.prototype.iterate=zn.prototype.iterate=function(t,e){for(var n=this.entries,r=0,o=n.length-1;r<=o;r++)if(!1===t(n[e?o-r:r]))return!1},Cn.prototype.iterate=jn.prototype.iterate=function(t,e){for(var n=this.nodes,r=0,o=n.length-1;r<=o;r++){var i=n[e?o-r:r];if(i&&!1===i.iterate(t,e))return!1}},Tn.prototype.iterate=function(t,e){return t(this.entry)};var An,En=function(t){function e(t,e,n){this._type=e,this._reverse=n,this._stack=t._root&&It(t._root)}return t&&(e.__proto__=t),e.prototype=Object.create(t&&t.prototype),e.prototype.constructor=e,e.prototype.next=function(){for(var t=this,e=this._type,n=this._stack;n;){var r=n.node,o=n.index++,i=void 0;if(r.entry){if(0===o)return mt(e,r.entry)}else if(r.entries){if(i=r.entries.length-1,o<=i)return mt(e,r.entries[t._reverse?i-o:o])}else if(i=r.nodes.length-1,o<=i){var a=r.nodes[t._reverse?i-o:o];if(a){if(a.entry)return mt(e,a.entry);n=t._stack=It(a,n)}continue}n=t._stack=t._stack.__prev}return D()},e}(He),Sn=Te/4,bn=Te/2,xn=Te/4,On=function(t){function e(e){var n=Pt();if(null===e||void 0===e)return n;if(Qt(e))return e;var r=t(e),o=r.size;return 0===o?n:(Mt(o),o>0&&o<Te?Bt(0,o,ze,null,new Ln(r.toArray())):n.withMutations(function(t){t.setSize(o),r.forEach(function(e,n){return t.set(n,e)})}))}return t&&(e.__proto__=t),e.prototype=Object.create(t&&t.prototype),e.prototype.constructor=e,e.of=function(){return this(arguments)},e.prototype.toString=function(){return this.__toString("List [","]")},e.prototype.get=function(t,e){if((t=a(this,t))>=0&&t<this.size){t+=this._origin;var n=Wt(this,t);return n&&n.array[t&Ae]}return e},e.prototype.set=function(t,e){return Rt(this,t,e)},e.prototype.remove=function(t){return this.has(t)?0===t?this.shift():t===this.size-1?this.pop():this.splice(t,1):this},e.prototype.insert=function(t,e){return this.splice(t,0,e)},e.prototype.clear=function(){return 0===this.size?this:this.__ownerID?(this.size=this._origin=this._capacity=0,this._level=ze,this._root=this._tail=null,this.__hash=void 0,this.__altered=!0,this):Pt()},e.prototype.push=function(){var t=arguments,e=this.size;return this.withMutations(function(n){Ft(n,0,e+t.length);for(var r=0;r<t.length;r++)n.set(e+r,t[r])})},e.prototype.pop=function(){return Ft(this,0,-1)},e.prototype.unshift=function(){var t=arguments;return this.withMutations(function(e){Ft(e,-t.length);for(var n=0;n<t.length;n++)e.set(n,t[n])})},e.prototype.shift=function(){return Ft(this,1)},e.prototype.merge=function(){return Ht(this,void 0,arguments)},e.prototype.mergeWith=function(t){for(var e=[],n=arguments.length-1;n-- >0;)e[n]=arguments[n+1];return Ht(this,t,e)},e.prototype.mergeDeep=function(){return Ht(this,St,arguments)},e.prototype.mergeDeepWith=function(t){for(var e=[],n=arguments.length-1;n-- >0;)e[n]=arguments[n+1];return Ht(this,bt(t),e)},e.prototype.setSize=function(t){return Ft(this,0,t)},e.prototype.slice=function(t,e){var n=this.size;return u(t,e,n)?this:Ft(this,c(t,n),l(e,n))},e.prototype.__iterator=function(t,e){var n=e?this.size:0,r=Yt(this,e);return new He(function(){var o=r();return o===Qn?D():w(t,e?--n:n++,o)})},e.prototype.__iterate=function(t,e){for(var n,r=this,o=e?this.size:0,i=Yt(this,e);(n=i())!==Qn&&!1!==t(n,e?--o:o++,r););return o},e.prototype.__ensureOwner=function(t){return t===this.__ownerID?this:t?Bt(this._origin,this._capacity,this._level,this._root,this._tail,t,this.__hash):0===this.size?Pt():(this.__ownerID=t,this)},e}(Ye);On.isList=Qt;var _n="@@__IMMUTABLE_LIST__@@",kn=On.prototype;kn[_n]=!0,kn.delete=kn.remove,kn.setIn=Nn.setIn,kn.deleteIn=kn.removeIn=Nn.removeIn,kn.update=Nn.update,kn.updateIn=Nn.updateIn,kn.mergeIn=Nn.mergeIn,kn.mergeDeepIn=Nn.mergeDeepIn,kn.withMutations=Nn.withMutations,kn.asMutable=Nn.asMutable,kn.asImmutable=Nn.asImmutable,kn.wasAltered=Nn.wasAltered;var Ln=function(t,e){this.array=t,this.ownerID=e};Ln.prototype.removeBefore=function(t,e,n){if(n===e?1<<e:0===this.array.length)return this;var r=n>>>e&Ae;if(r>=this.array.length)return new Ln([],t);var o,i=0===r;if(e>0){var a=this.array[r];if((o=a&&a.removeBefore(t,e-ze,n))===a&&i)return this}if(i&&!o)return this;var s=Gt(this,t);if(!i)for(var u=0;u<r;u++)s.array[u]=void 0;return o&&(s.array[r]=o),s},Ln.prototype.removeAfter=function(t,e,n){if(n===(e?1<<e:0)||0===this.array.length)return this;var r=n-1>>>e&Ae;if(r>=this.array.length)return this;var o;if(e>0){var i=this.array[r];if((o=i&&i.removeAfter(t,e-ze,n))===i&&r===this.array.length-1)return this}var a=Gt(this,t);return a.array.splice(r+1),o&&(a.array[r]=o),a};var Un,Qn={},Yn=function(t){function e(t){return null===t||void 0===t?Vt():Jt(t)?t:Vt().withMutations(function(e){var n=Qe(t);Mt(n.size),n.forEach(function(t,n){return e.set(n,t)})})}return t&&(e.__proto__=t),e.prototype=Object.create(t&&t.prototype),e.prototype.constructor=e,e.of=function(){return this(arguments)},e.prototype.toString=function(){return this.__toString("OrderedMap {","}")},e.prototype.get=function(t,e){var n=this._map.get(t);return void 0!==n?this._list.get(n)[1]:e},e.prototype.clear=function(){return 0===this.size?this:this.__ownerID?(this.size=0,this._map.clear(),this._list.clear(),this):Vt()},e.prototype.set=function(t,e){return Xt(this,t,e)},e.prototype.remove=function(t){return Xt(this,t,Ee)},e.prototype.wasAltered=function(){return this._map.wasAltered()||this._list.wasAltered()},e.prototype.__iterate=function(t,e){var n=this;return this._list.__iterate(function(e){return e&&t(e[1],e[0],n)},e)},e.prototype.__iterator=function(t,e){return this._list.fromEntrySeq().__iterator(t,e)},e.prototype.__ensureOwner=function(t){if(t===this.__ownerID)return this;var e=this._map.__ensureOwner(t),n=this._list.__ensureOwner(t);return t?qt(e,n,t,this.__hash):0===this.size?Vt():(this.__ownerID=t,this._map=e,this._list=n,this)},e}(wn);Yn.isOrderedMap=Jt,Yn.prototype[ke]=!0,Yn.prototype.delete=Yn.prototype.remove;var Bn,Pn=function(t){function e(t){return null===t||void 0===t?ee():$t(t)?t:ee().pushAll(t)}return t&&(e.__proto__=t),e.prototype=Object.create(t&&t.prototype),e.prototype.constructor=e,e.of=function(){return this(arguments)},e.prototype.toString=function(){return this.__toString("Stack [","]")},e.prototype.get=function(t,e){var n=this._head;for(t=a(this,t);n&&t--;)n=n.next;return n?n.value:e},e.prototype.peek=function(){return this._head&&this._head.value},e.prototype.push=function(){var t=arguments;if(0===arguments.length)return this;for(var e=this.size+arguments.length,n=this._head,r=arguments.length-1;r>=0;r--)n={value:t[r],next:n};return this.__ownerID?(this.size=e,this._head=n,this.__hash=void 0,this.__altered=!0,this):te(e,n)},e.prototype.pushAll=function(e){if(e=t(e),0===e.size)return this;if(0===this.size&&$t(e))return e;Mt(e.size);var n=this.size,r=this._head;return e.__iterate(function(t){n++,r={value:t,next:r}},!0),this.__ownerID?(this.size=n,this._head=r,this.__hash=void 0,this.__altered=!0,this):te(n,r)},e.prototype.pop=function(){return this.slice(1)},e.prototype.clear=function(){return 0===this.size?this:this.__ownerID?(this.size=0,this._head=void 0,this.__hash=void 0,this.__altered=!0,this):ee()},e.prototype.slice=function(e,n){if(u(e,n,this.size))return this;var r=c(e,this.size);if(l(n,this.size)!==this.size)return t.prototype.slice.call(this,e,n);for(var o=this.size-r,i=this._head;r--;)i=i.next;return this.__ownerID?(this.size=o,this._head=i,this.__hash=void 0,this.__altered=!0,this):te(o,i)},e.prototype.__ensureOwner=function(t){return t===this.__ownerID?this:t?te(this.size,this._head,t,this.__hash):0===this.size?ee():(this.__ownerID=t,this.__altered=!1,this)},e.prototype.__iterate=function(t,e){var n=this;if(e)return new $e(this.toArray()).__iterate(function(e,r){return t(e,r,n)},e);for(var r=0,o=this._head;o&&!1!==t(o.value,r++,n);)o=o.next;return r},e.prototype.__iterator=function(t,e){if(e)return new $e(this.toArray()).__iterator(t,e);var n=0,r=this._head;return new He(function(){if(r){var e=r.value;return r=r.next,w(t,n++,e)}return D()})},e}(Ye);Pn.isStack=$t;var Rn="@@__IMMUTABLE_STACK__@@",Zn=Pn.prototype;Zn[Rn]=!0,Zn.withMutations=Nn.withMutations,Zn.asMutable=Nn.asMutable,Zn.asImmutable=Nn.asImmutable,Zn.wasAltered=Nn.wasAltered,Zn.shift=Zn.pop,Zn.unshift=Zn.push,Zn.unshiftAll=Zn.pushAll;var Gn,Wn=function(t){function e(e){return null===e||void 0===e?se():oe(e)&&!y(e)?e:se().withMutations(function(n){var r=t(e);Mt(r.size),r.forEach(function(t){return n.add(t)})})}return t&&(e.__proto__=t),e.prototype=Object.create(t&&t.prototype),e.prototype.constructor=e,e.of=function(){return this(arguments)},e.fromKeys=function(t){return this(Qe(t).keySeq())},e.intersect=function(t){return t=Ue(t).toArray(),t.length?Hn.intersect.apply(e(t.pop()),t):se()},e.union=function(t){return t=Ue(t).toArray(),t.length?Hn.union.apply(e(t.pop()),t):se()},e.prototype.toString=function(){return this.__toString("Set {","}")},e.prototype.has=function(t){return this._map.has(t)},e.prototype.add=function(t){return ie(this,this._map.set(t,!0))},e.prototype.remove=function(t){return ie(this,this._map.remove(t))},e.prototype.clear=function(){return ie(this,this._map.clear())},e.prototype.union=function(){for(var e=[],n=arguments.length;n--;)e[n]=arguments[n];return e=e.filter(function(t){return 0!==t.size}),0===e.length?this:0!==this.size||this.__ownerID||1!==e.length?this.withMutations(function(n){for(var r=0;r<e.length;r++)t(e[r]).forEach(function(t){return n.add(t)})}):this.constructor(e[0])},e.prototype.intersect=function(){for(var e=[],n=arguments.length;n--;)e[n]=arguments[n];if(0===e.length)return this;e=e.map(function(e){return t(e)});var r=[];return this.forEach(function(t){e.every(function(e){return e.includes(t)})||r.push(t)}),this.withMutations(function(t){r.forEach(function(e){t.remove(e)})})},e.prototype.subtract=function(){for(var t=[],e=arguments.length;e--;)t[e]=arguments[e];if(0===t.length)return this;var n=[];return this.forEach(function(e){t.some(function(t){return t.includes(e)})&&n.push(e)}),this.withMutations(function(t){n.forEach(function(e){t.remove(e)})})},e.prototype.merge=function(){return this.union.apply(this,arguments)},e.prototype.mergeWith=function(t){for(var e=[],n=arguments.length-1;n-- >0;)e[n]=arguments[n+1];return this.union.apply(this,e)},e.prototype.sort=function(t){return tr(rt(this,t))},e.prototype.sortBy=function(t,e){return tr(rt(this,e,t))},e.prototype.wasAltered=function(){return this._map.wasAltered()},e.prototype.__iterate=function(t,e){var n=this;return this._map.__iterate(function(e,r){return t(r,r,n)},e)},e.prototype.__iterator=function(t,e){return this._map.map(function(t,e){return e}).__iterator(t,e)},e.prototype.__ensureOwner=function(t){if(t===this.__ownerID)return this;var e=this._map.__ensureOwner(t);return t?this.__make(e,t):0===this.size?se():(this.__ownerID=t,this._map=e,this)},e}(Be);Wn.isSet=oe;var Fn="@@__IMMUTABLE_SET__@@",Hn=Wn.prototype;Hn[Fn]=!0,Hn.delete=Hn.remove,Hn.mergeDeep=Hn.merge,Hn.mergeDeepWith=Hn.mergeWith,Hn.withMutations=Nn.withMutations,Hn.asMutable=Nn.asMutable,Hn.asImmutable=Nn.asImmutable,Hn.__empty=se,Hn.__make=ae;var Kn,Jn,qn=function(t){function e(t,n,r){if(!(this instanceof e))return new e(t,n,r);if(gt(0!==r,"Cannot step a Range by 0"),t=t||0,void 0===n&&(n=1/0),r=void 0===r?1:Math.abs(r),n<t&&(r=-r),this._start=t,this._end=n,this._step=r,this.size=Math.max(0,Math.ceil((n-t)/r-1)+1),0===this.size){if(Jn)return Jn;Jn=this}}return t&&(e.__proto__=t),e.prototype=Object.create(t&&t.prototype),e.prototype.constructor=e,e.prototype.toString=function(){return 0===this.size?"Range []":"Range [ "+this._start+"..."+this._end+(1!==this._step?" by "+this._step:"")+" ]"},e.prototype.get=function(t,e){return this.has(t)?this._start+a(this,t)*this._step:e},e.prototype.includes=function(t){var e=(t-this._start)/this._step;return e>=0&&e<this.size&&e===Math.floor(e)},e.prototype.slice=function(t,n){return u(t,n,this.size)?this:(t=c(t,this.size),n=l(n,this.size),n<=t?new e(0,0):new e(this.get(t,this._end),this.get(n,this._end),this._step))},e.prototype.indexOf=function(t){var e=t-this._start;if(e%this._step==0){var n=e/this._step;if(n>=0&&n<this.size)return n}return-1},e.prototype.lastIndexOf=function(t){return this.indexOf(t)},e.prototype.__iterate=function(t,e){for(var n=this,r=this.size,o=this._step,i=e?this._start+(r-1)*o:this._start,a=0;a!==r&&!1!==t(i,e?r-++a:a++,n);)i+=e?-o:o;return a},e.prototype.__iterator=function(t,e){var n=this.size,r=this._step,o=e?this._start+(n-1)*r:this._start,i=0;return new He(function(){if(i===n)return D();var a=o;return o+=e?-r:r,w(t,e?n-++i:i++,a)})},e.prototype.equals=function(t){return t instanceof e?this._start===t._start&&this._end===t._end&&this._step===t._step:ne(this,t)},e}(qe);Ue.isIterable=d,Ue.isKeyed=g,Ue.isIndexed=M,Ue.isAssociative=h,Ue.isOrdered=y,Ue.Iterator=He,re(Ue,{toArray:function(){Mt(this.size);var t=new Array(this.size||0);return this.valueSeq().__iterate(function(e,n){t[n]=e}),t},toIndexedSeq:function(){return new yn(this)},toJS:function(){return this.toSeq().map(fe).toJSON()},toKeyedSeq:function(){return new hn(this,!0)},toMap:function(){return wn(this.toKeyedSeq())},toObject:function(){Mt(this.size);var t={};return this.__iterate(function(e,n){t[n]=e}),t},toOrderedMap:function(){return Yn(this.toKeyedSeq())},toOrderedSet:function(){return tr(g(this)?this.valueSeq():this)},toSet:function(){return Wn(g(this)?this.valueSeq():this)},toSetSeq:function(){return new mn(this)},toSeq:function(){return M(this)?this.toIndexedSeq():g(this)?this.toKeyedSeq():this.toSetSeq()},toStack:function(){return Pn(g(this)?this.valueSeq():this)},toList:function(){return On(g(this)?this.valueSeq():this)},toString:function(){return"[Collection]"},__toString:function(t,e){return 0===this.size?t+e:t+" "+this.toSeq().map(this.__toStringMapper).join(", ")+" "+e},concat:function(){for(var t=[],e=arguments.length;e--;)t[e]=arguments[e];return st(this,$(this,t))},includes:function(t){return this.some(function(e){return O(e,t)})},entries:function(){return this.__iterator(Ze)},every:function(t,e){Mt(this.size);var n=!0;return this.__iterate(function(r,o,i){if(!t.call(e,r,o,i))return n=!1,!1}),n},filter:function(t,e){return st(this,H(this,t,e,!0))},find:function(t,e,n){var r=this.findEntry(t,e);return r?r[1]:n},forEach:function(t,e){return Mt(this.size),this.__iterate(e?t.bind(e):t)},join:function(t){Mt(this.size),t=void 0!==t?""+t:",";var e="",n=!0;return this.__iterate(function(r){n?n=!1:e+=t,e+=null!==r&&void 0!==r?r.toString():""}),e},keys:function(){return this.__iterator(Pe)},map:function(t,e){return st(this,W(this,t,e))},reduce:function(t,e,n){return ue(this,t,e,n,arguments.length<2,!1)},reduceRight:function(t,e,n){return ue(this,t,e,n,arguments.length<2,!0)},reverse:function(){return st(this,F(this,!0))},slice:function(t,e){return st(this,q(this,t,e,!0))},some:function(t,e){return!this.every(pe(t),e)},sort:function(t){return st(this,rt(this,t))},values:function(){return this.__iterator(Re)},butLast:function(){return this.slice(0,-1)},isEmpty:function(){return void 0!==this.size?0===this.size:!this.some(function(){return!0})},count:function(t,e){return i(t?this.toSeq().filter(t,e):this)},countBy:function(t,e){return K(this,t,e)},equals:function(t){return ne(this,t)},entrySeq:function(){var t=this;if(t._cache)return new $e(t._cache);var e=t.toSeq().map(le).toIndexedSeq();return e.fromEntrySeq=function(){return t.toSeq()},e.toJS=function(){return this.map(function(t){return[fe(t[0]),fe(t[1])]}).toJSON()},e},filterNot:function(t,e){return this.filter(pe(t),e)},findEntry:function(t,e,n){var r=n;return this.__iterate(function(n,o,i){if(t.call(e,n,o,i))return r=[o,n],!1}),r},findKey:function(t,e){var n=this.findEntry(t,e);return n&&n[0]},findLast:function(t,e,n){return this.toKeyedSeq().reverse().find(t,e,n)},findLastEntry:function(t,e,n){return this.toKeyedSeq().reverse().findEntry(t,e,n)},findLastKey:function(t,e){return this.toKeyedSeq().reverse().findKey(t,e)},first:function(){return this.find(s)},flatMap:function(t,e){return st(this,et(this,t,e))},flatten:function(t){return st(this,tt(this,t,!0))},fromEntrySeq:function(){return new In(this)},get:function(t,e){return this.find(function(e,n){return O(n,t)},void 0,e)},getIn:function(t,e){for(var n=this,r=dt(t),o=0;o!==r.length;){if(!n||!n.get)throw new TypeError("Invalid keyPath: Value at ["+r.slice(0,o).map(ht)+"] does not have a .get() method: "+n);if((n=n.get(r[o++],Ee))===Ee)return e}return n},groupBy:function(t,e){return J(this,t,e)},has:function(t){return this.get(t,Ee)!==Ee},hasIn:function(t){return this.getIn(t,Ee)!==Ee},isSubset:function(t){return t="function"==typeof t.includes?t:Ue(t),this.every(function(e){return t.includes(e)})},isSuperset:function(t){return t="function"==typeof t.isSubset?t:Ue(t),t.isSubset(this)},keyOf:function(t){return this.findKey(function(e){return O(e,t)})},keySeq:function(){return this.toSeq().map(ce).toIndexedSeq()},last:function(){return this.toSeq().reverse().first()},lastKeyOf:function(t){return this.toKeyedSeq().reverse().keyOf(t)},max:function(t){return ot(this,t)},maxBy:function(t,e){return ot(this,e,t)},min:function(t){return ot(this,t?de(t):Me)},minBy:function(t,e){return ot(this,e?de(e):Me,t)},rest:function(){return this.slice(1)},skip:function(t){return 0===t?this:this.slice(Math.max(0,t))},skipLast:function(t){return 0===t?this:this.slice(0,-Math.max(0,t))},skipWhile:function(t,e){return st(this,X(this,t,e,!0))},skipUntil:function(t,e){return this.skipWhile(pe(t),e)},sortBy:function(t,e){return st(this,rt(this,e,t))},take:function(t){return this.slice(0,Math.max(0,t))},takeLast:function(t){return this.slice(-Math.max(0,t))},takeWhile:function(t,e){return st(this,V(this,t,e))},takeUntil:function(t,e){return this.takeWhile(pe(t),e)},update:function(t){return t(this)},valueSeq:function(){return this.toIndexedSeq()},hashCode:function(){return this.__hash||(this.__hash=he(this))}});var Vn=Ue.prototype;Vn[xe]=!0,Vn[Fe]=Vn.values,Vn.toJSON=Vn.toArray,Vn.__toStringMapper=ht,Vn.inspect=Vn.toSource=function(){return this.toString()},Vn.chain=Vn.flatMap,Vn.contains=Vn.includes,re(Qe,{flip:function(){return st(this,G(this))},mapEntries:function(t,e){var n=this,r=0;return st(this,this.toSeq().map(function(o,i){return t.call(e,[i,o],r++,n)}).fromEntrySeq())},mapKeys:function(t,e){var n=this;return st(this,this.toSeq().flip().map(function(r,o){return t.call(e,r,o,n)}).flip())}});var Xn=Qe.prototype;Xn[Oe]=!0,Xn[Fe]=Vn.entries,Xn.toJSON=Vn.toObject,Xn.__toStringMapper=function(t,e){return ht(e)+": "+ht(t)},re(Ye,{toKeyedSeq:function(){return new hn(this,!1)},filter:function(t,e){return st(this,H(this,t,e,!1))},findIndex:function(t,e){var n=this.findEntry(t,e);return n?n[0]:-1},indexOf:function(t){var e=this.keyOf(t);return void 0===e?-1:e},lastIndexOf:function(t){var e=this.lastKeyOf(t);return void 0===e?-1:e},reverse:function(){return st(this,F(this,!1))},slice:function(t,e){return st(this,q(this,t,e,!1))},splice:function(t,e){var n=arguments.length;if(e=Math.max(e||0,0),0===n||2===n&&!e)return this;t=c(t,t<0?this.count():this.size);var r=this.slice(0,t);return st(this,1===n?r:r.concat(o(arguments,2),this.slice(t+e)))},findLastIndex:function(t,e){var n=this.findLastEntry(t,e);return n?n[0]:-1},first:function(){return this.get(0)},flatten:function(t){return st(this,tt(this,t,!1))},get:function(t,e){return t=a(this,t),t<0||this.size===1/0||void 0!==this.size&&t>this.size?e:this.find(function(e,n){return n===t},void 0,e)},has:function(t){return(t=a(this,t))>=0&&(void 0!==this.size?this.size===1/0||t<this.size:-1!==this.indexOf(t))},interpose:function(t){return st(this,nt(this,t))},interleave:function(){var t=[this].concat(o(arguments)),e=at(this.toSeq(),qe.of,t),n=e.flatten(!0);return e.size&&(n.size=e.size*t.length),st(this,n)},keySeq:function(){return qn(0,this.size)},last:function(){return this.get(-1)},skipWhile:function(t,e){return st(this,X(this,t,e,!1))},zip:function(){return st(this,at(this,ge,[this].concat(o(arguments))))},zipWith:function(t){var e=o(arguments);return e[0]=this,st(this,at(this,t,e))}});var $n=Ye.prototype;$n[_e]=!0,$n[ke]=!0,re(Be,{get:function(t,e){return this.has(t)?t:e},includes:function(t){return this.has(t)},keySeq:function(){return this.valueSeq()}}),Be.prototype.has=Vn.includes,Be.prototype.contains=Be.prototype.includes,re(Je,Qe.prototype),re(qe,Ye.prototype),re(Ve,Be.prototype);var tr=function(t){function e(t){return null===t||void 0===t?De():Ie(t)?t:De().withMutations(function(e){var n=Be(t);Mt(n.size),n.forEach(function(t){return e.add(t)})})}return t&&(e.__proto__=t),e.prototype=Object.create(t&&t.prototype),e.prototype.constructor=e,e.of=function(){return this(arguments)},e.fromKeys=function(t){return this(Qe(t).keySeq())},e.prototype.toString=function(){return this.__toString("OrderedSet {","}")},e}(Wn);tr.isOrderedSet=Ie;var er=tr.prototype;er[ke]=!0,er.zip=$n.zip,er.zipWith=$n.zipWith,er.__empty=De,er.__make=we;var nr,rr=function(t,e){var n,r=function(i){var a=this;if(i instanceof r)return i;if(!(this instanceof r))return new r(i);if(!n){n=!0;var s=Object.keys(t),u=o._indices={};o._name=e,o._keys=s,o._defaultValues=t;for(var c=0;c<s.length;c++){var l=s[c];u[l]=c,o[l]?"object"==typeof console&&console.warn&&console.warn("Cannot define "+ve(a)+' with property "'+l+'" since that property name is part of the Record API.'):je(o,l)}}this.__ownerID=void 0,this._values=On().withMutations(function(t){t.setSize(a._keys.length),Qe(i).forEach(function(e,n){t.set(a._indices[n],e===a._defaultValues[n]?void 0:e)})})},o=r.prototype=Object.create(or);return o.constructor=r,r};rr.prototype.toString=function(){for(var t,e=this,n=ve(this)+" { ",r=this._keys,o=0,i=r.length;o!==i;o++)t=r[o],n+=(o?", ":"")+t+": "+ht(e.get(t));return n+" }"},rr.prototype.equals=function(t){return this===t||this._keys===t._keys&&Ce(this).equals(Ce(t))},rr.prototype.hashCode=function(){return Ce(this).hashCode()},rr.prototype.has=function(t){return this._indices.hasOwnProperty(t)},rr.prototype.get=function(t,e){if(!this.has(t))return e;var n=this._indices[t],r=this._values.get(n);return void 0===r?this._defaultValues[t]:r},rr.prototype.set=function(t,e){if(this.has(t)){var n=this._values.set(this._indices[t],e===this._defaultValues[t]?void 0:e);if(n!==this._values&&!this.__ownerID)return Ne(this,n)}return this},rr.prototype.remove=function(t){return this.set(t)},rr.prototype.clear=function(){var t=this._values.clear().setSize(this._keys.length);return this.__ownerID?this:Ne(this,t)},rr.prototype.wasAltered=function(){return this._values.wasAltered()},rr.prototype.toSeq=function(){return Ce(this)},rr.prototype.toJS=function(){return Ce(this).toJS()},rr.prototype.__iterator=function(t,e){return Ce(this).__iterator(t,e)},rr.prototype.__iterate=function(t,e){return Ce(this).__iterate(t,e)},rr.prototype.__ensureOwner=function(t){if(t===this.__ownerID)return this;var e=this._values.__ensureOwner(t);return t?Ne(this,e,t):(this.__ownerID=t,this._values=e,this)},rr.isRecord=m,rr.getDescriptiveName=ve;var or=rr.prototype;or[Le]=!0,or.delete=or.remove,or.getIn=Vn.getIn,or.hasIn=Vn.hasIn,or.merge=Nn.merge,or.mergeWith=Nn.mergeWith,or.mergeIn=Nn.mergeIn,or.mergeDeep=Nn.mergeDeep,or.mergeDeepWith=Nn.mergeDeepWith,or.mergeDeepIn=Nn.mergeDeepIn,or.setIn=Nn.setIn,or.update=Nn.update,or.updateIn=Nn.updateIn,or.withMutations=Nn.withMutations,or.asMutable=Nn.asMutable,or.asImmutable=Nn.asImmutable,or[Fe]=Vn.entries,or.toJSON=or.toObject=Vn.toObject,or.inspect=or.toSource=Vn.toSource;var ir,ar=function(t){function e(t,n){if(!(this instanceof e))return new e(t,n);if(this._value=t,this.size=void 0===n?1/0:Math.max(0,n),0===this.size){if(ir)return ir;ir=this}}return t&&(e.__proto__=t),e.prototype=Object.create(t&&t.prototype),e.prototype.constructor=e,e.prototype.toString=function(){return 0===this.size?"Repeat []":"Repeat [ "+this._value+" "+this.size+" times ]"},e.prototype.get=function(t,e){return this.has(t)?this._value:e},e.prototype.includes=function(t){return O(this._value,t)},e.prototype.slice=function(t,n){var r=this.size;return u(t,n,r)?this:new e(this._value,l(n,r)-c(t,r))},e.prototype.reverse=function(){return this},e.prototype.indexOf=function(t){return O(this._value,t)?0:-1},e.prototype.lastIndexOf=function(t){return O(this._value,t)?this.size:-1},e.prototype.__iterate=function(t,e){for(var n=this,r=this.size,o=0;o!==r&&!1!==t(n._value,e?r-++o:o++,n););return o},e.prototype.__iterator=function(t,e){var n=this,r=this.size,o=0;return new He(function(){return o===r?D():w(t,e?r-++o:o++,n._value)})},e.prototype.equals=function(t){return t instanceof e?O(this._value,t._value):ne(t)},e}(qe),sr={Collection:Ue,Iterable:Ue,Seq:Ke,Map:wn,OrderedMap:Yn,List:On,Stack:Pn,Set:Wn,OrderedSet:tr,Record:rr,Range:qn,Repeat:ar,is:O,fromJS:_,hash:Y,isImmutable:p,isCollection:d,isKeyed:g,isIndexed:M,isAssociative:h,isOrdered:y,isValueObject:I},ur=Ue;t.default=sr,t.Collection=Ue,t.Iterable=ur,t.Seq=Ke,t.Map=wn,t.OrderedMap=Yn,t.List=On,t.Stack=Pn,t.Set=Wn,t.OrderedSet=tr,t.Record=rr,t.Range=qn,t.Repeat=ar,t.is=O,t.fromJS=_,t.hash=Y,t.isImmutable=p,t.isCollection=d,t.isKeyed=g,t.isIndexed=M,t.isAssociative=h,t.isOrdered=y,t.isValueObject=I,Object.defineProperty(t,"__esModule",{value:!0})})},function(t,e,n){"use strict";Object.defineProperty(e,"__esModule",{value:!0});var r=[];e.default={onKeyDown:function(t){r.forEach(function(e){e(t)})},registerCallBack:function(t){r.push(t)},deregisterCallBack:function(t){r=r.filter(function(e){return e!==t})}}},function(t,e,n){"use strict";Object.defineProperty(e,"__esModule",{value:!0});var r=void 0;e.default={open:function(){r=!0},close:function(){r=!1},isOpen:function(){return r}}},function(t,e,n){t.exports=n(73)},function(t,e,n){"use strict";function r(t){return t&&t.__esModule?t:{default:t}}var o=n(74),i=r(o),a=n(6),s=n(274),u=r(s);t.exports={Editor:i.default,EditorState:a.EditorState,convertToRaw:a.convertToRaw,ContentState:a.ContentState,draftToHtml:u.default,convertFromHTML:a.convertFromHTML}},function(t,e,n){"use strict";function r(t){return t&&t.__esModule?t:{default:t}}function o(t){if(Array.isArray(t)){for(var e=0,n=Array(t.length);e<t.length;e++)n[e]=t[e];return n}return Array.from(t)}function i(t,e){if(!(t instanceof e))throw new TypeError("Cannot call a class as a function")}function a(t,e){if(!t)throw new ReferenceError("this hasn't been initialised - super() hasn't been called");return!e||"object"!=typeof e&&"function"!=typeof e?t:e}function s(t,e){if("function"!=typeof e&&null!==e)throw new TypeError("Super expression must either be null or a function, not "+typeof e);t.prototype=Object.create(e&&e.prototype,{constructor:{value:t,enumerable:!1,writable:!0,configurable:!0}}),e&&(Object.setPrototypeOf?Object.setPrototypeOf(t,e):t.__proto__=e)}Object.defineProperty(e,"__esModule",{value:!0});var u=Object.assign||function(t){for(var e=1;e<arguments.length;e++){var n=arguments[e];for(var r in n)Object.prototype.hasOwnProperty.call(n,r)&&(t[r]=n[r])}return t},c=function(){function t(t,e){for(var n=0;n<e.length;n++){var r=e[n];r.enumerable=r.enumerable||!1,r.configurable=!0,"value"in r&&(r.writable=!0),Object.defineProperty(t,r.key,r)}}return function(e,n,r){return n&&t(e.prototype,n),r&&t(e,r),e}}(),l=n(0),f=r(l),p=n(1),d=r(p),g=n(6),M=n(9),h=n(5),y=r(h),m=n(166),I=r(m),w=n(167),D=r(w),N=n(70),v=r(N),C=n(71),j=r(C),z=n(168),T=r(z),A=n(20),E=n(14),S=n(169),b=n(171),x=r(b),O=n(218),_=r(O),k=n(221),L=r(k),U=n(227),Q=r(U),Y=n(229),B=r(Y),P=n(233),R=r(P),Z=n(259),G=r(Z);n(272),n(273);var W=function(t){function e(t){i(this,e);var n=a(this,(e.__proto__||Object.getPrototypeOf(e)).call(this,t));F.call(n);var r=(0,A.mergeRecursive)(R.default,t.toolbar);n.state={editorState:void 0,editorFocused:!1,toolbar:r};var o=t.wrapperId?t.wrapperId:Math.floor(1e4*Math.random());return n.wrapperId="rdw-wrapper-"+o,n.modalHandler=new I.default,n.focusHandler=new D.default,n.blockRendererFn=(0,B.default)({isReadOnly:n.isReadOnly,isImageAlignmentEnabled:n.isImageAlignmentEnabled,getEditorState:n.getEditorState,onChange:n.onChange},t.customBlockRenderFunc),n.editorProps=n.filterEditorProps(t),n.customStyleMap=(0,M.getCustomStyleMap)(),n}return s(e,t),c(e,[{key:"componentWillMount",value:function(){this.compositeDecorator=this.getCompositeDecorator();var t=this.createEditorState(this.compositeDecorator);(0,M.extractInlineStyle)(t),this.setState({editorState:t})}},{key:"componentDidMount",value:function(){this.modalHandler.init(this.wrapperId)}},{key:"componentWillReceiveProps",value:function(t){var e={};if(this.props.toolbar!==t.toolbar){var n=(0,A.mergeRecursive)(R.default,t.toolbar);e.toolbar=n}if((0,E.hasProperty)(t,"editorState")&&this.props.editorState!==t.editorState)t.editorState?e.editorState=g.EditorState.set(t.editorState,{decorator:this.compositeDecorator}):e.editorState=g.EditorState.createEmpty(this.compositeDecorator);else if((0,E.hasProperty)(t,"contentState")&&this.props.contentState!==t.contentState)if(t.contentState){var r=this.changeEditorState(t.contentState);r&&(e.editorState=r)}else e.editorState=g.EditorState.createEmpty(this.compositeDecorator);e.editorState&&(this.props.editorState&&this.props.editorState.getCurrentContent().getBlockMap().size)!==(e.editorState&&e.editorState.getCurrentContent().getBlockMap().size)&&(0,M.extractInlineStyle)(e.editorState),this.setState(e),this.editorProps=this.filterEditorProps(t),this.customStyleMap=(0,M.getCustomStyleMap)()}},{key:"render",value:function(){var t=this.state,e=t.editorState,n=t.editorFocused,r=t.toolbar,o=this.props,i=o.locale,a=o.localization,s=a.locale,c=a.translations,l=o.toolbarCustomButtons,p=o.toolbarOnFocus,d=o.toolbarClassName,h=o.toolbarHidden,m=o.editorClassName,I=o.wrapperClassName,w=o.toolbarStyle,D=o.editorStyle,N=o.wrapperStyle,C=o.uploadCallback,j=o.ariaLabel,z={modalHandler:this.modalHandler,editorState:e,onChange:this.onChange,translations:u({},G.default[i||s],c)},A=!h&&(n||this.focusHandler.isInputFocused()||!p);return f.default.createElement("div",{id:this.wrapperId,className:(0,y.default)(I,"rdw-editor-wrapper"),style:N,onClick:this.modalHandler.onEditorClick,onBlur:this.onWrapperBlur,"aria-label":"rdw-wrapper"},f.default.createElement("div",{className:(0,y.default)("rdw-editor-toolbar",d),style:u({visibility:A?"visible":"hidden"},w),onMouseDown:this.preventDefault,"aria-label":"rdw-toolbar","aria-hidden":(!n&&p).toString(),onFocus:this.onToolbarFocus},r.options.map(function(t,e){var n=x.default[t],o=r[t];return"image"===t&&C&&(o.uploadCallback=C),f.default.createElement(n,u({key:e},z,{config:o}))}),l&&l.map(function(t,e){return f.default.cloneElement(t,u({key:e},z))})),f.default.createElement("div",{ref:this.setWrapperReference,className:(0,y.default)(m,"rdw-editor-main"),style:D,onClick:this.focusEditor,onFocus:this.onEditorFocus,onBlur:this.onEditorBlur,onKeyDown:v.default.onKeyDown,onMouseDown:this.onEditorMouseDown},f.default.createElement(g.Editor,u({ref:this.setEditorReference,onTab:this.onTab,onUpArrow:this.onUpDownArrow,onDownArrow:this.onUpDownArrow,editorState:e,onChange:this.onChange,blockStyleFn:T.default,customStyleMap:(0,M.getCustomStyleMap)(),handleReturn:this.handleReturn,handlePastedText:this.handlePastedText,blockRendererFn:this.blockRendererFn,handleKeyCommand:this.handleKeyCommand,ariaLabel:j||"rdw-editor",blockRenderMap:M.blockRenderMap},this.editorProps))))}}]),e}(l.Component);W.propTypes={onChange:d.default.func,onEditorStateChange:d.default.func,onContentStateChange:d.default.func,initialContentState:d.default.object,defaultContentState:d.default.object,contentState:d.default.object,editorState:d.default.object,defaultEditorState:d.default.object,toolbarOnFocus:d.default.bool,spellCheck:d.default.bool,stripPastedStyles:d.default.bool,toolbar:d.default.object,toolbarCustomButtons:d.default.array,toolbarClassName:d.default.string,toolbarHidden:d.default.bool,locale:d.default.string,localization:d.default.object,editorClassName:d.default.string,wrapperClassName:d.default.string,toolbarStyle:d.default.object,editorStyle:d.default.object,wrapperStyle:d.default.object,uploadCallback:d.default.func,onFocus:d.default.func,onBlur:d.default.func,onTab:d.default.func,mention:d.default.object,hashtag:d.default.object,textAlignment:d.default.string,readOnly:d.default.bool,tabIndex:d.default.number,placeholder:d.default.string,ariaLabel:d.default.string,ariaOwneeID:d.default.string,ariaActiveDescendantID:d.default.string,ariaAutoComplete:d.default.string,ariaDescribedBy:d.default.string,ariaExpanded:d.default.string,ariaHasPopup:d.default.string,customBlockRenderFunc:d.default.func,wrapperId:d.default.number,customDecorators:d.default.array},W.defaultProps={toolbarOnFocus:!1,toolbarHidden:!1,stripPastedStyles:!1,localization:{locale:"en",translations:{}},customDecorators:[]};var F=function(){var t=this;this.onEditorBlur=function(){t.setState({editorFocused:!1})},this.onEditorFocus=function(e){var n=t.props.onFocus;t.setState({editorFocused:!0}),n&&t.focusHandler.isEditorFocused()&&n(e)},this.onEditorMouseDown=function(){t.focusHandler.onEditorMouseDown()},this.onTab=function(e){var n=t.props.onTab;if(!n||!n(e)){var r=(0,M.changeDepth)(t.state.editorState,e.shiftKey?-1:1,4);r&&r!==t.state.editorState&&(t.onChange(r),e.preventDefault())}},this.onUpDownArrow=function(t){j.default.isOpen()&&t.preventDefault()},this.onToolbarFocus=function(e){var n=t.props.onFocus;n&&t.focusHandler.isToolbarFocused()&&n(e)},this.onWrapperBlur=function(e){var n=t.props.onBlur;n&&t.focusHandler.isEditorBlur(e)&&n(e)},this.onChange=function(e){var n=t.props,r=n.readOnly,o=n.onEditorStateChange;r||"atomic"===(0,M.getSelectedBlocksType)(e)&&e.getSelection().isCollapsed||(o&&o(e,t.props.wrapperId),(0,E.hasProperty)(t.props,"editorState")?t.afterChange(e):t.setState({editorState:e},t.afterChange(e)))},this.setWrapperReference=function(e){t.wrapper=e},this.setEditorReference=function(e){t.editor=e},this.getCompositeDecorator=function(){var e=[].concat(o(t.props.customDecorators),[(0,_.default)({showOpenOptionOnHover:t.state.toolbar.link.showOpenOptionOnHover})]);return t.props.mention&&e.push.apply(e,o((0,L.default)(u({},t.props.mention,{onChange:t.onChange,getEditorState:t.getEditorState,getSuggestions:t.getSuggestions,getWrapperRef:t.getWrapperRef,modalHandler:t.modalHandler})))),t.props.hashtag&&e.push((0,Q.default)(t.props.hashtag)),new g.CompositeDecorator(e)},this.getWrapperRef=function(){return t.wrapper},this.getEditorState=function(){return t.state.editorState},this.getSuggestions=function(){return t.props.mention&&t.props.mention.suggestions},this.afterChange=function(e){setTimeout(function(){var n=t.props,r=n.onChange,o=n.onContentStateChange;r&&r((0,g.convertToRaw)(e.getCurrentContent())),o&&o((0,g.convertToRaw)(e.getCurrentContent()))})},this.isReadOnly=function(){return t.props.readOnly},this.isImageAlignmentEnabled=function(){return t.state.toolbar.image.alignmentEnabled},this.createEditorState=function(e){var n=void 0;if((0,E.hasProperty)(t.props,"editorState"))t.props.editorState&&(n=g.EditorState.set(t.props.editorState,{decorator:e}));else if((0,E.hasProperty)(t.props,"defaultEditorState"))t.props.defaultEditorState&&(n=g.EditorState.set(t.props.defaultEditorState,{decorator:e}));else if((0,E.hasProperty)(t.props,"contentState")){if(t.props.contentState){var r=(0,g.convertFromRaw)(t.props.contentState);n=g.EditorState.createWithContent(r,e),n=g.EditorState.moveSelectionToEnd(n)}}else if((0,E.hasProperty)(t.props,"defaultContentState")||(0,E.hasProperty)(t.props,"initialContentState")){var o=t.props.defaultContentState||t.props.initialContentState;o&&(o=(0,g.convertFromRaw)(o),n=g.EditorState.createWithContent(o,e),n=g.EditorState.moveSelectionToEnd(n))}return n||(n=g.EditorState.createEmpty(e)),n},this.filterEditorProps=function(t){return(0,E.filter)(t,["onChange","onEditorStateChange","onContentStateChange","initialContentState","defaultContentState","contentState","editorState","defaultEditorState","locale","localization","toolbarOnFocus","toolbar","toolbarCustomButtons","toolbarClassName","editorClassName","toolbarHidden","wrapperClassName","toolbarStyle","editorStyle","wrapperStyle","uploadCallback","onFocus","onBlur","onTab","mention","hashtag","ariaLabel","customBlockRenderFunc","customDecorators"])},this.changeEditorState=function(e){var n=(0,g.convertFromRaw)(e),r=t.state.editorState;return r=g.EditorState.push(r,n,"insert-characters"),r=g.EditorState.moveSelectionToEnd(r)},this.focusEditor=function(){setTimeout(function(){t.editor.focus()})},this.handleKeyCommand=function(e){var n=t.state,r=n.editorState,o=n.toolbar.inline;if(o&&o.options.indexOf(e)>=0){var i=g.RichUtils.handleKeyCommand(r,e);if(i)return t.onChange(i),!0}return!1},this.handleReturn=function(e){if(j.default.isOpen())return!0;var n=(0,M.handleNewLine)(t.state.editorState,e);return!!n&&(t.onChange(n),!0)},this.handlePastedText=function(e,n){var r=t.state.editorState;return(0,S.handlePastedText)(e,n,r,t.onChange)},this.preventDefault=function(e){"INPUT"===e.target.tagName?t.focusHandler.onInputMouseDown():e.preventDefault()}};e.default=W},function(t,e,n){"use strict";var r=n(26),o=n(2),i=n(76);t.exports=function(){function t(t,e,n,r,a,s){s!==i&&o(!1,"Calling PropTypes validators directly is not supported by the `prop-types` package. Use PropTypes.checkPropTypes() to call them. Read more at http://fb.me/use-check-prop-types")}function e(){return t}t.isRequired=t;var n={array:t,bool:t,func:t,number:t,object:t,string:t,symbol:t,any:t,arrayOf:e,element:t,instanceOf:e,node:t,objectOf:e,oneOf:e,oneOfType:e,shape:e};return n.checkPropTypes=r,n.PropTypes=n,n}},function(t,e,n){"use strict";t.exports="SECRET_DO_NOT_PASS_THIS_OR_YOU_WILL_BE_FIRED"},function(t,e,n){"use strict";var r=n(21),o=n(11),i=n(17),a=n(7),s=n(3),u=(n(22),n(4)),c=n(12),l=n(91),f=u.List,p=u.Repeat,d={insertAtomicBlock:function(t,e,n){var u=t.getCurrentContent(),l=t.getSelection(),d=a.removeRange(u,l,"backward"),g=d.getSelectionAfter(),M=a.splitBlock(d,g),h=M.getSelectionAfter(),y=a.setBlockType(M,h,"atomic"),m=o.create({entity:e}),I=[new i({key:c(),type:"atomic",text:n,characterList:f(p(m,n.length))}),new i({key:c(),type:"unstyled",text:"",characterList:f()})],w=r.createFromArray(I),D=a.replaceWithFragment(y,h,w),N=D.merge({selectionBefore:l,selectionAfter:D.getSelectionAfter().set("hasFocus",!0)});return s.push(t,N,"insert-fragment")},moveAtomicBlock:function(t,e,n,r){var o=t.getCurrentContent(),i=t.getSelection(),u=void 0;if("before"===r||"after"===r){var c=o.getBlockForKey("before"===r?n.getStartKey():n.getEndKey());u=l(o,e,c,r)}else{var f=a.removeRange(o,n,"backward"),p=f.getSelectionAfter(),d=f.getBlockForKey(p.getFocusKey());if(0===p.getStartOffset())u=l(f,e,d,"before");else if(p.getEndOffset()===d.getLength())u=l(f,e,d,"after");else{var g=a.splitBlock(f,p),M=g.getSelectionAfter(),h=g.getBlockForKey(M.getFocusKey());u=l(g,e,h,"before")}}var y=u.merge({selectionBefore:i,selectionAfter:u.getSelectionAfter().set("hasFocus",!0)});return s.push(t,y,"move-block")}};t.exports=d},function(t,e,n){"use strict";function r(t,e,n,r){var i=t.getBlockMap(),s=e.getStartKey(),u=e.getStartOffset(),c=e.getEndKey(),l=e.getEndOffset(),f=i.skipUntil(function(t,e){return e===s}).takeUntil(function(t,e){return e===c}).concat(a([[c,i.get(c)]])).map(function(t,e){var i,a;s===c?(i=u,a=l):(i=e===s?u:0,a=e===c?l:t.getLength());for(var f,p=t.getCharacterList();i<a;)f=p.get(i),p=p.set(i,r?o.applyStyle(f,n):o.removeStyle(f,n)),i++;return t.set("characterList",p)});return t.merge({blockMap:i.merge(f),selectionBefore:e,selectionAfter:e})}var o=n(11),i=n(4),a=i.Map,s={add:function(t,e,n){return r(t,e,n,!0)},remove:function(t,e,n){return r(t,e,n,!1)}};t.exports=s},function(t,e,n){"use strict";function r(t,e,n){var r=t.getBlockMap(),a=e.getStartKey(),s=e.getStartOffset(),u=e.getEndKey(),c=e.getEndOffset(),l=r.skipUntil(function(t,e){return e===a}).takeUntil(function(t,e){return e===u}).toOrderedMap().merge(o.OrderedMap([[u,r.get(u)]])).map(function(t,e){var r=e===a?s:0,o=e===u?c:t.getLength();return i(t,r,o,n)});return t.merge({blockMap:r.merge(l),selectionBefore:e,selectionAfter:e})}var o=n(4),i=n(80);t.exports=r},function(t,e,n){"use strict";function r(t,e,n,r){for(var i=t.getCharacterList();e<n;)i=i.set(e,o.applyEntity(i.get(e),r)),e++;return t.set("characterList",i)}var o=n(11);t.exports=r},function(t,e,n){"use strict";function r(t,e,n,r,i){var a=r.getStartOffset(),s=r.getEndOffset(),u=e.getEntityAt(a),c=n.getEntityAt(s-1);if(!u&&!c)return r;var l=r;if(u&&u===c)l=o(t,e,l,i,u,!0,!0);else if(u&&c){var f=o(t,e,l,i,u,!1,!0),p=o(t,n,l,i,c,!1,!1);l=l.merge({anchorOffset:f.getAnchorOffset(),focusOffset:p.getFocusOffset(),isBackward:!1})}else if(u){var d=o(t,e,l,i,u,!1,!0);l=l.merge({anchorOffset:d.getStartOffset(),isBackward:!1})}else if(c){var g=o(t,n,l,i,c,!1,!1);l=l.merge({focusOffset:g.getEndOffset(),isBackward:!1})}return l}function o(t,e,n,r,o,u,c){var l=n.getStartOffset(),f=n.getEndOffset(),p=t.__get(o),d=p.getMutability(),g=c?l:f;if("MUTABLE"===d)return n;var M=a(e,o).filter(function(t){return g<=t.end&&g>=t.start});1!=M.length&&s(!1);var h=M[0];if("IMMUTABLE"===d)return n.merge({anchorOffset:h.start,focusOffset:h.end,isBackward:!1});u||(c?f=h.end:l=h.start);var y=i.getRemovalRange(l,f,e.getText().slice(h.start,h.end),h.start,r);return n.merge({anchorOffset:y.start,focusOffset:y.end,isBackward:!1})}var i=n(82),a=n(83),s=n(2);t.exports=r},function(t,e,n){"use strict";var r={getRemovalRange:function(t,e,n,r,o){var i=n.split(" ");i=i.map(function(t,e){if("forward"===o){if(e>0)return" "+t}else if(e<i.length-1)return t+" ";return t});for(var a,s,u=r,c=null,l=null,f=0;f<i.length;f++){if(s=i[f],a=u+s.length,t<a&&u<e)null!==c?l=a:(c=u,l=a);else if(null!==c)break;u=a}var p=r+n.length,d=c===r,g=l===p;return(!d&&g||d&&!g)&&("forward"===o?l!==p&&l++:c!==r&&c--),{start:c,end:l}}};t.exports=r},function(t,e,n){"use strict";function r(t,e){var n=[];return t.findEntityRanges(function(t){return t.getEntity()===e},function(t,e){n.push({start:t,end:e})}),n.length||o(!1),n}var o=n(2);t.exports=r},function(t,e,n){"use strict";function r(t,e,n){e.isCollapsed()||s(!1);var r,u,c=e.getStartKey(),l=e.getStartOffset(),f=t.getBlockMap(),p=n.size;if(1===p){var d=f.get(c),g=n.first(),M=d.getText(),h=d.getCharacterList(),y=d.merge({text:M.slice(0,l)+g.getText()+M.slice(l),characterList:a(h,g.getCharacterList(),l),data:g.getData()});return f=f.set(c,y),r=c,u=l+g.getText().length,t.merge({blockMap:f.set(c,y),selectionBefore:e,selectionAfter:e.merge({anchorKey:r,anchorOffset:u,focusKey:r,focusOffset:u,isBackward:!1})})}var m=[];return t.getBlockMap().forEach(function(t,e){if(e!==c)return void m.push(t);var o=t.getText(),a=t.getCharacterList(),s=o.length,u=o.slice(0,l),f=a.slice(0,l),d=n.first(),g=t.merge({text:u+d.getText(),characterList:f.concat(d.getCharacterList()),type:u?t.getType():d.getType(),data:d.getData()});m.push(g),n.slice(1,p-1).forEach(function(t){m.push(t.set("key",i()))});var M=o.slice(l,s),h=a.slice(l,s),y=n.last();r=i();var I=y.merge({key:r,text:y.getText()+M,characterList:y.getCharacterList().concat(h),data:y.getData()});m.push(I)}),u=n.last().getLength(),t.merge({blockMap:o.createFromArray(m),selectionBefore:e,selectionAfter:e.merge({anchorKey:r,anchorOffset:u,focusKey:r,focusOffset:u,isBackward:!1})})}var o=n(21),i=n(12),a=n(46),s=n(2);t.exports=r},function(t,e,n){"use strict";function r(t,e,n,r){e.isCollapsed()||a(!1);var o=n.length;if(!o)return t;var u=t.getBlockMap(),c=e.getStartKey(),l=e.getStartOffset(),f=u.get(c),p=f.getText(),d=f.merge({text:p.slice(0,l)+n+p.slice(l,f.getLength()),characterList:i(f.getCharacterList(),s(r,o).toList(),l)}),g=l+o;return t.merge({blockMap:u.set(c,d),selectionAfter:e.merge({anchorOffset:g,focusOffset:g})})}var o=n(4),i=n(46),a=n(2),s=o.Repeat;t.exports=r},function(t,e,n){"use strict";function r(t,e,n){var r=e.getStartKey(),o=e.getEndKey(),a=t.getBlockMap(),s=a.toSeq().skipUntil(function(t,e){return e===r}).takeUntil(function(t,e){return e===o}).concat(i([[o,a.get(o)]])).map(n);return t.merge({blockMap:a.merge(s),selectionBefore:e,selectionAfter:e})}var o=n(4),i=o.Map;t.exports=r},function(t,e,n){"use strict";function r(t,e){if(e.isCollapsed())return t;var n,r=t.getBlockMap(),a=e.getStartKey(),s=e.getStartOffset(),u=e.getEndKey(),c=e.getEndOffset(),l=r.get(a),f=r.get(u);n=l===f?o(l.getCharacterList(),s,c):l.getCharacterList().slice(0,s).concat(f.getCharacterList().slice(c));var p=l.merge({text:l.getText().slice(0,s)+f.getText().slice(c),characterList:n}),d=r.toSeq().skipUntil(function(t,e){return e===a}).takeUntil(function(t,e){return e===u}).concat(i.Map([[u,null]])).map(function(t,e){return e===a?p:null});return r=r.merge(d).filter(function(t){return!!t}),t.merge({blockMap:r,selectionBefore:e,selectionAfter:e.merge({anchorKey:a,anchorOffset:s,focusKey:a,focusOffset:s,isBackward:!1})})}function o(t,e,n){if(0===e)for(;e<n;)t=t.shift(),e++;else if(n===t.count())for(;n>e;)t=t.pop(),n--;else{var r=t.slice(0,e),o=t.slice(n);t=r.concat(o).toList()}return t}var i=n(4);t.exports=r},function(t,e,n){"use strict";function r(t,e){e.isCollapsed()||a(!1);var n=e.getAnchorKey(),r=e.getAnchorOffset(),o=t.getBlockMap(),u=o.get(n),c=u.getText(),l=u.getCharacterList(),f=u.merge({text:c.slice(0,r),characterList:l.slice(0,r)}),p=i(),d=f.merge({key:p,text:c.slice(r),characterList:l.slice(r),data:s()}),g=o.toSeq().takeUntil(function(t){return t===u}),M=o.toSeq().skipUntil(function(t){return t===u}).rest(),h=g.concat([[f.getKey(),f],[d.getKey(),d]],M).toOrderedMap();return t.merge({blockMap:h,selectionBefore:e,selectionAfter:e.merge({anchorKey:p,anchorOffset:0,focusKey:p,focusOffset:0,isBackward:!1})})}var o=n(4),i=n(12),a=n(2),s=o.Map;t.exports=r},function(t,e,n){"use strict";var r,o=n(4),i=n(90),a=n(8),s=o.OrderedMap,u={getDirectionMap:function(t,e){r?r.reset():r=new i;var n=t.getBlockMap(),u=n.valueSeq().map(function(t){return a(r).getDirection(t.getText())}),c=s(n.keySeq().zip(u));return null!=e&&o.is(e,c)?e:c}};t.exports=u},function(t,e,n){"use strict";function r(t,e){if(!(t instanceof e))throw new TypeError("Cannot call a class as a function")}var o=n(49),i=n(34),a=n(2),s=function(){function t(e){r(this,t),e?i.isStrong(e)||a(!1):e=i.getGlobalDir(),this._defaultDir=e,this.reset()}return t.prototype.reset=function(){this._lastDir=this._defaultDir},t.prototype.getDirection=function(t){return this._lastDir=o.getDirection(t,this._lastDir),this._lastDir},t}();t.exports=s},function(t,e,n){"use strict";function r(t,e,n,r){e.getKey()===n.getKey()&&o(!1),"replace"===r&&o(!1);var i=n.getKey(),a=t.getBlockBefore(i),s=t.getBlockAfter(i),u=t.getBlockMap(),c=u.delete(e.getKey()),l=c.toSeq().takeUntil(function(t){return t===n}),f=c.toSeq().skipUntil(function(t){return t===n}).skip(1),p=void 0;return"before"===r?(a&&a.getKey()===e.getKey()&&o(!1),p=l.concat([[e.getKey(),e],[n.getKey(),n]],f).toOrderedMap()):"after"===r&&(s&&s.getKey()===e.getKey()&&o(!1),p=l.concat([[n.getKey(),n],[e.getKey(),e]],f).toOrderedMap()),t.merge({blockMap:p,selectionBefore:t.getSelectionAfter(),selectionAfter:t.getSelectionAfter().merge({anchorKey:e.getKey(),focusKey:e.getKey()})})}var o=n(2);t.exports=r},function(t,e,n){"use strict";function r(t,e){if(!(t instanceof e))throw new TypeError("Cannot call a class as a function")}function o(t,e,n){for(var r=e;r<n;r++)if(null!=t[r])return!1;return!0}function i(t,e,n,r){for(var o=e;o<n;o++)t[o]=r}var a=n(4),s=a.List,u=function(){function t(e){r(this,t),this._decorators=e.slice()}return t.prototype.getDecorations=function(t,e){var n=Array(t.getText().length).fill(null);return this._decorators.forEach(function(r,a){var s=0;(0,r.strategy)(t,function(t,e){o(n,t,e)&&(i(n,t,e,a+"."+s),s++)},e)}),s(n)},t.prototype.getComponentForKey=function(t){var e=parseInt(t.split(".")[0],10);return this._decorators[e].component},t.prototype.getPropsForKey=function(t){var e=parseInt(t.split(".")[0],10);return this._decorators[e].props},t}();t.exports=u},function(t,e,n){"use strict";function r(t,e){if(!(t instanceof e))throw new TypeError("Cannot call a class as a function")}function o(t,e){if(!t)throw new ReferenceError("this hasn't been initialised - super() hasn't been called");return!e||"object"!==(void 0===e?"undefined":a(e))&&"function"!=typeof e?t:e}function i(t,e){if("function"!=typeof e&&null!==e)throw new TypeError("Super expression must either be null or a function, not "+(void 0===e?"undefined":a(e)));t.prototype=Object.create(e&&e.prototype,{constructor:{value:t,enumerable:!1,writable:!0,configurable:!0}}),e&&(Object.setPrototypeOf?Object.setPrototypeOf(t,e):t.__proto__=e)}var a="function"==typeof Symbol&&"symbol"==typeof Symbol.iterator?function(t){return typeof t}:function(t){return t&&"function"==typeof Symbol&&t.constructor===Symbol&&t!==Symbol.prototype?"symbol":typeof t},s=n(18),u=s||function(t){for(var e=1;e<arguments.length;e++){var n=arguments[e];for(var r in n)Object.prototype.hasOwnProperty.call(n,r)&&(t[r]=n[r])}return t},c=n(35),l=n(50),f=n(94),p=n(95),d=n(118),g=n(121),M=n(154),h=n(3),y=n(0),m=n(24),I=n(55),w=n(39),D=n(13),N=n(23),v=n(26),C=n(12),j=n(67),z=n(40),T=n(2),A=n(8),E=D.isBrowser("IE"),S=!E,b={edit:g,composite:f,drag:d,cut:null,render:null},x=function(t){function e(n){r(this,e);var i=o(this,t.call(this,n));return i._blockSelectEvents=!1,i._clipboard=null,i._handler=null,i._dragCount=0,i._editorKey=n.editorKey||C(),i._placeholderAccessibilityID="placeholder-"+i._editorKey,i._latestEditorState=n.editorState,i._onBeforeInput=i._buildHandler("onBeforeInput"),i._onBlur=i._buildHandler("onBlur"),i._onCharacterData=i._buildHandler("onCharacterData"),i._onCompositionEnd=i._buildHandler("onCompositionEnd"),i._onCompositionStart=i._buildHandler("onCompositionStart"),i._onCopy=i._buildHandler("onCopy"),i._onCut=i._buildHandler("onCut"),i._onDragEnd=i._buildHandler("onDragEnd"),i._onDragOver=i._buildHandler("onDragOver"),i._onDragStart=i._buildHandler("onDragStart"),i._onDrop=i._buildHandler("onDrop"),i._onInput=i._buildHandler("onInput"),i._onFocus=i._buildHandler("onFocus"),i._onKeyDown=i._buildHandler("onKeyDown"),i._onKeyPress=i._buildHandler("onKeyPress"),i._onKeyUp=i._buildHandler("onKeyUp"),i._onMouseDown=i._buildHandler("onMouseDown"),i._onMouseUp=i._buildHandler("onMouseUp"),i._onPaste=i._buildHandler("onPaste"),i._onSelect=i._buildHandler("onSelect"),i.focus=i._focus.bind(i),i.blur=i._blur.bind(i),i.setMode=i._setMode.bind(i),i.exitCurrentMode=i._exitCurrentMode.bind(i),i.restoreEditorDOM=i._restoreEditorDOM.bind(i),i.setClipboard=i._setClipboard.bind(i),i.getClipboard=i._getClipboard.bind(i),i.getEditorKey=function(){return i._editorKey},i.update=i._update.bind(i),i.onDragEnter=i._onDragEnter.bind(i),i.onDragLeave=i._onDragLeave.bind(i),i.state={contentsKey:0},i}return i(e,t),e.prototype._buildHandler=function(t){var e=this;return function(n){if(!e.props.readOnly){var r=e._handler&&e._handler[t];r&&r(e,n)}}},e.prototype._showPlaceholder=function(){return!!this.props.placeholder&&!this.props.editorState.isInCompositionMode()&&!this.props.editorState.getCurrentContent().hasText()},e.prototype._renderPlaceholder=function(){return this._showPlaceholder()?y.createElement(M,{text:A(this.props.placeholder),editorState:this.props.editorState,textAlignment:this.props.textAlignment,accessibilityID:this._placeholderAccessibilityID}):null},e.prototype.render=function(){var t=this.props,e=t.readOnly,n=t.textAlignment,r=N({"DraftEditor/root":!0,"DraftEditor/alignLeft":"left"===n,"DraftEditor/alignRight":"right"===n,"DraftEditor/alignCenter":"center"===n}),o={outline:"none",whiteSpace:"pre-wrap",wordWrap:"break-word"};return y.createElement("div",{className:r},this._renderPlaceholder(),y.createElement("div",{className:N("DraftEditor/editorContainer"),ref:"editorContainer"},y.createElement("div",{"aria-activedescendant":e?null:this.props.ariaActiveDescendantID,"aria-autocomplete":e?null:this.props.ariaAutoComplete,"aria-describedby":this._showPlaceholder()?this._placeholderAccessibilityID:null,"aria-expanded":e?null:this.props.ariaExpanded,"aria-haspopup":e?null:this.props.ariaHasPopup,"aria-label":this.props.ariaLabel,"aria-owns":e?null:this.props.ariaOwneeID,autoCapitalize:this.props.autoCapitalize,autoComplete:this.props.autoComplete,autoCorrect:this.props.autoCorrect,className:N({notranslate:!e,"public/DraftEditor/content":!0}),contentEditable:!e,"data-testid":this.props.webDriverTestID,onBeforeInput:this._onBeforeInput,onBlur:this._onBlur,onCompositionEnd:this._onCompositionEnd,onCompositionStart:this._onCompositionStart,onCopy:this._onCopy,onCut:this._onCut,onDragEnd:this._onDragEnd,onDragEnter:this.onDragEnter,onDragLeave:this.onDragLeave,onDragOver:this._onDragOver,onDragStart:this._onDragStart,onDrop:this._onDrop,onFocus:this._onFocus,onInput:this._onInput,onKeyDown:this._onKeyDown,onKeyPress:this._onKeyPress,onKeyUp:this._onKeyUp,onMouseUp:this._onMouseUp,onPaste:this._onPaste,onSelect:this._onSelect,ref:"editor",role:e?null:this.props.role||"textbox",spellCheck:S&&this.props.spellCheck,style:o,suppressContentEditableWarning:!0,tabIndex:this.props.tabIndex},y.createElement(p,{blockRenderMap:this.props.blockRenderMap,blockRendererFn:this.props.blockRendererFn,blockStyleFn:this.props.blockStyleFn,customStyleMap:u({},l,this.props.customStyleMap),customStyleFn:this.props.customStyleFn,editorKey:this._editorKey,editorState:this.props.editorState,key:"contents"+this.state.contentsKey,textDirectionality:this.props.textDirectionality}))))},e.prototype.componentDidMount=function(){this.setMode("edit"),E&&document.execCommand("AutoUrlDetect",!1,!1)},e.prototype.componentWillUpdate=function(t){this._blockSelectEvents=!0,this._latestEditorState=t.editorState},e.prototype.componentDidUpdate=function(){this._blockSelectEvents=!1},e.prototype._focus=function(t){var e=this.props.editorState,n=e.getSelection().getHasFocus(),r=m.findDOMNode(this.refs.editor),o=w.getScrollParent(r),i=t||z(o),a=i.x,s=i.y;r instanceof HTMLElement||T(!1),r.focus(),o===window?window.scrollTo(a,s):I.setTop(o,s),n||this.update(h.forceSelection(e,e.getSelection()))},e.prototype._blur=function(){var t=m.findDOMNode(this.refs.editor);t instanceof HTMLElement||T(!1),t.blur()},e.prototype._setMode=function(t){this._handler=b[t]},e.prototype._exitCurrentMode=function(){this.setMode("edit")},e.prototype._restoreEditorDOM=function(t){var e=this;this.setState({contentsKey:this.state.contentsKey+1},function(){e._focus(t)})},e.prototype._setClipboard=function(t){this._clipboard=t},e.prototype._getClipboard=function(){return this._clipboard},e.prototype._update=function(t){this._latestEditorState=t,this.props.onChange(t)},e.prototype._onDragEnter=function(){this._dragCount++},e.prototype._onDragLeave=function(){0===--this._dragCount&&this.exitCurrentMode()},e}(y.Component);x.defaultProps={blockRenderMap:c,blockRendererFn:v.thatReturnsNull,blockStyleFn:v.thatReturns(""),keyBindingFn:j,readOnly:!1,spellCheck:!1,stripPastedStyles:!1},t.exports=x},function(t,e,n){"use strict";var r=n(7),o=n(3),i=n(36),a=n(37),s=n(51),u=!1,c=!1,l="",f={onBeforeInput:function(t,e){l=(l||"")+e.data},onCompositionStart:function(t){c=!0},onCompositionEnd:function(t){u=!1,c=!1,setTimeout(function(){u||f.resolveComposition(t)},20)},onKeyDown:function(t,e){if(!c)return f.resolveComposition(t),void t._onKeyDown(e);e.which!==i.RIGHT&&e.which!==i.LEFT||e.preventDefault()},onKeyPress:function(t,e){e.which===i.RETURN&&e.preventDefault()},resolveComposition:function(t){if(!c){u=!0;var e=l;l="";var n=o.set(t._latestEditorState,{inCompositionMode:!1}),i=n.getCurrentInlineStyle(),f=a(n.getCurrentContent(),n.getSelection()),p=!e||s(n)||i.size>0||null!==f;if(p&&t.restoreEditorDOM(),t.exitCurrentMode(),e){var d=r.replaceText(n.getCurrentContent(),n.getSelection(),e,i,f);return void t.update(o.push(n,d,"insert-characters"))}p&&t.update(o.set(n,{nativelyRenderedContent:null,forceSelection:!0}))}}};t.exports=f},function(t,e,n){"use strict";function r(t,e){if(!(t instanceof e))throw new TypeError("Cannot call a class as a function")}function o(t,e){if(!t)throw new ReferenceError("this hasn't been initialised - super() hasn't been called");return!e||"object"!==(void 0===e?"undefined":s(e))&&"function"!=typeof e?t:e}function i(t,e){if("function"!=typeof e&&null!==e)throw new TypeError("Super expression must either be null or a function, not "+(void 0===e?"undefined":s(e)));t.prototype=Object.create(e&&e.prototype,{constructor:{value:t,enumerable:!1,writable:!0,configurable:!0}}),e&&(Object.setPrototypeOf?Object.setPrototypeOf(t,e):t.__proto__=e)}function a(t,e,n,r){return d({"public/DraftStyleDefault/unorderedListItem":"unordered-list-item"===t,"public/DraftStyleDefault/orderedListItem":"ordered-list-item"===t,"public/DraftStyleDefault/reset":n,"public/DraftStyleDefault/depth0":0===e,"public/DraftStyleDefault/depth1":1===e,"public/DraftStyleDefault/depth2":2===e,"public/DraftStyleDefault/depth3":3===e,"public/DraftStyleDefault/depth4":4===e,"public/DraftStyleDefault/listLTR":"LTR"===r,"public/DraftStyleDefault/listRTL":"RTL"===r})}var s="function"==typeof Symbol&&"symbol"==typeof Symbol.iterator?function(t){return typeof t}:function(t){return t&&"function"==typeof Symbol&&t.constructor===Symbol&&t!==Symbol.prototype?"symbol":typeof t},u=n(18),c=u||function(t){for(var e=1;e<arguments.length;e++){var n=arguments[e];for(var r in n)Object.prototype.hasOwnProperty.call(n,r)&&(t[r]=n[r])}return t},l=n(52),f=n(30),p=(n(3),n(0)),d=n(23),g=n(117),M=n(8),h=function(t){function e(){return r(this,e),o(this,t.apply(this,arguments))}return i(e,t),e.prototype.shouldComponentUpdate=function(t){var e=this.props.editorState,n=t.editorState;if(e.getDirectionMap()!==n.getDirectionMap())return!0;if(e.getSelection().getHasFocus()!==n.getSelection().getHasFocus())return!0;var r=n.getNativelyRenderedContent(),o=e.isInCompositionMode(),i=n.isInCompositionMode();if(e===n||null!==r&&n.getCurrentContent()===r||o&&i)return!1;var a=e.getCurrentContent(),s=n.getCurrentContent(),u=e.getDecorator(),c=n.getDecorator();return o!==i||a!==s||u!==c||n.mustForceSelection()},e.prototype.render=function(){for(var t=this.props,e=t.blockRenderMap,n=t.blockRendererFn,r=t.customStyleMap,o=t.customStyleFn,i=t.editorState,s=i.getCurrentContent(),u=i.getSelection(),d=i.mustForceSelection(),h=i.getDecorator(),y=M(i.getDirectionMap()),m=s.getBlocksAsArray(),I=[],w=null,D=null,N=0;N<m.length;N++){var v=m[N],C=v.getKey(),j=v.getType(),z=n(v),T=void 0,A=void 0,E=void 0;z&&(T=z.component,A=z.props,E=z.editable);var S=this.props.textDirectionality,b=S||y.get(C),x=f.encode(C,0,0),O={contentState:s,block:v,blockProps:A,customStyleMap:r,customStyleFn:o,decorator:h,direction:b,forceSelection:d,key:C,offsetKey:x,selection:u,tree:i.getBlockTree(C)},_=e.get(j),k=_.wrapper,L=_.element||e.get("unstyled").element,U=v.getDepth(),Q=this.props.blockStyleFn(v);if("li"===L){Q=g(Q,a(j,U,D!==k||null===w||U>w,b))}var Y=T||l,B={className:Q,"data-block":!0,"data-editor":this.props.editorKey,"data-offset-key":x,key:C};void 0!==E&&(B=c({},B,{contentEditable:E,suppressContentEditableWarning:!0}));var P=p.createElement(L,B,p.createElement(Y,O));I.push({block:P,wrapperTemplate:k,key:C,offsetKey:x}),w=k?v.getDepth():null,D=k}for(var R=[],Z=0;Z<I.length;){var G=I[Z];if(G.wrapperTemplate){var W=[];do{W.push(I[Z].block),Z++}while(Z<I.length&&I[Z].wrapperTemplate===G.wrapperTemplate);var F=p.cloneElement(G.wrapperTemplate,{key:G.key+"-wrap","data-offset-key":G.offsetKey},W);R.push(F)}else R.push(G.block),Z++}return p.createElement("div",{"data-contents":"true"},R)},e}(p.Component);t.exports=h},function(t,e,n){"use strict";function r(t,e){if(!(t instanceof e))throw new TypeError("Cannot call a class as a function")}function o(t,e){if(!t)throw new ReferenceError("this hasn't been initialised - super() hasn't been called");return!e||"object"!==(void 0===e?"undefined":a(e))&&"function"!=typeof e?t:e}function i(t,e){if("function"!=typeof e&&null!==e)throw new TypeError("Super expression must either be null or a function, not "+(void 0===e?"undefined":a(e)));t.prototype=Object.create(e&&e.prototype,{constructor:{value:t,enumerable:!1,writable:!0,configurable:!0}}),e&&(Object.setPrototypeOf?Object.setPrototypeOf(t,e):t.__proto__=e)}var a="function"==typeof Symbol&&"symbol"==typeof Symbol.iterator?function(t){return typeof t}:function(t){return t&&"function"==typeof Symbol&&t.constructor===Symbol&&t!==Symbol.prototype?"symbol":typeof t},s=n(18),u=(n(17),n(97)),c=n(0),l=n(24),f=n(2),p=n(105),d=function(t){function e(){return r(this,e),o(this,t.apply(this,arguments))}return i(e,t),e.prototype._setSelection=function(){var t=this.props.selection;if(null!=t&&t.getHasFocus()){var e=this.props,n=e.block,r=e.start,o=e.text,i=n.getKey(),a=r+o.length;if(t.hasEdgeWithin(i,r,a)){var s=l.findDOMNode(this);s||f(!1);var u=s.firstChild;u||f(!1);var c=void 0;u.nodeType===Node.TEXT_NODE?c=u:"BR"===u.tagName?c=s:(c=u.firstChild)||f(!1),p(t,c,i,r,a)}}},e.prototype.shouldComponentUpdate=function(t){var e=l.findDOMNode(this.refs.leaf);return e||f(!1),e.textContent!==t.text||t.styleSet!==this.props.styleSet||t.forceSelection},e.prototype.componentDidUpdate=function(){this._setSelection()},e.prototype.componentDidMount=function(){this._setSelection()},e.prototype.render=function(){var t=this.props.block,e=this.props.text;e.endsWith("\n")&&this.props.isLast&&(e+="\n");var n=this.props,r=n.customStyleMap,o=n.customStyleFn,i=n.offsetKey,a=n.styleSet,l=a.reduce(function(t,e){var n={},o=r[e];return void 0!==o&&t.textDecoration!==o.textDecoration&&(n.textDecoration=[t.textDecoration,o.textDecoration].join(" ").trim()),s(t,o,n)},{});if(o){var f=o(a,t);l=s(l,f)}return c.createElement("span",{"data-offset-key":i,ref:"leaf",style:l},c.createElement(u,null,e))},e}(c.Component);t.exports=d},function(t,e,n){"use strict";function r(t,e){if(!(t instanceof e))throw new TypeError("Cannot call a class as a function")}function o(t,e){if(!t)throw new ReferenceError("this hasn't been initialised - super() hasn't been called");return!e||"object"!==(void 0===e?"undefined":s(e))&&"function"!=typeof e?t:e}function i(t,e){if("function"!=typeof e&&null!==e)throw new TypeError("Super expression must either be null or a function, not "+(void 0===e?"undefined":s(e)));t.prototype=Object.create(e&&e.prototype,{constructor:{value:t,enumerable:!1,writable:!0,configurable:!0}}),e&&(Object.setPrototypeOf?Object.setPrototypeOf(t,e):t.__proto__=e)}function a(t){return p?"\n"===t.textContent:"BR"===t.tagName}var s="function"==typeof Symbol&&"symbol"==typeof Symbol.iterator?function(t){return typeof t}:function(t){return t&&"function"==typeof Symbol&&t.constructor===Symbol&&t!==Symbol.prototype?"symbol":typeof t},u=n(0),c=n(24),l=n(13),f=n(2),p=l.isBrowser("IE <= 11"),d=p?u.createElement("span",{key:"A","data-text":"true"},"\n"):u.createElement("br",{key:"A","data-text":"true"}),g=p?u.createElement("span",{key:"B","data-text":"true"},"\n"):u.createElement("br",{key:"B","data-text":"true"}),M=function(t){function e(n){r(this,e);var i=o(this,t.call(this,n));return i._forceFlag=!1,i}return i(e,t),e.prototype.shouldComponentUpdate=function(t){var e=c.findDOMNode(this),n=""===t.children;return e instanceof Element||f(!1),n?!a(e):e.textContent!==t.children},e.prototype.componentWillUpdate=function(){this._forceFlag=!this._forceFlag},e.prototype.render=function(){return""===this.props.children?this._forceFlag?d:g:u.createElement("span",{key:this._forceFlag?"A":"B","data-text":"true"},this.props.children)},e}(u.Component);t.exports=M},function(t,e,n){"use strict";var r=n(99),o="Unknown",i={"Mac OS":"Mac OS X"},a=new r,s=a.getResult(),u=function(t){if(!t)return{major:"",minor:""};var e=t.split(".");return{major:e[0],minor:e[1]}}(s.browser.version),c={browserArchitecture:s.cpu.architecture||o,browserFullVersion:s.browser.version||o,browserMinorVersion:u.minor||o,browserName:s.browser.name||o,browserVersion:s.browser.major||o,deviceName:s.device.model||o,engineName:s.engine.name||o,engineVersion:s.engine.version||o,platformArchitecture:s.cpu.architecture||o,platformName:function(t){return i[t]||t}(s.os.name)||o,platformVersion:s.os.version||o,platformFullVersion:s.os.version||o};t.exports=c},function(t,e,n){"use strict";(function(t){var r,o="function"==typeof Symbol&&"symbol"==typeof Symbol.iterator?function(t){return typeof t}:function(t){return t&&"function"==typeof Symbol&&t.constructor===Symbol&&t!==Symbol.prototype?"symbol":typeof t};!function(i,a){var s="model",u="name",c="type",l="vendor",f="version",p="mobile",d="tablet",g={extend:function(t,e){var n={};for(var r in t)e[r]&&e[r].length%2==0?n[r]=e[r].concat(t[r]):n[r]=t[r];return n},has:function(t,e){return"string"==typeof t&&-1!==e.toLowerCase().indexOf(t.toLowerCase())},lowerize:function(t){return t.toLowerCase()},major:function(t){return"string"===(void 0===t?"undefined":o(t))?t.replace(/[^\d\.]/g,"").split(".")[0]:void 0},trim:function(t){return t.replace(/^[\s\uFEFF\xA0]+|[\s\uFEFF\xA0]+$/g,"")}},M={rgx:function(){for(var t,e,n,r,i,a,s,u=0,c=arguments;u<c.length&&!a;){var l=c[u],f=c[u+1];if("undefined"===(void 0===t?"undefined":o(t))){t={};for(r in f)f.hasOwnProperty(r)&&(i=f[r],"object"===(void 0===i?"undefined":o(i))?t[i[0]]=void 0:t[i]=void 0)}for(e=n=0;e<l.length&&!a;)if(a=l[e++].exec(this.getUA()))for(r=0;r<f.length;r++)s=a[++n],i=f[r],"object"===(void 0===i?"undefined":o(i))&&i.length>0?2==i.length?"function"==o(i[1])?t[i[0]]=i[1].call(this,s):t[i[0]]=i[1]:3==i.length?"function"!==o(i[1])||i[1].exec&&i[1].test?t[i[0]]=s?s.replace(i[1],i[2]):void 0:t[i[0]]=s?i[1].call(this,s,i[2]):void 0:4==i.length&&(t[i[0]]=s?i[3].call(this,s.replace(i[1],i[2])):void 0):t[i]=s||void 0;u+=2}return t},str:function(t,e){for(var n in e)if("object"===o(e[n])&&e[n].length>0){for(var r=0;r<e[n].length;r++)if(g.has(e[n][r],t))return"?"===n?void 0:n}else if(g.has(e[n],t))return"?"===n?void 0:n;return t}},h={browser:{oldsafari:{version:{"1.0":"/8",1.2:"/1",1.3:"/3","2.0":"/412","2.0.2":"/416","2.0.3":"/417","2.0.4":"/419","?":"/"}}},device:{amazon:{model:{"Fire Phone":["SD","KF"]}},sprint:{model:{"Evo Shift 4G":"7373KT"},vendor:{HTC:"APA",Sprint:"Sprint"}}},os:{windows:{version:{ME:"4.90","NT 3.11":"NT3.51","NT 4.0":"NT4.0",2000:"NT 5.0",XP:["NT 5.1","NT 5.2"],Vista:"NT 6.0",7:"NT 6.1",8:"NT 6.2",8.1:"NT 6.3",10:["NT 6.4","NT 10.0"],RT:"ARM"}}}},y={browser:[[/(opera\smini)\/([\w\.-]+)/i,/(opera\s[mobiletab]+).+version\/([\w\.-]+)/i,/(opera).+version\/([\w\.]+)/i,/(opera)[\/\s]+([\w\.]+)/i],[u,f],[/(opios)[\/\s]+([\w\.]+)/i],[[u,"Opera Mini"],f],[/\s(opr)\/([\w\.]+)/i],[[u,"Opera"],f],[/(kindle)\/([\w\.]+)/i,/(lunascape|maxthon|netfront|jasmine|blazer)[\/\s]?([\w\.]+)*/i,/(avant\s|iemobile|slim|baidu)(?:browser)?[\/\s]?([\w\.]*)/i,/(?:ms|\()(ie)\s([\w\.]+)/i,/(rekonq)\/([\w\.]+)*/i,/(chromium|flock|rockmelt|midori|epiphany|silk|skyfire|ovibrowser|bolt|iron|vivaldi|iridium|phantomjs)\/([\w\.-]+)/i],[u,f],[/(trident).+rv[:\s]([\w\.]+).+like\sgecko/i],[[u,"IE"],f],[/(edge)\/((\d+)?[\w\.]+)/i],[u,f],[/(yabrowser)\/([\w\.]+)/i],[[u,"Yandex"],f],[/(comodo_dragon)\/([\w\.]+)/i],[[u,/_/g," "],f],[/(micromessenger)\/([\w\.]+)/i],[[u,"WeChat"],f],[/xiaomi\/miuibrowser\/([\w\.]+)/i],[f,[u,"MIUI Browser"]],[/\swv\).+(chrome)\/([\w\.]+)/i],[[u,/(.+)/,"$1 WebView"],f],[/android.+samsungbrowser\/([\w\.]+)/i,/android.+version\/([\w\.]+)\s+(?:mobile\s?safari|safari)*/i],[f,[u,"Android Browser"]],[/(chrome|omniweb|arora|[tizenoka]{5}\s?browser)\/v?([\w\.]+)/i,/(qqbrowser)[\/\s]?([\w\.]+)/i],[u,f],[/(uc\s?browser)[\/\s]?([\w\.]+)/i,/ucweb.+(ucbrowser)[\/\s]?([\w\.]+)/i,/juc.+(ucweb)[\/\s]?([\w\.]+)/i],[[u,"UCBrowser"],f],[/(dolfin)\/([\w\.]+)/i],[[u,"Dolphin"],f],[/((?:android.+)crmo|crios)\/([\w\.]+)/i],[[u,"Chrome"],f],[/;fbav\/([\w\.]+);/i],[f,[u,"Facebook"]],[/fxios\/([\w\.-]+)/i],[f,[u,"Firefox"]],[/version\/([\w\.]+).+?mobile\/\w+\s(safari)/i],[f,[u,"Mobile Safari"]],[/version\/([\w\.]+).+?(mobile\s?safari|safari)/i],[f,u],[/webkit.+?(mobile\s?safari|safari)(\/[\w\.]+)/i],[u,[f,M.str,h.browser.oldsafari.version]],[/(konqueror)\/([\w\.]+)/i,/(webkit|khtml)\/([\w\.]+)/i],[u,f],[/(navigator|netscape)\/([\w\.-]+)/i],[[u,"Netscape"],f],[/(swiftfox)/i,/(icedragon|iceweasel|camino|chimera|fennec|maemo\sbrowser|minimo|conkeror)[\/\s]?([\w\.\+]+)/i,/(firefox|seamonkey|k-meleon|icecat|iceape|firebird|phoenix)\/([\w\.-]+)/i,/(mozilla)\/([\w\.]+).+rv\:.+gecko\/\d+/i,/(polaris|lynx|dillo|icab|doris|amaya|w3m|netsurf|sleipnir)[\/\s]?([\w\.]+)/i,/(links)\s\(([\w\.]+)/i,/(gobrowser)\/?([\w\.]+)*/i,/(ice\s?browser)\/v?([\w\._]+)/i,/(mosaic)[\/\s]([\w\.]+)/i],[u,f]],cpu:[[/(?:(amd|x(?:(?:86|64)[_-])?|wow|win)64)[;\)]/i],[["architecture","amd64"]],[/(ia32(?=;))/i],[["architecture",g.lowerize]],[/((?:i[346]|x)86)[;\)]/i],[["architecture","ia32"]],[/windows\s(ce|mobile);\sppc;/i],[["architecture","arm"]],[/((?:ppc|powerpc)(?:64)?)(?:\smac|;|\))/i],[["architecture",/ower/,"",g.lowerize]],[/(sun4\w)[;\)]/i],[["architecture","sparc"]],[/((?:avr32|ia64(?=;))|68k(?=\))|arm(?:64|(?=v\d+;))|(?=atmel\s)avr|(?:irix|mips|sparc)(?:64)?(?=;)|pa-risc)/i],[["architecture",g.lowerize]]],device:[[/\((ipad|playbook);[\w\s\);-]+(rim|apple)/i],[s,l,[c,d]],[/applecoremedia\/[\w\.]+ \((ipad)/],[s,[l,"Apple"],[c,d]],[/(apple\s{0,1}tv)/i],[[s,"Apple TV"],[l,"Apple"]],[/(archos)\s(gamepad2?)/i,/(hp).+(touchpad)/i,/(hp).+(tablet)/i,/(kindle)\/([\w\.]+)/i,/\s(nook)[\w\s]+build\/(\w+)/i,/(dell)\s(strea[kpr\s\d]*[\dko])/i],[l,s,[c,d]],[/(kf[A-z]+)\sbuild\/[\w\.]+.*silk\//i],[s,[l,"Amazon"],[c,d]],[/(sd|kf)[0349hijorstuw]+\sbuild\/[\w\.]+.*silk\//i],[[s,M.str,h.device.amazon.model],[l,"Amazon"],[c,p]],[/\((ip[honed|\s\w*]+);.+(apple)/i],[s,l,[c,p]],[/\((ip[honed|\s\w*]+);/i],[s,[l,"Apple"],[c,p]],[/(blackberry)[\s-]?(\w+)/i,/(blackberry|benq|palm(?=\-)|sonyericsson|acer|asus|dell|huawei|meizu|motorola|polytron)[\s_-]?([\w-]+)*/i,/(hp)\s([\w\s]+\w)/i,/(asus)-?(\w+)/i],[l,s,[c,p]],[/\(bb10;\s(\w+)/i],[s,[l,"BlackBerry"],[c,p]],[/android.+(transfo[prime\s]{4,10}\s\w+|eeepc|slider\s\w+|nexus 7|padfone)/i],[s,[l,"Asus"],[c,d]],[/(sony)\s(tablet\s[ps])\sbuild\//i,/(sony)?(?:sgp.+)\sbuild\//i],[[l,"Sony"],[s,"Xperia Tablet"],[c,d]],[/(?:sony)?(?:(?:(?:c|d)\d{4})|(?:so[-l].+))\sbuild\//i],[[l,"Sony"],[s,"Xperia Phone"],[c,p]],[/\s(ouya)\s/i,/(nintendo)\s([wids3u]+)/i],[l,s,[c,"console"]],[/android.+;\s(shield)\sbuild/i],[s,[l,"Nvidia"],[c,"console"]],[/(playstation\s[34portablevi]+)/i],[s,[l,"Sony"],[c,"console"]],[/(sprint\s(\w+))/i],[[l,M.str,h.device.sprint.vendor],[s,M.str,h.device.sprint.model],[c,p]],[/(lenovo)\s?(S(?:5000|6000)+(?:[-][\w+]))/i],[l,s,[c,d]],[/(htc)[;_\s-]+([\w\s]+(?=\))|\w+)*/i,/(zte)-(\w+)*/i,/(alcatel|geeksphone|huawei|lenovo|nexian|panasonic|(?=;\s)sony)[_\s-]?([\w-]+)*/i],[l,[s,/_/g," "],[c,p]],[/(nexus\s9)/i],[s,[l,"HTC"],[c,d]],[/(nexus\s6p)/i],[s,[l,"Huawei"],[c,p]],[/(microsoft);\s(lumia[\s\w]+)/i],[l,s,[c,p]],[/[\s\(;](xbox(?:\sone)?)[\s\);]/i],[s,[l,"Microsoft"],[c,"console"]],[/(kin\.[onetw]{3})/i],[[s,/\./g," "],[l,"Microsoft"],[c,p]],[/\s(milestone|droid(?:[2-4x]|\s(?:bionic|x2|pro|razr))?(:?\s4g)?)[\w\s]+build\//i,/mot[\s-]?(\w+)*/i,/(XT\d{3,4}) build\//i,/(nexus\s6)/i],[s,[l,"Motorola"],[c,p]],[/android.+\s(mz60\d|xoom[\s2]{0,2})\sbuild\//i],[s,[l,"Motorola"],[c,d]],[/hbbtv\/\d+\.\d+\.\d+\s+\([\w\s]*;\s*(\w[^;]*);([^;]*)/i],[[l,g.trim],[s,g.trim],[c,"smarttv"]],[/hbbtv.+maple;(\d+)/i],[[s,/^/,"SmartTV"],[l,"Samsung"],[c,"smarttv"]],[/\(dtv[\);].+(aquos)/i],[s,[l,"Sharp"],[c,"smarttv"]],[/android.+((sch-i[89]0\d|shw-m380s|gt-p\d{4}|gt-n\d+|sgh-t8[56]9|nexus 10))/i,/((SM-T\w+))/i],[[l,"Samsung"],s,[c,d]],[/smart-tv.+(samsung)/i],[l,[c,"smarttv"],s],[/((s[cgp]h-\w+|gt-\w+|galaxy\snexus|sm-\w[\w\d]+))/i,/(sam[sung]*)[\s-]*(\w+-?[\w-]*)*/i,/sec-((sgh\w+))/i],[[l,"Samsung"],s,[c,p]],[/sie-(\w+)*/i],[s,[l,"Siemens"],[c,p]],[/(maemo|nokia).*(n900|lumia\s\d+)/i,/(nokia)[\s_-]?([\w-]+)*/i],[[l,"Nokia"],s,[c,p]],[/android\s3\.[\s\w;-]{10}(a\d{3})/i],[s,[l,"Acer"],[c,d]],[/android\s3\.[\s\w;-]{10}(lg?)-([06cv9]{3,4})/i],[[l,"LG"],s,[c,d]],[/(lg) netcast\.tv/i],[l,s,[c,"smarttv"]],[/(nexus\s[45])/i,/lg[e;\s\/-]+(\w+)*/i],[s,[l,"LG"],[c,p]],[/android.+(ideatab[a-z0-9\-\s]+)/i],[s,[l,"Lenovo"],[c,d]],[/linux;.+((jolla));/i],[l,s,[c,p]],[/((pebble))app\/[\d\.]+\s/i],[l,s,[c,"wearable"]],[/android.+;\s(glass)\s\d/i],[s,[l,"Google"],[c,"wearable"]],[/android.+(\w+)\s+build\/hm\1/i,/android.+(hm[\s\-_]*note?[\s_]*(?:\d\w)?)\s+build/i,/android.+(mi[\s\-_]*(?:one|one[\s_]plus|note lte)?[\s_]*(?:\d\w)?)\s+build/i],[[s,/_/g," "],[l,"Xiaomi"],[c,p]],[/android.+a000(1)\s+build/i],[s,[l,"OnePlus"],[c,p]],[/\s(tablet)[;\/]/i,/\s(mobile)(?:[;\/]|\ssafari)/i],[[c,g.lowerize],l,s]],engine:[[/windows.+\sedge\/([\w\.]+)/i],[f,[u,"EdgeHTML"]],[/(presto)\/([\w\.]+)/i,/(webkit|trident|netfront|netsurf|amaya|lynx|w3m)\/([\w\.]+)/i,/(khtml|tasman|links)[\/\s]\(?([\w\.]+)/i,/(icab)[\/\s]([23]\.[\d\.]+)/i],[u,f],[/rv\:([\w\.]+).*(gecko)/i],[f,u]],os:[[/microsoft\s(windows)\s(vista|xp)/i],[u,f],[/(windows)\snt\s6\.2;\s(arm)/i,/(windows\sphone(?:\sos)*)[\s\/]?([\d\.\s]+\w)*/i,/(windows\smobile|windows)[\s\/]?([ntce\d\.\s]+\w)/i],[u,[f,M.str,h.os.windows.version]],[/(win(?=3|9|n)|win\s9x\s)([nt\d\.]+)/i],[[u,"Windows"],[f,M.str,h.os.windows.version]],[/\((bb)(10);/i],[[u,"BlackBerry"],f],[/(blackberry)\w*\/?([\w\.]+)*/i,/(tizen)[\/\s]([\w\.]+)/i,/(android|webos|palm\sos|qnx|bada|rim\stablet\sos|meego|contiki)[\/\s-]?([\w\.]+)*/i,/linux;.+(sailfish);/i],[u,f],[/(symbian\s?os|symbos|s60(?=;))[\/\s-]?([\w\.]+)*/i],[[u,"Symbian"],f],[/\((series40);/i],[u],[/mozilla.+\(mobile;.+gecko.+firefox/i],[[u,"Firefox OS"],f],[/(nintendo|playstation)\s([wids34portablevu]+)/i,/(mint)[\/\s\(]?(\w+)*/i,/(mageia|vectorlinux)[;\s]/i,/(joli|[kxln]?ubuntu|debian|[open]*suse|gentoo|(?=\s)arch|slackware|fedora|mandriva|centos|pclinuxos|redhat|zenwalk|linpus)[\/\s-]?(?!chrom)([\w\.-]+)*/i,/(hurd|linux)\s?([\w\.]+)*/i,/(gnu)\s?([\w\.]+)*/i],[u,f],[/(cros)\s[\w]+\s([\w\.]+\w)/i],[[u,"Chromium OS"],f],[/(sunos)\s?([\w\.]+\d)*/i],[[u,"Solaris"],f],[/\s([frentopc-]{0,4}bsd|dragonfly)\s?([\w\.]+)*/i],[u,f],[/(haiku)\s(\w+)/i],[u,f],[/(ip[honead]+)(?:.*os\s([\w]+)*\slike\smac|;\sopera)/i],[[u,"iOS"],[f,/_/g,"."]],[/(mac\sos\sx)\s?([\w\s\.]+\w)*/i,/(macintosh|mac(?=_powerpc)\s)/i],[[u,"Mac OS"],[f,/_/g,"."]],[/((?:open)?solaris)[\/\s-]?([\w\.]+)*/i,/(aix)\s((\d)(?=\.|\)|\s)[\w\.]*)*/i,/(plan\s9|minix|beos|os\/2|amigaos|morphos|risc\sos|openvms)/i,/(unix)\s?([\w\.]+)*/i],[u,f]]},m=function t(e,n){if(!(this instanceof t))return new t(e,n).getResult();var r=e||(i&&i.navigator&&i.navigator.userAgent?i.navigator.userAgent:""),o=n?g.extend(y,n):y;return this.getBrowser=function(){var t=M.rgx.apply(this,o.browser);return t.major=g.major(t.version),t},this.getCPU=function(){return M.rgx.apply(this,o.cpu)},this.getDevice=function(){return M.rgx.apply(this,o.device)},this.getEngine=function(){return M.rgx.apply(this,o.engine)},this.getOS=function(){return M.rgx.apply(this,o.os)},this.getResult=function(){return{ua:this.getUA(),browser:this.getBrowser(),engine:this.getEngine(),os:this.getOS(),device:this.getDevice(),cpu:this.getCPU()}},this.getUA=function(){return r},this.setUA=function(t){return r=t,this},this};m.VERSION="0.7.12",m.BROWSER={NAME:u,MAJOR:"major",VERSION:f},m.CPU={ARCHITECTURE:"architecture"},m.DEVICE={MODEL:s,VENDOR:l,TYPE:c,CONSOLE:"console",MOBILE:p,SMARTTV:"smarttv",TABLET:d,WEARABLE:"wearable",EMBEDDED:"embedded"},m.ENGINE={NAME:u,VERSION:f},m.OS={NAME:u,VERSION:f},"undefined"!==o(e)?("undefined"!==o(t)&&t.exports&&(e=t.exports=m),e.UAParser=m):"function"===o(n(101))&&n(38)?void 0!==(r=function(){return m}.call(e,n,e,t))&&(t.exports=r):i.UAParser=m;var I=i.jQuery||i.Zepto;if("undefined"!==(void 0===I?"undefined":o(I))){var w=new m;I.ua=w.getResult(),I.ua.get=function(){return w.getUA()},I.ua.set=function(t){w.setUA(t);var e=w.getResult();for(var n in e)I.ua[n]=e[n]}}}("object"===("undefined"==typeof window?"undefined":o(window))?window:void 0)}).call(e,n(100)(t))},function(t,e,n){"use strict";t.exports=function(t){return t.webpackPolyfill||(t.deprecate=function(){},t.paths=[],t.children||(t.children=[]),Object.defineProperty(t,"loaded",{enumerable:!0,get:function(){return t.l}}),Object.defineProperty(t,"id",{enumerable:!0,get:function(){return t.i}}),t.webpackPolyfill=1),t}},function(t,e){t.exports=function(){throw new Error("define cannot be used indirect")}},function(t,e,n){"use strict";function r(t,e){var n=t.split(v);return n.length>1?n.some(function(t){return T.contains(t,e)}):(t=n[0].trim(),o(t,e))}function o(t,e){var n=t.split(C);if(n.length>0&&n.length<=2||D(!1),1===n.length)return i(n[0],e);var r=n[0],o=n[1];return g(r)&&g(o)||D(!1),i(">="+r,e)&&i("<="+o,e)}function i(t,e){if(""===(t=t.trim()))return!0;var n=e.split(N),r=p(t),o=r.modifier,i=r.rangeComponents;switch(o){case"<":return a(n,i);case"<=":return s(n,i);case">=":return c(n,i);case">":return l(n,i);case"~":case"~>":return f(n,i);default:return u(n,i)}}function a(t,e){return-1===I(t,e)}function s(t,e){var n=I(t,e);return-1===n||0===n}function u(t,e){return 0===I(t,e)}function c(t,e){var n=I(t,e);return 1===n||0===n}function l(t,e){return 1===I(t,e)}function f(t,e){var n=e.slice(),r=e.slice();r.length>1&&r.pop();var o=r.length-1,i=parseInt(r[o],10);return d(i)&&(r[o]=i+1+""),c(t,n)&&a(t,r)}function p(t){var e=t.split(N),n=e[0].match(j);return n||D(!1),{modifier:n[1],rangeComponents:[n[2]].concat(e.slice(1))}}function d(t){return!isNaN(t)&&isFinite(t)}function g(t){return!p(t).modifier}function M(t,e){for(var n=t.length;n<e;n++)t[n]="0"}function h(t,e){t=t.slice(),e=e.slice(),M(t,e.length);for(var n=0;n<e.length;n++){var r=e[n].match(/^[x*]$/i);if(r&&(e[n]=t[n]="0","*"===r[0]&&n===e.length-1))for(var o=n;o<t.length;o++)t[o]="0"}return M(e,t.length),[t,e]}function y(t,e){var n=t.match(z)[1],r=e.match(z)[1],o=parseInt(n,10),i=parseInt(r,10);return d(o)&&d(i)&&o!==i?m(o,i):m(t,e)}function m(t,e){return(void 0===t?"undefined":w(t))!==(void 0===e?"undefined":w(e))&&D(!1),t>e?1:t<e?-1:0}function I(t,e){for(var n=h(t,e),r=n[0],o=n[1],i=0;i<o.length;i++){var a=y(r[i],o[i]);if(a)return a}return 0}var w="function"==typeof Symbol&&"symbol"==typeof Symbol.iterator?function(t){return typeof t}:function(t){return t&&"function"==typeof Symbol&&t.constructor===Symbol&&t!==Symbol.prototype?"symbol":typeof t},D=n(2),N=/\./,v=/\|\|/,C=/\s+\-\s+/,j=/^(<=|<|=|>=|~>|~|>|)?\s*(.+)/,z=/^(\d*)(.*)/,T={contains:function(t,e){return r(t.trim(),e.trim())}};t.exports=T},function(t,e,n){"use strict";function r(t,e,n){if(!t)return null;var r={};for(var i in t)o.call(t,i)&&(r[i]=e.call(n,t[i],i,t));return r}var o=Object.prototype.hasOwnProperty;t.exports=r},function(t,e,n){"use strict";function r(t){var e={};return function(n){return e.hasOwnProperty(n)||(e[n]=t.call(this,n)),e[n]}}t.exports=r},function(t,e,n){"use strict";(function(e){function r(t){if(!t)return"[empty]";var e=o(t);return e.nodeType===Node.TEXT_NODE?e.textContent:(e instanceof Element||d(!1),e.innerHTML)}function o(t){if(t.nodeType===Node.TEXT_NODE){var e=t.textContent.length;return document.createTextNode("[text "+e+"]")}for(var n=t.cloneNode(),r=t.childNodes,i=0;i<r.length;i++)n.appendChild(o(r[i]));return n}function i(t){for(var e=t;e;){if(e instanceof Element&&e.hasAttribute("contenteditable"))return r(e);e=e.parentNode}return"Could not find contentEditable parent of node"}function a(t){return null===t.nodeValue?t.childNodes.length:t.nodeValue.length}function s(t,n,r,o,i){if(f(document.documentElement,n)){var a=e.getSelection(),s=t.getAnchorKey(),l=t.getAnchorOffset(),p=t.getFocusKey(),d=t.getFocusOffset(),g=t.getIsBackward();if(!a.extend&&g){var M=s,h=l;s=p,l=d,p=M,d=h,g=!1}var y=s===r&&o<=l&&i>=l,m=p===r&&o<=d&&i>=d;if(y&&m)return a.removeAllRanges(),c(a,n,l-o,t),void u(a,n,d-o,t);if(g){if(m&&(a.removeAllRanges(),c(a,n,d-o,t)),y){var I=a.focusNode,w=a.focusOffset;a.removeAllRanges(),c(a,n,l-o,t),u(a,I,w,t)}}else y&&(a.removeAllRanges(),c(a,n,l-o,t)),m&&u(a,n,d-o,t)}}function u(t,e,n,r){if(t.extend&&f(p(),e))n>a(e)&&l.logSelectionStateFailure({anonymizedDom:i(e),extraParams:JSON.stringify({offset:n}),selectionState:JSON.stringify(r.toJS())}),t.extend(e,n);else{var o=t.getRangeAt(0);o.setEnd(e,n),t.addRange(o.cloneRange())}}function c(t,e,n,r){var o=document.createRange();n>a(e)&&l.logSelectionStateFailure({anonymizedDom:i(e),extraParams:JSON.stringify({offset:n}),selectionState:JSON.stringify(r.toJS())}),o.setStart(e,n),t.addRange(o)}var l=n(106),f=n(53),p=n(54),d=n(2);t.exports=s}).call(e,n(15))},function(t,e,n){"use strict";t.exports={logSelectionStateFailure:function(){return null}}},function(t,e,n){"use strict";function r(t){return o(t)&&3==t.nodeType}var o=n(108);t.exports=r},function(t,e,n){"use strict";function r(t){var e=t?t.ownerDocument||t:document,n=e.defaultView||window;return!(!t||!("function"==typeof n.Node?t instanceof n.Node:"object"===(void 0===t?"undefined":o(t))&&"number"==typeof t.nodeType&&"string"==typeof t.nodeName))}var o="function"==typeof Symbol&&"symbol"==typeof Symbol.iterator?function(t){return typeof t}:function(t){return t&&"function"==typeof Symbol&&t.constructor===Symbol&&t!==Symbol.prototype?"symbol":typeof t};t.exports=r},function(t,e,n){"use strict";function r(t){return null==t?t:String(t)}function o(t,e){var n=void 0;if(window.getComputedStyle&&(n=window.getComputedStyle(t,null)))return r(n.getPropertyValue(a(e)));if(document.defaultView&&document.defaultView.getComputedStyle){if(n=document.defaultView.getComputedStyle(t,null))return r(n.getPropertyValue(a(e)));if("display"===e)return"none"}return r(t.currentStyle?"float"===e?t.currentStyle.cssFloat||t.currentStyle.styleFloat:t.currentStyle[i(e)]:t.style&&t.style[i(e)])}var i=n(110),a=n(111);t.exports=o},function(t,e,n){"use strict";function r(t){return t.replace(o,function(t,e){return e.toUpperCase()})}var o=/-(.)/g;t.exports=r},function(t,e,n){"use strict";function r(t){return t.replace(o,"-$1").toLowerCase()}var o=/([A-Z])/g;t.exports=r},function(t,e,n){"use strict";function r(t){var e=o(t);return{x:e.left,y:e.top,width:e.right-e.left,height:e.bottom-e.top}}var o=n(113);t.exports=r},function(t,e,n){"use strict";function r(t){var e=t.ownerDocument.documentElement;if(!("getBoundingClientRect"in t&&o(e,t)))return{left:0,right:0,top:0,bottom:0};var n=t.getBoundingClientRect();return{left:Math.round(n.left)-e.clientLeft,right:Math.round(n.right)-e.clientLeft,top:Math.round(n.top)-e.clientTop,bottom:Math.round(n.bottom)-e.clientTop}}var o=n(53);t.exports=r},function(t,e,n){"use strict";function r(t){return t=t||document,o||"CSS1Compat"!==t.compatMode?t.body:t.documentElement}var o="undefined"!=typeof navigator&&navigator.userAgent.indexOf("AppleWebKit")>-1;t.exports=r},function(t,e,n){"use strict";function r(t){return t.Window&&t instanceof t.Window?{x:t.pageXOffset||t.document.documentElement.scrollLeft,y:t.pageYOffset||t.document.documentElement.scrollTop}:{x:t.scrollLeft,y:t.scrollTop}}t.exports=r},function(t,e,n){"use strict";function r(){var t=void 0;return document.documentElement&&(t=document.documentElement.clientWidth),!t&&document.body&&(t=document.body.clientWidth),t||0}function o(){var t=void 0;return document.documentElement&&(t=document.documentElement.clientHeight),!t&&document.body&&(t=document.body.clientHeight),t||0}function i(){return{width:window.innerWidth||r(),height:window.innerHeight||o()}}i.withoutScrollbars=function(){return{width:r(),height:o()}},t.exports=i},function(t,e,n){"use strict";function r(t){t||(t="");var e=void 0,n=arguments.length;if(n>1)for(var r=1;r<n;r++)(e=arguments[r])&&(t=(t?t+" ":"")+e);return t}t.exports=r},function(t,e,n){"use strict";function r(t,e){var n=null,r=null;if("function"==typeof document.caretRangeFromPoint){var o=document.caretRangeFromPoint(t.x,t.y);n=o.startContainer,r=o.startOffset}else{if(!t.rangeParent)return null;n=t.rangeParent,r=t.rangeOffset}n=p(n),r=p(r);var i=p(c(n));return f(e,i,r,i,r)}function o(t,e){var n=s.moveText(t.getCurrentContent(),t.getSelection(),e);return u.push(t,n,"insert-fragment")}function i(t,e,n){var r=s.insertText(t.getCurrentContent(),e,n,t.getCurrentInlineStyle());return u.push(t,r,"insert-fragment")}var a=n(56),s=n(7),u=n(3),c=n(41),l=n(58),f=n(59),p=n(8),d=n(31),g={onDragEnd:function(t){t.exitCurrentMode()},onDrop:function(t,e){var n=new a(e.nativeEvent.dataTransfer),s=t._latestEditorState,u=r(e.nativeEvent,s);if(e.preventDefault(),t.exitCurrentMode(),null!=u){var c=n.getFiles();if(c.length>0){if(t.props.handleDroppedFiles&&d(t.props.handleDroppedFiles(u,c)))return;return void l(c,function(e){e&&t.update(i(s,u,e))})}var f=t._internalDrag?"internal":"external";if(!t.props.handleDrop||!d(t.props.handleDrop(u,n,f)))return t._internalDrag?void t.update(o(s,u)):void t.update(i(s,u,n.getText()))}}};t.exports=g},function(t,e,n){"use strict";function r(t){return t.split("/")}var o={isImage:function(t){return"image"===r(t)[0]},isJpeg:function(t){var e=r(t);return o.isImage(t)&&("jpeg"===e[1]||"pjpeg"===e[1])}};t.exports=o},function(t,e,n){"use strict";function r(t){var e=t.length;if((Array.isArray(t)||"object"!==(void 0===t?"undefined":a(t))&&"function"!=typeof t)&&s(!1),"number"!=typeof e&&s(!1),0===e||e-1 in t||s(!1),"function"==typeof t.callee&&s(!1),t.hasOwnProperty)try{return Array.prototype.slice.call(t)}catch(t){}for(var n=Array(e),r=0;r<e;r++)n[r]=t[r];return n}function o(t){return!!t&&("object"==(void 0===t?"undefined":a(t))||"function"==typeof t)&&"length"in t&&!("setInterval"in t)&&"number"!=typeof t.nodeType&&(Array.isArray(t)||"callee"in t||"item"in t)}function i(t){return o(t)?Array.isArray(t)?t.slice():r(t):[t]}var a="function"==typeof Symbol&&"symbol"==typeof Symbol.iterator?function(t){return typeof t}:function(t){return t&&"function"==typeof Symbol&&t.constructor===Symbol&&t!==Symbol.prototype?"symbol":typeof t},s=n(2);t.exports=i},function(t,e,n){"use strict";var r=n(122),o=n(126),i=n(127),a=n(128),s=n(129),u=n(130),c=n(131),l=n(132),f=n(133),p=n(134),d=n(148),g=n(152),M={onBeforeInput:r,onBlur:o,onCompositionStart:i,onCopy:a,onCut:s,onDragOver:u,onDragStart:c,onFocus:l,onInput:f,onKeyDown:p,onPaste:d,onSelect:g};t.exports=M},function(t,e,n){"use strict";function r(t){return y&&(t==M||t==h)}function o(t,e,n,r){var o=s.replaceText(t.getCurrentContent(),t.getSelection(),e,n,r);return u.push(t,o,"insert-characters")}function i(t,e){void 0!==t._pendingStateFromBeforeInput&&(t.update(t._pendingStateFromBeforeInput),t._pendingStateFromBeforeInput=void 0);var n=t._latestEditorState,i=e.data;if(i){if(t.props.handleBeforeInput&&g(t.props.handleBeforeInput(i,n)))return void e.preventDefault();var s=n.getSelection();if(!s.isCollapsed())return e.preventDefault(),void t.update(o(n,i,n.getCurrentInlineStyle(),l(n.getCurrentContent(),n.getSelection())));var c=!f(n),M=o(n,i,n.getCurrentInlineStyle(),l(n.getCurrentContent(),n.getSelection()));if(!c)return e.preventDefault(),void t.update(M);var h=s.getAnchorKey(),y=n.getBlockTree(h),m=a.getFingerprint(y),I=a.getFingerprint(M.getBlockTree(h));r(i)||m!==I||p(M.getDirectionMap()).get(h)!==p(n.getDirectionMap()).get(h)?(e.preventDefault(),t.update(M)):(M=u.set(M,{nativelyRenderedContent:M.getCurrentContent()}),t._pendingStateFromBeforeInput=M,d(function(){void 0!==t._pendingStateFromBeforeInput&&(t.update(t._pendingStateFromBeforeInput),t._pendingStateFromBeforeInput=void 0)}))}}var a=n(47),s=n(7),u=n(3),c=n(13),l=n(37),f=n(51),p=n(8),d=n(123),g=n(31),M="'",h="/",y=c.isBrowser("Firefox");t.exports=i},function(t,e,n){"use strict";(function(e){n(124),t.exports=e.setImmediate}).call(e,n(15))},function(t,e,n){"use strict";(function(t,e){!function(t,n){function r(t){"function"!=typeof t&&(t=new Function(""+t));for(var e=new Array(arguments.length-1),n=0;n<e.length;n++)e[n]=arguments[n+1];var r={callback:t,args:e};return c[u]=r,s(u),u++}function o(t){delete c[t]}function i(t){var e=t.callback,r=t.args;switch(r.length){case 0:e();break;case 1:e(r[0]);break;case 2:e(r[0],r[1]);break;case 3:e(r[0],r[1],r[2]);break;default:e.apply(n,r)}}function a(t){if(l)setTimeout(a,0,t);else{var e=c[t];if(e){l=!0;try{i(e)}finally{o(t),l=!1}}}}if(!t.setImmediate){var s,u=1,c={},l=!1,f=t.document,p=Object.getPrototypeOf&&Object.getPrototypeOf(t);p=p&&p.setTimeout?p:t,"[object process]"==={}.toString.call(t.process)?function(){s=function(t){e.nextTick(function(){a(t)})}}():function(){if(t.postMessage&&!t.importScripts){var e=!0,n=t.onmessage;return t.onmessage=function(){e=!1},t.postMessage("","*"),t.onmessage=n,e}}()?function(){var e="setImmediate$"+Math.random()+"$",n=function(n){n.source===t&&"string"==typeof n.data&&0===n.data.indexOf(e)&&a(+n.data.slice(e.length))};t.addEventListener?t.addEventListener("message",n,!1):t.attachEvent("onmessage",n),s=function(n){t.postMessage(e+n,"*")}}():t.MessageChannel?function(){var t=new MessageChannel;t.port1.onmessage=function(t){a(t.data)},s=function(e){t.port2.postMessage(e)}}():f&&"onreadystatechange"in f.createElement("script")?function(){var t=f.documentElement;s=function(e){var n=f.createElement("script");n.onreadystatechange=function(){a(e),n.onreadystatechange=null,t.removeChild(n),n=null},t.appendChild(n)}}():function(){s=function(t){setTimeout(a,0,t)}}(),p.setImmediate=r,p.clearImmediate=o}}("undefined"==typeof self?void 0===t?void 0:t:self)}).call(e,n(15),n(125))},function(t,e,n){"use strict";function r(){throw new Error("setTimeout has not been defined")}function o(){throw new Error("clearTimeout has not been defined")}function i(t){if(f===setTimeout)return setTimeout(t,0);if((f===r||!f)&&setTimeout)return f=setTimeout,setTimeout(t,0);try{return f(t,0)}catch(e){try{return f.call(null,t,0)}catch(e){return f.call(this,t,0)}}}function a(t){if(p===clearTimeout)return clearTimeout(t);if((p===o||!p)&&clearTimeout)return p=clearTimeout,clearTimeout(t);try{return p(t)}catch(e){try{return p.call(null,t)}catch(e){return p.call(this,t)}}}function s(){h&&g&&(h=!1,g.length?M=g.concat(M):y=-1,M.length&&u())}function u(){if(!h){var t=i(s);h=!0;for(var e=M.length;e;){for(g=M,M=[];++y<e;)g&&g[y].run();y=-1,e=M.length}g=null,h=!1,a(t)}}function c(t,e){this.fun=t,this.array=e}function l(){}var f,p,d=t.exports={};!function(){try{f="function"==typeof setTimeout?setTimeout:r}catch(t){f=r}try{p="function"==typeof clearTimeout?clearTimeout:o}catch(t){p=o}}();var g,M=[],h=!1,y=-1;d.nextTick=function(t){var e=new Array(arguments.length-1);if(arguments.length>1)for(var n=1;n<arguments.length;n++)e[n-1]=arguments[n];M.push(new c(t,e)),1!==M.length||h||i(u)},c.prototype.run=function(){this.fun.apply(null,this.array)},d.title="browser",d.browser=!0,d.env={},d.argv=[],d.version="",d.versions={},d.on=l,d.addListener=l,d.once=l,d.off=l,d.removeListener=l,d.removeAllListeners=l,d.emit=l,d.binding=function(t){throw new Error("process.binding is not supported")},d.cwd=function(){return"/"},d.chdir=function(t){throw new Error("process.chdir is not supported")},d.umask=function(){return 0}},function(t,e,n){"use strict";(function(e){function r(t,n){s&&a()===document.body&&e.getSelection().removeAllRanges();var r=t._latestEditorState,i=r.getSelection();if(i.getHasFocus()){var u=i.set("hasFocus",!1);t.props.onBlur&&t.props.onBlur(n),t.update(o.acceptSelection(r,u))}}var o=n(3),i=n(13),a=n(54),s=i.isEngine("WebKit");t.exports=r}).call(e,n(15))},function(t,e,n){"use strict";function r(t,e){t.setMode("composite"),t.update(o.set(t._latestEditorState,{inCompositionMode:!0})),t._onCompositionStart(e)}var o=n(3);t.exports=r},function(t,e,n){"use strict";function r(t,e){if(t._latestEditorState.getSelection().isCollapsed())return void e.preventDefault();t.setClipboard(o(t._latestEditorState))}var o=n(60);t.exports=r},function(t,e,n){"use strict";function r(t,e){var n=t._latestEditorState;if(n.getSelection().isCollapsed())return void e.preventDefault();var r=s.getScrollParent(e.target),i=c(r),a=i.x,l=i.y,f=u(n);t.setClipboard(f),t.setMode("cut"),setTimeout(function(){t.restoreEditorDOM({x:a,y:l}),t.exitCurrentMode(),t.update(o(n))},0)}function o(t){var e=i.removeRange(t.getCurrentContent(),t.getSelection(),"forward");return a.push(t,e,"remove-range")}var i=n(7),a=n(3),s=n(39),u=n(60),c=n(40);t.exports=r},function(t,e,n){"use strict";function r(t,e){t._internalDrag=!1,t.setMode("drag"),e.preventDefault()}t.exports=r},function(t,e,n){"use strict";function r(t){t._internalDrag=!0,t.setMode("drag")}t.exports=r},function(t,e,n){"use strict";function r(t,e){var n=t._latestEditorState,r=n.getSelection();if(!r.getHasFocus()){var i=r.set("hasFocus",!0);t.props.onFocus&&t.props.onFocus(e),t.update(o.forceSelection(n,i))}}var o=n(3);t.exports=r},function(t,e,n){"use strict";(function(e){function r(t){void 0!==t._pendingStateFromBeforeInput&&(t.update(t._pendingStateFromBeforeInput),t._pendingStateFromBeforeInput=void 0);var n=e.getSelection(),r=n.anchorNode,u=n.isCollapsed,d=r.nodeType!==Node.TEXT_NODE,g=r.nodeType!==Node.TEXT_NODE&&r.nodeType!==Node.ELEMENT_NODE;if(o.draft_killswitch_allow_nontextnodes){if(d)return}else if(g)return;if(r.nodeType===Node.TEXT_NODE&&(null!==r.previousSibling||null!==r.nextSibling)){var M=r.parentNode;r.nodeValue=M.textContent;for(var h=M.firstChild;null!==h;h=h.nextSibling)h!==r&&M.removeChild(h)}var y=r.textContent,m=t._latestEditorState,I=l(c(r)),w=a.decode(I),D=w.blockKey,N=w.decoratorKey,v=w.leafKey,C=m.getBlockTree(D).getIn([N,"leaves",v]),j=C.start,z=C.end,T=m.getCurrentContent(),A=T.getBlockForKey(D),E=A.getText().slice(j,z);if(y.endsWith(p)&&(y=y.slice(0,-1)),y!==E){var S,b,x,O,_=m.getSelection(),k=_.merge({anchorOffset:j,focusOffset:z,isBackward:!1}),L=A.getEntityAt(j),U=L&&T.getEntity(L),Q=U&&U.getMutability(),Y="MUTABLE"===Q,B=Y?"spellcheck-change":"apply-entity",P=i.replaceText(T,k,y,A.getInlineStyleAt(j),Y?A.getEntityAt(j):null);if(f)S=n.anchorOffset,b=n.focusOffset,x=j+Math.min(S,b),O=x+Math.abs(S-b),S=x,b=O;else{var R=y.length-E.length;x=_.getStartOffset(),O=_.getEndOffset(),S=u?O+R:x,b=O+R}var Z=P.merge({selectionBefore:T.getSelectionAfter(),selectionAfter:_.merge({anchorOffset:S,focusOffset:b})});t.update(s.push(m,Z,B))}}var o=n(44),i=n(7),a=n(30),s=n(3),u=n(13),c=n(41),l=n(8),f=u.isEngine("Gecko"),p="\n\n";t.exports=r}).call(e,n(15))},function(t,e,n){"use strict";function r(t,e){switch(t){case"redo":return a.redo(e);case"delete":return h(e);case"delete-word":return d(e);case"backspace":return M(e);case"backspace-word":return p(e);case"backspace-to-start-of-line":return f(e);case"split-block":return g(e);case"transpose-characters":return I(e);case"move-selection-to-start-of-block":return m(e);case"move-selection-to-end-of-block":return y(e);case"secondary-cut":return c.cut(e);case"secondary-paste":return c.paste(e);default:return e}}function o(t,e){var n=e.which,o=t._latestEditorState;switch(n){case u.RETURN:if(e.preventDefault(),t.props.handleReturn&&D(t.props.handleReturn(e,o)))return;break;case u.ESC:return e.preventDefault(),void(t.props.onEscape&&t.props.onEscape(e));case u.TAB:return void(t.props.onTab&&t.props.onTab(e));case u.UP:return void(t.props.onUpArrow&&t.props.onUpArrow(e));case u.DOWN:return void(t.props.onDownArrow&&t.props.onDownArrow(e));case u.SPACE:if(v&&N(e)){e.preventDefault();var s=i.replaceText(o.getCurrentContent(),o.getSelection()," ");return void t.update(a.push(o,s,"insert-characters"))}}var c=t.props.keyBindingFn(e);if(c){if("undo"===c)return void w(e,o,t.update);if(e.preventDefault(),!t.props.handleKeyCommand||!D(t.props.handleKeyCommand(c,o))){var l=r(c,o);l!==o&&t.update(l)}}}var i=n(7),a=n(3),s=n(42),u=n(36),c=n(135),l=n(13),f=n(136),p=n(138),d=n(140),g=n(141),M=n(142),h=n(143),y=n(144),m=n(145),I=n(146),w=n(147),D=n(31),N=s.isOptionKeyCommand,v=l.isBrowser("Chrome");t.exports=o},function(t,e,n){"use strict";var r=n(7),o=n(3),i=n(28),a=n(8),s=null,u={cut:function(t){var e=t.getCurrentContent(),n=t.getSelection(),u=null;if(n.isCollapsed()){var c=n.getAnchorKey(),l=e.getBlockForKey(c).getLength();if(l===n.getAnchorOffset())return t;u=n.set("focusOffset",l)}else u=n;u=a(u),s=i(e,u);var f=r.removeRange(e,u,"forward");return f===e?t:o.push(t,f,"remove-range")},paste:function(t){if(!s)return t;var e=r.replaceWithFragment(t.getCurrentContent(),t.getSelection(),s);return o.push(t,e,"insert-fragment")}};t.exports=u},function(t,e,n){"use strict";(function(e){function r(t){var n=u(t,function(t){var n=t.getSelection();if(n.isCollapsed()&&0===n.getAnchorOffset())return s(t,1);var r=e.getSelection(),o=r.getRangeAt(0);return o=i(o),a(t,null,o.endContainer,o.endOffset,o.startContainer,o.startOffset).selectionState},"backward");return n===t.getCurrentContent()?t:o.push(t,n,"remove-range")}var o=n(3),i=n(137),a=n(62),s=n(43),u=n(25);t.exports=r}).call(e,n(15))},function(t,e,n){"use strict";function r(t){var e=getComputedStyle(t),n=document.createElement("div");n.style.fontFamily=e.fontFamily,n.style.fontSize=e.fontSize,n.style.fontStyle=e.fontStyle,n.style.fontWeight=e.fontWeight,n.style.lineHeight=e.lineHeight,n.style.position="absolute",n.textContent="M";var r=document.body;r||c(!1),r.appendChild(n);var o=n.getBoundingClientRect();return r.removeChild(n),o.height}function o(t,e){for(var n=1/0,r=1/0,o=-1/0,i=-1/0,a=0;a<t.length;a++){var s=t[a];0!==s.width&&1!==s.width&&(n=Math.min(n,s.top),r=Math.min(r,s.bottom),o=Math.max(o,s.top),i=Math.max(i,s.bottom))}return o<=r&&o-n<e&&i-r<e}function i(t){switch(t.nodeType){case Node.DOCUMENT_TYPE_NODE:return 0;case Node.TEXT_NODE:case Node.PROCESSING_INSTRUCTION_NODE:case Node.COMMENT_NODE:return t.length;default:return t.childNodes.length}}function a(t){t.collapsed||c(!1),t=t.cloneRange();var e=t.startContainer;1!==e.nodeType&&(e=e.parentNode);var n=r(e),a=t.endContainer,l=t.endOffset;for(t.setStart(t.startContainer,0);o(u(t),n)&&(a=t.startContainer,l=t.startOffset,a.parentNode||c(!1),t.setStartBefore(a),1!==a.nodeType||"inline"===getComputedStyle(a).display););for(var f=a,p=l-1;;){for(var d=f.nodeValue,g=p;g>=0;g--)if(!(null!=d&&g>0&&s.isSurrogatePair(d,g-1))){if(t.setStart(f,g),!o(u(t),n))break;a=f,l=g}if(-1===g||0===f.childNodes.length)break;f=f.childNodes[g],p=i(f)}return t.setStart(a,l),t}var s=n(19),u=n(61),c=n(2);t.exports=a},function(t,e,n){"use strict";function r(t){var e=s(t,function(t){var e=t.getSelection(),n=e.getStartOffset();if(0===n)return a(t,1);var r=e.getStartKey(),i=t.getCurrentContent(),s=i.getBlockForKey(r).getText().slice(0,n),u=o.getBackward(s);return a(t,u.length||1)},"backward");return e===t.getCurrentContent()?t:i.push(t,e,"remove-range")}var o=n(63),i=n(3),a=n(43),s=n(25);t.exports=r},function(t,e,n){"use strict";t.exports={getPunctuation:function(){return"[.,+*?$|#{}()'\\^\\-\\[\\]\\\\\\/!@%\"~=<>_:;・、。〈-】〔-〟：-？！-／［-｀｛-･⸮؟٪-٬؛،؍﴾﴿᠁।၊။‐-‧‰-⁞¡-±´-¸º»¿]"}}},function(t,e,n){"use strict";function r(t){var e=s(t,function(t){var e=t.getSelection(),n=e.getStartOffset(),r=e.getStartKey(),i=t.getCurrentContent(),s=i.getBlockForKey(r).getText().slice(n),u=o.getForward(s);return a(t,u.length||1)},"forward");return e===t.getCurrentContent()?t:i.push(t,e,"remove-range")}var o=n(63),i=n(3),a=n(64),s=n(25);t.exports=r},function(t,e,n){"use strict";function r(t){var e=o.splitBlock(t.getCurrentContent(),t.getSelection());return i.push(t,e,"split-block")}var o=n(7),i=n(3);t.exports=r},function(t,e,n){"use strict";function r(t){var e=s(t,function(t){var e=t.getSelection(),n=t.getCurrentContent(),r=e.getAnchorKey(),o=e.getAnchorOffset(),s=n.getBlockForKey(r).getText()[o-1];return a(t,s?i.getUTF16Length(s,0):1)},"backward");if(e===t.getCurrentContent())return t;var n=t.getSelection();return o.push(t,e.set("selectionBefore",n),n.isCollapsed()?"backspace-character":"remove-range")}var o=n(3),i=n(19),a=n(43),s=n(25);t.exports=r},function(t,e,n){"use strict";function r(t){var e=s(t,function(t){var e=t.getSelection(),n=t.getCurrentContent(),r=e.getAnchorKey(),o=e.getAnchorOffset(),s=n.getBlockForKey(r).getText()[o];return a(t,s?i.getUTF16Length(s,0):1)},"forward");if(e===t.getCurrentContent())return t;var n=t.getSelection();return o.push(t,e.set("selectionBefore",n),n.isCollapsed()?"delete-character":"remove-range")}var o=n(3),i=n(19),a=n(64),s=n(25);t.exports=r},function(t,e,n){"use strict";function r(t){var e=t.getSelection(),n=e.getEndKey(),r=t.getCurrentContent(),i=r.getBlockForKey(n).getLength();return o.set(t,{selection:e.merge({anchorKey:n,anchorOffset:i,focusKey:n,focusOffset:i,isBackward:!1}),forceSelection:!0})}var o=n(3);t.exports=r},function(t,e,n){"use strict";function r(t){var e=t.getSelection(),n=e.getStartKey();return o.set(t,{selection:e.merge({anchorKey:n,anchorOffset:0,focusKey:n,focusOffset:0,isBackward:!1}),forceSelection:!0})}var o=n(3);t.exports=r},function(t,e,n){"use strict";function r(t){var e=t.getSelection();if(!e.isCollapsed())return t;var n=e.getAnchorOffset();if(0===n)return t;var r=e.getAnchorKey(),s=t.getCurrentContent(),u=s.getBlockForKey(r),c=u.getLength();if(c<=1)return t;var l,f;n===c?(l=e.set("anchorOffset",n-1),f=e):(l=e.set("focusOffset",n+1),f=l.set("anchorOffset",n+1));var p=a(s,l),d=o.removeRange(s,l,"backward"),g=d.getSelectionAfter(),M=g.getAnchorOffset()-1,h=g.merge({anchorOffset:M,focusOffset:M}),y=o.replaceWithFragment(d,h,p),m=i.push(t,y,"insert-fragment");return i.acceptSelection(m,f)}var o=n(7),i=n(3),a=n(28);t.exports=r},function(t,e,n){"use strict";function r(t,e,n){var r=o.undo(e);if("spellcheck-change"===e.getLastChangeType()){var i=r.getCurrentContent();return void n(o.set(r,{nativelyRenderedContent:i}))}if(t.preventDefault(),!e.getNativelyRenderedContent())return void n(r);n(o.set(e,{nativelyRenderedContent:null})),setTimeout(function(){n(r)},0)}var o=n(3);t.exports=r},function(t,e,n){"use strict";function r(t,e){e.preventDefault();var n=new u(e.clipboardData);if(!n.isRichText()){var r=n.getFiles(),h=n.getText();if(r.length>0){if(t.props.handlePastedFiles&&g(t.props.handlePastedFiles(r)))return;return void d(r,function(e){if(e=e||h){var n=t._latestEditorState,r=M(e),o=s.create({style:n.getCurrentInlineStyle(),entity:p(n.getCurrentContent(),n.getSelection())}),i=l.processText(r,o),u=a.createFromArray(i),d=c.replaceWithFragment(n.getCurrentContent(),n.getSelection(),u);t.update(f.push(n,d,"insert-fragment"))}})}}var y=[],m=n.getText(),I=n.getHTML(),w=t._latestEditorState;if(!t.props.handlePastedText||!g(t.props.handlePastedText(m,I,w))){if(m&&(y=M(m)),!t.props.stripPastedStyles){var D=t.getClipboard();if(n.isRichText()&&D){if(-1!==I.indexOf(t.getEditorKey())||1===y.length&&1===D.size&&D.first().getText()===m)return void t.update(o(t._latestEditorState,D))}else if(D&&n.types.includes("com.apple.webarchive")&&!n.types.includes("text/html")&&i(y,D))return void t.update(o(t._latestEditorState,D));if(I){var N=l.processHTML(I,t.props.blockRenderMap);if(N){var v=N.contentBlocks,C=N.entityMap;if(v){var j=a.createFromArray(v);return void t.update(o(t._latestEditorState,j,C))}}}t.setClipboard(null)}if(y.length){var z=s.create({style:w.getCurrentInlineStyle(),entity:p(w.getCurrentContent(),w.getSelection())}),T=l.processText(y,z),A=a.createFromArray(T);t.update(o(t._latestEditorState,A))}}}function o(t,e,n){var r=c.replaceWithFragment(t.getCurrentContent(),t.getSelection(),e);return f.push(t,r.set("entityMap",n),"insert-fragment")}function i(t,e){return t.length===e.size&&e.valueSeq().every(function(e,n){return e.getText()===t[n]})}var a=n(21),s=n(11),u=n(56),c=n(7),l=n(149),f=n(3),p=n(37),d=n(58),g=n(31),M=n(151);t.exports=r},function(t,e,n){"use strict";var r=(n(11),n(17)),o=n(4),i=n(65),a=n(12),s=n(66),u=n(33),c=o.List,l=o.Repeat,f={processHTML:function(t,e){return i(t,s,e)},processText:function(t,e){return t.map(function(t){return t=u(t),new r({key:a(),type:"unstyled",text:t,characterList:c(l(e,t.length))})})}};t.exports=f},function(t,e,n){"use strict";function r(t,e){if(!(t instanceof e))throw new TypeError("Cannot call a class as a function")}var o=function(){function t(e){r(this,t),this._uri=e}return t.prototype.toString=function(){return this._uri},t}();t.exports=o},function(t,e,n){"use strict";function r(t){return t.split(o)}var o=/\r\n?|\n/g;t.exports=r},function(t,e,n){"use strict";function r(t){if(!t._blockSelectEvents&&t._latestEditorState===t.props.editorState){var e=t.props.editorState,n=i.findDOMNode(t.refs.editorContainer);n||s(!1),n.firstChild instanceof HTMLElement||s(!1);var r=a(e,n.firstChild),u=r.selectionState;u!==e.getSelection()&&(e=r.needsRecovery?o.forceSelection(e,u):o.acceptSelection(e,u),t.update(e))}}var o=n(3),i=n(24),a=n(153),s=n(2);t.exports=r},function(t,e,n){"use strict";(function(e){function r(t,n){var r=e.getSelection();return 0===r.rangeCount?{selectionState:t.getSelection().set("hasFocus",!1),needsRecovery:!1}:o(t,n,r.anchorNode,r.anchorOffset,r.focusNode,r.focusOffset)}var o=n(62);t.exports=r}).call(e,n(15))},function(t,e,n){"use strict";function r(t,e){if(!(t instanceof e))throw new TypeError("Cannot call a class as a function")}function o(t,e){if(!t)throw new ReferenceError("this hasn't been initialised - super() hasn't been called");return!e||"object"!==(void 0===e?"undefined":a(e))&&"function"!=typeof e?t:e}function i(t,e){if("function"!=typeof e&&null!==e)throw new TypeError("Super expression must either be null or a function, not "+(void 0===e?"undefined":a(e)));t.prototype=Object.create(e&&e.prototype,{constructor:{value:t,enumerable:!1,writable:!0,configurable:!0}}),e&&(Object.setPrototypeOf?Object.setPrototypeOf(t,e):t.__proto__=e)}var a="function"==typeof Symbol&&"symbol"==typeof Symbol.iterator?function(t){return typeof t}:function(t){return t&&"function"==typeof Symbol&&t.constructor===Symbol&&t!==Symbol.prototype?"symbol":typeof t},s=n(0),u=n(23),c=function(t){function e(){return r(this,e),o(this,t.apply(this,arguments))}return i(e,t),e.prototype.shouldComponentUpdate=function(t){return this.props.text!==t.text||this.props.editorState.getSelection().getHasFocus()!==t.editorState.getSelection().getHasFocus()},e.prototype.render=function(){var t=this.props.editorState.getSelection().getHasFocus(),e=u({"public/DraftEditorPlaceholder/root":!0,"public/DraftEditorPlaceholder/hasFocus":t});return s.createElement("div",{className:e},s.createElement("div",{className:u("public/DraftEditorPlaceholder/inner"),id:this.props.accessibilityID},this.props.text))},e}(s.Component);t.exports=c},function(t,e,n){"use strict";var r=n(7),o=n(3),i=(n(22),n(156)),a=n(8),s={currentBlockContainsLink:function(t){var e=t.getSelection(),n=t.getCurrentContent(),r=n.getEntityMap();return n.getBlockForKey(e.getAnchorKey()).getCharacterList().slice(e.getStartOffset(),e.getEndOffset()).some(function(t){var e=t.getEntity();return!!e&&"LINK"===r.__get(e).getType()})},getCurrentBlockType:function(t){var e=t.getSelection();return t.getCurrentContent().getBlockForKey(e.getStartKey()).getType()},getDataObjectForLinkURL:function(t){return{url:t.toString()}},handleKeyCommand:function(t,e){switch(e){case"bold":return s.toggleInlineStyle(t,"BOLD");case"italic":return s.toggleInlineStyle(t,"ITALIC");case"underline":return s.toggleInlineStyle(t,"UNDERLINE");case"code":return s.toggleCode(t);case"backspace":case"backspace-word":case"backspace-to-start-of-line":return s.onBackspace(t);case"delete":case"delete-word":case"delete-to-end-of-block":return s.onDelete(t);default:return null}},insertSoftNewline:function(t){var e=r.insertText(t.getCurrentContent(),t.getSelection(),"\n",t.getCurrentInlineStyle(),null),n=o.push(t,e,"insert-characters");return o.forceSelection(n,e.getSelectionAfter())},onBackspace:function(t){var e=t.getSelection();if(!e.isCollapsed()||e.getAnchorOffset()||e.getFocusOffset())return null;var n=t.getCurrentContent(),r=e.getStartKey(),i=n.getBlockBefore(r);if(i&&"atomic"===i.getType()){var a=n.getBlockMap().delete(i.getKey()),u=n.merge({blockMap:a,selectionAfter:e});if(u!==n)return o.push(t,u,"remove-range")}var c=s.tryToRemoveBlockStyle(t);return c?o.push(t,c,"change-block-type"):null},onDelete:function(t){var e=t.getSelection();if(!e.isCollapsed())return null;var n=t.getCurrentContent(),i=e.getStartKey(),a=n.getBlockForKey(i),s=a.getLength();if(e.getStartOffset()<s)return null;var u=n.getBlockAfter(i);if(!u||"atomic"!==u.getType())return null;var c=e.merge({focusKey:u.getKey(),focusOffset:u.getLength()}),l=r.removeRange(n,c,"forward");return l!==n?o.push(t,l,"remove-range"):null},onTab:function(t,e,n){var r=e.getSelection(),a=r.getAnchorKey();if(a!==r.getFocusKey())return e;var s=e.getCurrentContent(),u=s.getBlockForKey(a),c=u.getType();if("unordered-list-item"!==c&&"ordered-list-item"!==c)return e;t.preventDefault();var l=s.getBlockBefore(a);if(!l)return e;var f=l.getType();if("unordered-list-item"!==f&&"ordered-list-item"!==f)return e;var p=u.getDepth();if(!t.shiftKey&&p===n)return e;n=Math.min(l.getDepth()+1,n);var d=i(s,r,t.shiftKey?-1:1,n);return o.push(e,d,"adjust-depth")},toggleBlockType:function(t,e){var n=t.getSelection(),i=n.getStartKey(),s=n.getEndKey(),u=t.getCurrentContent(),c=n;if(i!==s&&0===n.getEndOffset()){var l=a(u.getBlockBefore(s));s=l.getKey(),c=c.merge({anchorKey:i,anchorOffset:n.getStartOffset(),focusKey:s,focusOffset:l.getLength(),isBackward:!1})}if(u.getBlockMap().skipWhile(function(t,e){return e!==i}).reverse().skipWhile(function(t,e){return e!==s}).some(function(t){return"atomic"===t.getType()}))return t;var f=u.getBlockForKey(i).getType()===e?"unstyled":e;return o.push(t,r.setBlockType(u,c,f),"change-block-type")},toggleCode:function(t){var e=t.getSelection(),n=e.getAnchorKey(),r=e.getFocusKey();return e.isCollapsed()||n!==r?s.toggleBlockType(t,"code-block"):s.toggleInlineStyle(t,"CODE")},toggleInlineStyle:function(t,e){var n=t.getSelection(),i=t.getCurrentInlineStyle();if(n.isCollapsed())return o.setInlineStyleOverride(t,i.has(e)?i.remove(e):i.add(e));var a,s=t.getCurrentContent();return a=i.has(e)?r.removeInlineStyle(s,n,e):r.applyInlineStyle(s,n,e),o.push(t,a,"change-inline-style")},toggleLink:function(t,e,n){var i=r.applyEntity(t.getCurrentContent(),e,n);return o.push(t,i,"apply-entity")},tryToRemoveBlockStyle:function(t){var e=t.getSelection(),n=e.getAnchorOffset();if(e.isCollapsed()&&0===n){var o=e.getAnchorKey(),i=t.getCurrentContent(),a=i.getBlockForKey(o);if(a.getLength()>0)return null;var s=a.getType(),u=i.getBlockBefore(o);if("code-block"===s&&u&&"code-block"===u.getType())return null;if("unstyled"!==s)return r.setBlockType(i,e,"unstyled")}return null}};t.exports=s},function(t,e,n){"use strict";function r(t,e,n,r){var o=e.getStartKey(),i=e.getEndKey(),a=t.getBlockMap(),s=a.toSeq().skipUntil(function(t,e){return e===o}).takeUntil(function(t,e){return e===i}).concat([[i,a.get(i)]]).map(function(t){var e=t.getDepth()+n;return e=Math.max(0,Math.min(e,r)),t.set("depth",e)});return a=a.merge(s),t.merge({blockMap:a,selectionBefore:e,selectionAfter:e})}t.exports=r},function(t,e,n){"use strict";function r(t){var e=0,n={},r=[];t.getBlockMap().forEach(function(t,s){t.findEntityRanges(function(t){return null!==t.getEntity()},function(r){var i=o.stringify(t.getEntityAt(r));n.hasOwnProperty(i)||(n[i]=""+e++)}),r.push({key:s,text:t.getText(),type:t.getType(),depth:t.getDepth(),inlineStyleRanges:a(t),entityRanges:i(t,n),data:t.getData().toObject()})});var s=Object.keys(n),u={};return s.forEach(function(e,n){var r=t.getEntity(o.unstringify(e));u[n]={type:r.getType(),mutability:r.getMutability(),data:r.getData()}}),{entityMap:u,blocks:r}}var o=n(68),i=n(158),a=n(159);t.exports=r},function(t,e,n){"use strict";function r(t,e){var n=[];return t.findEntityRanges(function(t){return!!t.getEntity()},function(r,i){var s=t.getText(),u=t.getEntityAt(r);n.push({offset:a(s.slice(0,r)),length:a(s.slice(r,i)),key:Number(e[o.stringify(u)])})}),n}var o=n(68),i=n(19),a=i.strlen;t.exports=r},function(t,e,n){"use strict";function r(t,e,n){var r=[],o=e.map(function(t){return t.has(n)}).toList();return a(o,s,u,function(e,o){var a=t.getText();r.push({offset:i.strlen(a.slice(0,e)),length:i.strlen(a.slice(e,o)),style:n})}),r}function o(t){var e=t.getCharacterList().map(function(t){return t.getStyle()}).toList(),n=e.flatten().toSet().map(function(n){return r(t,e,n)});return Array.prototype.concat.apply(c,n.toJS())}var i=n(19),a=n(27),s=function(t,e){return t===e},u=function(t){return!!t},c=[];t.exports=o},function(t,e,n){"use strict";function r(t){var e=t.blocks,n=t.entityMap,r={};Object.keys(n).forEach(function(t){var e=n[t],o=e.type,i=e.mutability,a=e.data,s=u.__create(o,i,a||{});r[t]=s});var o=e.map(function(t){var e=t.key,n=t.type,o=t.text,s=t.depth,u=t.inlineStyleRanges,d=t.entityRanges,M=t.data;e=e||p(),n=n||"unstyled",s=s||0,u=u||[],d=d||[],M=g(M);var h=f(o,u),y=d.filter(function(t){return r.hasOwnProperty(t.key)}).map(function(t){return i({},t,{key:r[t.key]})}),m=l(o,y),I=c(h,m);return new a({key:e,type:n,text:o,depth:s,characterList:I,data:M})});return s.createFromBlockArray(o)}var o=n(18),i=o||function(t){for(var e=1;e<arguments.length;e++){var n=arguments[e];for(var r in n)Object.prototype.hasOwnProperty.call(n,r)&&(t[r]=n[r])}return t},a=n(17),s=n(32),u=n(29),c=n(161),l=n(162),f=n(163),p=n(12),d=n(4),g=d.Map;t.exports=r},function(t,e,n){"use strict";function r(t,e){var n=t.map(function(t,n){var r=e[n];return o.create({style:t,entity:r})});return a(n)}var o=n(11),i=n(4),a=i.List;t.exports=r},function(t,e,n){"use strict";function r(t,e){var n=Array(t.length).fill(null);return e&&e.forEach(function(e){for(var r=i(t,0,e.offset).length,o=r+i(t,e.offset,e.length).length,a=r;a<o;a++)n[a]=e.key}),n}var o=n(19),i=o.substr;t.exports=r},function(t,e,n){"use strict";function r(t,e){var n=Array(t.length).fill(u);return e&&e.forEach(function(e){for(var r=s(t,0,e.offset).length,o=r+s(t,e.offset,e.length).length;r<o;)n[r]=n[r].add(e.style),r++}),n}var o=n(19),i=n(4),a=i.OrderedSet,s=o.substr,u=a();t.exports=r},function(t,e,n){"use strict";function r(t){var e=t.getSelection();if(!e.rangeCount)return null;var n=e.getRangeAt(0),r=o(n),i=r.top,a=r.right,s=r.bottom,u=r.left;return 0===i&&0===a&&0===s&&0===u?null:r}var o=n(165);t.exports=r},function(t,e,n){"use strict";function r(t){var e=o(t),n=0,r=0,i=0,a=0;if(e.length){if(e.length>1&&0===e[0].width){var s=e[1];n=s.top,r=s.right,i=s.bottom,a=s.left}else{var u=e[0];n=u.top,r=u.right,i=u.bottom,a=u.left}for(var c=1;c<e.length;c++){var l=e[c];0!==l.height&&0!==l.width&&(n=Math.min(n,l.top),r=Math.max(r,l.right),i=Math.max(i,l.bottom),a=Math.min(a,l.left))}}return{top:n,right:r,bottom:i,left:a,width:r-a,height:i-n}}var o=n(61);t.exports=r},function(t,e,n){"use strict";function r(t,e){if(!(t instanceof e))throw new TypeError("Cannot call a class as a function")}Object.defineProperty(e,"__esModule",{value:!0});var o=function t(){var e=this;r(this,t),this.callBacks=[],this.suggestionCallback=void 0,this.editorFlag=!1,this.suggestionFlag=!1,this.closeAllModals=function(t){e.callBacks.forEach(function(e){e(t)})},this.init=function(t){var n=document.getElementById(t);n&&n.addEventListener("click",function(){e.editorFlag=!0}),document&&(document.addEventListener("click",function(){e.editorFlag?e.editorFlag=!1:(e.closeAllModals(),e.suggestionCallback&&e.suggestionCallback())}),document.addEventListener("keydown",function(t){"Escape"===t.key&&e.closeAllModals()}))},this.onEditorClick=function(){e.closeModals(),!e.suggestionFlag&&e.suggestionCallback?e.suggestionCallback():e.suggestionFlag=!1},this.closeModals=function(t){e.closeAllModals(t)},this.registerCallBack=function(t){e.callBacks.push(t)},this.deregisterCallBack=function(t){e.callBacks=e.callBacks.filter(function(e){return e!==t})},this.setSuggestionCallback=function(t){e.suggestionCallback=t},this.removeSuggestionCallback=function(){e.suggestionCallback=void 0},this.onSuggestionClick=function(){e.suggestionFlag=!0}};e.default=o},function(t,e,n){"use strict";function r(t,e){if(!(t instanceof e))throw new TypeError("Cannot call a class as a function")}Object.defineProperty(e,"__esModule",{value:!0});var o=function t(){var e=this;r(this,t),this.inputFocused=!1,this.editorMouseDown=!1,this.onEditorMouseDown=function(){e.editorFocused=!0},this.onInputMouseDown=function(){e.inputFocused=!0},this.isEditorBlur=function(t){return"INPUT"!==t.target.tagName||e.editorFocused?"INPUT"!==t.target.tagName&&!e.inputFocused&&(e.editorFocused=!1,!0):(e.inputFocused=!1,!0)},this.isEditorFocused=function(){return!e.inputFocused||(e.inputFocused=!1,!1)},this.isToolbarFocused=function(){return!e.editorFocused||(e.editorFocused=!1,!1)},this.isInputFocused=function(){return e.inputFocused}};e.default=o},function(t,e,n){"use strict";function r(t){var e=t.getData()&&t.getData().get("text-align");return e?"rdw-"+e+"-aligned-block":""}Object.defineProperty(e,"__esModule",{value:!0}),e.default=r},function(t,e,n){"use strict";Object.defineProperty(e,"__esModule",{value:!0}),e.handlePastedText=void 0;var r=n(9),o=n(6),i=n(170),a=function(t){return t&&t.__esModule?t:{default:t}}(i),s=n(69);e.handlePastedText=function(t,e,n,i){var u=(0,r.getSelectedBlock)(n);if(u&&"code"===u.type){var c=o.Modifier.replaceText(n.getCurrentContent(),n.getSelection(),t,n.getCurrentInlineStyle());return i(o.EditorState.push(n,c,"insert-characters")),!0}if(e){var l=(0,a.default)(e),f=new s.OrderedMap({});l.contentBlocks.forEach(function(t){f=f.set(t.get("key"),t)});var p=n.getCurrentContent();return l.entityMap.forEach(function(t,e){p=p.mergeEntityData(e,t)}),p=o.Modifier.replaceWithFragment(p,n.getSelection(),f),i(o.EditorState.push(n,p,"insert-characters")),!0}return!1}},function(t,e,n){"use strict";var r="function"==typeof Symbol&&"symbol"==typeof Symbol.iterator?function(t){return typeof t}:function(t){return t&&"function"==typeof Symbol&&t.constructor===Symbol&&t!==Symbol.prototype?"symbol":typeof t};t.exports=function(t){function e(r){if(n[r])return n[r].exports;var o=n[r]={i:r,l:!1,exports:{}};return t[r].call(o.exports,o,o.exports,e),o.l=!0,o.exports}var n={};return e.m=t,e.c=n,e.i=function(t){return t},e.d=function(t,n,r){e.o(t,n)||Object.defineProperty(t,n,{configurable:!1,enumerable:!0,get:r})},e.n=function(t){var n=t&&t.__esModule?function(){return t.default}:function(){return t};return e.d(n,"a",n),n},e.o=function(t,e){return Object.prototype.hasOwnProperty.call(t,e)},e.p="",e(e.s=9)}([function(t,e,n){var o,i,a="function"==typeof Symbol&&"symbol"==r(Symbol.iterator)?function(t){return void 0===t?"undefined":r(t)}:function(t){return t&&"function"==typeof Symbol&&t.constructor===Symbol&&t!==Symbol.prototype?"symbol":void 0===t?"undefined":r(t)};!function(r,s){"object"===a(e)&&void 0!==t?t.exports=s():(o=s,void 0!==(i="function"==typeof o?o.call(e,n,e,t):o)&&(t.exports=i))}(0,function(){function t(t,e){e&&(t.prototype=Object.create(e.prototype)),t.prototype.constructor=t}function e(t){return i(t)?t:S(t)}function n(t){return s(t)?t:b(t)}function r(t){return u(t)?t:x(t)}function o(t){return i(t)&&!c(t)?t:O(t)}function i(t){return!(!t||!t[ln])}function s(t){return!(!t||!t[fn])}function u(t){return!(!t||!t[pn])}function c(t){return s(t)||u(t)}function l(t){return!(!t||!t[dn])}function f(t){return t.value=!1,t}function p(t){t&&(t.value=!0)}function d(){}function g(t,e){e=e||0;for(var n=Math.max(0,t.length-e),r=new Array(n),o=0;o<n;o++)r[o]=t[o+e];return r}function M(t){return void 0===t.size&&(t.size=t.__iterate(y)),t.size}function h(t,e){if("number"!=typeof e){var n=e>>>0;if(""+n!==e||4294967295===n)return NaN;e=n}return e<0?M(t)+e:e}function y(){return!0}function m(t,e,n){return(0===t||void 0!==n&&t<=-n)&&(void 0===e||void 0!==n&&e>=n)}function I(t,e){return D(t,e,0)}function w(t,e){return D(t,e,e)}function D(t,e,n){return void 0===t?n:t<0?Math.max(0,e+t):void 0===e?t:Math.min(e,t)}function N(t){this.next=t}function v(t,e,n,r){var o=0===t?e:1===t?n:[e,n];return r?r.value=o:r={value:o,done:!1},r}function C(){return{value:void 0,done:!0}}function j(t){return!!A(t)}function z(t){return t&&"function"==typeof t.next}function T(t){var e=A(t);return e&&e.call(t)}function A(t){var e=t&&(Cn&&t[Cn]||t[jn]);if("function"==typeof e)return e}function E(t){return t&&"number"==typeof t.length}function S(t){return null===t||void 0===t?Y():i(t)?t.toSeq():R(t)}function b(t){return null===t||void 0===t?Y().toKeyedSeq():i(t)?s(t)?t.toSeq():t.fromEntrySeq():B(t)}function x(t){return null===t||void 0===t?Y():i(t)?s(t)?t.entrySeq():t.toIndexedSeq():P(t)}function O(t){return(null===t||void 0===t?Y():i(t)?s(t)?t.entrySeq():t:P(t)).toSetSeq()}function _(t){this._array=t,this.size=t.length}function k(t){var e=Object.keys(t);this._object=t,this._keys=e,this.size=e.length}function L(t){this._iterable=t,this.size=t.length||t.size}function U(t){this._iterator=t,this._iteratorCache=[]}function Q(t){return!(!t||!t[Tn])}function Y(){return An||(An=new _([]))}function B(t){var e=Array.isArray(t)?new _(t).fromEntrySeq():z(t)?new U(t).fromEntrySeq():j(t)?new L(t).fromEntrySeq():"object"===(void 0===t?"undefined":a(t))?new k(t):void 0;if(!e)throw new TypeError("Expected Array or iterable object of [k, v] entries, or keyed object: "+t);return e}function P(t){var e=Z(t);if(!e)throw new TypeError("Expected Array or iterable object of values: "+t);return e}function R(t){var e=Z(t)||"object"===(void 0===t?"undefined":a(t))&&new k(t);if(!e)throw new TypeError("Expected Array or iterable object of values, or keyed object: "+t);return e}function Z(t){return E(t)?new _(t):z(t)?new U(t):j(t)?new L(t):void 0}function G(t,e,n,r){var o=t._cache;if(o){for(var i=o.length-1,a=0;a<=i;a++){var s=o[n?i-a:a];if(!1===e(s[1],r?s[0]:a,t))return a+1}return a}return t.__iterateUncached(e,n)}function W(t,e,n,r){var o=t._cache;if(o){var i=o.length-1,a=0;return new N(function(){var t=o[n?i-a:a];return a++>i?C():v(e,r?t[0]:a-1,t[1])})}return t.__iteratorUncached(e,n)}function F(t,e){return e?H(e,t,"",{"":t}):K(t)}function H(t,e,n,r){return Array.isArray(e)?t.call(r,n,x(e).map(function(n,r){return H(t,n,r,e)})):J(e)?t.call(r,n,b(e).map(function(n,r){return H(t,n,r,e)})):e}function K(t){return Array.isArray(t)?x(t).map(K).toList():J(t)?b(t).map(K).toMap():t}function J(t){return t&&(t.constructor===Object||void 0===t.constructor)}function q(t,e){if(t===e||t!==t&&e!==e)return!0;if(!t||!e)return!1;if("function"==typeof t.valueOf&&"function"==typeof e.valueOf){if(t=t.valueOf(),e=e.valueOf(),t===e||t!==t&&e!==e)return!0;if(!t||!e)return!1}return!("function"!=typeof t.equals||"function"!=typeof e.equals||!t.equals(e))}function V(t,e){if(t===e)return!0;if(!i(e)||void 0!==t.size&&void 0!==e.size&&t.size!==e.size||void 0!==t.__hash&&void 0!==e.__hash&&t.__hash!==e.__hash||s(t)!==s(e)||u(t)!==u(e)||l(t)!==l(e))return!1;if(0===t.size&&0===e.size)return!0;var n=!c(t);if(l(t)){var r=t.entries();return e.every(function(t,e){var o=r.next().value;return o&&q(o[1],t)&&(n||q(o[0],e))})&&r.next().done}var o=!1;if(void 0===t.size)if(void 0===e.size)"function"==typeof t.cacheResult&&t.cacheResult();else{o=!0;var a=t;t=e,e=a}var f=!0,p=e.__iterate(function(e,r){if(n?!t.has(e):o?!q(e,t.get(r,mn)):!q(t.get(r,mn),e))return f=!1,!1});return f&&t.size===p}function X(t,e){if(!(this instanceof X))return new X(t,e);if(this._value=t,this.size=void 0===e?1/0:Math.max(0,e),0===this.size){if(En)return En;En=this}}function $(t,e){if(!t)throw new Error(e)}function tt(t,e,n){if(!(this instanceof tt))return new tt(t,e,n);if($(0!==n,"Cannot step a Range by 0"),t=t||0,void 0===e&&(e=1/0),n=void 0===n?1:Math.abs(n),e<t&&(n=-n),this._start=t,this._end=e,this._step=n,this.size=Math.max(0,Math.ceil((e-t)/n-1)+1),0===this.size){if(Sn)return Sn;Sn=this}}function et(){throw TypeError("Abstract")}function nt(){}function rt(){}function ot(){}function it(t){return t>>>1&1073741824|3221225471&t}function at(t){if(!1===t||null===t||void 0===t)return 0;if("function"==typeof t.valueOf&&(!1===(t=t.valueOf())||null===t||void 0===t))return 0;if(!0===t)return 1;var e=void 0===t?"undefined":a(t);if("number"===e){var n=0|t;for(n!==t&&(n^=4294967295*t);t>4294967295;)t/=4294967295,n^=t;return it(n)}if("string"===e)return t.length>Qn?st(t):ut(t);if("function"==typeof t.hashCode)return t.hashCode();if("object"===e)return ct(t);if("function"==typeof t.toString)return ut(t.toString());throw new Error("Value type "+e+" cannot be hashed.")}function st(t){var e=Pn[t];return void 0===e&&(e=ut(t),Bn===Yn&&(Bn=0,Pn={}),Bn++,Pn[t]=e),e}function ut(t){for(var e=0,n=0;n<t.length;n++)e=31*e+t.charCodeAt(n)|0;return it(e)}function ct(t){var e;if(kn&&void 0!==(e=bn.get(t)))return e;if(void 0!==(e=t[Un]))return e;if(!_n){if(void 0!==(e=t.propertyIsEnumerable&&t.propertyIsEnumerable[Un]))return e;if(void 0!==(e=lt(t)))return e}if(e=++Ln,1073741824&Ln&&(Ln=0),kn)bn.set(t,e);else{if(void 0!==On&&!1===On(t))throw new Error("Non-extensible objects are not allowed as keys.");if(_n)Object.defineProperty(t,Un,{enumerable:!1,configurable:!1,writable:!1,value:e});else if(void 0!==t.propertyIsEnumerable&&t.propertyIsEnumerable===t.constructor.prototype.propertyIsEnumerable)t.propertyIsEnumerable=function(){return this.constructor.prototype.propertyIsEnumerable.apply(this,arguments)},t.propertyIsEnumerable[Un]=e;else{if(void 0===t.nodeType)throw new Error("Unable to set a non-enumerable property on object.");t[Un]=e}}return e}function lt(t){if(t&&t.nodeType>0)switch(t.nodeType){case 1:return t.uniqueID;case 9:return t.documentElement&&t.documentElement.uniqueID}}function ft(t){$(t!==1/0,"Cannot perform this action with an infinite size.")}function pt(t){return null===t||void 0===t?vt():dt(t)&&!l(t)?t:vt().withMutations(function(e){var r=n(t);ft(r.size),r.forEach(function(t,n){return e.set(n,t)})})}function dt(t){return!(!t||!t[Rn])}function gt(t,e){this.ownerID=t,this.entries=e}function Mt(t,e,n){this.ownerID=t,this.bitmap=e,this.nodes=n}function ht(t,e,n){this.ownerID=t,this.count=e,this.nodes=n}function yt(t,e,n){this.ownerID=t,this.keyHash=e,this.entries=n}function mt(t,e,n){this.ownerID=t,this.keyHash=e,this.entry=n}function It(t,e,n){this._type=e,this._reverse=n,this._stack=t._root&&Dt(t._root)}function wt(t,e){return v(t,e[0],e[1])}function Dt(t,e){return{node:t,index:0,__prev:e}}function Nt(t,e,n,r){var o=Object.create(Zn);return o.size=t,o._root=e,o.__ownerID=n,o.__hash=r,o.__altered=!1,o}function vt(){return Gn||(Gn=Nt(0))}function Ct(t,e,n){var r,o;if(t._root){var i=f(In),a=f(wn);if(r=jt(t._root,t.__ownerID,0,void 0,e,n,i,a),!a.value)return t;o=t.size+(i.value?n===mn?-1:1:0)}else{if(n===mn)return t;o=1,r=new gt(t.__ownerID,[[e,n]])}return t.__ownerID?(t.size=o,t._root=r,t.__hash=void 0,t.__altered=!0,t):r?Nt(o,r):vt()}function jt(t,e,n,r,o,i,a,s){return t?t.update(e,n,r,o,i,a,s):i===mn?t:(p(s),p(a),new mt(e,r,[o,i]))}function zt(t){return t.constructor===mt||t.constructor===yt}function Tt(t,e,n,r,o){if(t.keyHash===r)return new yt(e,r,[t.entry,o]);var i,a=(0===n?t.keyHash:t.keyHash>>>n)&yn,s=(0===n?r:r>>>n)&yn;return new Mt(e,1<<a|1<<s,a===s?[Tt(t,e,n+Mn,r,o)]:(i=new mt(e,r,o),a<s?[t,i]:[i,t]))}function At(t,e,n,r){t||(t=new d);for(var o=new mt(t,at(n),[n,r]),i=0;i<e.length;i++){var a=e[i];o=o.update(t,0,void 0,a[0],a[1])}return o}function Et(t,e,n,r){for(var o=0,i=0,a=new Array(n),s=0,u=1,c=e.length;s<c;s++,u<<=1){var l=e[s];void 0!==l&&s!==r&&(o|=u,a[i++]=l)}return new Mt(t,o,a)}function St(t,e,n,r,o){for(var i=0,a=new Array(hn),s=0;0!==n;s++,n>>>=1)a[s]=1&n?e[i++]:void 0;return a[r]=o,new ht(t,i+1,a)}function bt(t,e,r){for(var o=[],a=0;a<r.length;a++){var s=r[a],u=n(s);i(s)||(u=u.map(function(t){return F(t)})),o.push(u)}return _t(t,e,o)}function xt(t,e,n){return t&&t.mergeDeep&&i(e)?t.mergeDeep(e):q(t,e)?t:e}function Ot(t){return function(e,n,r){if(e&&e.mergeDeepWith&&i(n))return e.mergeDeepWith(t,n);var o=t(e,n,r);return q(e,o)?e:o}}function _t(t,e,n){return n=n.filter(function(t){return 0!==t.size}),0===n.length?t:0!==t.size||t.__ownerID||1!==n.length?t.withMutations(function(t){for(var r=e?function(n,r){t.update(r,mn,function(t){return t===mn?n:e(t,n,r)})}:function(e,n){t.set(n,e)},o=0;o<n.length;o++)n[o].forEach(r)}):t.constructor(n[0])}function kt(t,e,n,r){var o=t===mn,i=e.next();if(i.done){var a=o?n:t,s=r(a);return s===a?t:s}$(o||t&&t.set,"invalid keyPath");var u=i.value,c=o?mn:t.get(u,mn),l=kt(c,e,n,r);return l===c?t:l===mn?t.remove(u):(o?vt():t).set(u,l)}function Lt(t){return t-=t>>1&1431655765,t=(858993459&t)+(t>>2&858993459),t=t+(t>>4)&252645135,t+=t>>8,127&(t+=t>>16)}function Ut(t,e,n,r){var o=r?t:g(t);return o[e]=n,o}function Qt(t,e,n,r){var o=t.length+1;if(r&&e+1===o)return t[e]=n,t;for(var i=new Array(o),a=0,s=0;s<o;s++)s===e?(i[s]=n,a=-1):i[s]=t[s+a];return i}function Yt(t,e,n){var r=t.length-1;if(n&&e===r)return t.pop(),t;for(var o=new Array(r),i=0,a=0;a<r;a++)a===e&&(i=1),o[a]=t[a+i];return o}function Bt(t){var e=Wt();if(null===t||void 0===t)return e;if(Pt(t))return t;var n=r(t),o=n.size;return 0===o?e:(ft(o),o>0&&o<hn?Gt(0,o,Mn,null,new Rt(n.toArray())):e.withMutations(function(t){t.setSize(o),n.forEach(function(e,n){return t.set(n,e)})}))}function Pt(t){return!(!t||!t[Kn])}function Rt(t,e){this.array=t,this.ownerID=e}function Zt(t,e){function n(t,e,n){return 0===e?r(t,n):o(t,e,n)}function r(t,n){var r=n===s?u&&u.array:t&&t.array,o=n>i?0:i-n,c=a-n;return c>hn&&(c=hn),function(){if(o===c)return Vn;var t=e?--c:o++;return r&&r[t]}}function o(t,r,o){var s,u=t&&t.array,c=o>i?0:i-o>>r,l=1+(a-o>>r);return l>hn&&(l=hn),function(){for(;;){if(s){var t=s();if(t!==Vn)return t;s=null}if(c===l)return Vn;var i=e?--l:c++;s=n(u&&u[i],r-Mn,o+(i<<r))}}}var i=t._origin,a=t._capacity,s=Xt(a),u=t._tail;return n(t._root,t._level,0)}function Gt(t,e,n,r,o,i,a){var s=Object.create(Jn);return s.size=e-t,s._origin=t,s._capacity=e,s._level=n,s._root=r,s._tail=o,s.__ownerID=i,s.__hash=a,s.__altered=!1,s}function Wt(){return qn||(qn=Gt(0,0,Mn))}function Ft(t,e,n){if((e=h(t,e))!==e)return t;if(e>=t.size||e<0)return t.withMutations(function(t){e<0?qt(t,e).set(0,n):qt(t,0,e+1).set(e,n)});e+=t._origin;var r=t._tail,o=t._root,i=f(wn);return e>=Xt(t._capacity)?r=Ht(r,t.__ownerID,0,e,n,i):o=Ht(o,t.__ownerID,t._level,e,n,i),i.value?t.__ownerID?(t._root=o,t._tail=r,t.__hash=void 0,t.__altered=!0,t):Gt(t._origin,t._capacity,t._level,o,r):t}function Ht(t,e,n,r,o,i){var a=r>>>n&yn,s=t&&a<t.array.length;if(!s&&void 0===o)return t;var u;if(n>0){var c=t&&t.array[a],l=Ht(c,e,n-Mn,r,o,i);return l===c?t:(u=Kt(t,e),u.array[a]=l,u)}return s&&t.array[a]===o?t:(p(i),u=Kt(t,e),void 0===o&&a===u.array.length-1?u.array.pop():u.array[a]=o,u)}function Kt(t,e){return e&&t&&e===t.ownerID?t:new Rt(t?t.array.slice():[],e)}function Jt(t,e){if(e>=Xt(t._capacity))return t._tail;if(e<1<<t._level+Mn){for(var n=t._root,r=t._level;n&&r>0;)n=n.array[e>>>r&yn],r-=Mn;return n}}function qt(t,e,n){void 0!==e&&(e|=0),void 0!==n&&(n|=0);var r=t.__ownerID||new d,o=t._origin,i=t._capacity,a=o+e,s=void 0===n?i:n<0?i+n:o+n;if(a===o&&s===i)return t;if(a>=s)return t.clear();for(var u=t._level,c=t._root,l=0;a+l<0;)c=new Rt(c&&c.array.length?[void 0,c]:[],r),u+=Mn,l+=1<<u;l&&(a+=l,o+=l,s+=l,i+=l);for(var f=Xt(i),p=Xt(s);p>=1<<u+Mn;)c=new Rt(c&&c.array.length?[c]:[],r),u+=Mn;var g=t._tail,M=p<f?Jt(t,s-1):p>f?new Rt([],r):g;if(g&&p>f&&a<i&&g.array.length){c=Kt(c,r);for(var h=c,y=u;y>Mn;y-=Mn){var m=f>>>y&yn;h=h.array[m]=Kt(h.array[m],r)}h.array[f>>>Mn&yn]=g}if(s<i&&(M=M&&M.removeAfter(r,0,s)),a>=p)a-=p,s-=p,u=Mn,c=null,M=M&&M.removeBefore(r,0,a);else if(a>o||p<f){for(l=0;c;){var I=a>>>u&yn;if(I!==p>>>u&yn)break;I&&(l+=(1<<u)*I),u-=Mn,c=c.array[I]}c&&a>o&&(c=c.removeBefore(r,u,a-l)),c&&p<f&&(c=c.removeAfter(r,u,p-l)),l&&(a-=l,s-=l)}return t.__ownerID?(t.size=s-a,t._origin=a,t._capacity=s,t._level=u,t._root=c,t._tail=M,t.__hash=void 0,t.__altered=!0,t):Gt(a,s,u,c,M)}function Vt(t,e,n){for(var o=[],a=0,s=0;s<n.length;s++){var u=n[s],c=r(u);c.size>a&&(a=c.size),i(u)||(c=c.map(function(t){return F(t)})),o.push(c)}return a>t.size&&(t=t.setSize(a)),_t(t,e,o)}function Xt(t){return t<hn?0:t-1>>>Mn<<Mn}function $t(t){return null===t||void 0===t?ne():te(t)?t:ne().withMutations(function(e){var r=n(t);ft(r.size),r.forEach(function(t,n){return e.set(n,t)})})}function te(t){return dt(t)&&l(t)}function ee(t,e,n,r){var o=Object.create($t.prototype);return o.size=t?t.size:0,o._map=t,o._list=e,o.__ownerID=n,o.__hash=r,o}function ne(){return Xn||(Xn=ee(vt(),Wt()))}function re(t,e,n){var r,o,i=t._map,a=t._list,s=i.get(e),u=void 0!==s;if(n===mn){if(!u)return t;a.size>=hn&&a.size>=2*i.size?(o=a.filter(function(t,e){return void 0!==t&&s!==e}),r=o.toKeyedSeq().map(function(t){return t[0]}).flip().toMap(),t.__ownerID&&(r.__ownerID=o.__ownerID=t.__ownerID)):(r=i.remove(e),o=s===a.size-1?a.pop():a.set(s,void 0))}else if(u){if(n===a.get(s)[1])return t;r=i,o=a.set(s,[e,n])}else r=i.set(e,a.size),o=a.set(a.size,[e,n]);return t.__ownerID?(t.size=r.size,t._map=r,t._list=o,t.__hash=void 0,t):ee(r,o)}function oe(t,e){this._iter=t,this._useKeys=e,this.size=t.size}function ie(t){this._iter=t,this.size=t.size}function ae(t){this._iter=t,this.size=t.size}function se(t){this._iter=t,this.size=t.size}function ue(t){var e=Ee(t);return e._iter=t,e.size=t.size,e.flip=function(){return t},e.reverse=function(){var e=t.reverse.apply(this);return e.flip=function(){return t.reverse()},e},e.has=function(e){return t.includes(e)},e.includes=function(e){return t.has(e)},e.cacheResult=Se,e.__iterateUncached=function(e,n){var r=this;return t.__iterate(function(t,n){return!1!==e(n,t,r)},n)},e.__iteratorUncached=function(e,n){if(e===vn){var r=t.__iterator(e,n);return new N(function(){var t=r.next();if(!t.done){var e=t.value[0];t.value[0]=t.value[1],t.value[1]=e}return t})}return t.__iterator(e===Nn?Dn:Nn,n)},e}function ce(t,e,n){var r=Ee(t);return r.size=t.size,r.has=function(e){return t.has(e)},r.get=function(r,o){var i=t.get(r,mn);return i===mn?o:e.call(n,i,r,t)},r.__iterateUncached=function(r,o){var i=this;return t.__iterate(function(t,o,a){return!1!==r(e.call(n,t,o,a),o,i)},o)},r.__iteratorUncached=function(r,o){var i=t.__iterator(vn,o);return new N(function(){var o=i.next();if(o.done)return o;var a=o.value,s=a[0];return v(r,s,e.call(n,a[1],s,t),o)})},r}function le(t,e){var n=Ee(t);return n._iter=t,n.size=t.size,n.reverse=function(){return t},t.flip&&(n.flip=function(){var e=ue(t);return e.reverse=function(){return t.flip()},e}),n.get=function(n,r){return t.get(e?n:-1-n,r)},n.has=function(n){return t.has(e?n:-1-n)},n.includes=function(e){return t.includes(e)},n.cacheResult=Se,n.__iterate=function(e,n){var r=this;return t.__iterate(function(t,n){return e(t,n,r)},!n)},n.__iterator=function(e,n){return t.__iterator(e,!n)},n}function fe(t,e,n,r){var o=Ee(t);return r&&(o.has=function(r){var o=t.get(r,mn);return o!==mn&&!!e.call(n,o,r,t)},o.get=function(r,o){var i=t.get(r,mn);return i!==mn&&e.call(n,i,r,t)?i:o}),o.__iterateUncached=function(o,i){var a=this,s=0;return t.__iterate(function(t,i,u){if(e.call(n,t,i,u))return s++,o(t,r?i:s-1,a)},i),s},o.__iteratorUncached=function(o,i){var a=t.__iterator(vn,i),s=0;return new N(function(){for(;;){var i=a.next();if(i.done)return i;var u=i.value,c=u[0],l=u[1];if(e.call(n,l,c,t))return v(o,r?c:s++,l,i)}})},o}function pe(t,e,n){var r=pt().asMutable();return t.__iterate(function(o,i){r.update(e.call(n,o,i,t),0,function(t){return t+1})}),r.asImmutable()}function de(t,e,n){var r=s(t),o=(l(t)?$t():pt()).asMutable();t.__iterate(function(i,a){o.update(e.call(n,i,a,t),function(t){return t=t||[],t.push(r?[a,i]:i),t})});var i=Ae(t);return o.map(function(e){return je(t,i(e))})}function ge(t,e,n,r){var o=t.size;if(void 0!==e&&(e|=0),void 0!==n&&(n|=0),m(e,n,o))return t;var i=I(e,o),a=w(n,o);if(i!==i||a!==a)return ge(t.toSeq().cacheResult(),e,n,r);var s,u=a-i;u===u&&(s=u<0?0:u);var c=Ee(t);return c.size=0===s?s:t.size&&s||void 0,!r&&Q(t)&&s>=0&&(c.get=function(e,n){return e=h(this,e),e>=0&&e<s?t.get(e+i,n):n}),c.__iterateUncached=function(e,n){var o=this;if(0===s)return 0;if(n)return this.cacheResult().__iterate(e,n);var a=0,u=!0,c=0;return t.__iterate(function(t,n){if(!u||!(u=a++<i))return c++,!1!==e(t,r?n:c-1,o)&&c!==s}),c},c.__iteratorUncached=function(e,n){if(0!==s&&n)return this.cacheResult().__iterator(e,n);var o=0!==s&&t.__iterator(e,n),a=0,u=0;return new N(function(){for(;a++<i;)o.next();if(++u>s)return C();var t=o.next();return r||e===Nn?t:e===Dn?v(e,u-1,void 0,t):v(e,u-1,t.value[1],t)})},c}function Me(t,e,n){var r=Ee(t);return r.__iterateUncached=function(r,o){var i=this;if(o)return this.cacheResult().__iterate(r,o);var a=0;return t.__iterate(function(t,o,s){return e.call(n,t,o,s)&&++a&&r(t,o,i)}),a},r.__iteratorUncached=function(r,o){var i=this;if(o)return this.cacheResult().__iterator(r,o);var a=t.__iterator(vn,o),s=!0;return new N(function(){if(!s)return C();var t=a.next();if(t.done)return t;var o=t.value,u=o[0],c=o[1];return e.call(n,c,u,i)?r===vn?t:v(r,u,c,t):(s=!1,C())})},r}function he(t,e,n,r){var o=Ee(t);return o.__iterateUncached=function(o,i){var a=this;if(i)return this.cacheResult().__iterate(o,i);var s=!0,u=0;return t.__iterate(function(t,i,c){if(!s||!(s=e.call(n,t,i,c)))return u++,o(t,r?i:u-1,a)}),u},o.__iteratorUncached=function(o,i){var a=this;if(i)return this.cacheResult().__iterator(o,i);var s=t.__iterator(vn,i),u=!0,c=0;return new N(function(){var t,i,l;do{if(t=s.next(),t.done)return r||o===Nn?t:o===Dn?v(o,c++,void 0,t):v(o,c++,t.value[1],t);var f=t.value;i=f[0],l=f[1],u&&(u=e.call(n,l,i,a))}while(u);return o===vn?t:v(o,i,l,t)})},o}function ye(t,e){var r=s(t),o=[t].concat(e).map(function(t){return i(t)?r&&(t=n(t)):t=r?B(t):P(Array.isArray(t)?t:[t]),t}).filter(function(t){return 0!==t.size});if(0===o.length)return t;if(1===o.length){var a=o[0];if(a===t||r&&s(a)||u(t)&&u(a))return a}var c=new _(o);return r?c=c.toKeyedSeq():u(t)||(c=c.toSetSeq()),c=c.flatten(!0),c.size=o.reduce(function(t,e){if(void 0!==t){var n=e.size;if(void 0!==n)return t+n}},0),c}function me(t,e,n){var r=Ee(t);return r.__iterateUncached=function(r,o){function a(t,c){var l=this;t.__iterate(function(t,o){return(!e||c<e)&&i(t)?a(t,c+1):!1===r(t,n?o:s++,l)&&(u=!0),!u},o)}var s=0,u=!1;return a(t,0),s},r.__iteratorUncached=function(r,o){var a=t.__iterator(r,o),s=[],u=0;return new N(function(){for(;a;){var t=a.next();if(!1===t.done){var c=t.value;if(r===vn&&(c=c[1]),e&&!(s.length<e)||!i(c))return n?t:v(r,u++,c,t);s.push(a),a=c.__iterator(r,o)}else a=s.pop()}return C()})},r}function Ie(t,e,n){var r=Ae(t);return t.toSeq().map(function(o,i){return r(e.call(n,o,i,t))}).flatten(!0)}function we(t,e){var n=Ee(t);return n.size=t.size&&2*t.size-1,n.__iterateUncached=function(n,r){var o=this,i=0;return t.__iterate(function(t,r){return(!i||!1!==n(e,i++,o))&&!1!==n(t,i++,o)},r),i},n.__iteratorUncached=function(n,r){var o,i=t.__iterator(Nn,r),a=0;return new N(function(){return(!o||a%2)&&(o=i.next(),o.done)?o:a%2?v(n,a++,e):v(n,a++,o.value,o)})},n}function De(t,e,n){e||(e=be);var r=s(t),o=0,i=t.toSeq().map(function(e,r){return[r,e,o++,n?n(e,r,t):e]}).toArray();return i.sort(function(t,n){return e(t[3],n[3])||t[2]-n[2]}).forEach(r?function(t,e){i[e].length=2}:function(t,e){i[e]=t[1]}),r?b(i):u(t)?x(i):O(i)}function Ne(t,e,n){if(e||(e=be),n){var r=t.toSeq().map(function(e,r){return[e,n(e,r,t)]}).reduce(function(t,n){return ve(e,t[1],n[1])?n:t});return r&&r[0]}return t.reduce(function(t,n){return ve(e,t,n)?n:t})}function ve(t,e,n){var r=t(n,e);return 0===r&&n!==e&&(void 0===n||null===n||n!==n)||r>0}function Ce(t,n,r){var o=Ee(t);return o.size=new _(r).map(function(t){return t.size}).min(),o.__iterate=function(t,e){for(var n,r=this.__iterator(Nn,e),o=0;!(n=r.next()).done&&!1!==t(n.value,o++,this););return o},o.__iteratorUncached=function(t,o){var i=r.map(function(t){return t=e(t),T(o?t.reverse():t)}),a=0,s=!1;return new N(function(){var e;return s||(e=i.map(function(t){return t.next()}),s=e.some(function(t){return t.done})),s?C():v(t,a++,n.apply(null,e.map(function(t){return t.value})))})},o}function je(t,e){return Q(t)?e:t.constructor(e)}function ze(t){if(t!==Object(t))throw new TypeError("Expected [K, V] tuple: "+t)}function Te(t){return ft(t.size),M(t)}function Ae(t){return s(t)?n:u(t)?r:o}function Ee(t){return Object.create((s(t)?b:u(t)?x:O).prototype)}function Se(){return this._iter.cacheResult?(this._iter.cacheResult(),this.size=this._iter.size,this):S.prototype.cacheResult.call(this)}function be(t,e){return t>e?1:t<e?-1:0}function xe(t){var n=T(t);if(!n){if(!E(t))throw new TypeError("Expected iterable or array-like: "+t);n=T(e(t))}return n}function Oe(t,e){var n,r=function r(i){if(i instanceof r)return i;if(!(this instanceof r))return new r(i);if(!n){n=!0;var a=Object.keys(t);Le(o,a),o.size=a.length,o._name=e,o._keys=a,o._defaultValues=t}this._map=pt(i)},o=r.prototype=Object.create($n);return o.constructor=r,r}function _e(t,e,n){var r=Object.create(Object.getPrototypeOf(t));return r._map=e,r.__ownerID=n,r}function ke(t){return t._name||t.constructor.name||"Record"}function Le(t,e){try{e.forEach(Ue.bind(void 0,t))}catch(t){}}function Ue(t,e){Object.defineProperty(t,e,{get:function(){return this.get(e)},set:function(t){$(this.__ownerID,"Cannot set on an immutable record."),this.set(e,t)}})}function Qe(t){return null===t||void 0===t?Re():Ye(t)&&!l(t)?t:Re().withMutations(function(e){var n=o(t);ft(n.size),n.forEach(function(t){return e.add(t)})})}function Ye(t){return!(!t||!t[tr])}function Be(t,e){return t.__ownerID?(t.size=e.size,t._map=e,t):e===t._map?t:0===e.size?t.__empty():t.__make(e)}function Pe(t,e){var n=Object.create(er);return n.size=t?t.size:0,n._map=t,n.__ownerID=e,n}function Re(){return nr||(nr=Pe(vt()))}function Ze(t){return null===t||void 0===t?Fe():Ge(t)?t:Fe().withMutations(function(e){var n=o(t);ft(n.size),n.forEach(function(t){return e.add(t)})})}function Ge(t){return Ye(t)&&l(t)}function We(t,e){var n=Object.create(rr);return n.size=t?t.size:0,n._map=t,n.__ownerID=e,n}function Fe(){return or||(or=We(ne()))}function He(t){return null===t||void 0===t?qe():Ke(t)?t:qe().unshiftAll(t)}function Ke(t){return!(!t||!t[ir])}function Je(t,e,n,r){var o=Object.create(ar);return o.size=t,o._head=e,o.__ownerID=n,o.__hash=r,o.__altered=!1,o}function qe(){return sr||(sr=Je(0))}function Ve(t,e){var n=function(n){t.prototype[n]=e[n]};return Object.keys(e).forEach(n),Object.getOwnPropertySymbols&&Object.getOwnPropertySymbols(e).forEach(n),t}function Xe(t,e){return e}function $e(t,e){return[e,t]}function tn(t){return function(){return!t.apply(this,arguments)}}function en(t){return function(){return-t.apply(this,arguments)}}function nn(t){return"string"==typeof t?JSON.stringify(t):t}function rn(){return g(arguments)}function on(t,e){return t<e?1:t>e?-1:0}function an(t){if(t.size===1/0)return 0;var e=l(t),n=s(t),r=e?1:0;return sn(t.__iterate(n?e?function(t,e){r=31*r+un(at(t),at(e))|0}:function(t,e){r=r+un(at(t),at(e))|0}:e?function(t){r=31*r+at(t)|0}:function(t){r=r+at(t)|0}),r)}function sn(t,e){return e=xn(e,3432918353),e=xn(e<<15|e>>>-15,461845907),e=xn(e<<13|e>>>-13,5),e=(e+3864292196|0)^t,e=xn(e^e>>>16,2246822507),e=xn(e^e>>>13,3266489909),e=it(e^e>>>16)}function un(t,e){return t^e+2654435769+(t<<6)+(t>>2)|0}var cn=Array.prototype.slice;t(n,e),t(r,e),t(o,e),e.isIterable=i,e.isKeyed=s,e.isIndexed=u,e.isAssociative=c,e.isOrdered=l,e.Keyed=n,e.Indexed=r,e.Set=o;var ln="@@__IMMUTABLE_ITERABLE__@@",fn="@@__IMMUTABLE_KEYED__@@",pn="@@__IMMUTABLE_INDEXED__@@",dn="@@__IMMUTABLE_ORDERED__@@",gn="delete",Mn=5,hn=1<<Mn,yn=hn-1,mn={},In={value:!1},wn={value:!1},Dn=0,Nn=1,vn=2,Cn="function"==typeof Symbol&&Symbol.iterator,jn="@@iterator",zn=Cn||jn;N.prototype.toString=function(){return"[Iterator]"},N.KEYS=Dn,N.VALUES=Nn,N.ENTRIES=vn,N.prototype.inspect=N.prototype.toSource=function(){return this.toString()},N.prototype[zn]=function(){return this},t(S,e),S.of=function(){return S(arguments)},S.prototype.toSeq=function(){return this},S.prototype.toString=function(){return this.__toString("Seq {","}")},S.prototype.cacheResult=function(){return!this._cache&&this.__iterateUncached&&(this._cache=this.entrySeq().toArray(),this.size=this._cache.length),this},S.prototype.__iterate=function(t,e){return G(this,t,e,!0)},S.prototype.__iterator=function(t,e){return W(this,t,e,!0)},t(b,S),b.prototype.toKeyedSeq=function(){return this},t(x,S),x.of=function(){return x(arguments)},x.prototype.toIndexedSeq=function(){return this},x.prototype.toString=function(){return this.__toString("Seq [","]")},x.prototype.__iterate=function(t,e){return G(this,t,e,!1)},x.prototype.__iterator=function(t,e){return W(this,t,e,!1)},t(O,S),O.of=function(){return O(arguments)},O.prototype.toSetSeq=function(){return this},S.isSeq=Q,S.Keyed=b,S.Set=O,S.Indexed=x;var Tn="@@__IMMUTABLE_SEQ__@@";S.prototype[Tn]=!0,t(_,x),_.prototype.get=function(t,e){return this.has(t)?this._array[h(this,t)]:e},_.prototype.__iterate=function(t,e){for(var n=this._array,r=n.length-1,o=0;o<=r;o++)if(!1===t(n[e?r-o:o],o,this))return o+1;return o},_.prototype.__iterator=function(t,e){var n=this._array,r=n.length-1,o=0;return new N(function(){return o>r?C():v(t,o,n[e?r-o++:o++])})},t(k,b),k.prototype.get=function(t,e){return void 0===e||this.has(t)?this._object[t]:e},k.prototype.has=function(t){return this._object.hasOwnProperty(t)},k.prototype.__iterate=function(t,e){for(var n=this._object,r=this._keys,o=r.length-1,i=0;i<=o;i++){var a=r[e?o-i:i];if(!1===t(n[a],a,this))return i+1}return i},k.prototype.__iterator=function(t,e){var n=this._object,r=this._keys,o=r.length-1,i=0;return new N(function(){var a=r[e?o-i:i];return i++>o?C():v(t,a,n[a])})},k.prototype[dn]=!0,t(L,x),L.prototype.__iterateUncached=function(t,e){if(e)return this.cacheResult().__iterate(t,e);var n=this._iterable,r=T(n),o=0;if(z(r))for(var i;!(i=r.next()).done&&!1!==t(i.value,o++,this););return o},L.prototype.__iteratorUncached=function(t,e){if(e)return this.cacheResult().__iterator(t,e);var n=this._iterable,r=T(n);if(!z(r))return new N(C);var o=0;return new N(function(){var e=r.next();return e.done?e:v(t,o++,e.value)})},t(U,x),U.prototype.__iterateUncached=function(t,e){if(e)return this.cacheResult().__iterate(t,e);for(var n=this._iterator,r=this._iteratorCache,o=0;o<r.length;)if(!1===t(r[o],o++,this))return o;for(var i;!(i=n.next()).done;){var a=i.value;if(r[o]=a,!1===t(a,o++,this))break}return o},U.prototype.__iteratorUncached=function(t,e){if(e)return this.cacheResult().__iterator(t,e);var n=this._iterator,r=this._iteratorCache,o=0;return new N(function(){if(o>=r.length){var e=n.next();if(e.done)return e;r[o]=e.value}return v(t,o,r[o++])})};var An;t(X,x),X.prototype.toString=function(){return 0===this.size?"Repeat []":"Repeat [ "+this._value+" "+this.size+" times ]"},X.prototype.get=function(t,e){return this.has(t)?this._value:e},X.prototype.includes=function(t){return q(this._value,t)},X.prototype.slice=function(t,e){var n=this.size;return m(t,e,n)?this:new X(this._value,w(e,n)-I(t,n))},X.prototype.reverse=function(){return this},X.prototype.indexOf=function(t){return q(this._value,t)?0:-1},X.prototype.lastIndexOf=function(t){return q(this._value,t)?this.size:-1},X.prototype.__iterate=function(t,e){for(var n=0;n<this.size;n++)if(!1===t(this._value,n,this))return n+1;return n},X.prototype.__iterator=function(t,e){var n=this,r=0;return new N(function(){return r<n.size?v(t,r++,n._value):C()})},X.prototype.equals=function(t){return t instanceof X?q(this._value,t._value):V(t)};var En;t(tt,x),tt.prototype.toString=function(){return 0===this.size?"Range []":"Range [ "+this._start+"..."+this._end+(this._step>1?" by "+this._step:"")+" ]"},tt.prototype.get=function(t,e){return this.has(t)?this._start+h(this,t)*this._step:e},tt.prototype.includes=function(t){var e=(t-this._start)/this._step;return e>=0&&e<this.size&&e===Math.floor(e)},tt.prototype.slice=function(t,e){return m(t,e,this.size)?this:(t=I(t,this.size),e=w(e,this.size),e<=t?new tt(0,0):new tt(this.get(t,this._end),this.get(e,this._end),this._step))},tt.prototype.indexOf=function(t){var e=t-this._start;if(e%this._step==0){var n=e/this._step;if(n>=0&&n<this.size)return n}return-1},tt.prototype.lastIndexOf=function(t){return this.indexOf(t)},tt.prototype.__iterate=function(t,e){for(var n=this.size-1,r=this._step,o=e?this._start+n*r:this._start,i=0;i<=n;i++){if(!1===t(o,i,this))return i+1;o+=e?-r:r}return i},tt.prototype.__iterator=function(t,e){var n=this.size-1,r=this._step,o=e?this._start+n*r:this._start,i=0;return new N(function(){var a=o;return o+=e?-r:r,i>n?C():v(t,i++,a)})},tt.prototype.equals=function(t){return t instanceof tt?this._start===t._start&&this._end===t._end&&this._step===t._step:V(this,t)};var Sn;t(et,e),t(nt,et),t(rt,et),t(ot,et),et.Keyed=nt,et.Indexed=rt,et.Set=ot;var bn,xn="function"==typeof Math.imul&&-2===Math.imul(4294967295,2)?Math.imul:function(t,e){t|=0,e|=0;var n=65535&t,r=65535&e;return n*r+((t>>>16)*r+n*(e>>>16)<<16>>>0)|0},On=Object.isExtensible,_n=function(){try{return Object.defineProperty({},"@",{}),!0}catch(t){return!1}}(),kn="function"==typeof WeakMap;kn&&(bn=new WeakMap);var Ln=0,Un="__immutablehash__";"function"==typeof Symbol&&(Un=Symbol(Un));var Qn=16,Yn=255,Bn=0,Pn={};t(pt,nt),pt.prototype.toString=function(){return this.__toString("Map {","}")},pt.prototype.get=function(t,e){return this._root?this._root.get(0,void 0,t,e):e},pt.prototype.set=function(t,e){return Ct(this,t,e)},pt.prototype.setIn=function(t,e){return this.updateIn(t,mn,function(){return e})},pt.prototype.remove=function(t){return Ct(this,t,mn)},pt.prototype.deleteIn=function(t){return this.updateIn(t,function(){return mn})},pt.prototype.update=function(t,e,n){return 1===arguments.length?t(this):this.updateIn([t],e,n)},pt.prototype.updateIn=function(t,e,n){n||(n=e,e=void 0);var r=kt(this,xe(t),e,n);return r===mn?void 0:r},pt.prototype.clear=function(){return 0===this.size?this:this.__ownerID?(this.size=0,this._root=null,this.__hash=void 0,this.__altered=!0,this):vt()},pt.prototype.merge=function(){return bt(this,void 0,arguments)},pt.prototype.mergeWith=function(t){return bt(this,t,cn.call(arguments,1))},pt.prototype.mergeIn=function(t){var e=cn.call(arguments,1);return this.updateIn(t,vt(),function(t){return"function"==typeof t.merge?t.merge.apply(t,e):e[e.length-1]})},pt.prototype.mergeDeep=function(){return bt(this,xt,arguments)},pt.prototype.mergeDeepWith=function(t){var e=cn.call(arguments,1);return bt(this,Ot(t),e)},pt.prototype.mergeDeepIn=function(t){var e=cn.call(arguments,1);return this.updateIn(t,vt(),function(t){return"function"==typeof t.mergeDeep?t.mergeDeep.apply(t,e):e[e.length-1]})},pt.prototype.sort=function(t){return $t(De(this,t))},pt.prototype.sortBy=function(t,e){return $t(De(this,e,t))},pt.prototype.withMutations=function(t){var e=this.asMutable();return t(e),e.wasAltered()?e.__ensureOwner(this.__ownerID):this},pt.prototype.asMutable=function(){return this.__ownerID?this:this.__ensureOwner(new d)},pt.prototype.asImmutable=function(){return this.__ensureOwner()},pt.prototype.wasAltered=function(){return this.__altered},pt.prototype.__iterator=function(t,e){return new It(this,t,e)},pt.prototype.__iterate=function(t,e){var n=this,r=0;return this._root&&this._root.iterate(function(e){return r++,t(e[1],e[0],n)},e),r},pt.prototype.__ensureOwner=function(t){return t===this.__ownerID?this:t?Nt(this.size,this._root,t,this.__hash):(this.__ownerID=t,this.__altered=!1,this)},pt.isMap=dt;var Rn="@@__IMMUTABLE_MAP__@@",Zn=pt.prototype;Zn[Rn]=!0,Zn[gn]=Zn.remove,Zn.removeIn=Zn.deleteIn,gt.prototype.get=function(t,e,n,r){for(var o=this.entries,i=0,a=o.length;i<a;i++)if(q(n,o[i][0]))return o[i][1];return r},gt.prototype.update=function(t,e,n,r,o,i,a){for(var s=o===mn,u=this.entries,c=0,l=u.length;c<l&&!q(r,u[c][0]);c++);var f=c<l;if(f?u[c][1]===o:s)return this;if(p(a),(s||!f)&&p(i),!s||1!==u.length){if(!f&&!s&&u.length>=Wn)return At(t,u,r,o);var d=t&&t===this.ownerID,M=d?u:g(u);return f?s?c===l-1?M.pop():M[c]=M.pop():M[c]=[r,o]:M.push([r,o]),d?(this.entries=M,this):new gt(t,M)}},Mt.prototype.get=function(t,e,n,r){void 0===e&&(e=at(n));var o=1<<((0===t?e:e>>>t)&yn),i=this.bitmap;return 0==(i&o)?r:this.nodes[Lt(i&o-1)].get(t+Mn,e,n,r)},Mt.prototype.update=function(t,e,n,r,o,i,a){void 0===n&&(n=at(r));var s=(0===e?n:n>>>e)&yn,u=1<<s,c=this.bitmap,l=0!=(c&u);if(!l&&o===mn)return this;var f=Lt(c&u-1),p=this.nodes,d=l?p[f]:void 0,g=jt(d,t,e+Mn,n,r,o,i,a);if(g===d)return this;if(!l&&g&&p.length>=Fn)return St(t,p,c,s,g);if(l&&!g&&2===p.length&&zt(p[1^f]))return p[1^f];if(l&&g&&1===p.length&&zt(g))return g;var M=t&&t===this.ownerID,h=l?g?c:c^u:c|u,y=l?g?Ut(p,f,g,M):Yt(p,f,M):Qt(p,f,g,M);return M?(this.bitmap=h,this.nodes=y,this):new Mt(t,h,y)},ht.prototype.get=function(t,e,n,r){void 0===e&&(e=at(n));var o=(0===t?e:e>>>t)&yn,i=this.nodes[o];return i?i.get(t+Mn,e,n,r):r},ht.prototype.update=function(t,e,n,r,o,i,a){void 0===n&&(n=at(r));var s=(0===e?n:n>>>e)&yn,u=o===mn,c=this.nodes,l=c[s];if(u&&!l)return this;var f=jt(l,t,e+Mn,n,r,o,i,a);if(f===l)return this;var p=this.count;if(l){if(!f&&--p<Hn)return Et(t,c,p,s)}else p++;var d=t&&t===this.ownerID,g=Ut(c,s,f,d);return d?(this.count=p,this.nodes=g,this):new ht(t,p,g)},yt.prototype.get=function(t,e,n,r){for(var o=this.entries,i=0,a=o.length;i<a;i++)if(q(n,o[i][0]))return o[i][1];return r},yt.prototype.update=function(t,e,n,r,o,i,a){void 0===n&&(n=at(r));var s=o===mn;if(n!==this.keyHash)return s?this:(p(a),p(i),Tt(this,t,e,n,[r,o]));for(var u=this.entries,c=0,l=u.length;c<l&&!q(r,u[c][0]);c++);var f=c<l;if(f?u[c][1]===o:s)return this;if(p(a),(s||!f)&&p(i),s&&2===l)return new mt(t,this.keyHash,u[1^c]);var d=t&&t===this.ownerID,M=d?u:g(u);return f?s?c===l-1?M.pop():M[c]=M.pop():M[c]=[r,o]:M.push([r,o]),d?(this.entries=M,this):new yt(t,this.keyHash,M)},mt.prototype.get=function(t,e,n,r){return q(n,this.entry[0])?this.entry[1]:r},mt.prototype.update=function(t,e,n,r,o,i,a){var s=o===mn,u=q(r,this.entry[0]);return(u?o===this.entry[1]:s)?this:(p(a),s?void p(i):u?t&&t===this.ownerID?(this.entry[1]=o,this):new mt(t,this.keyHash,[r,o]):(p(i),Tt(this,t,e,at(r),[r,o])))},gt.prototype.iterate=yt.prototype.iterate=function(t,e){for(var n=this.entries,r=0,o=n.length-1;r<=o;r++)if(!1===t(n[e?o-r:r]))return!1},Mt.prototype.iterate=ht.prototype.iterate=function(t,e){for(var n=this.nodes,r=0,o=n.length-1;r<=o;r++){var i=n[e?o-r:r];if(i&&!1===i.iterate(t,e))return!1}},mt.prototype.iterate=function(t,e){return t(this.entry)},t(It,N),It.prototype.next=function(){for(var t=this._type,e=this._stack;e;){var n,r=e.node,o=e.index++;if(r.entry){if(0===o)return wt(t,r.entry)}else if(r.entries){if(n=r.entries.length-1,o<=n)return wt(t,r.entries[this._reverse?n-o:o])}else if(n=r.nodes.length-1,o<=n){var i=r.nodes[this._reverse?n-o:o];if(i){if(i.entry)return wt(t,i.entry);e=this._stack=Dt(i,e)}continue}e=this._stack=this._stack.__prev}return C()};var Gn,Wn=hn/4,Fn=hn/2,Hn=hn/4;t(Bt,rt),Bt.of=function(){return this(arguments)},Bt.prototype.toString=function(){return this.__toString("List [","]")},Bt.prototype.get=function(t,e){if((t=h(this,t))>=0&&t<this.size){t+=this._origin;var n=Jt(this,t);return n&&n.array[t&yn]}return e},Bt.prototype.set=function(t,e){return Ft(this,t,e)},Bt.prototype.remove=function(t){return this.has(t)?0===t?this.shift():t===this.size-1?this.pop():this.splice(t,1):this},Bt.prototype.insert=function(t,e){return this.splice(t,0,e)},Bt.prototype.clear=function(){return 0===this.size?this:this.__ownerID?(this.size=this._origin=this._capacity=0,this._level=Mn,this._root=this._tail=null,this.__hash=void 0,this.__altered=!0,this):Wt()},Bt.prototype.push=function(){var t=arguments,e=this.size;return this.withMutations(function(n){qt(n,0,e+t.length);for(var r=0;r<t.length;r++)n.set(e+r,t[r])})},Bt.prototype.pop=function(){return qt(this,0,-1)},Bt.prototype.unshift=function(){var t=arguments;return this.withMutations(function(e){qt(e,-t.length);for(var n=0;n<t.length;n++)e.set(n,t[n])})},Bt.prototype.shift=function(){return qt(this,1)},Bt.prototype.merge=function(){return Vt(this,void 0,arguments)},Bt.prototype.mergeWith=function(t){return Vt(this,t,cn.call(arguments,1))},Bt.prototype.mergeDeep=function(){return Vt(this,xt,arguments)},Bt.prototype.mergeDeepWith=function(t){var e=cn.call(arguments,1);return Vt(this,Ot(t),e)},Bt.prototype.setSize=function(t){return qt(this,0,t)},Bt.prototype.slice=function(t,e){var n=this.size;return m(t,e,n)?this:qt(this,I(t,n),w(e,n))},Bt.prototype.__iterator=function(t,e){var n=0,r=Zt(this,e);return new N(function(){var e=r();return e===Vn?C():v(t,n++,e)})},Bt.prototype.__iterate=function(t,e){for(var n,r=0,o=Zt(this,e);(n=o())!==Vn&&!1!==t(n,r++,this););return r},Bt.prototype.__ensureOwner=function(t){return t===this.__ownerID?this:t?Gt(this._origin,this._capacity,this._level,this._root,this._tail,t,this.__hash):(this.__ownerID=t,this)},Bt.isList=Pt;var Kn="@@__IMMUTABLE_LIST__@@",Jn=Bt.prototype;Jn[Kn]=!0,Jn[gn]=Jn.remove,Jn.setIn=Zn.setIn,Jn.deleteIn=Jn.removeIn=Zn.removeIn,Jn.update=Zn.update,Jn.updateIn=Zn.updateIn,Jn.mergeIn=Zn.mergeIn,Jn.mergeDeepIn=Zn.mergeDeepIn,Jn.withMutations=Zn.withMutations,Jn.asMutable=Zn.asMutable,Jn.asImmutable=Zn.asImmutable,Jn.wasAltered=Zn.wasAltered,Rt.prototype.removeBefore=function(t,e,n){if(n===e?1<<e:0===this.array.length)return this;var r=n>>>e&yn;if(r>=this.array.length)return new Rt([],t);var o,i=0===r;if(e>0){var a=this.array[r];if((o=a&&a.removeBefore(t,e-Mn,n))===a&&i)return this}if(i&&!o)return this;var s=Kt(this,t);if(!i)for(var u=0;u<r;u++)s.array[u]=void 0;return o&&(s.array[r]=o),s},Rt.prototype.removeAfter=function(t,e,n){if(n===(e?1<<e:0)||0===this.array.length)return this;var r=n-1>>>e&yn;if(r>=this.array.length)return this;var o;if(e>0){var i=this.array[r];if((o=i&&i.removeAfter(t,e-Mn,n))===i&&r===this.array.length-1)return this}var a=Kt(this,t);return a.array.splice(r+1),o&&(a.array[r]=o),a};var qn,Vn={};t($t,pt),$t.of=function(){return this(arguments)},$t.prototype.toString=function(){return this.__toString("OrderedMap {","}")},$t.prototype.get=function(t,e){var n=this._map.get(t);return void 0!==n?this._list.get(n)[1]:e},$t.prototype.clear=function(){return 0===this.size?this:this.__ownerID?(this.size=0,this._map.clear(),this._list.clear(),this):ne()},$t.prototype.set=function(t,e){return re(this,t,e)},$t.prototype.remove=function(t){return re(this,t,mn)},$t.prototype.wasAltered=function(){return this._map.wasAltered()||this._list.wasAltered()},$t.prototype.__iterate=function(t,e){var n=this;return this._list.__iterate(function(e){return e&&t(e[1],e[0],n)},e)},$t.prototype.__iterator=function(t,e){return this._list.fromEntrySeq().__iterator(t,e)},$t.prototype.__ensureOwner=function(t){if(t===this.__ownerID)return this;var e=this._map.__ensureOwner(t),n=this._list.__ensureOwner(t);return t?ee(e,n,t,this.__hash):(this.__ownerID=t,this._map=e,this._list=n,this)},$t.isOrderedMap=te,$t.prototype[dn]=!0,$t.prototype[gn]=$t.prototype.remove;var Xn;t(oe,b),oe.prototype.get=function(t,e){return this._iter.get(t,e)},oe.prototype.has=function(t){return this._iter.has(t)},oe.prototype.valueSeq=function(){return this._iter.valueSeq()},oe.prototype.reverse=function(){var t=this,e=le(this,!0);return this._useKeys||(e.valueSeq=function(){return t._iter.toSeq().reverse()}),e},oe.prototype.map=function(t,e){var n=this,r=ce(this,t,e);return this._useKeys||(r.valueSeq=function(){return n._iter.toSeq().map(t,e)}),r},oe.prototype.__iterate=function(t,e){var n,r=this;return this._iter.__iterate(this._useKeys?function(e,n){return t(e,n,r)}:(n=e?Te(this):0,function(o){return t(o,e?--n:n++,r)}),e)},oe.prototype.__iterator=function(t,e){if(this._useKeys)return this._iter.__iterator(t,e);var n=this._iter.__iterator(Nn,e),r=e?Te(this):0;return new N(function(){var o=n.next();return o.done?o:v(t,e?--r:r++,o.value,o)})},oe.prototype[dn]=!0,t(ie,x),ie.prototype.includes=function(t){return this._iter.includes(t)},ie.prototype.__iterate=function(t,e){var n=this,r=0;return this._iter.__iterate(function(e){return t(e,r++,n)},e)},ie.prototype.__iterator=function(t,e){var n=this._iter.__iterator(Nn,e),r=0;return new N(function(){var e=n.next();return e.done?e:v(t,r++,e.value,e)})},t(ae,O),ae.prototype.has=function(t){return this._iter.includes(t)},ae.prototype.__iterate=function(t,e){var n=this;return this._iter.__iterate(function(e){return t(e,e,n)},e)},ae.prototype.__iterator=function(t,e){var n=this._iter.__iterator(Nn,e);return new N(function(){var e=n.next();return e.done?e:v(t,e.value,e.value,e)})},t(se,b),se.prototype.entrySeq=function(){return this._iter.toSeq()},se.prototype.__iterate=function(t,e){var n=this;return this._iter.__iterate(function(e){if(e){ze(e);var r=i(e);return t(r?e.get(1):e[1],r?e.get(0):e[0],n)}},e)},se.prototype.__iterator=function(t,e){var n=this._iter.__iterator(Nn,e);return new N(function(){for(;;){var e=n.next();if(e.done)return e;var r=e.value;if(r){ze(r);var o=i(r);return v(t,o?r.get(0):r[0],o?r.get(1):r[1],e)}}})},ie.prototype.cacheResult=oe.prototype.cacheResult=ae.prototype.cacheResult=se.prototype.cacheResult=Se,t(Oe,nt),Oe.prototype.toString=function(){return this.__toString(ke(this)+" {","}")},Oe.prototype.has=function(t){return this._defaultValues.hasOwnProperty(t)},Oe.prototype.get=function(t,e){if(!this.has(t))return e;var n=this._defaultValues[t];return this._map?this._map.get(t,n):n},Oe.prototype.clear=function(){if(this.__ownerID)return this._map&&this._map.clear(),this;var t=this.constructor;return t._empty||(t._empty=_e(this,vt()))},Oe.prototype.set=function(t,e){if(!this.has(t))throw new Error('Cannot set unknown key "'+t+'" on '+ke(this));var n=this._map&&this._map.set(t,e);return this.__ownerID||n===this._map?this:_e(this,n)},Oe.prototype.remove=function(t){if(!this.has(t))return this;var e=this._map&&this._map.remove(t);return this.__ownerID||e===this._map?this:_e(this,e)},Oe.prototype.wasAltered=function(){return this._map.wasAltered()},Oe.prototype.__iterator=function(t,e){var r=this;return n(this._defaultValues).map(function(t,e){return r.get(e)}).__iterator(t,e)},Oe.prototype.__iterate=function(t,e){var r=this;return n(this._defaultValues).map(function(t,e){return r.get(e)}).__iterate(t,e)},Oe.prototype.__ensureOwner=function(t){if(t===this.__ownerID)return this;var e=this._map&&this._map.__ensureOwner(t);return t?_e(this,e,t):(this.__ownerID=t,this._map=e,this)};var $n=Oe.prototype;$n[gn]=$n.remove,$n.deleteIn=$n.removeIn=Zn.removeIn,$n.merge=Zn.merge,$n.mergeWith=Zn.mergeWith,$n.mergeIn=Zn.mergeIn,$n.mergeDeep=Zn.mergeDeep,$n.mergeDeepWith=Zn.mergeDeepWith,$n.mergeDeepIn=Zn.mergeDeepIn,$n.setIn=Zn.setIn,$n.update=Zn.update,$n.updateIn=Zn.updateIn,$n.withMutations=Zn.withMutations,$n.asMutable=Zn.asMutable,$n.asImmutable=Zn.asImmutable,t(Qe,ot),Qe.of=function(){return this(arguments)},Qe.fromKeys=function(t){return this(n(t).keySeq())},Qe.prototype.toString=function(){return this.__toString("Set {","}")},Qe.prototype.has=function(t){return this._map.has(t)},Qe.prototype.add=function(t){return Be(this,this._map.set(t,!0))},Qe.prototype.remove=function(t){return Be(this,this._map.remove(t))},Qe.prototype.clear=function(){return Be(this,this._map.clear())},Qe.prototype.union=function(){var t=cn.call(arguments,0);return t=t.filter(function(t){return 0!==t.size}),0===t.length?this:0!==this.size||this.__ownerID||1!==t.length?this.withMutations(function(e){for(var n=0;n<t.length;n++)o(t[n]).forEach(function(t){return e.add(t)})}):this.constructor(t[0])},Qe.prototype.intersect=function(){var t=cn.call(arguments,0);if(0===t.length)return this;t=t.map(function(t){return o(t)});var e=this;return this.withMutations(function(n){e.forEach(function(e){t.every(function(t){return t.includes(e)})||n.remove(e)})})},Qe.prototype.subtract=function(){var t=cn.call(arguments,0);if(0===t.length)return this;t=t.map(function(t){return o(t)});var e=this;return this.withMutations(function(n){e.forEach(function(e){t.some(function(t){return t.includes(e)})&&n.remove(e)})})},Qe.prototype.merge=function(){return this.union.apply(this,arguments)},Qe.prototype.mergeWith=function(t){var e=cn.call(arguments,1);return this.union.apply(this,e)},Qe.prototype.sort=function(t){return Ze(De(this,t))},Qe.prototype.sortBy=function(t,e){return Ze(De(this,e,t))},Qe.prototype.wasAltered=function(){return this._map.wasAltered()},Qe.prototype.__iterate=function(t,e){var n=this;return this._map.__iterate(function(e,r){return t(r,r,n)},e)},Qe.prototype.__iterator=function(t,e){return this._map.map(function(t,e){return e}).__iterator(t,e)},Qe.prototype.__ensureOwner=function(t){if(t===this.__ownerID)return this;var e=this._map.__ensureOwner(t);return t?this.__make(e,t):(this.__ownerID=t,this._map=e,this)},Qe.isSet=Ye;var tr="@@__IMMUTABLE_SET__@@",er=Qe.prototype;er[tr]=!0,er[gn]=er.remove,er.mergeDeep=er.merge,er.mergeDeepWith=er.mergeWith,er.withMutations=Zn.withMutations,er.asMutable=Zn.asMutable,er.asImmutable=Zn.asImmutable,er.__empty=Re,er.__make=Pe;var nr;t(Ze,Qe),Ze.of=function(){return this(arguments)},Ze.fromKeys=function(t){return this(n(t).keySeq())},Ze.prototype.toString=function(){return this.__toString("OrderedSet {","}")},Ze.isOrderedSet=Ge;var rr=Ze.prototype;rr[dn]=!0,rr.__empty=Fe,rr.__make=We;var or;t(He,rt),He.of=function(){return this(arguments)},He.prototype.toString=function(){return this.__toString("Stack [","]")},He.prototype.get=function(t,e){var n=this._head;for(t=h(this,t);n&&t--;)n=n.next;return n?n.value:e},He.prototype.peek=function(){return this._head&&this._head.value},He.prototype.push=function(){if(0===arguments.length)return this;for(var t=this.size+arguments.length,e=this._head,n=arguments.length-1;n>=0;n--)e={value:arguments[n],next:e};return this.__ownerID?(this.size=t,this._head=e,this.__hash=void 0,this.__altered=!0,this):Je(t,e)},He.prototype.pushAll=function(t){if(t=r(t),0===t.size)return this;ft(t.size);var e=this.size,n=this._head;return t.reverse().forEach(function(t){e++,n={value:t,next:n}}),this.__ownerID?(this.size=e,this._head=n,this.__hash=void 0,this.__altered=!0,this):Je(e,n)},He.prototype.pop=function(){return this.slice(1)},He.prototype.unshift=function(){return this.push.apply(this,arguments)},He.prototype.unshiftAll=function(t){return this.pushAll(t)},He.prototype.shift=function(){return this.pop.apply(this,arguments)},He.prototype.clear=function(){return 0===this.size?this:this.__ownerID?(this.size=0,this._head=void 0,this.__hash=void 0,this.__altered=!0,this):qe()},He.prototype.slice=function(t,e){if(m(t,e,this.size))return this;var n=I(t,this.size);if(w(e,this.size)!==this.size)return rt.prototype.slice.call(this,t,e);for(var r=this.size-n,o=this._head;n--;)o=o.next;return this.__ownerID?(this.size=r,this._head=o,this.__hash=void 0,this.__altered=!0,this):Je(r,o)},He.prototype.__ensureOwner=function(t){return t===this.__ownerID?this:t?Je(this.size,this._head,t,this.__hash):(this.__ownerID=t,this.__altered=!1,this)},He.prototype.__iterate=function(t,e){if(e)return this.reverse().__iterate(t);for(var n=0,r=this._head;r&&!1!==t(r.value,n++,this);)r=r.next;return n},He.prototype.__iterator=function(t,e){if(e)return this.reverse().__iterator(t);var n=0,r=this._head;return new N(function(){if(r){var e=r.value;return r=r.next,v(t,n++,e)}return C()})},He.isStack=Ke;var ir="@@__IMMUTABLE_STACK__@@",ar=He.prototype;ar[ir]=!0,ar.withMutations=Zn.withMutations,ar.asMutable=Zn.asMutable,ar.asImmutable=Zn.asImmutable,ar.wasAltered=Zn.wasAltered;var sr;e.Iterator=N,Ve(e,{toArray:function(){ft(this.size);var t=new Array(this.size||0);return this.valueSeq().__iterate(function(e,n){t[n]=e}),t},toIndexedSeq:function(){return new ie(this)},toJS:function(){return this.toSeq().map(function(t){return t&&"function"==typeof t.toJS?t.toJS():t}).__toJS()},toJSON:function(){return this.toSeq().map(function(t){return t&&"function"==typeof t.toJSON?t.toJSON():t}).__toJS()},toKeyedSeq:function(){return new oe(this,!0)},toMap:function(){return pt(this.toKeyedSeq())},toObject:function(){ft(this.size);var t={};return this.__iterate(function(e,n){t[n]=e}),t},toOrderedMap:function(){return $t(this.toKeyedSeq())},toOrderedSet:function(){return Ze(s(this)?this.valueSeq():this)},toSet:function(){return Qe(s(this)?this.valueSeq():this)},toSetSeq:function(){return new ae(this)},toSeq:function(){return u(this)?this.toIndexedSeq():s(this)?this.toKeyedSeq():this.toSetSeq()},toStack:function(){return He(s(this)?this.valueSeq():this)},toList:function(){return Bt(s(this)?this.valueSeq():this)},toString:function(){return"[Iterable]"},__toString:function(t,e){return 0===this.size?t+e:t+" "+this.toSeq().map(this.__toStringMapper).join(", ")+" "+e},concat:function(){return je(this,ye(this,cn.call(arguments,0)))},includes:function(t){return this.some(function(e){return q(e,t)})},entries:function(){return this.__iterator(vn)},every:function(t,e){ft(this.size);var n=!0;return this.__iterate(function(r,o,i){if(!t.call(e,r,o,i))return n=!1,!1}),n},filter:function(t,e){return je(this,fe(this,t,e,!0))},find:function(t,e,n){var r=this.findEntry(t,e);return r?r[1]:n},findEntry:function(t,e){var n;return this.__iterate(function(r,o,i){if(t.call(e,r,o,i))return n=[o,r],!1}),n},findLastEntry:function(t,e){return this.toSeq().reverse().findEntry(t,e)},forEach:function(t,e){return ft(this.size),this.__iterate(e?t.bind(e):t)},join:function(t){ft(this.size),t=void 0!==t?""+t:",";var e="",n=!0;return this.__iterate(function(r){n?n=!1:e+=t,e+=null!==r&&void 0!==r?r.toString():""}),e},keys:function(){return this.__iterator(Dn)},map:function(t,e){return je(this,ce(this,t,e))},reduce:function(t,e,n){ft(this.size);var r,o;return arguments.length<2?o=!0:r=e,this.__iterate(function(e,i,a){o?(o=!1,r=e):r=t.call(n,r,e,i,a)}),r},reduceRight:function(t,e,n){var r=this.toKeyedSeq().reverse();return r.reduce.apply(r,arguments)},reverse:function(){return je(this,le(this,!0))},slice:function(t,e){return je(this,ge(this,t,e,!0))},some:function(t,e){return!this.every(tn(t),e)},sort:function(t){return je(this,De(this,t))},values:function(){return this.__iterator(Nn)},butLast:function(){return this.slice(0,-1)},isEmpty:function(){return void 0!==this.size?0===this.size:!this.some(function(){return!0})},count:function(t,e){return M(t?this.toSeq().filter(t,e):this)},countBy:function(t,e){return pe(this,t,e)},equals:function(t){return V(this,t)},entrySeq:function(){var t=this;if(t._cache)return new _(t._cache);var e=t.toSeq().map($e).toIndexedSeq();return e.fromEntrySeq=function(){return t.toSeq()},e},filterNot:function(t,e){return this.filter(tn(t),e)},findLast:function(t,e,n){return this.toKeyedSeq().reverse().find(t,e,n)},first:function(){return this.find(y)},flatMap:function(t,e){return je(this,Ie(this,t,e))},flatten:function(t){return je(this,me(this,t,!0))},fromEntrySeq:function(){return new se(this)},get:function(t,e){return this.find(function(e,n){return q(n,t)},void 0,e)},getIn:function(t,e){for(var n,r=this,o=xe(t);!(n=o.next()).done;){var i=n.value;if((r=r&&r.get?r.get(i,mn):mn)===mn)return e}return r},groupBy:function(t,e){return de(this,t,e)},has:function(t){return this.get(t,mn)!==mn},hasIn:function(t){return this.getIn(t,mn)!==mn},isSubset:function(t){return t="function"==typeof t.includes?t:e(t),this.every(function(e){return t.includes(e)})},isSuperset:function(t){return t="function"==typeof t.isSubset?t:e(t),t.isSubset(this)},keySeq:function(){return this.toSeq().map(Xe).toIndexedSeq()},last:function(){return this.toSeq().reverse().first()},max:function(t){return Ne(this,t)},maxBy:function(t,e){return Ne(this,e,t)},min:function(t){return Ne(this,t?en(t):on)},minBy:function(t,e){return Ne(this,e?en(e):on,t)},rest:function(){return this.slice(1)},skip:function(t){return this.slice(Math.max(0,t))},skipLast:function(t){return je(this,this.toSeq().reverse().skip(t).reverse())},skipWhile:function(t,e){return je(this,he(this,t,e,!0))},skipUntil:function(t,e){return this.skipWhile(tn(t),e)},sortBy:function(t,e){return je(this,De(this,e,t))},take:function(t){return this.slice(0,Math.max(0,t))},takeLast:function(t){return je(this,this.toSeq().reverse().take(t).reverse())},takeWhile:function(t,e){return je(this,Me(this,t,e))},takeUntil:function(t,e){return this.takeWhile(tn(t),e)},valueSeq:function(){return this.toIndexedSeq()},hashCode:function(){return this.__hash||(this.__hash=an(this))}});var ur=e.prototype;ur[ln]=!0,ur[zn]=ur.values,ur.__toJS=ur.toArray,ur.__toStringMapper=nn,ur.inspect=ur.toSource=function(){return this.toString()},ur.chain=ur.flatMap,ur.contains=ur.includes,function(){try{Object.defineProperty(ur,"length",{get:function(){if(!e.noLengthWarning){var t;try{throw new Error}catch(e){t=e.stack}if(-1===t.indexOf("_wrapObject"))return console&&console.warn&&console.warn("iterable.length has been deprecated, use iterable.size or iterable.count(). This warning will become a silent error in a future version. "+t),this.size}}})}catch(t){}}(),Ve(n,{flip:function(){return je(this,ue(this))},findKey:function(t,e){var n=this.findEntry(t,e);return n&&n[0]},findLastKey:function(t,e){return this.toSeq().reverse().findKey(t,e)},keyOf:function(t){return this.findKey(function(e){return q(e,t)})},lastKeyOf:function(t){return this.findLastKey(function(e){return q(e,t)})},mapEntries:function(t,e){var n=this,r=0;return je(this,this.toSeq().map(function(o,i){return t.call(e,[i,o],r++,n)}).fromEntrySeq())},mapKeys:function(t,e){var n=this;return je(this,this.toSeq().flip().map(function(r,o){return t.call(e,r,o,n)}).flip())}});var cr=n.prototype;return cr[fn]=!0,cr[zn]=ur.entries,cr.__toJS=ur.toObject,cr.__toStringMapper=function(t,e){return JSON.stringify(e)+": "+nn(t)},Ve(r,{toKeyedSeq:function(){return new oe(this,!1)},filter:function(t,e){return je(this,fe(this,t,e,!1))},findIndex:function(t,e){var n=this.findEntry(t,e);return n?n[0]:-1},indexOf:function(t){var e=this.toKeyedSeq().keyOf(t);return void 0===e?-1:e},lastIndexOf:function(t){var e=this.toKeyedSeq().reverse().keyOf(t);return void 0===e?-1:e},reverse:function(){return je(this,le(this,!1))},slice:function(t,e){return je(this,ge(this,t,e,!1))},splice:function(t,e){var n=arguments.length;if(e=Math.max(0|e,0),0===n||2===n&&!e)return this;t=I(t,t<0?this.count():this.size);var r=this.slice(0,t);return je(this,1===n?r:r.concat(g(arguments,2),this.slice(t+e)))},findLastIndex:function(t,e){var n=this.toKeyedSeq().findLastKey(t,e);return void 0===n?-1:n},first:function(){return this.get(0)},flatten:function(t){return je(this,me(this,t,!1))},get:function(t,e){return t=h(this,t),t<0||this.size===1/0||void 0!==this.size&&t>this.size?e:this.find(function(e,n){return n===t},void 0,e)},has:function(t){return(t=h(this,t))>=0&&(void 0!==this.size?this.size===1/0||t<this.size:-1!==this.indexOf(t))},interpose:function(t){return je(this,we(this,t))},interleave:function(){var t=[this].concat(g(arguments)),e=Ce(this.toSeq(),x.of,t),n=e.flatten(!0);return e.size&&(n.size=e.size*t.length),je(this,n)},last:function(){return this.get(-1)},skipWhile:function(t,e){return je(this,he(this,t,e,!1))},zip:function(){return je(this,Ce(this,rn,[this].concat(g(arguments))))},zipWith:function(t){var e=g(arguments);return e[0]=this,je(this,Ce(this,t,e))}}),r.prototype[pn]=!0,r.prototype[dn]=!0,Ve(o,{get:function(t,e){return this.has(t)?t:e},includes:function(t){return this.has(t)},keySeq:function(){return this.valueSeq()}}),o.prototype.has=ur.includes,Ve(b,n.prototype),Ve(x,r.prototype),Ve(O,o.prototype),Ve(nt,n.prototype),Ve(rt,r.prototype),Ve(ot,o.prototype),{Iterable:e,Seq:S,Collection:et,Map:pt,OrderedMap:$t,List:Bt,Stack:He,Set:Qe,OrderedSet:Ze,Record:Oe,Range:tt,Repeat:X,is:q,fromJS:F}})},function(t,e){t.exports=n(6)},function(t,e,n){function r(t){return t&&t.__esModule?t:{default:t}}function o(t,e,n,r,i){var a=t.nodeName.toLowerCase();if("#text"===a&&"\n"!==t.textContent)return(0,f.createTextChunk)(t,e,i);if("br"===a)return{chunk:(0,f.getSoftNewlineChunk)()};if("img"===a&&t instanceof HTMLImageElement){var u={};u.src=t.src,u.alt=t.alt,u.height=t.style.height,u.width=t.style.width;var c=s.Entity.create("IMAGE","MUTABLE",u);return{chunk:(0,f.getAtomicBlockChunk)(c)}}if("iframe"===a&&t instanceof HTMLIFrameElement){var l={};l.src=t.src,l.height=t.height,l.width=t.width;var p=s.Entity.create("EMBEDDED_LINK","MUTABLE",l);return{chunk:(0,f.getAtomicBlockChunk)(p)}}var g=(0,d.default)(a,r),h=void 0;g&&("ul"===a||"ol"===a?(r=a,n+=1):("unordered-list-item"!==g&&"ordered-list-item"!==g&&(r="",n=-1),N?(h=(0,f.getFirstBlockChunk)(g,(0,y.default)(t)),N=!1):h=(0,f.getBlockDividerChunk)(g,n,(0,y.default)(t)))),h||(h=(0,f.getEmptyChunk)()),e=(0,M.default)(a,t,e);for(var m=t.firstChild;m;){var w=(0,I.default)(m),D=o(m,e,n,r,w||i),v=D.chunk;h=(0,f.joinChunks)(h,v);m=m.nextSibling}return{chunk:h}}function i(t){var e=t.trim().replace(D,w),n=(0,l.default)(e);return n?(N=!0,{chunk:o(n,new u.OrderedSet,-1,"",void 0).chunk}):null}function a(t){var e=i(t);if(e){var n=e.chunk,r=new u.OrderedMap({}),o=0;return{contentBlocks:n.text.split("\r").map(function(t,e){var r=o+t.length,i=n&&n.inlines.slice(o,r),a=n&&n.entities.slice(o,r),c=new u.List(i.map(function(t,e){var n={style:t,entity:null};return a[e]&&(n.entity=a[e]),s.CharacterMetadata.create(n)}));return o=r,new s.ContentBlock({key:(0,s.genKey)(),type:n&&n.blocks[e].type,depth:n&&n.blocks[e].depth,data:n&&n.blocks[e].data,text:t,characterList:c})}),entityMap:r}}return null}Object.defineProperty(e,"__esModule",{value:!0}),e.default=a;var s=n(1),u=n(0),c=n(7),l=r(c),f=n(3),p=n(5),d=r(p),g=n(8),M=r(g),h=n(4),y=r(h),m=n(6),I=r(m),w=" ",D=new RegExp("&nbsp;","g"),N=!0},function(t,e,n){var r=n(0),o=function(t){return{text:" ",inlines:[new r.OrderedSet],entities:[t],blocks:[]}},i=function(t,e,n){var r=t.textContent;return""===r.trim()?{chunk:o(n)}:{chunk:{text:r,inlines:Array(r.length).fill(e),entities:Array(r.length).fill(n),blocks:[]}}},a=function(){return{text:"\n",inlines:[new r.OrderedSet],entities:new Array(1),blocks:[]}},s=function(){return{text:"",inlines:[],entities:[],blocks:[{type:"unstyled",depth:0,data:new r.Map({})}]}},u=function(t,e){return{text:"",inlines:[],entities:[],blocks:[{type:t,depth:0,data:e||new r.Map({})}]}},c=function(t,e,n){return{text:"\r",inlines:[],entities:[],blocks:[{type:t,depth:Math.max(0,Math.min(4,e)),data:n||new r.Map({})}]}},l=function(t){return{text:"\r ",inlines:[new r.OrderedSet],entities:[t],blocks:[{type:"atomic",depth:0,data:new r.Map({})}]}},f=function(t,e){return{text:t.text+e.text,inlines:t.inlines.concat(e.inlines),entities:t.entities.concat(e.entities),blocks:t.blocks.concat(e.blocks)}};t.exports={createTextChunk:i,getWhitespaceChunk:o,getSoftNewlineChunk:a,getEmptyChunk:s,getBlockDividerChunk:c,getFirstBlockChunk:u,getAtomicBlockChunk:l,joinChunks:f}},function(t,e,n){function r(t){if(t.style.textAlign)return new o.Map({"text-align":t.style.textAlign})}Object.defineProperty(e,"__esModule",{value:!0}),e.default=r;var o=n(0)},function(t,e,n){function r(t,e){var n=i.filter(function(n){return n.element===t&&(!n.wrapper||n.wrapper===e)||n.wrapper===t||n.aliasedElements&&n.aliasedElements.indexOf(t)>-1}).keySeq().toSet().toArray();if(1===n.length)return n[0]}Object.defineProperty(e,"__esModule",{value:!0}),e.default=r;var o=n(0),i=new o.Map({"header-one":{element:"h1"},"header-two":{element:"h2"},"header-three":{element:"h3"},"header-four":{element:"h4"},"header-five":{element:"h5"},"header-six":{element:"h6"},"unordered-list-item":{element:"li",wrapper:"ul"},"ordered-list-item":{element:"li",wrapper:"ol"},blockquote:{element:"blockquote"},atomic:{element:"figure"},unstyled:{element:"p",aliasedElements:["div"]}})},function(t,e,n){var r=n(1),o=function(t){var e=void 0;if(t instanceof HTMLAnchorElement){var n={};void 0!==t.dataset.mention?(n.url=t.href,n.text=t.innerHTML,n.value=t.dataset.value,e=r.Entity.create("MENTION","IMMUTABLE",n)):(n.url=t.href,n.title=t.innerHTML,n.target=t.target,e=r.Entity.create("LINK","MUTABLE",n))}return e};t.exports=o},function(t,e,n){var r=function(t){var e,n=null;return document.implementation&&document.implementation.createHTMLDocument&&(e=document.implementation.createHTMLDocument("foo"),e.documentElement.innerHTML=t,n=e.getElementsByTagName("body")[0]),n};t.exports=r},function(t,e,n){function r(t,e,n){var r=o[t],i=void 0;if(r)i=n.add(r).toOrderedSet();else if(e instanceof HTMLElement){i=n;var a=e;i=i.withMutations(function(t){var e=a.style.color,n=a.style.backgroundColor,r=a.style.fontSize,o=a.style.fontFamily;e&&t.add("color-"+e.replace(/ /g,"")),n&&t.add("bgcolor-"+n.replace(/ /g,"")),r&&t.add("fontsize-"+r.substr(0,r.length-2)),o&&t.add("fontfamily-"+o)}).toOrderedSet()}return i}Object.defineProperty(e,"__esModule",{value:!0}),e.default=r;var o={code:"CODE",del:"STRIKETHROUGH",em:"ITALIC",strong:"BOLD",ins:"UNDERLINE",sub:"SUBSCRIPT",sup:"SUPERSCRIPT"}},function(t,e,n){t.exports=n(2)}])},function(t,e,n){"use strict";function r(t){return t&&t.__esModule?t:{default:t}}var o=n(172),i=r(o),a=n(180),s=r(a),u=n(183),c=r(u),l=n(186),f=r(l),p=n(189),d=r(p),g=n(192),M=r(g),h=n(195),y=r(h),m=n(198),I=r(m),w=n(201),D=r(w),N=n(204),v=r(N),C=n(207),j=r(C),z=n(212),T=r(z),A=n(215),E=r(A);t.exports={inline:i.default,blockType:s.default,fontSize:c.default,fontFamily:f.default,list:d.default,textAlign:M.default,colorPicker:y.default,link:I.default,embedded:D.default,emoji:v.default,image:j.default,remove:T.default,history:E.default}},function(t,e,n){"use strict";function r(t){return t&&t.__esModule?t:{default:t}}function o(t,e){if(!(t instanceof e))throw new TypeError("Cannot call a class as a function")}function i(t,e){if(!t)throw new ReferenceError("this hasn't been initialised - super() hasn't been called");return!e||"object"!=typeof e&&"function"!=typeof e?t:e}function a(t,e){if("function"!=typeof e&&null!==e)throw new TypeError("Super expression must either be null or a function, not "+typeof e);t.prototype=Object.create(e&&e.prototype,{constructor:{value:t,enumerable:!1,writable:!0,configurable:!0}}),e&&(Object.setPrototypeOf?Object.setPrototypeOf(t,e):t.__proto__=e)}Object.defineProperty(e,"__esModule",{value:!0});var s=function(){function t(t,e){for(var n=0;n<e.length;n++){var r=e[n];r.enumerable=r.enumerable||!1,r.configurable=!0,"value"in r&&(r.writable=!0),Object.defineProperty(t,r.key,r)}}return function(e,n,r){return n&&t(e.prototype,n),r&&t(e,r),e}}(),u=n(0),c=r(u),l=n(1),f=r(l),p=n(9),d=n(6),g=n(14),M=n(173),h=r(M),y=function(t){function e(){var t,n,r,a;o(this,e);for(var s=arguments.length,u=Array(s),c=0;c<s;c++)u[c]=arguments[c];return n=r=i(this,(t=e.__proto__||Object.getPrototypeOf(e)).call.apply(t,[this].concat(u))),r.state={currentStyles:{}},r.onExpandEvent=function(){r.signalExpanded=!r.state.expanded},r.expandCollapse=function(){r.setState({expanded:r.signalExpanded}),r.signalExpanded=!1},r.toggleInlineStyle=function(t){var e="monospace"===t?"CODE":t.toUpperCase(),n=r.props,o=n.editorState,i=n.onChange,a=d.RichUtils.toggleInlineStyle(o,e);if("subscript"===t||"superscript"===t){var s="subscript"===t?"SUPERSCRIPT":"SUBSCRIPT",u=d.Modifier.removeInlineStyle(a.getCurrentContent(),a.getSelection(),s);a=d.EditorState.push(a,u,"change-inline-style")}a&&i(a)},r.changeKeys=function(t){if(t){var e={};return(0,g.forEach)(t,function(t,n){e["CODE"===t?"monospace":t.toLowerCase()]=n}),e}},r.doExpand=function(){r.setState({expanded:!0})},r.doCollapse=function(){r.setState({expanded:!1})},a=n,i(r,a)}return a(e,t),s(e,[{key:"componentWillMount",value:function(){var t=this.props,e=t.editorState,n=t.modalHandler;e&&this.setState({currentStyles:this.changeKeys((0,p.getSelectionInlineStyle)(e))}),n.registerCallBack(this.expandCollapse)}},{key:"componentWillReceiveProps",value:function(t){t.editorState&&this.props.editorState!==t.editorState&&this.setState({currentStyles:this.changeKeys((0,p.getSelectionInlineStyle)(t.editorState))})}},{key:"componentWillUnmount",value:function(){this.props.modalHandler.deregisterCallBack(this.expandCollapse)}},{key:"render",value:function(){var t=this.props,e=t.config,n=t.translations,r=this.state,o=r.expanded,i=r.currentStyles,a=e.component||h.default;return c.default.createElement(a,{config:e,translations:n,currentState:i,expanded:o,onExpandEvent:this.onExpandEvent,doExpand:this.doExpand,doCollapse:this.doCollapse,onChange:this.toggleInlineStyle})}}]),e}(u.Component);y.propTypes={onChange:f.default.func.isRequired,editorState:f.default.object.isRequired,modalHandler:f.default.object,config:f.default.object,translations:f.default.object},e.default=y},function(t,e,n){"use strict";function r(t){return t&&t.__esModule?t:{default:t}}function o(t,e){if(!(t instanceof e))throw new TypeError("Cannot call a class as a function")}function i(t,e){if(!t)throw new ReferenceError("this hasn't been initialised - super() hasn't been called");return!e||"object"!=typeof e&&"function"!=typeof e?t:e}function a(t,e){if("function"!=typeof e&&null!==e)throw new TypeError("Super expression must either be null or a function, not "+typeof e);t.prototype=Object.create(e&&e.prototype,{constructor:{value:t,enumerable:!1,writable:!0,configurable:!0}}),e&&(Object.setPrototypeOf?Object.setPrototypeOf(t,e):t.__proto__=e)}Object.defineProperty(e,"__esModule",{value:!0});var s=function(){function t(t,e){for(var n=0;n<e.length;n++){var r=e[n];r.enumerable=r.enumerable||!1,r.configurable=!0,"value"in r&&(r.writable=!0),Object.defineProperty(t,r.key,r)}}return function(e,n,r){return n&&t(e.prototype,n),r&&t(e,r),e}}(),u=n(0),c=r(u),l=n(1),f=r(l),p=n(5),d=r(p),g=n(20),M=n(10),h=r(M),y=n(16);n(179);var m=function(t){function e(){return o(this,e),i(this,(e.__proto__||Object.getPrototypeOf(e)).apply(this,arguments))}return a(e,t),s(e,[{key:"renderInFlatList",value:function(){var t=this.props,e=t.config,n=t.currentState,r=t.onChange,o=t.translations;return c.default.createElement("div",{className:(0,d.default)("rdw-inline-wrapper",e.className),"aria-label":"rdw-inline-control"},e.options.map(function(t,i){return c.default.createElement(h.default,{key:i,value:t,onClick:r,className:(0,d.default)(e[t].className),active:!0===n[t]||"MONOSPACE"===t&&n.CODE,title:e[t].title||o["components.controls.inline."+t]},c.default.createElement("img",{alt:"",src:e[t].icon}))}))}},{key:"renderInDropDown",value:function(){var t=this.props,e=t.config,n=t.expanded,r=t.doExpand,o=t.onExpandEvent,i=t.doCollapse,a=t.currentState,s=t.onChange,u=t.translations,l=e.className,f=e.dropdownClassName,p=e.title;return c.default.createElement(y.Dropdown,{className:(0,d.default)("rdw-inline-dropdown",l),optionWrapperClassName:(0,d.default)(f),onChange:s,expanded:n,doExpand:r,doCollapse:i,onExpandEvent:o,"aria-label":"rdw-inline-control",title:p},c.default.createElement("img",{src:(0,g.getFirstIcon)(e),alt:""}),e.options.map(function(t,n){return c.default.createElement(y.DropdownOption,{key:n,value:t,className:(0,d.default)("rdw-inline-dropdownoption",e[t].className),active:!0===a[t]||"MONOSPACE"===t&&a.CODE,title:e[t].title||u["components.controls.inline."+t]},c.default.createElement("img",{src:e[t].icon,alt:""}))}))}},{key:"render",value:function(){return this.props.config.inDropdown?this.renderInDropDown():this.renderInFlatList()}}]),e}(u.Component);m.propTypes={expanded:f.default.bool,doExpand:f.default.func,doCollapse:f.default.func,onExpandEvent:f.default.func,config:f.default.object,onChange:f.default.func,currentState:f.default.object,translations:f.default.object},e.default=m},function(t,e){t.exports={"rdw-option-wrapper":"rdw-option-wrapper","rdw-option-active":"rdw-option-active","rdw-option-disabled":"rdw-option-disabled"}},function(t,e,n){"use strict";function r(t){return t&&t.__esModule?t:{default:t}}function o(t,e){if(!(t instanceof e))throw new TypeError("Cannot call a class as a function")}function i(t,e){if(!t)throw new ReferenceError("this hasn't been initialised - super() hasn't been called");return!e||"object"!=typeof e&&"function"!=typeof e?t:e}function a(t,e){if("function"!=typeof e&&null!==e)throw new TypeError("Super expression must either be null or a function, not "+typeof e);t.prototype=Object.create(e&&e.prototype,{constructor:{value:t,enumerable:!1,writable:!0,configurable:!0}}),e&&(Object.setPrototypeOf?Object.setPrototypeOf(t,e):t.__proto__=e)}Object.defineProperty(e,"__esModule",{value:!0});var s=function(){function t(t,e){for(var n=0;n<e.length;n++){var r=e[n];r.enumerable=r.enumerable||!1,r.configurable=!0,"value"in r&&(r.writable=!0),Object.defineProperty(t,r.key,r)}}return function(e,n,r){return n&&t(e.prototype,n),r&&t(e,r),e}}(),u=n(0),c=r(u),l=n(1),f=r(l),p=n(5),d=r(p);n(176);var g=n(14),M=function(t){function e(){var t,n,r,a;o(this,e);for(var s=arguments.length,u=Array(s),c=0;c<s;c++)u[c]=arguments[c];return n=r=i(this,(t=e.__proto__||Object.getPrototypeOf(e)).call.apply(t,[this].concat(u))),r.state={highlighted:-1},r.onChange=function(t){var e=r.props.onChange;e&&e(t),r.toggleExpansion()},r.setHighlighted=function(t){r.setState({highlighted:t})},r.toggleExpansion=function(){var t=r.props,e=t.doExpand,n=t.doCollapse;t.expanded?n():e()},a=n,i(r,a)}return a(e,t),s(e,[{key:"componentWillReceiveProps",value:function(t){this.props.expanded&&!t.expanded&&this.setState({highlighted:-1})}},{key:"render",value:function(){var t=this,e=this.props,n=e.expanded,r=e.children,o=e.className,i=e.optionWrapperClassName,a=e.ariaLabel,s=e.onExpandEvent,u=e.title,l=this.state.highlighted,f=r.slice(1,r.length);return c.default.createElement("div",{className:(0,d.default)("rdw-dropdown-wrapper",o),"aria-expanded":n,"aria-label":a||"rdw-dropdown"},c.default.createElement("a",{className:"rdw-dropdown-selectedtext",onClick:s,title:u},r[0],c.default.createElement("div",{className:(0,d.default)({"rdw-dropdown-carettoclose":n,"rdw-dropdown-carettoopen":!n})})),n?c.default.createElement("ul",{className:(0,d.default)("rdw-dropdown-optionwrapper",i),onClick:g.stopPropagation},c.default.Children.map(f,function(e,n){return e&&c.default.cloneElement(e,{onSelect:t.onChange,highlighted:l===n,setHighlighted:t.setHighlighted,index:n})})):void 0)}}]),e}(u.Component);M.propTypes={children:f.default.any,onChange:f.default.func,className:f.default.string,expanded:f.default.bool,doExpand:f.default.func,doCollapse:f.default.func,onExpandEvent:f.default.func,optionWrapperClassName:f.default.string,ariaLabel:f.default.string,title:f.default.string},e.default=M},function(t,e){t.exports={"rdw-dropdown-wrapper":"rdw-dropdown-wrapper","rdw-dropdown-carettoopen":"rdw-dropdown-carettoopen","rdw-dropdown-carettoclose":"rdw-dropdown-carettoclose","rdw-dropdown-selectedtext":"rdw-dropdown-selectedtext","rdw-dropdown-optionwrapper":"rdw-dropdown-optionwrapper"}},function(t,e,n){"use strict";function r(t){return t&&t.__esModule?t:{default:t}}function o(t,e,n){return e in t?Object.defineProperty(t,e,{value:n,enumerable:!0,configurable:!0,writable:!0}):t[e]=n,t}function i(t,e){if(!(t instanceof e))throw new TypeError("Cannot call a class as a function")}function a(t,e){if(!t)throw new ReferenceError("this hasn't been initialised - super() hasn't been called");return!e||"object"!=typeof e&&"function"!=typeof e?t:e}function s(t,e){if("function"!=typeof e&&null!==e)throw new TypeError("Super expression must either be null or a function, not "+typeof e);t.prototype=Object.create(e&&e.prototype,{constructor:{value:t,enumerable:!1,writable:!0,configurable:!0}}),e&&(Object.setPrototypeOf?Object.setPrototypeOf(t,e):t.__proto__=e)}Object.defineProperty(e,"__esModule",{value:!0});var u=function(){function t(t,e){for(var n=0;n<e.length;n++){var r=e[n];r.enumerable=r.enumerable||!1,r.configurable=!0,"value"in r&&(r.writable=!0),Object.defineProperty(t,r.key,r)}}return function(e,n,r){return n&&t(e.prototype,n),r&&t(e,r),e}}(),c=n(0),l=r(c),f=n(1),p=r(f),d=n(5),g=r(d);n(178);var M=function(t){function e(){var t,n,r,o;i(this,e);for(var s=arguments.length,u=Array(s),c=0;c<s;c++)u[c]=arguments[c];return n=r=a(this,(t=e.__proto__||Object.getPrototypeOf(e)).call.apply(t,[this].concat(u))),r.onClick=function(t){var e=r.props,n=e.onSelect,o=e.onClick,i=e.value;e.disabled||(n&&n(i),o&&(t.stopPropagation(),o(i)))},r.setHighlighted=function(){var t=r.props;(0,t.setHighlighted)(t.index)},r.resetHighlighted=function(){(0,r.props.setHighlighted)(-1)},o=n,a(r,o)}return s(e,t),u(e,[{key:"render",value:function(){var t,e=this.props,n=e.children,r=e.active,i=e.disabled,a=e.highlighted,s=e.className,u=e.activeClassName,c=e.disabledClassName,f=e.highlightedClassName,p=e.title;return l.default.createElement("li",{className:(0,g.default)("rdw-dropdownoption-default",s,(t={},o(t,"rdw-dropdownoption-active "+u,r),o(t,"rdw-dropdownoption-highlighted "+f,a),o(t,"rdw-dropdownoption-disabled "+c,i),t)),onMouseEnter:this.setHighlighted,onMouseLeave:this.resetHighlighted,onClick:this.onClick,title:p},n)}}]),e}(c.Component);M.propTypes={children:p.default.any,value:p.default.any,onClick:p.default.func,onSelect:p.default.func,setHighlighted:p.default.func,index:p.default.number,disabled:p.default.bool,active:p.default.bool,highlighted:p.default.bool,className:p.default.string,activeClassName:p.default.string,disabledClassName:p.default.string,highlightedClassName:p.default.string,title:p.default.string},e.default=M},function(t,e){t.exports={"rdw-dropdownoption-default":"rdw-dropdownoption-default","rdw-dropdownoption-highlighted":"rdw-dropdownoption-highlighted","rdw-dropdownoption-active":"rdw-dropdownoption-active","rdw-dropdownoption-disabled":"rdw-dropdownoption-disabled"}},function(t,e){t.exports={"rdw-inline-wrapper":"rdw-inline-wrapper","rdw-inline-dropdown":"rdw-inline-dropdown","rdw-inline-dropdownoption":"rdw-inline-dropdownoption"}},function(t,e,n){"use strict";function r(t){return t&&t.__esModule?t:{default:t}}function o(t,e){if(!(t instanceof e))throw new TypeError("Cannot call a class as a function")}function i(t,e){if(!t)throw new ReferenceError("this hasn't been initialised - super() hasn't been called");return!e||"object"!=typeof e&&"function"!=typeof e?t:e}function a(t,e){if("function"!=typeof e&&null!==e)throw new TypeError("Super expression must either be null or a function, not "+typeof e);t.prototype=Object.create(e&&e.prototype,{constructor:{value:t,enumerable:!1,writable:!0,configurable:!0}}),e&&(Object.setPrototypeOf?Object.setPrototypeOf(t,e):t.__proto__=e)}Object.defineProperty(e,"__esModule",{value:!0});var s=function(){function t(t,e){for(var n=0;n<e.length;n++){var r=e[n];r.enumerable=r.enumerable||!1,r.configurable=!0,"value"in r&&(r.writable=!0),Object.defineProperty(t,r.key,r)}}return function(e,n,r){return n&&t(e.prototype,n),r&&t(e,r),e}}(),u=n(0),c=r(u),l=n(1),f=r(l),p=n(9),d=n(6),g=n(181),M=r(g),h=function(t){function e(){var t,n,r,a;o(this,e);for(var s=arguments.length,u=Array(s),c=0;c<s;c++)u[c]=arguments[c];return n=r=i(this,(t=e.__proto__||Object.getPrototypeOf(e)).call.apply(t,[this].concat(u))),r.state={expanded:!1,currentBlockType:"unstyled"},r.onExpandEvent=function(){r.signalExpanded=!r.state.expanded},r.expandCollapse=function(){r.setState({expanded:r.signalExpanded}),r.signalExpanded=!1},r.blocksTypes=[{label:"Normal",style:"unstyled"},{label:"H1",style:"header-one"},{label:"H2",style:"header-two"},{label:"H3",style:"header-three"},{label:"H4",style:"header-four"},{label:"H5",style:"header-five"},{label:"H6",style:"header-six"},{label:"Blockquote",style:"blockquote"},{label:"Code",style:"code"}],r.doExpand=function(){r.setState({expanded:!0})},r.doCollapse=function(){r.setState({expanded:!1})},r.toggleBlockType=function(t){var e=r.blocksTypes.find(function(e){return e.label===t}).style,n=r.props,o=n.editorState,i=n.onChange,a=d.RichUtils.toggleBlockType(o,e);a&&i(a)},a=n,i(r,a)}return a(e,t),s(e,[{key:"componentWillMount",value:function(){var t=this.props,e=t.editorState,n=t.modalHandler;e&&this.setState({currentBlockType:(0,p.getSelectedBlocksType)(e)}),n.registerCallBack(this.expandCollapse)}},{key:"componentWillReceiveProps",value:function(t){t.editorState&&this.props.editorState!==t.editorState&&this.setState({currentBlockType:(0,p.getSelectedBlocksType)(t.editorState)})}},{key:"componentWillUnmount",value:function(){this.props.modalHandler.deregisterCallBack(this.expandCollapse)}},{key:"render",value:function(){var t=this.props,e=t.config,n=t.translations,r=this.state,o=r.expanded,i=r.currentBlockType,a=e.component||M.default,s=this.blocksTypes.find(function(t){return t.style===i});return c.default.createElement(a,{config:e,translations:n,currentState:{blockType:s&&s.label},onChange:this.toggleBlockType,expanded:o,onExpandEvent:this.onExpandEvent,doExpand:this.doExpand,doCollapse:this.doCollapse})}}]),e}(u.Component);h.propTypes={onChange:f.default.func.isRequired,editorState:f.default.object,modalHandler:f.default.object,config:f.default.object,translations:f.default.object},e.default=h},function(t,e,n){"use strict";function r(t){return t&&t.__esModule?t:{default:t}}function o(t,e){if(!(t instanceof e))throw new TypeError("Cannot call a class as a function")}function i(t,e){if(!t)throw new ReferenceError("this hasn't been initialised - super() hasn't been called");return!e||"object"!=typeof e&&"function"!=typeof e?t:e}function a(t,e){if("function"!=typeof e&&null!==e)throw new TypeError("Super expression must either be null or a function, not "+typeof e);t.prototype=Object.create(e&&e.prototype,{constructor:{value:t,enumerable:!1,writable:!0,configurable:!0}}),e&&(Object.setPrototypeOf?Object.setPrototypeOf(t,e):t.__proto__=e)}Object.defineProperty(e,"__esModule",{value:!0});var s=function(){function t(t,e){for(var n=0;n<e.length;n++){var r=e[n];r.enumerable=r.enumerable||!1,r.configurable=!0,"value"in r&&(r.writable=!0),Object.defineProperty(t,r.key,r)}}return function(e,n,r){return n&&t(e.prototype,n),r&&t(e,r),e}}(),u=n(0),c=r(u),l=n(1),f=r(l),p=n(5),d=r(p),g=n(10),M=r(g),h=n(16);n(182);var y=function(t){function e(t){o(this,e);var n=i(this,(e.__proto__||Object.getPrototypeOf(e)).call(this,t));return n.getBlockTypes=function(t){return[{label:"Normal",displayName:t["components.controls.blocktype.normal"]},{label:"H1",displayName:t["components.controls.blocktype.h1"]},{label:"H2",displayName:t["components.controls.blocktype.h2"]},{label:"H3",displayName:t["components.controls.blocktype.h3"]},{label:"H4",displayName:t["components.controls.blocktype.h4"]},{label:"H5",displayName:t["components.controls.blocktype.h5"]},{label:"H6",displayName:t["components.controls.blocktype.h6"]},{label:"Blockquote",displayName:t["components.controls.blocktype.blockquote"]},{label:"Code",displayName:t["components.controls.blocktype.code"]}]},n.state={blockTypes:n.getBlockTypes(t.translations)},n}return a(e,t),s(e,[{key:"componentWillReceiveProps",value:function(t){this.props.translations!==t.translations&&this.setState({blockTypes:this.getBlockTypes(t.translations)})}},{key:"renderFlat",value:function(t){var e=this.props,n=e.config.className,r=e.onChange,o=e.currentState.blockType;return c.default.createElement("div",{className:(0,d.default)("rdw-inline-wrapper",n)},t.map(function(t,e){return c.default.createElement(M.default,{key:e,value:t.label,active:o===t.label,onClick:r},t.displayName)}))}},{key:"renderInDropdown",value:function(t){var e=this.props,n=e.config,r=n.className,o=n.dropdownClassName,i=n.title,a=e.currentState.blockType,s=e.expanded,u=e.doExpand,l=e.onExpandEvent,f=e.doCollapse,p=e.onChange,g=e.translations,M=this.state.blockTypes,y=M.filter(function(t){return t.label===a}),m=y&&y[0]&&y[0].displayName;return c.default.createElement("div",{className:"rdw-block-wrapper","aria-label":"rdw-block-control"},c.default.createElement(h.Dropdown,{className:(0,d.default)("rdw-block-dropdown",r),optionWrapperClassName:(0,d.default)(o),onChange:p,expanded:s,doExpand:u,doCollapse:f,onExpandEvent:l,title:i||g["components.controls.blocktype.blocktype"]},c.default.createElement("span",null,m||g["components.controls.blocktype.blocktype"]),t.map(function(t,e){return c.default.createElement(h.DropdownOption,{active:a===t.label,value:t.label,key:e},t.displayName)})))}},{key:"render",value:function(){var t=this.props.config,e=t.inDropdown,n=this.state.blockTypes,r=n.filter(function(e){var n=e.label;return t.options.includes(n)});return e?this.renderInDropdown(r):this.renderFlat(r)}}]),e}(u.Component);y.propTypes={expanded:f.default.bool,onExpandEvent:f.default.func,doExpand:f.default.func,doCollapse:f.default.func,onChange:f.default.func,config:f.default.object,currentState:f.default.object,translations:f.default.object},e.default=y},function(t,e){t.exports={"rdw-block-wrapper":"rdw-block-wrapper","rdw-block-dropdown":"rdw-block-dropdown"}},function(t,e,n){"use strict";function r(t){return t&&t.__esModule?t:{default:t}}function o(t,e){if(!(t instanceof e))throw new TypeError("Cannot call a class as a function")}function i(t,e){if(!t)throw new ReferenceError("this hasn't been initialised - super() hasn't been called");return!e||"object"!=typeof e&&"function"!=typeof e?t:e}function a(t,e){if("function"!=typeof e&&null!==e)throw new TypeError("Super expression must either be null or a function, not "+typeof e);t.prototype=Object.create(e&&e.prototype,{constructor:{value:t,enumerable:!1,writable:!0,configurable:!0}}),e&&(Object.setPrototypeOf?Object.setPrototypeOf(t,e):t.__proto__=e)}Object.defineProperty(e,"__esModule",{value:!0});var s=function(){function t(t,e){for(var n=0;n<e.length;n++){var r=e[n];r.enumerable=r.enumerable||!1,r.configurable=!0,"value"in r&&(r.writable=!0),Object.defineProperty(t,r.key,r)}}return function(e,n,r){return n&&t(e.prototype,n),r&&t(e,r),e}}(),u=n(0),c=r(u),l=n(1),f=r(l),p=n(9),d=n(184),g=r(d),M=function(t){function e(){var t,n,r,a;o(this,e);for(var s=arguments.length,u=Array(s),c=0;c<s;c++)u[c]=arguments[c];return n=r=i(this,(t=e.__proto__||Object.getPrototypeOf(e)).call.apply(t,[this].concat(u))),r.state={expanded:void 0,currentFontSize:void 0},r.onExpandEvent=function(){r.signalExpanded=!r.state.expanded},r.expandCollapse=function(){r.setState({expanded:r.signalExpanded}),r.signalExpanded=!1},r.doExpand=function(){r.setState({expanded:!0})},r.doCollapse=function(){r.setState({expanded:!1})},r.toggleFontSize=function(t){var e=r.props,n=e.editorState,o=e.onChange,i=(0,p.toggleCustomInlineStyle)(n,"fontSize",t);i&&o(i)},a=n,i(r,a)}return a(e,t),s(e,[{key:"componentWillMount",value:function(){var t=this.props,e=t.editorState,n=t.modalHandler;e&&this.setState({currentFontSize:(0,p.getSelectionCustomInlineStyle)(e,["FONTSIZE"]).FONTSIZE}),n.registerCallBack(this.expandCollapse)}},{key:"componentWillReceiveProps",value:function(t){t.editorState&&this.props.editorState!==t.editorState&&this.setState({currentFontSize:(0,p.getSelectionCustomInlineStyle)(t.editorState,["FONTSIZE"]).FONTSIZE})}},{key:"componentWillUnmount",value:function(){this.props.modalHandler.deregisterCallBack(this.expandCollapse)}},{key:"render",value:function(){var t=this.props,e=t.config,n=t.translations,r=this.state,o=r.expanded,i=r.currentFontSize,a=e.component||g.default,s=i&&Number(i.substring(9));return c.default.createElement(a,{config:e,translations:n,currentState:{fontSize:s},onChange:this.toggleFontSize,expanded:o,onExpandEvent:this.onExpandEvent,doExpand:this.doExpand,doCollapse:this.doCollapse})}}]),e}(u.Component);M.propTypes={onChange:f.default.func.isRequired,editorState:f.default.object,modalHandler:f.default.object,config:f.default.object,translations:f.default.object},e.default=M},function(t,e,n){"use strict";function r(t){return t&&t.__esModule?t:{default:t}}function o(t,e){if(!(t instanceof e))throw new TypeError("Cannot call a class as a function")}function i(t,e){if(!t)throw new ReferenceError("this hasn't been initialised - super() hasn't been called");return!e||"object"!=typeof e&&"function"!=typeof e?t:e}function a(t,e){if("function"!=typeof e&&null!==e)throw new TypeError("Super expression must either be null or a function, not "+typeof e);t.prototype=Object.create(e&&e.prototype,{constructor:{value:t,enumerable:!1,writable:!0,configurable:!0}}),e&&(Object.setPrototypeOf?Object.setPrototypeOf(t,e):t.__proto__=e)}Object.defineProperty(e,"__esModule",{value:!0});var s=function(){function t(t,e){for(var n=0;n<e.length;n++){var r=e[n];r.enumerable=r.enumerable||!1,r.configurable=!0,"value"in r&&(r.writable=!0),Object.defineProperty(t,r.key,r)}}return function(e,n,r){return n&&t(e.prototype,n),r&&t(e,r),e}}(),u=n(0),c=r(u),l=n(1),f=r(l),p=n(5),d=r(p),g=n(16);n(185);var M=function(t){function e(){var t,n,r,a;o(this,e);for(var s=arguments.length,u=Array(s),c=0;c<s;c++)u[c]=arguments[c];return n=r=i(this,(t=e.__proto__||Object.getPrototypeOf(e)).call.apply(t,[this].concat(u))),r.state={defaultFontSize:void 0},a=n,i(r,a)}return a(e,t),s(e,[{key:"componentDidMount",value:function(){var t=document.getElementsByClassName("DraftEditor-root");if(t&&t.length>0){var e=window.getComputedStyle(t[0]),n=e.getPropertyValue("font-size");n=n.substring(0,n.length-2),this.setState({defaultFontSize:n})}}},{key:"render",value:function(){var t=this.props,e=t.config,n=e.icon,r=e.className,o=e.dropdownClassName,i=e.options,a=e.title,s=t.onChange,u=t.expanded,l=t.doCollapse,f=t.onExpandEvent,p=t.doExpand,M=t.translations,h=this.props.currentState.fontSize,y=this.state.defaultFontSize;return y=Number(y),h=h||i&&i.indexOf(y)>=0&&y,c.default.createElement("div",{className:"rdw-fontsize-wrapper","aria-label":"rdw-font-size-control"},c.default.createElement(g.Dropdown,{className:(0,d.default)("rdw-fontsize-dropdown",r),optionWrapperClassName:(0,d.default)(o),onChange:s,expanded:u,doExpand:p,doCollapse:l,onExpandEvent:f,title:a||M["components.controls.fontsize.fontsize"]},h?c.default.createElement("span",null,h):c.default.createElement("img",{src:n,alt:""}),i.map(function(t,e){return c.default.createElement(g.DropdownOption,{className:"rdw-fontsize-option",active:h===t,value:t,key:e},t)})))}}]),e}(u.Component);M.propTypes={expanded:f.default.bool,onExpandEvent:f.default.func,doExpand:f.default.func,doCollapse:f.default.func,onChange:f.default.func,config:f.default.object,currentState:f.default.object,translations:f.default.object},e.default=M},function(t,e){t.exports={"rdw-fontsize-wrapper":"rdw-fontsize-wrapper","rdw-fontsize-dropdown":"rdw-fontsize-dropdown","rdw-fontsize-option":"rdw-fontsize-option"}},function(t,e,n){"use strict";function r(t){return t&&t.__esModule?t:{default:t}}function o(t,e){if(!(t instanceof e))throw new TypeError("Cannot call a class as a function")}function i(t,e){if(!t)throw new ReferenceError("this hasn't been initialised - super() hasn't been called");return!e||"object"!=typeof e&&"function"!=typeof e?t:e}function a(t,e){if("function"!=typeof e&&null!==e)throw new TypeError("Super expression must either be null or a function, not "+typeof e);t.prototype=Object.create(e&&e.prototype,{constructor:{value:t,enumerable:!1,writable:!0,configurable:!0}}),e&&(Object.setPrototypeOf?Object.setPrototypeOf(t,e):t.__proto__=e)}Object.defineProperty(e,"__esModule",{value:!0});var s=function(){function t(t,e){for(var n=0;n<e.length;n++){var r=e[n];r.enumerable=r.enumerable||!1,r.configurable=!0,"value"in r&&(r.writable=!0),Object.defineProperty(t,r.key,r)}}return function(e,n,r){return n&&t(e.prototype,n),r&&t(e,r),e}}(),u=n(0),c=r(u),l=n(1),f=r(l),p=n(9),d=n(187),g=r(d),M=function(t){function e(){var t,n,r,a;o(this,e);for(var s=arguments.length,u=Array(s),c=0;c<s;c++)u[c]=arguments[c];return n=r=i(this,(t=e.__proto__||Object.getPrototypeOf(e)).call.apply(t,[this].concat(u))),r.state={expanded:void 0,currentFontFamily:void 0},r.onExpandEvent=function(){r.signalExpanded=!r.state.expanded},r.expandCollapse=function(){r.setState({expanded:r.signalExpanded}),r.signalExpanded=!1},r.doExpand=function(){r.setState({expanded:!0})},r.doCollapse=function(){r.setState({expanded:!1})},r.toggleFontFamily=function(t){var e=r.props,n=e.editorState,o=e.onChange,i=(0,p.toggleCustomInlineStyle)(n,"fontFamily",t);i&&o(i)},a=n,i(r,a)}return a(e,t),s(e,[{key:"componentWillMount",value:function(){var t=this.props,e=t.editorState,n=t.modalHandler;e&&this.setState({currentFontFamily:(0,p.getSelectionCustomInlineStyle)(e,["FONTFAMILY"]).FONTFAMILY}),n.registerCallBack(this.expandCollapse)}},{key:"componentWillReceiveProps",value:function(t){t.editorState&&this.props.editorState!==t.editorState&&this.setState({currentFontFamily:(0,p.getSelectionCustomInlineStyle)(t.editorState,["FONTFAMILY"]).FONTFAMILY})}},{key:"componentWillUnmount",value:function(){this.props.modalHandler.deregisterCallBack(this.expandCollapse)}},{key:"render",value:function(){var t=this.props,e=t.config,n=t.translations,r=this.state,o=r.expanded,i=r.currentFontFamily,a=e.component||g.default,s=i&&i.substring(11);return c.default.createElement(a,{translations:n,config:e,currentState:{fontFamily:s},onChange:this.toggleFontFamily,expanded:o,onExpandEvent:this.onExpandEvent,doExpand:this.doExpand,doCollapse:this.doCollapse})}}]),e}(u.Component);M.propTypes={onChange:f.default.func.isRequired,editorState:f.default.object,modalHandler:f.default.object,config:f.default.object,translations:f.default.object},e.default=M},function(t,e,n){"use strict";function r(t){return t&&t.__esModule?t:{default:t}}function o(t,e){if(!(t instanceof e))throw new TypeError("Cannot call a class as a function")}function i(t,e){if(!t)throw new ReferenceError("this hasn't been initialised - super() hasn't been called");return!e||"object"!=typeof e&&"function"!=typeof e?t:e}function a(t,e){if("function"!=typeof e&&null!==e)throw new TypeError("Super expression must either be null or a function, not "+typeof e);t.prototype=Object.create(e&&e.prototype,{constructor:{value:t,enumerable:!1,writable:!0,configurable:!0}}),e&&(Object.setPrototypeOf?Object.setPrototypeOf(t,e):t.__proto__=e)}Object.defineProperty(e,"__esModule",{value:!0});var s=function(){function t(t,e){for(var n=0;n<e.length;n++){var r=e[n];r.enumerable=r.enumerable||!1,r.configurable=!0,"value"in r&&(r.writable=!0),Object.defineProperty(t,r.key,r)}}return function(e,n,r){return n&&t(e.prototype,n),r&&t(e,r),e}}(),u=n(0),c=r(u),l=n(1),f=r(l),p=n(5),d=r(p),g=n(16);n(188);var M=function(t){function e(){var t,n,r,a;o(this,e);for(var s=arguments.length,u=Array(s),c=0;c<s;c++)u[c]=arguments[c];return n=r=i(this,(t=e.__proto__||Object.getPrototypeOf(e)).call.apply(t,[this].concat(u))),r.state={defaultFontFamily:void 0},a=n,i(r,a)}return a(e,t),s(e,[{key:"componentDidMount",value:function(){var t=document.getElementsByClassName("DraftEditor-root");if(t&&t.length>0){var e=window.getComputedStyle(t[0]),n=e.getPropertyValue("font-family");this.setState({defaultFontFamily:n})}}},{key:"render",value:function(){var t=this.state.defaultFontFamily,e=this.props,n=e.config,r=n.className,o=n.dropdownClassName,i=n.options,a=n.title,s=e.translations,u=e.onChange,l=e.expanded,f=e.doCollapse,p=e.onExpandEvent,M=e.doExpand,h=this.props.currentState.fontFamily;return h=h||i&&t&&i.some(function(e){return e.toLowerCase()===t.toLowerCase()})&&t,c.default.createElement("div",{className:"rdw-fontfamily-wrapper","aria-label":"rdw-font-family-control"},c.default.createElement(g.Dropdown,{className:(0,d.default)("rdw-fontfamily-dropdown",r),optionWrapperClassName:(0,d.default)("rdw-fontfamily-optionwrapper",o),onChange:u,expanded:l,doExpand:M,doCollapse:f,onExpandEvent:p,title:a||s["components.controls.fontfamily.fontfamily"]},c.default.createElement("span",{className:"rdw-fontfamily-placeholder"},h||s["components.controls.fontfamily.fontfamily"]),i.map(function(t,e){return c.default.createElement(g.DropdownOption,{active:h===t,value:t,key:e},t)})))}}]),e}(u.Component);M.propTypes={expanded:f.default.bool,onExpandEvent:f.default.func,doExpand:f.default.func,doCollapse:f.default.func,onChange:f.default.func,config:f.default.object,currentState:f.default.object,translations:f.default.object},e.default=M},function(t,e){t.exports={"rdw-fontfamily-wrapper":"rdw-fontfamily-wrapper","rdw-fontfamily-dropdown":"rdw-fontfamily-dropdown","rdw-fontfamily-placeholder":"rdw-fontfamily-placeholder","rdw-fontfamily-optionwrapper":"rdw-fontfamily-optionwrapper"}},function(t,e,n){"use strict";function r(t){return t&&t.__esModule?t:{default:t}}function o(t,e){if(!(t instanceof e))throw new TypeError("Cannot call a class as a function")}function i(t,e){if(!t)throw new ReferenceError("this hasn't been initialised - super() hasn't been called");return!e||"object"!=typeof e&&"function"!=typeof e?t:e}function a(t,e){if("function"!=typeof e&&null!==e)throw new TypeError("Super expression must either be null or a function, not "+typeof e);t.prototype=Object.create(e&&e.prototype,{constructor:{value:t,enumerable:!1,writable:!0,configurable:!0}}),e&&(Object.setPrototypeOf?Object.setPrototypeOf(t,e):t.__proto__=e)}Object.defineProperty(e,"__esModule",{value:!0});var s=function(){function t(t,e){for(var n=0;n<e.length;n++){var r=e[n];r.enumerable=r.enumerable||!1,r.configurable=!0,"value"in r&&(r.writable=!0),Object.defineProperty(t,r.key,r)}}return function(e,n,r){return n&&t(e.prototype,n),r&&t(e,r),e}}(),u=n(0),c=r(u),l=n(1),f=r(l),p=n(6),d=n(9),g=n(190),M=r(g),h=function(t){function e(){var t,n,r,a;o(this,e);for(var s=arguments.length,u=Array(s),c=0;c<s;c++)u[c]=arguments[c];return n=r=i(this,(t=e.__proto__||Object.getPrototypeOf(e)).call.apply(t,[this].concat(u))),r.state={expanded:!1,currentBlock:void 0},r.onExpandEvent=function(){r.signalExpanded=!r.state.expanded},r.onChange=function(t){"unordered"===t?r.toggleBlockType("unordered-list-item"):"ordered"===t?r.toggleBlockType("ordered-list-item"):"indent"===t?r.adjustDepth(1):r.adjustDepth(-1)},r.expandCollapse=function(){r.setState({expanded:r.signalExpanded}),r.signalExpanded=!1},r.doExpand=function(){r.setState({expanded:!0})},r.doCollapse=function(){r.setState({expanded:!1})},r.toggleBlockType=function(t){var e=r.props,n=e.onChange,o=e.editorState,i=p.RichUtils.toggleBlockType(o,t);i&&n(i)},r.adjustDepth=function(t){var e=r.props,n=e.onChange,o=e.editorState,i=(0,d.changeDepth)(o,t,4);i&&n(i)},r.isIndentDisabled=function(){var t=r.props.editorState,e=r.state.currentBlock,n=(0,d.getBlockBeforeSelectedBlock)(t);return!n||!(0,d.isListBlock)(e)||n.get("type")!==e.get("type")||n.get("depth")<e.get("depth")},r.isOutdentDisabled=function(){var t=r.state.currentBlock;return!t||!(0,d.isListBlock)(t)||t.get("depth")<=0},a=n,i(r,a)}return a(e,t),s(e,[{key:"componentWillMount",value:function(){var t=this.props,e=t.editorState,n=t.modalHandler;e&&this.setState({currentBlock:(0,d.getSelectedBlock)(e)}),n.registerCallBack(this.expandCollapse)}},{key:"componentWillReceiveProps",value:function(t){if(t.editorState&&this.props.editorState!==t.editorState){(0,d.getSelectedBlock)(t.editorState);this.setState({currentBlock:(0,d.getSelectedBlock)(t.editorState)})}}},{key:"componentWillUnmount",value:function(){this.props.modalHandler.deregisterCallBack(this.expandCollapse)}},{key:"render",value:function(){var t=this.props,e=t.config,n=t.translations,r=this.state,o=r.expanded,i=r.currentBlock,a=e.component||M.default,s=void 0;"unordered-list-item"===i.get("type")?s="unordered":"ordered-list-item"===i.get("type")&&(s="ordered");var u=this.isIndentDisabled(),l=this.isOutdentDisabled();return c.default.createElement(a,{config:e,translations:n,currentState:{listType:s},expanded:o,onExpandEvent:this.onExpandEvent,doExpand:this.doExpand,doCollapse:this.doCollapse,onChange:this.onChange,indentDisabled:u,outdentDisabled:l})}}]),e}(u.Component);h.propTypes={onChange:f.default.func.isRequired,editorState:f.default.object.isRequired,modalHandler:f.default.object,config:f.default.object,translations:f.default.object},e.default=h},function(t,e,n){"use strict";function r(t){return t&&t.__esModule?t:{default:t}}function o(t,e){if(!(t instanceof e))throw new TypeError("Cannot call a class as a function")}function i(t,e){if(!t)throw new ReferenceError("this hasn't been initialised - super() hasn't been called");return!e||"object"!=typeof e&&"function"!=typeof e?t:e}function a(t,e){if("function"!=typeof e&&null!==e)throw new TypeError("Super expression must either be null or a function, not "+typeof e);t.prototype=Object.create(e&&e.prototype,{constructor:{value:t,enumerable:!1,writable:!0,configurable:!0}}),e&&(Object.setPrototypeOf?Object.setPrototypeOf(t,e):t.__proto__=e)}Object.defineProperty(e,"__esModule",{value:!0});var s=function(){function t(t,e){for(var n=0;n<e.length;n++){var r=e[n];r.enumerable=r.enumerable||!1,r.configurable=!0,"value"in r&&(r.writable=!0),Object.defineProperty(t,r.key,r)}}return function(e,n,r){return n&&t(e.prototype,n),r&&t(e,r),e}}(),u=n(0),c=r(u),l=n(1),f=r(l),p=n(5),d=r(p),g=n(20),M=n(16),h=n(10),y=r(h);n(191);var m=function(t){function e(){var t,n,r,a;o(this,e);for(var s=arguments.length,u=Array(s),c=0;c<s;c++)u[c]=arguments[c];return n=r=i(this,(t=e.__proto__||Object.getPrototypeOf(e)).call.apply(t,[this].concat(u))),r.options=["unordered","ordered","indent","outdent"],r.toggleBlockType=function(t){(0,r.props.onChange)(t)},r.indent=function(){(0,r.props.onChange)("indent")},r.outdent=function(){(0,r.props.onChange)("outdent")},a=n,i(r,a)}return a(e,t),s(e,[{key:"renderInFlatList",value:function(){var t=this.props,e=t.config,n=t.currentState.listType,r=t.translations,o=t.indentDisabled,i=t.outdentDisabled,a=e.options,s=e.unordered,u=e.ordered,l=e.indent,f=e.outdent,p=e.className;return c.default.createElement("div",{className:(0,d.default)("rdw-list-wrapper",p),"aria-label":"rdw-list-control"},a.indexOf("unordered")>=0&&c.default.createElement(y.default,{value:"unordered",onClick:this.toggleBlockType,className:(0,d.default)(s.className),active:"unordered"===n,title:s.title||r["components.controls.list.unordered"]},c.default.createElement("img",{src:s.icon,alt:""})),a.indexOf("ordered")>=0&&c.default.createElement(y.default,{value:"ordered",onClick:this.toggleBlockType,className:(0,d.default)(u.className),active:"ordered"===n,title:u.title||r["components.controls.list.ordered"]},c.default.createElement("img",{src:u.icon,alt:""})),a.indexOf("indent")>=0&&c.default.createElement(y.default,{onClick:this.indent,disabled:o,className:(0,d.default)(l.className),title:l.title||r["components.controls.list.indent"]},c.default.createElement("img",{src:l.icon,alt:""})),a.indexOf("outdent")>=0&&c.default.createElement(y.default,{onClick:this.outdent,disabled:i,className:(0,d.default)(f.className),title:f.title||r["components.controls.list.outdent"]},c.default.createElement("img",{src:f.icon,alt:""})))}},{key:"renderInDropDown",value:function(){var t=this,e=this.props,n=e.config,r=e.expanded,o=e.doCollapse,i=e.doExpand,a=e.onExpandEvent,s=e.onChange,u=e.currentState.listType,l=e.translations,f=n.options,p=n.className,h=n.dropdownClassName,y=n.title;return c.default.createElement(M.Dropdown,{className:(0,d.default)("rdw-list-dropdown",p),optionWrapperClassName:(0,d.default)(h),onChange:s,expanded:r,doExpand:i,doCollapse:o,onExpandEvent:a,"aria-label":"rdw-list-control",title:y||l["components.controls.list.list"]},c.default.createElement("img",{src:(0,g.getFirstIcon)(n),alt:""}),this.options.filter(function(t){return f.indexOf(t)>=0}).map(function(e,r){return c.default.createElement(M.DropdownOption,{key:r,value:e,disabled:t.props[e+"Disabled"],className:(0,d.default)("rdw-list-dropdownOption",n[e].className),active:u===e,title:n[e].title||l["components.controls.list."+e]},c.default.createElement("img",{src:n[e].icon,alt:""}))}))}},{key:"render",value:function(){return this.props.config.inDropdown?this.renderInDropDown():this.renderInFlatList()}}]),e}(u.Component);m.propTypes={expanded:f.default.bool,doExpand:f.default.func,doCollapse:f.default.func,onExpandEvent:f.default.func,config:f.default.object,onChange:f.default.func,currentState:f.default.object,translations:f.default.object,indentDisabled:f.default.bool,outdentDisabled:f.default.bool},e.default=m},function(t,e){t.exports={"rdw-list-wrapper":"rdw-list-wrapper","rdw-list-dropdown":"rdw-list-dropdown","rdw-list-dropdownOption":"rdw-list-dropdownOption"}},function(t,e,n){"use strict";function r(t){return t&&t.__esModule?t:{default:t}}function o(t,e){if(!(t instanceof e))throw new TypeError("Cannot call a class as a function")}function i(t,e){if(!t)throw new ReferenceError("this hasn't been initialised - super() hasn't been called");return!e||"object"!=typeof e&&"function"!=typeof e?t:e}function a(t,e){if("function"!=typeof e&&null!==e)throw new TypeError("Super expression must either be null or a function, not "+typeof e);t.prototype=Object.create(e&&e.prototype,{constructor:{value:t,enumerable:!1,writable:!0,configurable:!0}}),e&&(Object.setPrototypeOf?Object.setPrototypeOf(t,e):t.__proto__=e)}Object.defineProperty(e,"__esModule",{value:!0});var s=function(){function t(t,e){for(var n=0;n<e.length;n++){var r=e[n];r.enumerable=r.enumerable||!1,r.configurable=!0,"value"in r&&(r.writable=!0),Object.defineProperty(t,r.key,r)}}return function(e,n,r){return n&&t(e.prototype,n),r&&t(e,r),e}}(),u=n(0),c=r(u),l=n(1),f=r(l),p=n(9),d=n(193),g=r(d),M=function(t){function e(){var t,n,r,a;o(this,e);for(var s=arguments.length,u=Array(s),c=0;c<s;c++)u[c]=arguments[c];return n=r=i(this,(t=e.__proto__||Object.getPrototypeOf(e)).call.apply(t,[this].concat(u))),r.state={currentTextAlignment:void 0},r.onExpandEvent=function(){r.signalExpanded=!r.state.expanded},r.expandCollapse=function(){r.setState({expanded:r.signalExpanded}),r.signalExpanded=!1},r.doExpand=function(){r.setState({expanded:!0})},r.doCollapse=function(){r.setState({expanded:!1})},r.addBlockAlignmentData=function(t){var e=r.props,n=e.editorState,o=e.onChange;o(r.state.currentTextAlignment!==t?(0,p.setBlockData)(n,{"text-align":t}):(0,p.setBlockData)(n,{"text-align":void 0}))},a=n,i(r,a)}return a(e,t),s(e,[{key:"componentWillMount",value:function(){this.props.modalHandler.registerCallBack(this.expandCollapse)}},{key:"componentWillReceiveProps",value:function(t){t.editorState!==this.props.editorState&&this.setState({currentTextAlignment:(0,p.getSelectedBlocksMetadata)(t.editorState).get("text-align")})}},{key:"componentWillUnmount",value:function(){this.props.modalHandler.deregisterCallBack(this.expandCollapse)}},{key:"render",value:function(){var t=this.props,e=t.config,n=t.translations,r=this.state,o=r.expanded,i=r.currentTextAlignment,a=e.component||g.default;return c.default.createElement(a,{config:e,translations:n,expanded:o,onExpandEvent:this.onExpandEvent,doExpand:this.doExpand,doCollapse:this.doCollapse,currentState:{textAlignment:i},onChange:this.addBlockAlignmentData})}}]),e}(u.Component);M.propTypes={editorState:f.default.object.isRequired,onChange:f.default.func.isRequired,modalHandler:f.default.object,config:f.default.object,translations:f.default.object},e.default=M},function(t,e,n){"use strict";function r(t){return t&&t.__esModule?t:{default:t}}function o(t,e){if(!(t instanceof e))throw new TypeError("Cannot call a class as a function")}function i(t,e){if(!t)throw new ReferenceError("this hasn't been initialised - super() hasn't been called");return!e||"object"!=typeof e&&"function"!=typeof e?t:e}function a(t,e){if("function"!=typeof e&&null!==e)throw new TypeError("Super expression must either be null or a function, not "+typeof e);t.prototype=Object.create(e&&e.prototype,{constructor:{value:t,enumerable:!1,writable:!0,configurable:!0}}),e&&(Object.setPrototypeOf?Object.setPrototypeOf(t,e):t.__proto__=e)}Object.defineProperty(e,"__esModule",{value:!0});var s=function(){function t(t,e){for(var n=0;n<e.length;n++){var r=e[n];r.enumerable=r.enumerable||!1,r.configurable=!0,"value"in r&&(r.writable=!0),Object.defineProperty(t,r.key,r)}}return function(e,n,r){return n&&t(e.prototype,n),r&&t(e,r),e}}(),u=n(0),c=r(u),l=n(1),f=r(l),p=n(5),d=r(p),g=n(10),M=r(g),h=n(16),y=n(20);n(194);var m=function(t){function e(){return o(this,e),i(this,(e.__proto__||Object.getPrototypeOf(e)).apply(this,arguments))}return a(e,t),s(e,[{key:"renderInFlatList",value:function(){var t=this.props,e=t.config,n=e.options,r=e.left,o=e.center,i=e.right,a=e.justify,s=e.className,u=t.onChange,l=t.currentState.textAlignment,f=t.translations;return c.default.createElement("div",{className:(0,d.default)("rdw-text-align-wrapper",s),"aria-label":"rdw-textalign-control"},n.indexOf("left")>=0&&c.default.createElement(M.default,{value:"left",className:(0,d.default)(r.className),active:"left"===l,onClick:u,title:r.title||f["components.controls.textalign.left"]},c.default.createElement("img",{src:r.icon,alt:""})),n.indexOf("center")>=0&&c.default.createElement(M.default,{value:"center",className:(0,d.default)(o.className),active:"center"===l,onClick:u,title:o.title||f["components.controls.textalign.center"]},c.default.createElement("img",{src:o.icon,alt:""})),n.indexOf("right")>=0&&c.default.createElement(M.default,{value:"right",className:(0,d.default)(i.className),active:"right"===l,onClick:u,title:i.title||f["components.controls.textalign.right"]},c.default.createElement("img",{src:i.icon,alt:""})),n.indexOf("justify")>=0&&c.default.createElement(M.default,{value:"justify",className:(0,d.default)(a.className),active:"justify"===l,onClick:u,title:a.title||f["components.controls.textalign.justify"]},c.default.createElement("img",{src:a.icon,alt:""})))}},{key:"renderInDropDown",value:function(){var t=this.props,e=t.config,n=t.expanded,r=t.doExpand,o=t.onExpandEvent,i=t.doCollapse,a=t.currentState.textAlignment,s=t.onChange,u=t.translations,l=e.options,f=e.left,p=e.center,g=e.right,M=e.justify,m=e.className,I=e.dropdownClassName,w=e.title;return c.default.createElement(h.Dropdown,{className:(0,d.default)("rdw-text-align-dropdown",m),optionWrapperClassName:(0,d.default)(I),onChange:s,expanded:n,doExpand:r,doCollapse:i,onExpandEvent:o,"aria-label":"rdw-textalign-control",title:w||u["components.controls.textalign.textalign"]},c.default.createElement("img",{src:a&&e[a].icon||(0,y.getFirstIcon)(e),alt:""}),l.indexOf("left")>=0&&c.default.createElement(h.DropdownOption,{value:"left",active:"left"===a,className:(0,d.default)("rdw-text-align-dropdownOption",f.className),title:f.title||u["components.controls.textalign.left"]},c.default.createElement("img",{src:f.icon,alt:""})),l.indexOf("center")>=0&&c.default.createElement(h.DropdownOption,{value:"center",active:"center"===a,className:(0,d.default)("rdw-text-align-dropdownOption",p.className),title:p.title||u["components.controls.textalign.center"]},c.default.createElement("img",{src:p.icon,alt:""})),l.indexOf("right")>=0&&c.default.createElement(h.DropdownOption,{value:"right",active:"right"===a,className:(0,d.default)("rdw-text-align-dropdownOption",g.className),title:g.title||u["components.controls.textalign.right"]},c.default.createElement("img",{src:g.icon,alt:""})),l.indexOf("justify")>=0&&c.default.createElement(h.DropdownOption,{value:"justify",active:"justify"===a,className:(0,d.default)("rdw-text-align-dropdownOption",M.className),title:M.title||u["components.controls.textalign.justify"]},c.default.createElement("img",{src:M.icon,alt:""})))}},{key:"render",value:function(){return this.props.config.inDropdown?this.renderInDropDown():this.renderInFlatList()}}]),e}(u.Component);m.propTypes={expanded:f.default.bool,doExpand:f.default.func,doCollapse:f.default.func,onExpandEvent:f.default.func,config:f.default.object,onChange:f.default.func,currentState:f.default.object,translations:f.default.object},e.default=m},function(t,e){t.exports={"rdw-text-align-wrapper":"rdw-text-align-wrapper","rdw-text-align-dropdown":"rdw-text-align-dropdown","rdw-text-align-dropdownOption":"rdw-text-align-dropdownOption","rdw-right-aligned-block":"rdw-right-aligned-block","rdw-left-aligned-block":"rdw-left-aligned-block","rdw-center-aligned-block":"rdw-center-aligned-block","rdw-justify-aligned-block":"rdw-justify-aligned-block"}},function(t,e,n){"use strict";function r(t){return t&&t.__esModule?t:{default:t}}function o(t,e){if(!(t instanceof e))throw new TypeError("Cannot call a class as a function")}function i(t,e){if(!t)throw new ReferenceError("this hasn't been initialised - super() hasn't been called");return!e||"object"!=typeof e&&"function"!=typeof e?t:e}function a(t,e){if("function"!=typeof e&&null!==e)throw new TypeError("Super expression must either be null or a function, not "+typeof e);t.prototype=Object.create(e&&e.prototype,{constructor:{value:t,enumerable:!1,writable:!0,configurable:!0}}),e&&(Object.setPrototypeOf?Object.setPrototypeOf(t,e):t.__proto__=e)}Object.defineProperty(e,"__esModule",{value:!0});var s=function(){function t(t,e){for(var n=0;n<e.length;n++){var r=e[n];r.enumerable=r.enumerable||!1,r.configurable=!0,"value"in r&&(r.writable=!0),Object.defineProperty(t,r.key,r)}}return function(e,n,r){return n&&t(e.prototype,n),r&&t(e,r),e}}(),u=n(0),c=r(u),l=n(1),f=r(l),p=n(9),d=n(196),g=r(d),M=function(t){function e(){var t,n,r,a;o(this,e);for(var s=arguments.length,u=Array(s),c=0;c<s;c++)u[c]=arguments[c];return n=r=i(this,(t=e.__proto__||Object.getPrototypeOf(e)).call.apply(t,[this].concat(u))),r.state={expanded:!1,currentColor:void 0,currentBgColor:void 0},r.onExpandEvent=function(){r.signalExpanded=!r.state.expanded},r.expandCollapse=function(){r.setState({expanded:r.signalExpanded}),r.signalExpanded=!1},r.doExpand=function(){r.setState({expanded:!0})},r.doCollapse=function(){r.setState({expanded:!1})},r.toggleColor=function(t,e){var n=r.props,o=n.editorState,i=n.onChange,a=(0,p.toggleCustomInlineStyle)(o,t,e);a&&i(a),r.doCollapse()},a=n,i(r,a)}return a(e,t),s(e,[{key:"componentWillMount",value:function(){var t=this.props,e=t.editorState,n=t.modalHandler;e&&this.setState({currentColor:(0,p.getSelectionCustomInlineStyle)(e,["COLOR"]).COLOR,currentBgColor:(0,p.getSelectionCustomInlineStyle)(e,["BGCOLOR"]).BGCOLOR}),n.registerCallBack(this.expandCollapse)}},{key:"componentWillReceiveProps",value:function(t){var e={};t.editorState&&this.props.editorState!==t.editorState&&(e.currentColor=(0,p.getSelectionCustomInlineStyle)(t.editorState,["COLOR"]).COLOR,e.currentBgColor=(0,p.getSelectionCustomInlineStyle)(t.editorState,["BGCOLOR"]).BGCOLOR),this.setState(e)}},{key:"componentWillUnmount",value:function(){this.props.modalHandler.deregisterCallBack(this.expandCollapse)}},{key:"render",value:function(){var t=this.props,e=t.config,n=t.translations,r=this.state,o=r.currentColor,i=r.currentBgColor,a=r.expanded,s=e.component||g.default,u=o&&o.substring(6),l=i&&i.substring(8);return c.default.createElement(s,{config:e,translations:n,onChange:this.toggleColor,expanded:a,onExpandEvent:this.onExpandEvent,doExpand:this.doExpand,doCollapse:this.doCollapse,currentState:{color:u,bgColor:l}})}}]),e}(u.Component);M.propTypes={onChange:f.default.func.isRequired,editorState:f.default.object.isRequired,modalHandler:f.default.object,config:f.default.object,translations:f.default.object},e.default=M},function(t,e,n){"use strict";function r(t){return t&&t.__esModule?t:{default:t}}function o(t,e){if(!(t instanceof e))throw new TypeError("Cannot call a class as a function")}function i(t,e){if(!t)throw new ReferenceError("this hasn't been initialised - super() hasn't been called");return!e||"object"!=typeof e&&"function"!=typeof e?t:e}function a(t,e){if("function"!=typeof e&&null!==e)throw new TypeError("Super expression must either be null or a function, not "+typeof e);t.prototype=Object.create(e&&e.prototype,{constructor:{value:t,enumerable:!1,writable:!0,configurable:!0}}),e&&(Object.setPrototypeOf?Object.setPrototypeOf(t,e):t.__proto__=e)}Object.defineProperty(e,"__esModule",{value:!0});var s=function(){function t(t,e){for(var n=0;n<e.length;n++){var r=e[n];r.enumerable=r.enumerable||!1,r.configurable=!0,"value"in r&&(r.writable=!0),Object.defineProperty(t,r.key,r)}}return function(e,n,r){return n&&t(e.prototype,n),r&&t(e,r),e}}(),u=n(0),c=r(u),l=n(1),f=r(l),p=n(5),d=r(p),g=n(14),M=n(10),h=r(M);n(197);var y=function(t){function e(){var t,n,r,a;o(this,e);for(var s=arguments.length,u=Array(s),l=0;l<s;l++)u[l]=arguments[l];return n=r=i(this,(t=e.__proto__||Object.getPrototypeOf(e)).call.apply(t,[this].concat(u))),r.state={currentStyle:"color"},r.onChange=function(t){(0,r.props.onChange)(r.state.currentStyle,t)},r.setCurrentStyleColor=function(){r.setState({currentStyle:"color"})},r.setCurrentStyleBgcolor=function(){r.setState({currentStyle:"bgcolor"})},r.renderModal=function(){var t=r.props,e=t.config,n=e.popupClassName,o=e.colors,i=t.currentState,a=i.color,s=i.bgColor,u=t.translations,l=r.state.currentStyle,f="color"===l?a:s;return c.default.createElement("div",{className:(0,d.default)("rdw-colorpicker-modal",n),onClick:g.stopPropagation},c.default.createElement("span",{className:"rdw-colorpicker-modal-header"},c.default.createElement("span",{className:(0,d.default)("rdw-colorpicker-modal-style-label",{"rdw-colorpicker-modal-style-label-active":"color"===l}),onClick:r.setCurrentStyleColor},u["components.controls.colorpicker.text"]),c.default.createElement("span",{className:(0,d.default)("rdw-colorpicker-modal-style-label",{"rdw-colorpicker-modal-style-label-active":"bgcolor"===l}),onClick:r.setCurrentStyleBgcolor},u["components.controls.colorpicker.background"])),c.default.createElement("span",{className:"rdw-colorpicker-modal-options"},o.map(function(t,e){return c.default.createElement(h.default,{value:t,key:e,className:"rdw-colorpicker-option",activeClassName:"rdw-colorpicker-option-active",active:f===t,onClick:r.onChange},c.default.createElement("span",{style:{backgroundColor:t},className:"rdw-colorpicker-cube"}))})))},a=n,i(r,a)}return a(e,t),s(e,[{key:"componentWillReceiveProps",value:function(t){!this.props.expanded&&t.expanded&&this.setState({currentStyle:"color"})}},{key:"render",value:function(){var t=this.props,e=t.config,n=e.icon,r=e.className,o=e.title,i=t.expanded,a=t.onExpandEvent,s=t.translations;return c.default.createElement("div",{className:"rdw-colorpicker-wrapper","aria-haspopup":"true","aria-expanded":i,"aria-label":"rdw-color-picker",title:o||s["components.controls.colorpicker.colorpicker"]},c.default.createElement(h.default,{onClick:a,className:(0,d.default)(r)},c.default.createElement("img",{src:n,alt:""})),i?this.renderModal():void 0)}}]),e}(u.Component);y.propTypes={expanded:f.default.bool,onExpandEvent:f.default.func,onChange:f.default.func,config:f.default.object,currentState:f.default.object,translations:f.default.object},e.default=y},function(t,e){t.exports={"rdw-colorpicker-wrapper":"rdw-colorpicker-wrapper","rdw-colorpicker-modal":"rdw-colorpicker-modal","rdw-colorpicker-modal-header":"rdw-colorpicker-modal-header","rdw-colorpicker-modal-style-label":"rdw-colorpicker-modal-style-label","rdw-colorpicker-modal-style-label-active":"rdw-colorpicker-modal-style-label-active","rdw-colorpicker-modal-options":"rdw-colorpicker-modal-options","rdw-colorpicker-cube":"rdw-colorpicker-cube","rdw-colorpicker-option":"rdw-colorpicker-option","rdw-colorpicker-option-active":"rdw-colorpicker-option-active"}},function(t,e,n){"use strict";function r(t){return t&&t.__esModule?t:{default:t}}function o(t,e){if(!(t instanceof e))throw new TypeError("Cannot call a class as a function")}function i(t,e){if(!t)throw new ReferenceError("this hasn't been initialised - super() hasn't been called");return!e||"object"!=typeof e&&"function"!=typeof e?t:e}function a(t,e){if("function"!=typeof e&&null!==e)throw new TypeError("Super expression must either be null or a function, not "+typeof e);t.prototype=Object.create(e&&e.prototype,{constructor:{value:t,enumerable:!1,writable:!0,configurable:!0}}),e&&(Object.setPrototypeOf?Object.setPrototypeOf(t,e):t.__proto__=e)}Object.defineProperty(e,"__esModule",{value:!0});var s=function(){function t(t,e){for(var n=0;n<e.length;n++){var r=e[n];r.enumerable=r.enumerable||!1,r.configurable=!0,"value"in r&&(r.writable=!0),Object.defineProperty(t,r.key,r)}}return function(e,n,r){return n&&t(e.prototype,n),r&&t(e,r),e}}(),u=n(0),c=r(u),l=n(1),f=r(l),p=n(6),d=n(9),g=n(199),M=r(g),h=function(t){function e(){var t,n,r,a;o(this,e);for(var s=arguments.length,u=Array(s),c=0;c<s;c++)u[c]=arguments[c];return n=r=i(this,(t=e.__proto__||Object.getPrototypeOf(e)).call.apply(t,[this].concat(u))),r.state={expanded:!1,link:void 0,selectionText:void 0},r.onExpandEvent=function(){r.signalExpanded=!r.state.expanded},r.onChange=function(t,e,n,o){"link"===t?r.addLink(e,n,o):r.removeLink()},r.getCurrentValues=function(){var t=r.props.editorState,e=r.state.currentEntity,n=t.getCurrentContent(),o={};if(e&&"LINK"===n.getEntity(e).get("type")){o.link={};var i=e&&(0,d.getEntityRange)(t,e);o.link.target=e&&n.getEntity(e).get("data").url,o.link.targetOption=e&&n.getEntity(e).get("data").target,o.link.title=i&&i.text}return o.selectionText=(0,d.getSelectionText)(t),o},r.doExpand=function(){r.setState({expanded:!0})},r.expandCollapse=function(){r.setState({expanded:r.signalExpanded}),r.signalExpanded=!1},r.doCollapse=function(){r.setState({expanded:!1})},r.removeLink=function(){var t=r.props,e=t.editorState,n=t.onChange,o=r.state.currentEntity,i=e.getSelection();if(o){var a=(0,d.getEntityRange)(e,o);i=i.merge({anchorOffset:a.start,focusOffset:a.end}),n(p.RichUtils.toggleLink(e,i,null))}},r.addLink=function(t,e,n){var o=r.props,i=o.editorState,a=o.onChange,s=r.state.currentEntity,u=i.getSelection();if(s){var c=(0,d.getEntityRange)(i,s);u=u.merge({anchorOffset:c.start,focusOffset:c.end})}var l=i.getCurrentContent().createEntity("LINK","MUTABLE",{url:e,target:n}).getLastCreatedEntityKey(),f=p.Modifier.replaceText(i.getCurrentContent(),u,""+t,i.getCurrentInlineStyle(),l),g=p.EditorState.push(i,f,"insert-characters");u=g.getSelection().merge({anchorOffset:u.get("anchorOffset")+t.length,focusOffset:u.get("anchorOffset")+t.length}),g=p.EditorState.acceptSelection(g,u),f=p.Modifier.insertText(g.getCurrentContent(),u," ",g.getCurrentInlineStyle(),void 0),a(p.EditorState.push(g,f,"insert-characters")),r.doCollapse()},a=n,i(r,a)}return a(e,t),s(e,[{key:"componentWillMount",value:function(){var t=this.props,e=t.editorState,n=t.modalHandler;e&&this.setState({currentEntity:(0,d.getSelectionEntity)(e)}),n.registerCallBack(this.expandCollapse)}},{key:"componentWillReceiveProps",value:function(t){var e={};t.editorState&&this.props.editorState!==t.editorState&&(e.currentEntity=(0,d.getSelectionEntity)(t.editorState)),this.setState(e)}},{key:"componentWillUnmount",value:function(){this.props.modalHandler.deregisterCallBack(this.expandCollapse)}},{key:"render",value:function(){var t=this.props,e=t.config,n=t.translations,r=this.state.expanded,o=this.getCurrentValues(),i=o.link,a=o.selectionText,s=e.component||M.default;return c.default.createElement(s,{config:e,translations:n,expanded:r,onExpandEvent:this.onExpandEvent,doExpand:this.doExpand,doCollapse:this.doCollapse,currentState:{link:i,selectionText:a},onChange:this.onChange})}}]),e}(u.Component);h.propTypes={editorState:f.default.object.isRequired,onChange:f.default.func.isRequired,modalHandler:f.default.object,config:f.default.object,translations:f.default.object},e.default=h},function(t,e,n){"use strict";function r(t){return t&&t.__esModule?t:{default:t}}function o(t,e,n){return e in t?Object.defineProperty(t,e,{value:n,enumerable:!0,configurable:!0,writable:!0}):t[e]=n,t}function i(t,e){if(!(t instanceof e))throw new TypeError("Cannot call a class as a function")}function a(t,e){if(!t)throw new ReferenceError("this hasn't been initialised - super() hasn't been called");return!e||"object"!=typeof e&&"function"!=typeof e?t:e}function s(t,e){if("function"!=typeof e&&null!==e)throw new TypeError("Super expression must either be null or a function, not "+typeof e);t.prototype=Object.create(e&&e.prototype,{constructor:{value:t,enumerable:!1,writable:!0,configurable:!0}}),e&&(Object.setPrototypeOf?Object.setPrototypeOf(t,e):t.__proto__=e)}Object.defineProperty(e,"__esModule",{value:!0});var u=function(){function t(t,e){for(var n=0;n<e.length;n++){var r=e[n];r.enumerable=r.enumerable||!1,r.configurable=!0,"value"in r&&(r.writable=!0),Object.defineProperty(t,r.key,r)}}return function(e,n,r){return n&&t(e.prototype,n),r&&t(e,r),e}}(),c=n(0),l=r(c),f=n(1),p=r(f),d=n(5),g=r(d),M=n(14),h=n(20),y=n(10),m=r(y),I=n(16);n(200);var w=function(t){function e(){var t,n,r,s;i(this,e);for(var u=arguments.length,c=Array(u),l=0;l<u;l++)c[l]=arguments[l];return n=r=a(this,(t=e.__proto__||Object.getPrototypeOf(e)).call.apply(t,[this].concat(c))),r.state={showModal:!1,linkTarget:"",linkTitle:"",linkTargetOption:r.props.config.defaultTargetOption},r.removeLink=function(){(0,r.props.onChange)("unlink")},r.addLink=function(){var t=r.props.onChange,e=r.state;t("link",e.linkTitle,e.linkTarget,e.linkTargetOption)},r.updateValue=function(t){r.setState(o({},""+t.target.name,t.target.value))},r.updateTarget=function(t){r.setState({linkTargetOption:t.target.checked?"_blank":"_self"})},r.hideModal=function(){r.setState({showModal:!1})},r.signalExpandShowModal=function(){var t=r.props,e=t.onExpandEvent,n=t.currentState,o=n.link,i=n.selectionText,a=r.state.linkTargetOption;e(),r.setState({showModal:!0,linkTarget:o&&o.target,linkTargetOption:o&&o.targetOption||a,linkTitle:o&&o.title||i})},r.forceExpandAndShowModal=function(){var t=r.props,e=t.doExpand,n=t.currentState,o=n.link,i=n.selectionText,a=r.state.linkTargetOption;e(),r.setState({showModal:!0,linkTarget:o&&o.target,linkTargetOption:o&&o.targetOption||a,linkTitle:o&&o.title||i})},s=n,a(r,s)}return s(e,t),u(e,[{key:"componentWillReceiveProps",value:function(t){this.props.expanded&&!t.expanded&&this.setState({showModal:!1,linkTarget:"",linkTitle:"",linkTargetOption:this.props.config.defaultTargetOption})}},{key:"renderAddLinkModal",value:function(){var t=this.props,e=t.config.popupClassName,n=t.doCollapse,r=t.translations,o=this.state,i=o.linkTitle,a=o.linkTarget,s=o.linkTargetOption;return l.default.createElement("div",{className:(0,g.default)("rdw-link-modal",e),onClick:M.stopPropagation},l.default.createElement("span",{className:"rdw-link-modal-label"},r["components.controls.link.linkTitle"]),l.default.createElement("input",{className:"rdw-link-modal-input",onChange:this.updateValue,onBlur:this.updateValue,name:"linkTitle",value:i}),l.default.createElement("span",{className:"rdw-link-modal-label"},r["components.controls.link.linkTarget"]),l.default.createElement("input",{className:"rdw-link-modal-input",onChange:this.updateValue,onBlur:this.updateValue,name:"linkTarget",value:a}),l.default.createElement("span",{className:"rdw-link-modal-target-option"},l.default.createElement("input",{type:"checkbox",defaultChecked:"_blank"===s,value:"_blank",onChange:this.updateTarget}),l.default.createElement("span",null,r["components.controls.link.linkTargetOption"])),l.default.createElement("span",{className:"rdw-link-modal-buttonsection"},l.default.createElement("button",{className:"rdw-link-modal-btn",onClick:this.addLink,disabled:!a||!i},r["generic.add"]),l.default.createElement("button",{className:"rdw-link-modal-btn",onClick:n},r["generic.cancel"])))}},{key:"renderInFlatList",value:function(){var t=this.props,e=t.config,n=e.options,r=e.link,o=e.unlink,i=e.className,a=t.currentState,s=t.expanded,u=t.translations,c=this.state.showModal;return l.default.createElement("div",{className:(0,g.default)("rdw-link-wrapper",i),"aria-label":"rdw-link-control"},n.indexOf("link")>=0&&l.default.createElement(m.default,{value:"unordered-list-item",className:(0,g.default)(r.className),onClick:this.signalExpandShowModal,"aria-haspopup":"true","aria-expanded":c,title:r.title||u["components.controls.link.link"]},l.default.createElement("img",{src:r.icon,alt:""})),n.indexOf("unlink")>=0&&l.default.createElement(m.default,{disabled:!a.link,value:"ordered-list-item",className:(0,g.default)(o.className),onClick:this.removeLink,title:o.title||u["components.controls.link.unlink"]},l.default.createElement("img",{src:o.icon,alt:""})),s&&c?this.renderAddLinkModal():void 0)}},{key:"renderInDropDown",value:function(){var t=this.props,e=t.expanded,n=t.onExpandEvent,r=t.doCollapse,o=t.doExpand,i=t.onChange,a=t.config,s=t.currentState,u=t.translations,c=a.options,f=a.link,p=a.unlink,d=a.className,M=a.dropdownClassName,y=a.title,m=this.state.showModal;return l.default.createElement("div",{className:"rdw-link-wrapper","aria-haspopup":"true","aria-label":"rdw-link-control","aria-expanded":e,title:y},l.default.createElement(I.Dropdown,{className:(0,g.default)("rdw-link-dropdown",d),optionWrapperClassName:(0,g.default)(M),onChange:i,expanded:e&&!m,doExpand:o,doCollapse:r,onExpandEvent:n},l.default.createElement("img",{src:(0,h.getFirstIcon)(a),alt:""}),c.indexOf("link")>=0&&l.default.createElement(I.DropdownOption,{onClick:this.forceExpandAndShowModal,className:(0,g.default)("rdw-link-dropdownoption",f.className),title:f.title||u["components.controls.link.link"]},l.default.createElement("img",{src:f.icon,alt:""})),c.indexOf("unlink")>=0&&l.default.createElement(I.DropdownOption,{onClick:this.removeLink,disabled:!s.link,className:(0,g.default)("rdw-link-dropdownoption",p.className),title:p.title||u["components.controls.link.unlink"]},l.default.createElement("img",{src:p.icon,alt:""}))),e&&m?this.renderAddLinkModal():void 0)}},{key:"render",value:function(){return this.props.config.inDropdown?this.renderInDropDown():this.renderInFlatList()}}]),e}(c.Component);w.propTypes={expanded:p.default.bool,doExpand:p.default.func,doCollapse:p.default.func,onExpandEvent:p.default.func,config:p.default.object,onChange:p.default.func,currentState:p.default.object,translations:p.default.object},e.default=w},function(t,e){t.exports={"rdw-link-wrapper":"rdw-link-wrapper","rdw-link-dropdown":"rdw-link-dropdown","rdw-link-dropdownOption":"rdw-link-dropdownOption","rdw-link-dropdownPlaceholder":"rdw-link-dropdownPlaceholder","rdw-link-modal":"rdw-link-modal","rdw-link-modal-label":"rdw-link-modal-label","rdw-link-modal-input":"rdw-link-modal-input","rdw-link-modal-buttonsection":"rdw-link-modal-buttonsection","rdw-link-modal-target-option":"rdw-link-modal-target-option","rdw-link-modal-btn":"rdw-link-modal-btn","rdw-link-dropdownoption":"rdw-link-dropdownoption","rdw-history-dropdown":"rdw-history-dropdown"}},function(t,e,n){"use strict";function r(t){return t&&t.__esModule?t:{default:t}}function o(t,e){if(!(t instanceof e))throw new TypeError("Cannot call a class as a function")}function i(t,e){if(!t)throw new ReferenceError("this hasn't been initialised - super() hasn't been called");return!e||"object"!=typeof e&&"function"!=typeof e?t:e}function a(t,e){if("function"!=typeof e&&null!==e)throw new TypeError("Super expression must either be null or a function, not "+typeof e);t.prototype=Object.create(e&&e.prototype,{constructor:{value:t,enumerable:!1,writable:!0,configurable:!0}}),e&&(Object.setPrototypeOf?Object.setPrototypeOf(t,e):t.__proto__=e)}Object.defineProperty(e,"__esModule",{value:!0});var s=function(){function t(t,e){for(var n=0;n<e.length;n++){var r=e[n];r.enumerable=r.enumerable||!1,r.configurable=!0,"value"in r&&(r.writable=!0),Object.defineProperty(t,r.key,r)}}return function(e,n,r){return n&&t(e.prototype,n),r&&t(e,r),e}}(),u=n(0),c=r(u),l=n(1),f=r(l),p=n(6),d=n(202),g=r(d),M=function(t){function e(){var t,n,r,a;o(this,e);for(var s=arguments.length,u=Array(s),c=0;c<s;c++)u[c]=arguments[c];return n=r=i(this,(t=e.__proto__||Object.getPrototypeOf(e)).call.apply(t,[this].concat(u))),r.state={expanded:!1},r.onExpandEvent=function(){r.signalExpanded=!r.state.expanded},r.expandCollapse=function(){r.setState({expanded:r.signalExpanded}),r.signalExpanded=!1},r.doExpand=function(){r.setState({expanded:!0})},r.doCollapse=function(){r.setState({expanded:!1})},r.addEmbeddedLink=function(t,e,n){var o=r.props,i=o.editorState,a=o.onChange,s=i.getCurrentContent().createEntity("EMBEDDED_LINK","MUTABLE",{src:t,height:e,width:n}).getLastCreatedEntityKey();a(p.AtomicBlockUtils.insertAtomicBlock(i,s," ")),r.doCollapse()},a=n,i(r,a)}return a(e,t),s(e,[{key:"componentWillMount",value:function(){this.props.modalHandler.registerCallBack(this.expandCollapse)}},{key:"componentWillUnmount",value:function(){this.props.modalHandler.deregisterCallBack(this.expandCollapse)}},{key:"render",value:function(){var t=this.props,e=t.config,n=t.translations,r=this.state.expanded,o=e.component||g.default;return c.default.createElement(o,{config:e,translations:n,onChange:this.addEmbeddedLink,expanded:r,onExpandEvent:this.onExpandEvent,doExpand:this.doExpand,doCollapse:this.doCollapse})}}]),e}(u.Component);M.propTypes={editorState:f.default.object.isRequired,onChange:f.default.func.isRequired,modalHandler:f.default.object,config:f.default.object,translations:f.default.object},e.default=M},function(t,e,n){"use strict";function r(t){return t&&t.__esModule?t:{default:t}}function o(t,e,n){return e in t?Object.defineProperty(t,e,{value:n,enumerable:!0,configurable:!0,writable:!0}):t[e]=n,t}function i(t,e){if(!(t instanceof e))throw new TypeError("Cannot call a class as a function")}function a(t,e){if(!t)throw new ReferenceError("this hasn't been initialised - super() hasn't been called");return!e||"object"!=typeof e&&"function"!=typeof e?t:e}function s(t,e){if("function"!=typeof e&&null!==e)throw new TypeError("Super expression must either be null or a function, not "+typeof e);t.prototype=Object.create(e&&e.prototype,{constructor:{value:t,enumerable:!1,writable:!0,configurable:!0}}),e&&(Object.setPrototypeOf?Object.setPrototypeOf(t,e):t.__proto__=e)}Object.defineProperty(e,"__esModule",{value:!0});var u=function(){function t(t,e){for(var n=0;n<e.length;n++){var r=e[n];r.enumerable=r.enumerable||!1,r.configurable=!0,"value"in r&&(r.writable=!0),Object.defineProperty(t,r.key,r)}}return function(e,n,r){return n&&t(e.prototype,n),r&&t(e,r),e}}(),c=n(0),l=r(c),f=n(1),p=r(f),d=n(5),g=r(d),M=n(14),h=n(10),y=r(h);n(203);var m=function(t){function e(){var t,n,r,s;i(this,e);for(var u=arguments.length,c=Array(u),l=0;l<u;l++)c[l]=arguments[l];return n=r=a(this,(t=e.__proto__||Object.getPrototypeOf(e)).call.apply(t,[this].concat(c))),r.state={embeddedLink:"",height:r.props.config.defaultSize.height,width:r.props.config.defaultSize.width},r.onChange=function(){var t=r.props.onChange,e=r.state;t(e.embeddedLink,e.height,e.width)},r.updateValue=function(t){r.setState(o({},""+t.target.name,t.target.value))},s=n,a(r,s)}return s(e,t),u(e,[{key:"componentWillReceiveProps",value:function(t){if(this.props.expanded&&!t.expanded){var e=this.props.config.defaultSize,n=e.height,r=e.width;this.setState({embeddedLink:"",height:n,width:r})}}},{key:"rendeEmbeddedLinkModal",value:function(){var t=this.state,e=t.embeddedLink,n=t.height,r=t.width,o=this.props,i=o.config.popupClassName,a=o.doCollapse,s=o.translations;return l.default.createElement("div",{className:(0,g.default)("rdw-embedded-modal",i),onClick:M.stopPropagation},l.default.createElement("div",{className:"rdw-embedded-modal-header"},l.default.createElement("span",{className:"rdw-embedded-modal-header-option"},s["components.controls.embedded.embeddedlink"],l.default.createElement("span",{className:"rdw-embedded-modal-header-label"}))),l.default.createElement("div",{className:"rdw-embedded-modal-link-section"},l.default.createElement("span",{className:"rdw-embedded-modal-link-input-wrapper"},l.default.createElement("input",{className:"rdw-embedded-modal-link-input",placeholder:s["components.controls.embedded.enterlink"],onChange:this.updateValue,onBlur:this.updateValue,value:e,name:"embeddedLink"}),l.default.createElement("span",{className:"rdw-image-mandatory-sign"},"*")),l.default.createElement("div",{className:"rdw-embedded-modal-size"},l.default.createElement("span",null,l.default.createElement("input",{onChange:this.updateValue,onBlur:this.updateValue,value:n,name:"height",className:"rdw-embedded-modal-size-input",placeholder:"Height"}),l.default.createElement("span",{className:"rdw-image-mandatory-sign"},"*")),l.default.createElement("span",null,l.default.createElement("input",{onChange:this.updateValue,onBlur:this.updateValue,value:r,name:"width",className:"rdw-embedded-modal-size-input",placeholder:"Width"}),l.default.createElement("span",{className:"rdw-image-mandatory-sign"},"*")))),l.default.createElement("span",{className:"rdw-embedded-modal-btn-section"},l.default.createElement("button",{type:"button",className:"rdw-embedded-modal-btn",onClick:this.onChange,disabled:!e||!n||!r},s["generic.add"]),l.default.createElement("button",{type:"button",className:"rdw-embedded-modal-btn",onClick:a},s["generic.cancel"])))}},{key:"render",value:function(){var t=this.props,e=t.config,n=e.icon,r=e.className,o=e.title,i=t.expanded,a=t.onExpandEvent,s=t.translations;return l.default.createElement("div",{className:"rdw-embedded-wrapper","aria-haspopup":"true","aria-expanded":i,"aria-label":"rdw-embedded-control"},l.default.createElement(y.default,{className:(0,g.default)(r),value:"unordered-list-item",onClick:a,title:o||s["components.controls.embedded.embedded"]},l.default.createElement("img",{src:n,alt:""})),i?this.rendeEmbeddedLinkModal():void 0)}}]),e}(c.Component);m.propTypes={expanded:p.default.bool,onExpandEvent:p.default.func,onChange:p.default.func,config:p.default.object,translations:p.default.object,doCollapse:p.default.func},e.default=m},function(t,e){t.exports={"rdw-embedded-wrapper":"rdw-embedded-wrapper","rdw-embedded-modal":"rdw-embedded-modal","rdw-embedded-modal-header":"rdw-embedded-modal-header","rdw-embedded-modal-header-option":"rdw-embedded-modal-header-option","rdw-embedded-modal-header-label":"rdw-embedded-modal-header-label","rdw-embedded-modal-link-section":"rdw-embedded-modal-link-section","rdw-embedded-modal-link-input":"rdw-embedded-modal-link-input","rdw-embedded-modal-link-input-wrapper":"rdw-embedded-modal-link-input-wrapper","rdw-embedded-modal-btn-section":"rdw-embedded-modal-btn-section","rdw-embedded-modal-btn":"rdw-embedded-modal-btn","rdw-embedded-modal-size":"rdw-embedded-modal-size","rdw-embedded-modal-size-input":"rdw-embedded-modal-size-input"}},function(t,e,n){"use strict";function r(t){return t&&t.__esModule?t:{default:t}}function o(t,e){if(!(t instanceof e))throw new TypeError("Cannot call a class as a function")}function i(t,e){if(!t)throw new ReferenceError("this hasn't been initialised - super() hasn't been called");return!e||"object"!=typeof e&&"function"!=typeof e?t:e}function a(t,e){if("function"!=typeof e&&null!==e)throw new TypeError("Super expression must either be null or a function, not "+typeof e);t.prototype=Object.create(e&&e.prototype,{constructor:{value:t,enumerable:!1,writable:!0,configurable:!0}}),e&&(Object.setPrototypeOf?Object.setPrototypeOf(t,e):t.__proto__=e)}Object.defineProperty(e,"__esModule",{value:!0});var s=function(){function t(t,e){for(var n=0;n<e.length;n++){var r=e[n];r.enumerable=r.enumerable||!1,r.configurable=!0,"value"in r&&(r.writable=!0),Object.defineProperty(t,r.key,r)}}return function(e,n,r){return n&&t(e.prototype,n),r&&t(e,r),e}}(),u=n(0),c=r(u),l=n(1),f=r(l),p=n(6),d=n(205),g=r(d),M=function(t){function e(){var t,n,r,a;o(this,e);for(var s=arguments.length,u=Array(s),c=0;c<s;c++)u[c]=arguments[c];return n=r=i(this,(t=e.__proto__||Object.getPrototypeOf(e)).call.apply(t,[this].concat(u))),r.state={expanded:!1},r.onExpandEvent=function(){r.signalExpanded=!r.state.expanded},r.expandCollapse=function(){r.setState({expanded:r.signalExpanded}),r.signalExpanded=!1},r.doExpand=function(){r.setState({expanded:!0})},r.doCollapse=function(){r.setState({expanded:!1})},r.addEmoji=function(t){var e=r.props,n=e.editorState,o=e.onChange,i=p.Modifier.replaceText(n.getCurrentContent(),n.getSelection(),t,n.getCurrentInlineStyle());o(p.EditorState.push(n,i,"insert-characters")),r.doCollapse()},a=n,i(r,a)}return a(e,t),s(e,[{key:"componentWillMount",value:function(){this.props.modalHandler.registerCallBack(this.expandCollapse)}},{key:"componentWillUnmount",value:function(){this.props.modalHandler.deregisterCallBack(this.expandCollapse)}},{key:"render",value:function(){var t=this.props,e=t.config,n=t.translations,r=this.state.expanded,o=e.component||g.default;return c.default.createElement(o,{config:e,translations:n,onChange:this.addEmoji,expanded:r,onExpandEvent:this.onExpandEvent,doExpand:this.doExpand,doCollapse:this.doCollapse,onCollpase:this.closeModal})}}]),e}(u.Component);M.propTypes={editorState:f.default.object.isRequired,onChange:f.default.func.isRequired,modalHandler:f.default.object,config:f.default.object,translations:f.default.object},e.default=M},function(t,e,n){"use strict";function r(t){return t&&t.__esModule?t:{default:t}}function o(t,e){if(!(t instanceof e))throw new TypeError("Cannot call a class as a function")}function i(t,e){if(!t)throw new ReferenceError("this hasn't been initialised - super() hasn't been called");return!e||"object"!=typeof e&&"function"!=typeof e?t:e}function a(t,e){if("function"!=typeof e&&null!==e)throw new TypeError("Super expression must either be null or a function, not "+typeof e);t.prototype=Object.create(e&&e.prototype,{constructor:{value:t,enumerable:!1,writable:!0,configurable:!0}}),e&&(Object.setPrototypeOf?Object.setPrototypeOf(t,e):t.__proto__=e)}Object.defineProperty(e,"__esModule",{value:!0});var s=function(){function t(t,e){for(var n=0;n<e.length;n++){var r=e[n];r.enumerable=r.enumerable||!1,r.configurable=!0,"value"in r&&(r.writable=!0),Object.defineProperty(t,r.key,r)}}return function(e,n,r){return n&&t(e.prototype,n),r&&t(e,r),e}}(),u=n(0),c=r(u),l=n(1),f=r(l),p=n(5),d=r(p),g=n(14),M=n(10),h=r(M);n(206);var y=function(t){function e(){var t,n,r,a;o(this,e);for(var s=arguments.length,u=Array(s),c=0;c<s;c++)u[c]=arguments[c];return n=r=i(this,(t=e.__proto__||Object.getPrototypeOf(e)).call.apply(t,[this].concat(u))),r.onChange=function(t){(0,r.props.onChange)(t.target.innerHTML)},a=n,i(r,a)}return a(e,t),s(e,[{key:"renderEmojiModal",value:function(){var t=this,e=this.props.config,n=e.popupClassName,r=e.emojis;return c.default.createElement("div",{className:(0,d.default)("rdw-emoji-modal",n),onClick:g.stopPropagation},r.map(function(e,n){return c.default.createElement("span",{key:n,className:"rdw-emoji-icon",alt:"",onClick:t.onChange},e)}))}},{key:"render",value:function(){var t=this.props,e=t.config,n=e.icon,r=e.className,o=e.title,i=t.expanded,a=t.onExpandEvent,s=t.translations;return c.default.createElement("div",{className:"rdw-emoji-wrapper","aria-haspopup":"true","aria-label":"rdw-emoji-control","aria-expanded":i,title:o||s["components.controls.emoji.emoji"]},c.default.createElement(h.default,{className:(0,d.default)(r),value:"unordered-list-item",onClick:a},c.default.createElement("img",{src:n,alt:""})),i?this.renderEmojiModal():void 0)}}]),e}(u.Component);y.propTypes={expanded:f.default.bool,onExpandEvent:f.default.func,onChange:f.default.func,config:f.default.object,translations:f.default.object},e.default=y},function(t,e){t.exports={"rdw-emoji-wrapper":"rdw-emoji-wrapper","rdw-emoji-modal":"rdw-emoji-modal","rdw-emoji-icon":"rdw-emoji-icon"}},function(t,e,n){"use strict";function r(t){return t&&t.__esModule?t:{default:t}}function o(t,e){if(!(t instanceof e))throw new TypeError("Cannot call a class as a function")}function i(t,e){if(!t)throw new ReferenceError("this hasn't been initialised - super() hasn't been called");return!e||"object"!=typeof e&&"function"!=typeof e?t:e}function a(t,e){if("function"!=typeof e&&null!==e)throw new TypeError("Super expression must either be null or a function, not "+typeof e);t.prototype=Object.create(e&&e.prototype,{constructor:{value:t,enumerable:!1,writable:!0,configurable:!0}}),e&&(Object.setPrototypeOf?Object.setPrototypeOf(t,e):t.__proto__=e)}Object.defineProperty(e,"__esModule",{value:!0});var s=function(){function t(t,e){for(var n=0;n<e.length;n++){var r=e[n];r.enumerable=r.enumerable||!1,r.configurable=!0,"value"in r&&(r.writable=!0),Object.defineProperty(t,r.key,r)}}return function(e,n,r){return n&&t(e.prototype,n),r&&t(e,r),e}}(),u=n(0),c=r(u),l=n(1),f=r(l),p=n(6),d=n(208),g=r(d),M=function(t){function e(){var t,n,r,a;o(this,e);for(var s=arguments.length,u=Array(s),c=0;c<s;c++)u[c]=arguments[c];return n=r=i(this,(t=e.__proto__||Object.getPrototypeOf(e)).call.apply(t,[this].concat(u))),r.state={expanded:!1},r.onExpandEvent=function(){r.signalExpanded=!r.state.expanded},r.doExpand=function(){r.setState({expanded:!0})},r.doCollapse=function(){r.setState({expanded:!1})},r.expandCollapse=function(){r.setState({expanded:r.signalExpanded}),r.signalExpanded=!1},r.addImage=function(t,e,n,o){var i=r.props,a=i.editorState,s=i.onChange,u=i.config,c={src:t,height:e,width:n};u.alt.present&&(c.alt=o);var l=a.getCurrentContent().createEntity("IMAGE","MUTABLE",c).getLastCreatedEntityKey();s(p.AtomicBlockUtils.insertAtomicBlock(a,l," ")),r.doCollapse()},a=n,i(r,a)}return a(e,t),s(e,[{key:"componentWillMount",value:function(){this.props.modalHandler.registerCallBack(this.expandCollapse)}},{key:"componentWillUnmount",value:function(){this.props.modalHandler.deregisterCallBack(this.expandCollapse)}},{key:"render",value:function(){var t=this.props,e=t.config,n=t.translations,r=this.state.expanded,o=e.component||g.default;return c.default.createElement(o,{config:e,translations:n,onChange:this.addImage,expanded:r,onExpandEvent:this.onExpandEvent,doExpand:this.doExpand,doCollapse:this.doCollapse})}}]),e}(u.Component);M.propTypes={editorState:f.default.object.isRequired,onChange:f.default.func.isRequired,modalHandler:f.default.object,config:f.default.object,translations:f.default.object},e.default=M},function(t,e,n){"use strict";function r(t){return t&&t.__esModule?t:{default:t}}function o(t,e,n){return e in t?Object.defineProperty(t,e,{value:n,enumerable:!0,configurable:!0,writable:!0}):t[e]=n,t}function i(t,e){if(!(t instanceof e))throw new TypeError("Cannot call a class as a function")}function a(t,e){if(!t)throw new ReferenceError("this hasn't been initialised - super() hasn't been called");return!e||"object"!=typeof e&&"function"!=typeof e?t:e}function s(t,e){if("function"!=typeof e&&null!==e)throw new TypeError("Super expression must either be null or a function, not "+typeof e);t.prototype=Object.create(e&&e.prototype,{constructor:{value:t,enumerable:!1,writable:!0,configurable:!0}}),e&&(Object.setPrototypeOf?Object.setPrototypeOf(t,e):t.__proto__=e)}Object.defineProperty(e,"__esModule",{value:!0});var u=function(){function t(t,e){for(var n=0;n<e.length;n++){var r=e[n];r.enumerable=r.enumerable||!1,r.configurable=!0,"value"in r&&(r.writable=!0),Object.defineProperty(t,r.key,r)}}return function(e,n,r){return n&&t(e.prototype,n),r&&t(e,r),e}}(),c=n(0),l=r(c),f=n(1),p=r(f),d=n(5),g=r(d),M=n(10),h=r(M),y=n(209),m=r(y);n(211);var I=function(t){function e(){var t,n,r,s;i(this,e);for(var u=arguments.length,c=Array(u),l=0;l<u;l++)c[l]=arguments[l];return n=r=a(this,(t=e.__proto__||Object.getPrototypeOf(e)).call.apply(t,[this].concat(c))),r.state={imgSrc:"",dragEnter:!1,uploadHighlighted:r.props.config.uploadEnabled&&!!r.props.config.uploadCallback,showImageLoading:!1,height:r.props.config.defaultSize.height,width:r.props.config.defaultSize.width,alt:""},r.onDragEnter=function(t){r.stopPropagation(t),r.setState({dragEnter:!0})},r.onImageDrop=function(t){t.preventDefault(),t.stopPropagation(),r.setState({dragEnter:!1});var e=void 0,n=void 0;t.dataTransfer.items?(e=t.dataTransfer.items,n=!0):(e=t.dataTransfer.files,n=!1);for(var o=0;o<e.length;o+=1)if((!n||"file"===e[o].kind)&&e[o].type.match("^image/")){var i=n?e[o].getAsFile():e[o];r.uploadImage(i)}},r.showImageUploadOption=function(){r.setState({uploadHighlighted:!0})},r.addImageFromState=function(){var t=r.state,e=t.imgSrc,n=t.alt,o=r.state,i=o.height,a=o.width,s=r.props.onChange;isNaN(i)||(i+="px"),isNaN(a)||(a+="px"),s(e,i,a,n)},r.showImageURLOption=function(){r.setState({uploadHighlighted:!1})},r.toggleShowImageLoading=function(){var t=!r.state.showImageLoading;r.setState({showImageLoading:t})},r.updateValue=function(t){r.setState(o({},""+t.target.name,t.target.value))},r.selectImage=function(t){t.target.files&&t.target.files.length>0&&r.uploadImage(t.target.files[0])},r.uploadImage=function(t){r.toggleShowImageLoading(),(0,r.props.config.uploadCallback)(t).then(function(t){var e=t.data;r.setState({showImageLoading:!1,dragEnter:!1,imgSrc:e.link}),r.fileUpload=!1}).catch(function(){r.setState({showImageLoading:!1,dragEnter:!1})})},r.fileUploadClick=function(t){r.fileUpload=!0,t.stopPropagation()},r.stopPropagation=function(t){r.fileUpload?r.fileUpload=!1:(t.preventDefault(),t.stopPropagation())},s=n,a(r,s)}return s(e,t),u(e,[{key:"componentWillReceiveProps",value:function(t){this.props.expanded&&!t.expanded?this.setState({imgSrc:"",dragEnter:!1,uploadHighlighted:this.props.config.uploadEnabled&&!!this.props.config.uploadCallback,showImageLoading:!1,height:this.props.config.defaultSize.height,width:this.props.config.defaultSize.width,alt:""}):t.config.uploadCallback===this.props.config.uploadCallback&&t.config.uploadEnabled===this.props.config.uploadEnabled||this.setState({uploadHighlighted:t.config.uploadEnabled&&!!t.config.uploadCallback})}},{key:"renderAddImageModal",value:function(){var t=this.state,e=t.imgSrc,n=t.uploadHighlighted,r=t.showImageLoading,o=t.dragEnter,i=t.height,a=t.width,s=t.alt,u=this.props,c=u.config,f=c.popupClassName,p=c.uploadCallback,d=c.uploadEnabled,M=c.urlEnabled,h=c.inputAccept,y=c.alt,I=u.doCollapse,w=u.translations;return l.default.createElement("div",{className:(0,g.default)("rdw-image-modal",f),onClick:this.stopPropagation},l.default.createElement("div",{className:"rdw-image-modal-header"},d&&p&&l.default.createElement("span",{onClick:this.showImageUploadOption,className:"rdw-image-modal-header-option"},w["components.controls.image.fileUpload"],l.default.createElement("span",{className:(0,g.default)("rdw-image-modal-header-label",{"rdw-image-modal-header-label-highlighted":n})})),M&&l.default.createElement("span",{onClick:this.showImageURLOption,className:"rdw-image-modal-header-option"},w["components.controls.image.byURL"],l.default.createElement("span",{className:(0,g.default)("rdw-image-modal-header-label",{"rdw-image-modal-header-label-highlighted":!n})}))),n?l.default.createElement("div",{onClick:this.fileUploadClick},l.default.createElement("div",{onDragEnter:this.onDragEnter,onDragOver:this.stopPropagation,onDrop:this.onImageDrop,className:(0,g.default)("rdw-image-modal-upload-option",{"rdw-image-modal-upload-option-highlighted":o})},l.default.createElement("label",{htmlFor:"file",className:"rdw-image-modal-upload-option-label"},e||w["components.controls.image.dropFileText"])),l.default.createElement("input",{type:"file",id:"file",accept:h,onChange:this.selectImage,className:"rdw-image-modal-upload-option-input"})):l.default.createElement("div",{className:"rdw-image-modal-url-section"},l.default.createElement("input",{className:"rdw-image-modal-url-input",placeholder:w["components.controls.image.enterlink"],name:"imgSrc",onChange:this.updateValue,onBlur:this.updateValue,value:e}),l.default.createElement("span",{className:"rdw-image-mandatory-sign"},"*")),y.present&&l.default.createElement("div",{className:"rdw-image-modal-size"},l.default.createElement("span",{className:"rdw-image-modal-alt-lbl"},"Alt Text"),l.default.createElement("input",{onChange:this.updateValue,onBlur:this.updateValue,value:s,name:"alt",className:"rdw-image-modal-alt-input",placeholder:"alt"}),l.default.createElement("span",{className:"rdw-image-mandatory-sign"},y.mandatory&&"*")),l.default.createElement("div",{className:"rdw-image-modal-size"},"↕ ",l.default.createElement("input",{onChange:this.updateValue,onBlur:this.updateValue,value:i,name:"height",className:"rdw-image-modal-size-input",placeholder:"Height"}),l.default.createElement("span",{className:"rdw-image-mandatory-sign"},"*")," ↔ ",l.default.createElement("input",{onChange:this.updateValue,onBlur:this.updateValue,value:a,name:"width",className:"rdw-image-modal-size-input",placeholder:"Width"}),l.default.createElement("span",{className:"rdw-image-mandatory-sign"},"*")),l.default.createElement("span",{className:"rdw-image-modal-btn-section"},l.default.createElement("button",{className:"rdw-image-modal-btn",onClick:this.addImageFromState,disabled:!e||!i||!a||y.mandatory&&!s},w["generic.add"]),l.default.createElement("button",{className:"rdw-image-modal-btn",onClick:I},w["generic.cancel"])),r?l.default.createElement("div",{className:"rdw-image-modal-spinner"},l.default.createElement(m.default,null)):void 0)}},{key:"render",value:function(){var t=this.props,e=t.config,n=e.icon,r=e.className,o=e.title,i=t.expanded,a=t.onExpandEvent,s=t.translations;return l.default.createElement("div",{className:"rdw-image-wrapper","aria-haspopup":"true","aria-expanded":i,"aria-label":"rdw-image-control"},l.default.createElement(h.default,{className:(0,g.default)(r),value:"unordered-list-item",onClick:a,title:o||s["components.controls.image.image"]},l.default.createElement("img",{src:n,alt:""})),i?this.renderAddImageModal():void 0)}}]),e}(c.Component);I.propTypes={expanded:p.default.bool,onExpandEvent:p.default.func,doCollapse:p.default.func,onChange:p.default.func,config:p.default.object,translations:p.default.object},e.default=I},function(t,e,n){"use strict";Object.defineProperty(e,"__esModule",{value:!0});var r=n(0),o=function(t){return t&&t.__esModule?t:{default:t}}(r);n(210),e.default=function(){return o.default.createElement("div",{className:"rdw-spinner"},o.default.createElement("div",{className:"rdw-bounce1"}),o.default.createElement("div",{className:"rdw-bounce2"}),o.default.createElement("div",{className:"rdw-bounce3"}))}},function(t,e){t.exports={"rdw-spinner":"rdw-spinner","sk-bouncedelay":"sk-bouncedelay","rdw-bounce1":"rdw-bounce1","rdw-bounce2":"rdw-bounce2"}},function(t,e){t.exports={"rdw-image-wrapper":"rdw-image-wrapper","rdw-image-modal":"rdw-image-modal","rdw-image-modal-header":"rdw-image-modal-header","rdw-image-modal-header-option":"rdw-image-modal-header-option","rdw-image-modal-header-label":"rdw-image-modal-header-label","rdw-image-modal-header-label-highlighted":"rdw-image-modal-header-label-highlighted","rdw-image-modal-upload-option":"rdw-image-modal-upload-option","rdw-image-modal-upload-option-highlighted":"rdw-image-modal-upload-option-highlighted","rdw-image-modal-upload-option-label":"rdw-image-modal-upload-option-label","rdw-image-modal-upload-option-input":"rdw-image-modal-upload-option-input","rdw-image-modal-url-section":"rdw-image-modal-url-section","rdw-image-modal-url-input":"rdw-image-modal-url-input","rdw-image-modal-btn-section":"rdw-image-modal-btn-section","rdw-image-modal-btn":"rdw-image-modal-btn","rdw-image-modal-spinner":"rdw-image-modal-spinner","rdw-image-modal-alt-input":"rdw-image-modal-alt-input","rdw-image-modal-alt-lbl":"rdw-image-modal-alt-lbl","rdw-image-modal-size":"rdw-image-modal-size","rdw-image-modal-size-input":"rdw-image-modal-size-input","rdw-image-mandatory-sign":"rdw-image-mandatory-sign"}},function(t,e,n){"use strict";function r(t){return t&&t.__esModule?t:{default:t}}function o(t,e){if(!(t instanceof e))throw new TypeError("Cannot call a class as a function")}function i(t,e){if(!t)throw new ReferenceError("this hasn't been initialised - super() hasn't been called");return!e||"object"!=typeof e&&"function"!=typeof e?t:e}function a(t,e){if("function"!=typeof e&&null!==e)throw new TypeError("Super expression must either be null or a function, not "+typeof e);t.prototype=Object.create(e&&e.prototype,{constructor:{value:t,enumerable:!1,writable:!0,configurable:!0}}),e&&(Object.setPrototypeOf?Object.setPrototypeOf(t,e):t.__proto__=e)}Object.defineProperty(e,"__esModule",{value:!0});var s=function(){function t(t,e){for(var n=0;n<e.length;n++){var r=e[n];r.enumerable=r.enumerable||!1,r.configurable=!0,"value"in r&&(r.writable=!0),Object.defineProperty(t,r.key,r)}}return function(e,n,r){return n&&t(e.prototype,n),r&&t(e,r),e}}(),u=n(0),c=r(u),l=n(1),f=r(l),p=n(6),d=n(9),g=n(14),M=n(213),h=r(M),y=function(t){function e(){var t,n,r,a;o(this,e);for(var s=arguments.length,u=Array(s),c=0;c<s;c++)u[c]=arguments[c];return n=r=i(this,(t=e.__proto__||Object.getPrototypeOf(e)).call.apply(t,[this].concat(u))),r.state={expanded:!1},r.onExpandEvent=function(){r.signalExpanded=!r.state.expanded},r.expandCollapse=function(){r.setState({expanded:r.signalExpanded}),r.signalExpanded=!1},r.removeInlineStyles=function(){var t=r.props,e=t.editorState;(0,t.onChange)(r.removeAllInlineStyles(e))},r.removeAllInlineStyles=function(t){var e=t.getCurrentContent();["BOLD","ITALIC","UNDERLINE","STRIKETHROUGH","MONOSPACE","SUPERSCRIPT","SUBSCRIPT"].forEach(function(n){e=p.Modifier.removeInlineStyle(e,t.getSelection(),n)});var n=(0,d.getSelectionCustomInlineStyle)(t,["FONTSIZE","FONTFAMILY","COLOR","BGCOLOR"]);return(0,g.forEach)(n,function(n,r){r&&(e=p.Modifier.removeInlineStyle(e,t.getSelection(),r))}),p.EditorState.push(t,e,"change-inline-style")},r.doExpand=function(){r.setState({expanded:!0})},r.doCollapse=function(){r.setState({expanded:!1})},a=n,i(r,a)}return a(e,t),s(e,[{key:"componentWillMount",value:function(){this.props.modalHandler.registerCallBack(this.expandCollapse)}},{key:"componentWillUnmount",value:function(){this.props.modalHandler.deregisterCallBack(this.expandCollapse)}},{key:"render",value:function(){var t=this.props,e=t.config,n=t.translations,r=this.state.expanded,o=e.component||h.default;return c.default.createElement(o,{config:e,translations:n,expanded:r,onExpandEvent:this.onExpandEvent,doExpand:this.doExpand,doCollapse:this.doCollapse,onChange:this.removeInlineStyles})}}]),e}(u.Component);y.propTypes={onChange:f.default.func.isRequired,editorState:f.default.object.isRequired,config:f.default.object,translations:f.default.object,modalHandler:f.default.object},e.default=y},function(t,e,n){"use strict";function r(t){return t&&t.__esModule?t:{default:t}}Object.defineProperty(e,"__esModule",{value:!0});var o=n(0),i=r(o),a=n(1),s=r(a),u=n(5),c=r(u),l=n(10),f=r(l);n(214);var p=function(t){var e=t.config,n=t.onChange,r=t.translations,o=e.icon,a=e.className,s=e.title;return i.default.createElement("div",{className:"rdw-remove-wrapper","aria-label":"rdw-remove-control"},i.default.createElement(f.default,{className:(0,c.default)(a),onClick:n,title:s||r["components.controls.remove.remove"]},i.default.createElement("img",{src:o,alt:""})))};p.propTypes={onChange:s.default.func,config:s.default.object,translations:s.default.object},e.default=p},function(t,e){t.exports={"rdw-remove-wrapper":"rdw-remove-wrapper"}},function(t,e,n){"use strict";function r(t){return t&&t.__esModule?t:{default:t}}function o(t,e){if(!(t instanceof e))throw new TypeError("Cannot call a class as a function")}function i(t,e){if(!t)throw new ReferenceError("this hasn't been initialised - super() hasn't been called");return!e||"object"!=typeof e&&"function"!=typeof e?t:e}function a(t,e){if("function"!=typeof e&&null!==e)throw new TypeError("Super expression must either be null or a function, not "+typeof e);t.prototype=Object.create(e&&e.prototype,{constructor:{value:t,enumerable:!1,writable:!0,configurable:!0}}),e&&(Object.setPrototypeOf?Object.setPrototypeOf(t,e):t.__proto__=e)}Object.defineProperty(e,"__esModule",{value:!0});var s=function(){function t(t,e){for(var n=0;n<e.length;n++){var r=e[n];r.enumerable=r.enumerable||!1,r.configurable=!0,"value"in r&&(r.writable=!0),Object.defineProperty(t,r.key,r)}}return function(e,n,r){return n&&t(e.prototype,n),r&&t(e,r),e}}(),u=n(0),c=r(u),l=n(1),f=r(l),p=n(6),d=n(216),g=r(d),M=function(t){function e(){var t,n,r,a;o(this,e);for(var s=arguments.length,u=Array(s),c=0;c<s;c++)u[c]=arguments[c];return n=r=i(this,(t=e.__proto__||Object.getPrototypeOf(e)).call.apply(t,[this].concat(u))),r.state={expanded:!1,undoDisabled:!1,redoDisabled:!1},r.onExpandEvent=function(){r.signalExpanded=!r.state.expanded},r.onChange=function(t){var e=r.props,n=e.editorState,o=e.onChange,i=p.EditorState[t](n);i&&o(i)},r.doExpand=function(){r.setState({expanded:!0})},r.doCollapse=function(){r.setState({expanded:!1})},r.expandCollapse=function(){r.setState({expanded:r.signalExpanded}),r.signalExpanded=!1},a=n,i(r,a)}return a(e,t),s(e,[{key:"componentWillMount",value:function(){var t=this.props,e=t.editorState,n=t.modalHandler;e&&this.setState({undoDisabled:0===e.getUndoStack().size,redoDisabled:0===e.getRedoStack().size}),n.registerCallBack(this.expandCollapse)}},{key:"componentWillReceiveProps",value:function(t){t.editorState&&this.props.editorState!==t.editorState&&this.setState({undoDisabled:0===t.editorState.getUndoStack().size,redoDisabled:0===t.editorState.getRedoStack().size})}},{key:"componentWillUnmount",value:function(){this.props.modalHandler.deregisterCallBack(this.expandCollapse)}},{key:"render",value:function(){var t=this.props,e=t.config,n=t.translations,r=this.state,o=r.undoDisabled,i=r.redoDisabled,a=r.expanded,s=e.component||g.default;return c.default.createElement(s,{config:e,translations:n,currentState:{undoDisabled:o,redoDisabled:i},expanded:a,onExpandEvent:this.onExpandEvent,doExpand:this.doExpand,doCollapse:this.doCollapse,onChange:this.onChange})}}]),e}(u.Component);M.propTypes={onChange:f.default.func.isRequired,editorState:f.default.object,modalHandler:f.default.object,config:f.default.object,translations:f.default.object},e.default=M},function(t,e,n){"use strict";function r(t){return t&&t.__esModule?t:{default:t}}function o(t,e){if(!(t instanceof e))throw new TypeError("Cannot call a class as a function")}function i(t,e){if(!t)throw new ReferenceError("this hasn't been initialised - super() hasn't been called");return!e||"object"!=typeof e&&"function"!=typeof e?t:e}function a(t,e){if("function"!=typeof e&&null!==e)throw new TypeError("Super expression must either be null or a function, not "+typeof e);t.prototype=Object.create(e&&e.prototype,{constructor:{value:t,enumerable:!1,writable:!0,configurable:!0}}),e&&(Object.setPrototypeOf?Object.setPrototypeOf(t,e):t.__proto__=e)}Object.defineProperty(e,"__esModule",{value:!0});var s=function(){function t(t,e){for(var n=0;n<e.length;n++){var r=e[n];r.enumerable=r.enumerable||!1,r.configurable=!0,"value"in r&&(r.writable=!0),Object.defineProperty(t,r.key,r)}}return function(e,n,r){return n&&t(e.prototype,n),r&&t(e,r),e}}(),u=n(0),c=r(u),l=n(1),f=r(l),p=n(5),d=r(p),g=n(20),M=n(10),h=r(M),y=n(16);n(217);var m=function(t){function e(){var t,n,r,a;o(this,e);for(var s=arguments.length,u=Array(s),c=0;c<s;c++)u[c]=arguments[c];return n=r=i(this,(t=e.__proto__||Object.getPrototypeOf(e)).call.apply(t,[this].concat(u))),r.onChange=function(t){(0,r.props.onChange)(t)},a=n,i(r,a)}return a(e,t),s(e,[{key:"renderInDropDown",value:function(){var t=this.props,e=t.config,n=t.expanded,r=t.doExpand,o=t.onExpandEvent,i=t.doCollapse,a=t.currentState,s=a.undoDisabled,u=a.redoDisabled,l=t.translations,f=e.options,p=e.undo,M=e.redo,h=e.className,m=e.dropdownClassName,I=e.title;return c.default.createElement(y.Dropdown,{className:(0,d.default)("rdw-history-dropdown",h),optionWrapperClassName:(0,d.default)(m),expanded:n,doExpand:r,doCollapse:i,onExpandEvent:o,"aria-label":"rdw-history-control",title:I||l["components.controls.history.history"]},c.default.createElement("img",{src:(0,g.getFirstIcon)(e),alt:""}),f.indexOf("undo")>=0&&c.default.createElement(y.DropdownOption,{value:"undo",onClick:this.onChange,disabled:s,className:(0,d.default)("rdw-history-dropdownoption",p.className),title:p.title||l["components.controls.history.undo"]},c.default.createElement("img",{src:p.icon,alt:""})),f.indexOf("redo")>=0&&c.default.createElement(y.DropdownOption,{value:"redo",onClick:this.onChange,disabled:u,className:(0,d.default)("rdw-history-dropdownoption",M.className),title:M.title||l["components.controls.history.redo"]},c.default.createElement("img",{src:M.icon,alt:""})))}},{key:"renderInFlatList",value:function(){var t=this.props,e=t.config,n=e.options,r=e.undo,o=e.redo,i=e.className,a=t.currentState,s=a.undoDisabled,u=a.redoDisabled,l=t.translations;return c.default.createElement("div",{className:(0,d.default)("rdw-history-wrapper",i),"aria-label":"rdw-history-control"},n.indexOf("undo")>=0&&c.default.createElement(h.default,{value:"undo",onClick:this.onChange,className:(0,d.default)(r.className),disabled:s,title:r.title||l["components.controls.history.undo"]},c.default.createElement("img",{src:r.icon,alt:""})),n.indexOf("redo")>=0&&c.default.createElement(h.default,{value:"redo",onClick:this.onChange,className:(0,d.default)(o.className),disabled:u,title:o.title||l["components.controls.history.redo"]},c.default.createElement("img",{src:o.icon,alt:""})))}},{key:"render",value:function(){return this.props.config.inDropdown?this.renderInDropDown():this.renderInFlatList()}}]),e}(u.Component);m.propTypes={expanded:f.default.bool,doExpand:f.default.func,doCollapse:f.default.func,onExpandEvent:f.default.func,config:f.default.object,onChange:f.default.func,currentState:f.default.object,translations:f.default.object},e.default=m},function(t,e){t.exports={"rdw-history-wrapper":"rdw-history-wrapper","rdw-history-dropdownoption":"rdw-history-dropdownoption","rdw-history-dropdown":"rdw-history-dropdown"}},function(t,e,n){"use strict";function r(t){return t&&t.__esModule?t:{default:t}}function o(t,e){if(!(t instanceof e))throw new TypeError("Cannot call a class as a function")}function i(t,e){if(!t)throw new ReferenceError("this hasn't been initialised - super() hasn't been called");return!e||"object"!=typeof e&&"function"!=typeof e?t:e}function a(t,e){if("function"!=typeof e&&null!==e)throw new TypeError("Super expression must either be null or a function, not "+typeof e);t.prototype=Object.create(e&&e.prototype,{constructor:{value:t,enumerable:!1,writable:!0,configurable:!0}}),e&&(Object.setPrototypeOf?Object.setPrototypeOf(t,e):t.__proto__=e)}function s(t,e,n){t.findEntityRanges(function(t){var e=t.getEntity();return null!==e&&"LINK"===n.getEntity(e).getType()},e)}function u(t){var e,n,r=t.showOpenOptionOnHover;return n=e=function(t){function e(){var t,n,r,a;o(this,e);for(var s=arguments.length,u=Array(s),c=0;c<s;c++)u[c]=arguments[c];return n=r=i(this,(t=e.__proto__||Object.getPrototypeOf(e)).call.apply(t,[this].concat(u))),r.state={showPopOver:!1},r.openLink=function(){var t=r.props,e=t.entityKey,n=t.contentState,o=n.getEntity(e).getData(),i=o.url;window.open(i,"blank").focus()},r.toggleShowPopOver=function(){var t=!r.state.showPopOver;r.setState({showPopOver:t})},a=n,i(r,a)}return a(e,t),c(e,[{key:"render",value:function(){var t=this.props,e=t.children,n=t.entityKey,o=t.contentState,i=o.getEntity(n).getData(),a=i.url,s=i.targetOption,u=this.state.showPopOver;return f.default.createElement("span",{className:"rdw-link-decorator-wrapper",onMouseEnter:this.toggleShowPopOver,onMouseLeave:this.toggleShowPopOver},f.default.createElement("a",{href:a,target:s},e),u&&r?f.default.createElement("img",{src:M.default,alt:"",onClick:this.openLink,className:"rdw-link-decorator-icon"}):void 0)}}]),e}(l.Component),e.propTypes={entityKey:d.default.string.isRequired,children:d.default.array,contentState:d.default.object},n}Object.defineProperty(e,"__esModule",{value:!0});var c=function(){function t(t,e){for(var n=0;n<e.length;n++){var r=e[n];r.enumerable=r.enumerable||!1,r.configurable=!0,"value"in r&&(r.writable=!0),Object.defineProperty(t,r.key,r)}}return function(e,n,r){return n&&t(e.prototype,n),r&&t(e,r),e}}(),l=n(0),f=r(l),p=n(1),d=r(p),g=n(219),M=r(g);n(220),e.default=function(t){return{strategy:s,component:u(t)}}},function(t,e){t.exports="data:image/svg+xml;base64,PD94bWwgdmVyc2lvbj0iMS4wIiBlbmNvZGluZz0iVVRGLTgiIHN0YW5kYWxvbmU9Im5vIj8+Cjxzdmcgd2lkdGg9IjE1cHgiIGhlaWdodD0iMTVweCIgdmlld0JveD0iMCAwIDE1IDE1IiB2ZXJzaW9uPSIxLjEiIHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZyIgeG1sbnM6eGxpbms9Imh0dHA6Ly93d3cudzMub3JnLzE5OTkveGxpbmsiPgogICAgPCEtLSBHZW5lcmF0b3I6IFNrZXRjaCA0MC4zICgzMzgzOSkgLSBodHRwOi8vd3d3LmJvaGVtaWFuY29kaW5nLmNvbS9za2V0Y2ggLS0+CiAgICA8dGl0bGU+b3Blbmxpbms8L3RpdGxlPgogICAgPGRlc2M+Q3JlYXRlZCB3aXRoIFNrZXRjaC48L2Rlc2M+CiAgICA8ZGVmcz48L2RlZnM+CiAgICA8ZyBpZD0iUGFnZS0xIiBzdHJva2U9Im5vbmUiIHN0cm9rZS13aWR0aD0iMSIgZmlsbD0ibm9uZSIgZmlsbC1ydWxlPSJldmVub2RkIj4KICAgICAgICA8ZyBpZD0ib3BlbmxpbmsiIGZpbGw9IiMwMDAwMDAiPgogICAgICAgICAgICA8ZyBpZD0iQ2FwYV8xIj4KICAgICAgICAgICAgICAgIDxnIGlkPSJHcm91cCI+CiAgICAgICAgICAgICAgICAgICAgPHBhdGggZD0iTTE0LjA3MTU4NDUsMCBMOC45MTUzMzQ1MSwwIEM4LjQwNTY1MTQxLDAgNy45OTEwMzg3MywwLjQxNDY2NTQ5MyA3Ljk5MTAzODczLDAuOTI0Mjk1Nzc1IEM3Ljk5MTAzODczLDEuNDMzOTI2MDYgOC40MDU2NTE0MSwxLjg0ODU5MTU1IDguOTE1MzM0NTEsMS44NDg1OTE1NSBMMTEuODQwMTc2MSwxLjg0ODU5MTU1IEw2Ljk2MTIxNDc5LDYuNzI3NSBDNi43ODY1NDkzLDYuOTAyMDU5ODYgNi42OTA0MjI1NCw3LjEzNDEzNzMyIDYuNjkwNDIyNTQsNy4zODExMDkxNSBDNi42OTA0MjI1NCw3LjYyODA4MDk5IDYuNzg2NDk2NDgsNy44NjAxMDU2MyA2Ljk2MTEwOTE1LDguMDM0NTA3MDQgQzcuMTM1NzIxODMsOC4yMDkyNzgxNyA3LjM2Nzc0NjQ4LDguMzA1NDU3NzUgNy42MTQ3MTgzMSw4LjMwNTQ1Nzc1IEM3Ljg2MTU4NDUxLDguMzA1NDU3NzUgOC4wOTM3MTQ3OSw4LjIwOTMzMDk5IDguMjY4MzgwMjgsOC4wMzQ2NjU0OSBMMTMuMTQ3Mjg4NywzLjE1NTcwNDIzIEwxMy4xNDcyODg3LDYuMDgwNTQ1NzcgQzEzLjE0NzI4ODcsNi41OTAxNzYwNiAxMy41NjE5NTQyLDcuMDA0ODQxNTUgMTQuMDcxNTg0NSw3LjAwNDg0MTU1IEMxNC41ODEyMTQ4LDcuMDA0ODQxNTUgMTQuOTk1ODgwMyw2LjU5MDE3NjA2IDE0Ljk5NTg4MDMsNi4wODA1NDU3NyBMMTQuOTk1ODgwMywwLjkyNDI5NTc3NSBDMTQuOTk1ODgwMywwLjQxNDY2NTQ5MyAxNC41ODEyMTQ4LDAgMTQuMDcxNTg0NSwwIEwxNC4wNzE1ODQ1LDAgWiIgaWQ9IlNoYXBlIj48L3BhdGg+CiAgICAgICAgICAgICAgICAgICAgPHBhdGggZD0iTTEwLjYyMzQzMzEsMTMuNDExMzczMiBMMS41ODQ1MDcwNCwxMy40MTEzNzMyIEwxLjU4NDUwNzA0LDQuMzcyNDQ3MTggTDguMzgyNjIzMjQsNC4zNzI0NDcxOCBMOS45NjcxMzAyOCwyLjc4Nzk0MDE0IEwwLjc5MjI1MzUyMSwyLjc4Nzk0MDE0IEMwLjM1NDcxODMxLDIuNzg3OTQwMTQgMCwzLjE0MjY1ODQ1IDAsMy41ODAxOTM2NiBMMCwxNC4yMDM2MjY4IEMwLDE0LjY0MTE2MiAwLjM1NDcxODMxLDE0Ljk5NTg4MDMgMC43OTIyNTM1MjEsMTQuOTk1ODgwMyBMMTEuNDE1Njg2NiwxNC45OTU4ODAzIEMxMS44NTMyMjE4LDE0Ljk5NTg4MDMgMTIuMjA3OTQwMSwxNC42NDExNjIgMTIuMjA3OTQwMSwxNC4yMDM2MjY4IEwxMi4yMDc5NDAxLDUuMDI4NzUgTDEwLjYyMzQzMzEsNi42MTMyNTcwNCBMMTAuNjIzNDMzMSwxMy40MTEzNzMyIEwxMC42MjM0MzMxLDEzLjQxMTM3MzIgWiIgaWQ9IlNoYXBlIj48L3BhdGg+CiAgICAgICAgICAgICAgICA8L2c+CiAgICAgICAgICAgIDwvZz4KICAgICAgICA8L2c+CiAgICA8L2c+Cjwvc3ZnPg=="},function(t,e){t.exports={"rdw-link-decorator-wrapper":"rdw-link-decorator-wrapper","rdw-link-decorator-icon":"rdw-link-decorator-icon"}},function(t,e,n){"use strict";function r(t){return t&&t.__esModule?t:{default:t}}var o=n(222),i=r(o),a=n(224),s=r(a),u=function(t){return[new i.default(t.mentionClassName).getMentionDecorator(),new s.default(t).getSuggestionDecorator()]};t.exports=u},function(t,e,n){"use strict";function r(t){return t&&t.__esModule?t:{default:t}}function o(t,e){if(!(t instanceof e))throw new TypeError("Cannot call a class as a function")}var i=n(0),a=r(i),s=n(1),u=r(s),c=n(5),l=r(c);n(223);var f=function t(e){o(this,t),p.call(this),this.className=e},p=function(){var t=this;this.getMentionComponent=function(){var e=t.className,n=function(t){var n=t.entityKey,r=t.children,o=t.contentState,i=o.getEntity(n).getData(),s=i.url,u=i.value;return a.default.createElement("a",{href:s||u,className:(0,l.default)("rdw-mention-link",e)},r)};return n.propTypes={entityKey:u.default.number,children:u.default.array,contentState:u.default.object},n},this.getMentionDecorator=function(){return{strategy:t.findMentionEntities,component:t.getMentionComponent()}}};f.prototype.findMentionEntities=function(t,e,n){t.findEntityRanges(function(t){var e=t.getEntity();return null!==e&&"MENTION"===n.getEntity(e).getType()},e)},t.exports=f},function(t,e){t.exports={"rdw-mention-link":"rdw-mention-link"}},function(t,e,n){"use strict";function r(t){return t&&t.__esModule?t:{default:t}}function o(t,e){if(!t)throw new ReferenceError("this hasn't been initialised - super() hasn't been called");return!e||"object"!=typeof e&&"function"!=typeof e?t:e}function i(t,e){if("function"!=typeof e&&null!==e)throw new TypeError("Super expression must either be null or a function, not "+typeof e);t.prototype=Object.create(e&&e.prototype,{constructor:{value:t,enumerable:!1,writable:!0,configurable:!0}}),e&&(Object.setPrototypeOf?Object.setPrototypeOf(t,e):t.__proto__=e)}function a(t,e){if(!(t instanceof e))throw new TypeError("Cannot call a class as a function")}function s(){var t,e,n=this.config;return e=t=function(t){function e(){var t,r,i,s;a(this,e);for(var u=arguments.length,c=Array(u),l=0;l<u;l++)c[l]=arguments[l];return r=i=o(this,(t=e.__proto__||Object.getPrototypeOf(e)).call.apply(t,[this].concat(c))),i.state={style:{left:15},activeOption:-1,showSuggestions:!0},i.onEditorKeyDown=function(t){var e=i.state.activeOption,n={};"ArrowDown"===t.key?(t.preventDefault(),e===i.filteredSuggestions.length-1?n.activeOption=0:n.activeOption=e+1):"ArrowUp"===t.key?n.activeOption=e<=0?i.filteredSuggestions.length-1:e-1:"Escape"===t.key?(n.showSuggestions=!1,w.default.close()):"Enter"===t.key&&i.addMention(),i.setState(n)},i.onOptionMouseEnter=function(t){var e=t.target.getAttribute("data-index");i.setState({activeOption:e})},i.onOptionMouseLeave=function(){i.setState({activeOption:-1})},i.setSuggestionReference=function(t){i.suggestion=t},i.setDropdownReference=function(t){i.dropdown=t},i.closeSuggestionDropdown=function(){i.setState({showSuggestions:!1})},i.filteredSuggestions=[],i.filterSuggestions=function(t){var e=t.children[0].props.text.substr(1),r=n.getSuggestions();i.filteredSuggestions=r&&r.filter(function(t){return!e||0===e.length||(n.caseSensitive?t.value.indexOf(e)>=0:t.value.toLowerCase().indexOf(e&&e.toLowerCase())>=0)})},i.addMention=function(){var t=i.state.activeOption,e=n.getEditorState(),r=n.onChange,o=n.separator,a=n.trigger,s=i.filteredSuggestions[t];s&&(0,h.default)(e,r,o,a,s)},s=r,o(i,s)}return i(e,t),u(e,[{key:"componentDidMount",value:function(){var t=n.getWrapperRef().getBoundingClientRect(),e=this.suggestion.getBoundingClientRect(),r=this.dropdown.getBoundingClientRect(),o=void 0,i=void 0,a=void 0;t.width<e.left-t.left+r.width?i=15:o=15,t.bottom<r.bottom&&(a=0),this.setState({style:{left:o,right:i,bottom:a}}),m.default.registerCallBack(this.onEditorKeyDown),w.default.open(),n.modalHandler.setSuggestionCallback(this.closeSuggestionDropdown),this.filterSuggestions(this.props)}},{key:"componentWillReceiveProps",value:function(t){this.props.children!==t.children&&(this.filterSuggestions(t),this.setState({showSuggestions:!0}))}},{key:"componentWillUnmount",value:function(){m.default.deregisterCallBack(this.onEditorKeyDown),w.default.close(),n.modalHandler.removeSuggestionCallback()}},{key:"render",value:function(){var t=this,e=this.props.children,r=this.state,o=r.activeOption,i=r.showSuggestions,a=n.dropdownClassName,s=n.optionClassName;return l.default.createElement("span",{className:"rdw-suggestion-wrapper",ref:this.setSuggestionReference,onClick:n.modalHandler.onSuggestionClick,"aria-haspopup":"true","aria-label":"rdw-suggestion-popup"},l.default.createElement("span",null,e),i&&l.default.createElement("span",{className:(0,g.default)("rdw-suggestion-dropdown",a),contentEditable:"false",suppressContentEditableWarning:!0,style:this.state.style,ref:this.setDropdownReference},this.filteredSuggestions.map(function(e,n){return l.default.createElement("span",{key:n,spellCheck:!1,onClick:t.addMention,"data-index":n,onMouseEnter:t.onOptionMouseEnter,onMouseLeave:t.onOptionMouseLeave,className:(0,g.default)("rdw-suggestion-option",s,{"rdw-suggestion-option-active":n===o})},e.text)})))}}]),e}(c.Component),t.propTypes={children:p.default.array},e}var u=function(){function t(t,e){for(var n=0;n<e.length;n++){var r=e[n];r.enumerable=r.enumerable||!1,r.configurable=!0,"value"in r&&(r.writable=!0),Object.defineProperty(t,r.key,r)}}return function(e,n,r){return n&&t(e.prototype,n),r&&t(e,r),e}}(),c=n(0),l=r(c),f=n(1),p=r(f),d=n(5),g=r(d),M=n(225),h=r(M),y=n(70),m=r(y),I=n(71),w=r(I);n(226);var D=function t(e){a(this,t),N.call(this);var n=e.separator,r=e.trigger,o=e.getSuggestions,i=e.onChange,s=e.getEditorState,u=e.getWrapperRef,c=e.caseSensitive,l=e.dropdownClassName,f=e.optionClassName,p=e.modalHandler;this.config={separator:n,trigger:r,getSuggestions:o,onChange:i,getEditorState:s,getWrapperRef:u,caseSensitive:c,dropdownClassName:l,optionClassName:f,modalHandler:p}},N=function(){var t=this;this.findSuggestionEntities=function(e,n){if(t.config.getEditorState()){var r=t.config,o=r.separator,i=r.trigger,a=r.getSuggestions,s=r.getEditorState,u=s().getSelection();if(u.get("anchorKey")===e.get("key")&&u.get("anchorKey")===u.get("focusKey")){var c=e.getText();c=c.substr(0,u.get("focusOffset")===c.length-1?c.length:u.get("focusOffset")+1);var l=c.lastIndexOf(o+i),f=o+i;if((void 0===l||l<0)&&c[0]===i&&(l=0,f=i),l>=0){var p=c.substr(l+f.length,c.length);a().some(function(e){return!!e.value&&(t.config.caseSensitive?e.value.indexOf(p)>=0:e.value.toLowerCase().indexOf(p&&p.toLowerCase())>=0)})&&n(0===l?0:l+1,c.length)}}}},this.getSuggestionComponent=s.bind(this),this.getSuggestionDecorator=function(){return{strategy:t.findSuggestionEntities,component:t.getSuggestionComponent()}}};t.exports=D},function(t,e,n){"use strict";function r(t,e,n,r,a){var s=a.value,u=a.url,c=t.getCurrentContent().createEntity("MENTION","IMMUTABLE",{text:""+r+s,value:s,url:u}).getLastCreatedEntityKey(),l=(0,i.getSelectedBlock)(t),f=l.getText(),p=t.getSelection().focusOffset,d=(f.lastIndexOf(n+r,p)||0)+1,g=!1;f.length===d+1&&(p=f.length)," "===f[p]&&(g=!0);var M=t.getSelection().merge({anchorOffset:d,focusOffset:p}),h=o.EditorState.acceptSelection(t,M),y=o.Modifier.replaceText(h.getCurrentContent(),M,""+r+s,h.getCurrentInlineStyle(),c);h=o.EditorState.push(h,y,"insert-characters"),g||(M=h.getSelection().merge({anchorOffset:d+s.length+r.length,focusOffset:d+s.length+r.length}),h=o.EditorState.acceptSelection(h,M),y=o.Modifier.insertText(h.getCurrentContent(),M," ",h.getCurrentInlineStyle(),void 0)),e(o.EditorState.push(h,y,"insert-characters"))}Object.defineProperty(e,"__esModule",{value:!0}),e.default=r;var o=n(6),i=n(9)},function(t,e){t.exports={"rdw-suggestion-wrapper":"rdw-suggestion-wrapper","rdw-suggestion-dropdown":"rdw-suggestion-dropdown","rdw-suggestion-option":"rdw-suggestion-option","rdw-suggestion-option-active":"rdw-suggestion-option-active"}},function(t,e,n){"use strict";function r(t){return t&&t.__esModule?t:{default:t}}function o(t,e){if(!(t instanceof e))throw new TypeError("Cannot call a class as a function")}var i=n(0),a=r(i),s=n(1),u=r(s),c=n(5),l=r(c);n(228);var f=function t(e){var n=this;o(this,t),this.getHashtagComponent=function(){var t=n.className,e=function(e){var n=e.children,r=n[0].props.text;return a.default.createElement("a",{href:r,className:(0,l.default)("rdw-hashtag-link",t)},n)};return e.propTypes={children:u.default.object},e},this.findHashtagEntities=function(t,e){for(var r=t.getText(),o=0,i=0;r.length>0&&o>=0;)if(r[0]===n.hashCharacter?(o=0,i=0,r=r.substr(n.hashCharacter.length)):(o=r.indexOf(n.separator+n.hashCharacter))>=0&&(r=r.substr(o+(n.separator+n.hashCharacter).length),i+=o+n.separator.length),o>=0){var a=r.indexOf(n.separator)>=0?r.indexOf(n.separator):r.length,s=r.substr(0,a);s&&s.length>0&&(e(i,i+s.length+n.hashCharacter.length),i+=n.hashCharacter.length)}},this.getHashtagDecorator=function(){return{strategy:n.findHashtagEntities,component:n.getHashtagComponent()}},this.className=e.className,this.hashCharacter=e.hashCharacter||"#",this.separator=e.separator||" "},p=function(t){return new f(t).getHashtagDecorator()};t.exports=p},function(t,e){t.exports={"rdw-hashtag-link":"rdw-hashtag-link"}},function(t,e,n){"use strict";function r(t){return t&&t.__esModule?t:{default:t}}Object.defineProperty(e,"__esModule",{value:!0});var o=n(230),i=r(o),a=n(231),s=r(a),u=function(t,e){return function(n){if("function"==typeof e){var r=e(n,t,t.getEditorState);if(r)return r}if("atomic"===n.getType()){var o=t.getEditorState().getCurrentContent(),a=o.getEntity(n.getEntityAt(0));if(a&&"IMAGE"===a.type)return{component:(0,s.default)(t),editable:!1};if(a&&"EMBEDDED_LINK"===a.type)return{component:i.default,editable:!1}}}};e.default=u},function(t,e,n){"use strict";function r(t){return t&&t.__esModule?t:{default:t}}Object.defineProperty(e,"__esModule",{value:!0});var o=n(0),i=r(o),a=n(1),s=r(a),u=function(t){var e=t.block,n=t.contentState,r=n.getEntity(e.getEntityAt(0)),o=r.getData(),a=o.src,s=o.height,u=o.width;return i.default.createElement("iframe",{height:s,width:u,src:a,frameBorder:"0",allowFullScreen:!0,title:"Wysiwyg Embedded Content"})};u.propTypes={block:s.default.object,contentState:s.default.object},e.default=u},function(t,e,n){"use strict";function r(t){return t&&t.__esModule?t:{default:t}}function o(t,e){if(!(t instanceof e))throw new TypeError("Cannot call a class as a function")}function i(t,e){if(!t)throw new ReferenceError("this hasn't been initialised - super() hasn't been called");return!e||"object"!=typeof e&&"function"!=typeof e?t:e}function a(t,e){if("function"!=typeof e&&null!==e)throw new TypeError("Super expression must either be null or a function, not "+typeof e);t.prototype=Object.create(e&&e.prototype,{constructor:{value:t,enumerable:!1,writable:!0,configurable:!0}}),e&&(Object.setPrototypeOf?Object.setPrototypeOf(t,e):t.__proto__=e)}Object.defineProperty(e,"__esModule",{value:!0});var s=function(){function t(t,e){for(var n=0;n<e.length;n++){var r=e[n];r.enumerable=r.enumerable||!1,r.configurable=!0,"value"in r&&(r.writable=!0),Object.defineProperty(t,r.key,r)}}return function(e,n,r){return n&&t(e.prototype,n),r&&t(e,r),e}}(),u=n(0),c=r(u),l=n(1),f=r(l),p=n(6),d=n(5),g=r(d),M=n(10),h=r(M);n(232);var y=function(t){var e,n;return n=e=function(e){function n(){var e,r,a,s;o(this,n);for(var u=arguments.length,c=Array(u),l=0;l<u;l++)c[l]=arguments[l];return r=a=i(this,(e=n.__proto__||Object.getPrototypeOf(n)).call.apply(e,[this].concat(c))),a.state={hovered:!1},a.setEntityAlignmentLeft=function(){a.setEntityAlignment("left")},a.setEntityAlignmentRight=function(){a.setEntityAlignment("right")},a.setEntityAlignmentCenter=function(){a.setEntityAlignment("none")},a.setEntityAlignment=function(e){var n=a.props,r=n.block,o=n.contentState,i=r.getEntityAt(0);o.mergeEntityData(i,{alignment:e}),t.onChange(p.EditorState.push(t.getEditorState(),o,"change-block-data")),a.setState({dummy:!0})},a.toggleHovered=function(){var t=!a.state.hovered;a.setState({hovered:t})},s=r,i(a,s)}return a(n,e),s(n,[{key:"renderAlignmentOptions",value:function(t){return c.default.createElement("div",{className:(0,g.default)("rdw-image-alignment-options-popup",{"rdw-image-alignment-options-popup-right":"right"===t})},c.default.createElement(h.default,{onClick:this.setEntityAlignmentLeft,className:"rdw-image-alignment-option"},"L"),c.default.createElement(h.default,{onClick:this.setEntityAlignmentCenter,className:"rdw-image-alignment-option"},"C"),c.default.createElement(h.default,{onClick:this.setEntityAlignmentRight,className:"rdw-image-alignment-option"},"R"))}},{key:"render",value:function(){var e=this.props,n=e.block,r=e.contentState,o=this.state.hovered,i=t.isReadOnly,a=t.isImageAlignmentEnabled,s=r.getEntity(n.getEntityAt(0)),u=s.getData(),l=u.src,f=u.alignment,p=u.height,d=u.width,M=u.alt;return c.default.createElement("span",{onMouseEnter:this.toggleHovered,onMouseLeave:this.toggleHovered,className:(0,g.default)("rdw-image-alignment",{"rdw-image-left":"left"===f,"rdw-image-right":"right"===f,"rdw-image-center":!f||"none"===f})},c.default.createElement("span",{className:"rdw-image-imagewrapper"},c.default.createElement("img",{src:l,alt:M,style:{height:p,width:d}}),!i()&&o&&a()?this.renderAlignmentOptions(f):void 0))}}]),n}(u.Component),e.propTypes={block:f.default.object,contentState:f.default.object},n};e.default=y},function(t,e){t.exports={"rdw-image-alignment-options-popup":"rdw-image-alignment-options-popup","rdw-alignment-option-left":"rdw-alignment-option-left","rdw-image-alignment-option":"rdw-image-alignment-option","rdw-image-alignment":"rdw-image-alignment","rdw-image-imagewrapper":"rdw-image-imagewrapper","rdw-image-center":"rdw-image-center","rdw-image-left":"rdw-image-left","rdw-image-right":"rdw-image-right","rdw-image-alignment-options-popup-right":"rdw-image-alignment-options-popup-right"}},function(t,e,n){"use strict";function r(t){return t&&t.__esModule?t:{default:t}}Object.defineProperty(e,"__esModule",{value:!0});var o=n(234),i=r(o),a=n(235),s=r(a),u=n(236),c=r(u),l=n(237),f=r(l),p=n(238),d=r(p),g=n(239),M=r(g),h=n(240),y=r(h),m=n(241),I=r(m),w=n(242),D=r(w),N=n(243),v=r(N),C=n(244),j=r(C),z=n(245),T=r(z),A=n(246),E=r(A),S=n(247),b=r(S),x=n(248),O=r(x),_=n(249),k=r(_),L=n(250),U=r(L),Q=n(251),Y=r(Q),B=n(252),P=r(B),R=n(253),Z=r(R),G=n(254),W=r(G),F=n(255),H=r(F),K=n(256),J=r(K),q=n(257),V=r(q),X=n(258),$=r(X);e.default={options:["inline","blockType","fontSize","fontFamily","list","textAlign","colorPicker","link","embedded","emoji","image","remove","history"],inline:{inDropdown:!1,className:void 0,component:void 0,dropdownClassName:void 0,options:["bold","italic","underline","strikethrough","monospace","superscript","subscript"],bold:{icon:i.default,className:void 0,title:void 0},italic:{icon:s.default,className:void 0,title:void 0},underline:{icon:c.default,className:void 0,title:void 0},strikethrough:{icon:f.default,className:void 0,title:void 0},monospace:{icon:d.default,className:void 0,title:void 0},superscript:{icon:$.default,className:void 0,title:void 0},subscript:{icon:V.default,className:void 0,title:void 0}},blockType:{inDropdown:!0,options:["Normal","H1","H2","H3","H4","H5","H6","Blockquote","Code"],className:void 0,component:void 0,dropdownClassName:void 0,title:void 0},fontSize:{icon:M.default,options:[8,9,10,11,12,14,16,18,24,30,36,48,60,72,96],className:void 0,component:void 0,dropdownClassName:void 0,title:void 0},fontFamily:{options:["Arial","Georgia","Impact","Tahoma","Times New Roman","Verdana"],className:void 0,component:void 0,dropdownClassName:void 0,title:void 0},list:{inDropdown:!1,className:void 0,component:void 0,dropdownClassName:void 0,options:["unordered","ordered","indent","outdent"],unordered:{icon:v.default,className:void 0,title:void 0},ordered:{icon:D.default,className:void 0,title:void 0},indent:{icon:y.default,className:void 0,title:void 0},outdent:{icon:I.default,className:void 0,title:void 0},title:void 0},textAlign:{inDropdown:!1,className:void 0,component:void 0,dropdownClassName:void 0,options:["left","center","right","justify"],left:{icon:j.default,className:void 0,title:void 0},center:{icon:T.default,className:void 0,title:void 0},right:{icon:E.default,className:void 0,title:void 0},justify:{icon:b.default,className:void 0,title:void 0},title:void 0},colorPicker:{icon:O.default,className:void 0,component:void 0,popupClassName:void 0,colors:["rgb(97,189,109)","rgb(26,188,156)","rgb(84,172,210)","rgb(44,130,201)","rgb(147,101,184)","rgb(71,85,119)","rgb(204,204,204)","rgb(65,168,95)","rgb(0,168,133)","rgb(61,142,185)","rgb(41,105,176)","rgb(85,57,130)","rgb(40,50,78)","rgb(0,0,0)","rgb(247,218,100)","rgb(251,160,38)","rgb(235,107,86)","rgb(226,80,65)","rgb(163,143,132)","rgb(239,239,239)","rgb(255,255,255)","rgb(250,197,28)","rgb(243,121,52)","rgb(209,72,65)","rgb(184,49,47)","rgb(124,112,107)","rgb(209,213,216)"],title:void 0},link:{inDropdown:!1,className:void 0,component:void 0,popupClassName:void 0,dropdownClassName:void 0,showOpenOptionOnHover:!0,defaultTargetOption:"_self",options:["link","unlink"],link:{icon:U.default,className:void 0,title:void 0},unlink:{icon:Y.default,className:void 0,title:void 0}},emoji:{icon:P.default,className:void 0,component:void 0,popupClassName:void 0,emojis:["😀","😁","😂","😃","😉","😋","😎","😍","😗","🤗","🤔","😣","😫","😴","😌","🤓","😛","😜","😠","😇","😷","😈","👻","😺","😸","😹","😻","😼","😽","🙀","🙈","🙉","🙊","👼","👮","🕵","💂","👳","🎅","👸","👰","👲","🙍","🙇","🚶","🏃","💃","⛷","🏂","🏌","🏄","🚣","🏊","⛹","🏋","🚴","👫","💪","👈","👉","👉","👆","🖕","👇","🖖","🤘","🖐","👌","👍","👎","✊","👊","👏","🙌","🙏","🐵","🐶","🐇","🐥","🐸","🐌","🐛","🐜","🐝","🍉","🍄","🍔","🍤","🍨","🍪","🎂","🍰","🍾","🍷","🍸","🍺","🌍","🚑","⏰","🌙","🌝","🌞","⭐","🌟","🌠","🌨","🌩","⛄","🔥","🎄","🎈","🎉","🎊","🎁","🎗","🏀","🏈","🎲","🔇","🔈","📣","🔔","🎵","🎷","💰","🖊","📅","✅","❎","💯"],title:void 0},embedded:{icon:Z.default,className:void 0,component:void 0,popupClassName:void 0,defaultSize:{height:"auto",width:"auto"},title:void 0},image:{icon:W.default,className:void 0,component:void 0,popupClassName:void 0,urlEnabled:!0,uploadEnabled:!0,alignmentEnabled:!0,uploadCallback:void 0,inputAccept:"image/gif,image/jpeg,image/jpg,image/png,image/svg",alt:{present:!1,mandatory:!1},defaultSize:{height:"auto",width:"auto"},title:void 0},remove:{icon:k.default,className:void 0,component:void 0,title:void 0},history:{inDropdown:!1,className:void 0,component:void 0,dropdownClassName:void 0,options:["undo","redo"],undo:{icon:H.default,className:void 0,title:void 0},redo:{icon:J.default,className:void 0,title:void 0},title:void 0}}},function(t,e){t.exports="data:image/svg+xml;base64,PD94bWwgdmVyc2lvbj0iMS4wIiBlbmNvZGluZz0iVVRGLTgiIHN0YW5kYWxvbmU9Im5vIj8+Cjxzdmcgd2lkdGg9IjEycHgiIGhlaWdodD0iMTNweCIgdmlld0JveD0iMCAwIDEyIDEzIiB2ZXJzaW9uPSIxLjEiIHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZyIgeG1sbnM6eGxpbms9Imh0dHA6Ly93d3cudzMub3JnLzE5OTkveGxpbmsiPgogICAgPCEtLSBHZW5lcmF0b3I6IFNrZXRjaCA0MC4zICgzMzgzOSkgLSBodHRwOi8vd3d3LmJvaGVtaWFuY29kaW5nLmNvbS9za2V0Y2ggLS0+CiAgICA8dGl0bGU+Ym9sZDwvdGl0bGU+CiAgICA8ZGVzYz5DcmVhdGVkIHdpdGggU2tldGNoLjwvZGVzYz4KICAgIDxkZWZzPjwvZGVmcz4KICAgIDxnIGlkPSJQYWdlLTEiIHN0cm9rZT0ibm9uZSIgc3Ryb2tlLXdpZHRoPSIxIiBmaWxsPSJub25lIiBmaWxsLXJ1bGU9ImV2ZW5vZGQiPgogICAgICAgIDxnIGlkPSJib2xkIiBmaWxsPSIjMDAwMDAwIj4KICAgICAgICAgICAgPGcgaWQ9IlBhZ2UtMSI+CiAgICAgICAgICAgICAgICA8Zz4KICAgICAgICAgICAgICAgICAgICA8ZyBpZD0iYm9sZCI+CiAgICAgICAgICAgICAgICAgICAgICAgIDxnIGlkPSJDYWxxdWVfMSI+CiAgICAgICAgICAgICAgICAgICAgICAgICAgICA8cGF0aCBkPSJNNi4yMzY0LDAgQzcuODg3NiwwIDkuMTc2NCwwLjI5NzkxNjY2NyAxMC4xMDE2LDAuODkyNjY2NjY3IEMxMS4wMjY4LDEuNDg4NSAxMS40OSwyLjM3NzkxNjY3IDExLjQ5LDMuNTYyIEMxMS40OSw0LjE2MzI1IDExLjMxNzIsNC43MDA1ODMzMyAxMC45NzQsNS4xNzI5MTY2NyBDMTAuNjMwOCw1LjY0NjMzMzMzIDEwLjEzMDQsNi4wMDI3NSA5LjQ3NTIsNi4yNCBDMTAuMzE3Niw2LjQwNjgzMzMzIDEwLjk0ODgsNi43NjMyNSAxMS4zNyw3LjMxMTQxNjY3IEMxMS43ODg4LDcuODYwNjY2NjcgMTIsOC40OTQ0MTY2NyAxMiw5LjIxMzc1IEMxMiwxMC40NTg1IDExLjU1NiwxMS40MDEgMTAuNjcwNCwxMi4wMzkwODMzIEM5Ljc4MzYsMTIuNjgwNDE2NyA4LjUyNiwxMyA2LjkwMTIsMTMgTDAsMTMgTDAsMTAuODMzMzMzMyBMMS40OTQsMTAuODMzMzMzMyBMMS40OTQsMi4xNjY2NjY2NyBMMCwyLjE2NjY2NjY3IEwwLDAgTDEuNDk0LDAgTDYuMjM2NCwwIEw2LjIzNjQsMCBMNi4yMzY0LDAgWiBNNC4zMDgsNS40NDU5MTY2NyBMNi4zMzI0LDUuNDQ1OTE2NjcgQzcuMDgzNiw1LjQ0NTkxNjY3IDcuNjYyLDUuMzAyOTE2NjcgOC4wNjY0LDUuMDE2OTE2NjcgQzguNDcwOCw0LjczMDkxNjY3IDguNjczNiw0LjMxNDkxNjY3IDguNjczNiwzLjc2Njc1IEM4LjY3MzYsMy4xNjU1IDguNDY5NiwyLjcyMjQxNjY3IDguMDYxNiwyLjQzNjQxNjY3IEM3LjY1MzYsMi4xNTA0MTY2NyA3LjA0NjQsMi4wMDg1IDYuMjM2NCwyLjAwODUgTDQuMzA4LDIuMDA4NSBMNC4zMDgsNS40NDU5MTY2NyBMNC4zMDgsNS40NDU5MTY2NyBMNC4zMDgsNS40NDU5MTY2NyBaIE00LjMwOCw3LjI0OTY2NjY3IEw0LjMwOCwxMC45OTkwODMzIEw2LjkwMTIsMTAuOTk5MDgzMyBDNy42NDc2LDEwLjk5OTA4MzMgOC4yMTUyLDEwLjg0ODUgOC42MDc2LDEwLjU0ODQxNjcgQzguOTk4OCwxMC4yNDgzMzMzIDkuMTk1Niw5LjgwMzA4MzMzIDkuMTk1Niw5LjIxMzc1IEM5LjE5NTYsOC41Nzc4MzMzMyA5LjAyNzYsOC4wOTAzMzMzMyA4LjY5NTIsNy43NTQ1IEM4LjM2MDQsNy40MTg2NjY2NyA3LjgzMjQsNy4yNDk2NjY2NyA3LjExMzYsNy4yNDk2NjY2NyBMNC4zMDgsNy4yNDk2NjY2NyBMNC4zMDgsNy4yNDk2NjY2NyBMNC4zMDgsNy4yNDk2NjY2NyBaIiBpZD0iU2hhcGUiPjwvcGF0aD4KICAgICAgICAgICAgICAgICAgICAgICAgPC9nPgogICAgICAgICAgICAgICAgICAgIDwvZz4KICAgICAgICAgICAgICAgIDwvZz4KICAgICAgICAgICAgPC9nPgogICAgICAgIDwvZz4KICAgIDwvZz4KPC9zdmc+"},function(t,e){t.exports="data:image/svg+xml;base64,PD94bWwgdmVyc2lvbj0iMS4wIiBlbmNvZGluZz0idXRmLTgiPz4KPCEtLSBHZW5lcmF0b3I6IEFkb2JlIElsbHVzdHJhdG9yIDE1LjAuMiwgU1ZHIEV4cG9ydCBQbHVnLUluIC4gU1ZHIFZlcnNpb246IDYuMDAgQnVpbGQgMCkgIC0tPgo8IURPQ1RZUEUgc3ZnIFBVQkxJQyAiLS8vVzNDLy9EVEQgU1ZHIDEuMS8vRU4iICJodHRwOi8vd3d3LnczLm9yZy9HcmFwaGljcy9TVkcvMS4xL0RURC9zdmcxMS5kdGQiPgo8c3ZnIHZlcnNpb249IjEuMSIgaWQ9IkNhbHF1ZV8xIiB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHhtbG5zOnhsaW5rPSJodHRwOi8vd3d3LnczLm9yZy8xOTk5L3hsaW5rIiB4PSIwcHgiIHk9IjBweCIKCSB3aWR0aD0iMTZweCIgaGVpZ2h0PSIxNnB4IiB2aWV3Qm94PSIwIDAgMTYgMTYiIGVuYWJsZS1iYWNrZ3JvdW5kPSJuZXcgMCAwIDE2IDE2IiB4bWw6c3BhY2U9InByZXNlcnZlIj4KPGc+Cgk8cGF0aCBkPSJNNywzVjJoNHYxSDkuNzUzbC0zLDEwSDh2MUg0di0xaDEuMjQ3bDMtMTBIN3oiLz4KPC9nPgo8L3N2Zz4K"},function(t,e){t.exports="data:image/svg+xml;base64,PD94bWwgdmVyc2lvbj0iMS4wIiBlbmNvZGluZz0idXRmLTgiPz4KPCEtLSBHZW5lcmF0b3I6IEFkb2JlIElsbHVzdHJhdG9yIDE1LjAuMiwgU1ZHIEV4cG9ydCBQbHVnLUluIC4gU1ZHIFZlcnNpb246IDYuMDAgQnVpbGQgMCkgIC0tPgo8IURPQ1RZUEUgc3ZnIFBVQkxJQyAiLS8vVzNDLy9EVEQgU1ZHIDEuMS8vRU4iICJodHRwOi8vd3d3LnczLm9yZy9HcmFwaGljcy9TVkcvMS4xL0RURC9zdmcxMS5kdGQiPgo8c3ZnIHZlcnNpb249IjEuMSIgaWQ9IkNhbHF1ZV8xIiB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHhtbG5zOnhsaW5rPSJodHRwOi8vd3d3LnczLm9yZy8xOTk5L3hsaW5rIiB4PSIwcHgiIHk9IjBweCIKCSB3aWR0aD0iMTZweCIgaGVpZ2h0PSIxNnB4IiB2aWV3Qm94PSIwIDAgMTYgMTYiIGVuYWJsZS1iYWNrZ3JvdW5kPSJuZXcgMCAwIDE2IDE2IiB4bWw6c3BhY2U9InByZXNlcnZlIj4KPGc+Cgk8cGF0aCBkPSJNNi4wNDUsMnYwLjk5Mkw0Ljc4NSwzdjUuMTcyYzAsMC44NTksMC4yNDMsMS41MTIsMC43MjcsMS45NTdzMS4xMjQsMC42NjgsMS45MTgsMC42NjhjMC44MzYsMCwxLjUwOS0wLjIyMSwyLjAxOS0wLjY2NAoJCWMwLjUxMS0wLjQ0MiwwLjc2Ni0xLjA5NiwwLjc2Ni0xLjk2MVYzbC0xLjI2LTAuMDA4VjJoMi43ODRIMTN2MC45OTJMMTEuNzM5LDN2NS4xNzJjMCwxLjIzNC0wLjM5OCwyLjE4MS0xLjE5NSwyLjg0CgkJQzkuNzQ3LDExLjY3MSw4LjcwOSwxMiw3LjQzLDEyYy0xLjI0MiwwLTIuMjQ4LTAuMzI5LTMuMDE3LTAuOTg4Yy0wLjc2OS0wLjY1OS0xLjE1Mi0xLjYwNS0xLjE1Mi0yLjg0VjNMMiwyLjk5MlYyaDEuMjYxSDYuMDQ1eiIKCQkvPgo8L2c+CjxyZWN0IHg9IjIiIHk9IjEzIiB3aWR0aD0iMTEiIGhlaWdodD0iMSIvPgo8L3N2Zz4K"},function(t,e){t.exports="data:image/svg+xml;base64,PD94bWwgdmVyc2lvbj0iMS4wIiBlbmNvZGluZz0iVVRGLTgiIHN0YW5kYWxvbmU9Im5vIj8+Cjxzdmcgd2lkdGg9IjE1cHgiIGhlaWdodD0iMTNweCIgdmlld0JveD0iMCAwIDE1IDEzIiB2ZXJzaW9uPSIxLjEiIHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZyIgeG1sbnM6eGxpbms9Imh0dHA6Ly93d3cudzMub3JnLzE5OTkveGxpbmsiPgogICAgPCEtLSBHZW5lcmF0b3I6IFNrZXRjaCA0MC4zICgzMzgzOSkgLSBodHRwOi8vd3d3LmJvaGVtaWFuY29kaW5nLmNvbS9za2V0Y2ggLS0+CiAgICA8dGl0bGU+c3RyaWtldGhyb3VnaDwvdGl0bGU+CiAgICA8ZGVzYz5DcmVhdGVkIHdpdGggU2tldGNoLjwvZGVzYz4KICAgIDxkZWZzPjwvZGVmcz4KICAgIDxnIGlkPSJQYWdlLTEiIHN0cm9rZT0ibm9uZSIgc3Ryb2tlLXdpZHRoPSIxIiBmaWxsPSJub25lIiBmaWxsLXJ1bGU9ImV2ZW5vZGQiPgogICAgICAgIDxnIGlkPSJzdHJpa2V0aHJvdWdoIiBmaWxsPSIjMDAwMDAwIj4KICAgICAgICAgICAgPGcgaWQ9IlBhZ2UtMSI+CiAgICAgICAgICAgICAgICA8Zz4KICAgICAgICAgICAgICAgICAgICA8ZyBpZD0ic3RyaWtldGhyb3VnaCI+CiAgICAgICAgICAgICAgICAgICAgICAgIDxnIGlkPSJDYXBhXzEiPgogICAgICAgICAgICAgICAgICAgICAgICAgICAgPGcgaWQ9Ikdyb3VwIj4KICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA8cGF0aCBkPSJNNC4wNDAwNjgzNiw1Ljk1NDM4NDA5IEwxMC4yNTQ2Mzg2LDUuOTU0Mzg0MDkgQzEwLjA0ODMzMDEsNS44MTk1NjgxOCA5Ljc4MzQyNzc2LDUuNjczMjU5MDkgOS40NTk5OTAyNiw1LjUxNTc4MTgyIEM4Ljg4MDMyMjI0LDUuMjU3MTQwOTEgOC4zOTc2NTYyNSw1LjA3MTUwNjgyIDguMDEyODQxNzksNC45NTkwODYzNyBDNi44MjUyMzQzNyw0LjYxMDUwOTA5IDYuMDQ3MzQzNzUsNC4yNDc2OTA5MSA1LjY3OTI4NzExLDMuODcwOTU2ODIgQzUuMzExMjMwNDcsMy40OTQxNjM2MyA1LjEyNzI0NjEsMy4xMDA1NTkwOSA1LjEyNzI0NjEsMi42ODk5OTU0NSBDNS4xMjcyNDYxLDIuMTk1MDIwNDUgNS4zMTQxMzA4NiwxLjc4NDQ1NjgyIDUuNjg3Njk1MzEsMS40NTgzMzQwOSBDNi4wNjY4ODQ3NiwxLjEyNjYyNzI3IDYuNTc0MzM1OTQsMC45NjA2MTEzNjggNy4yMTAwMTk1MywwLjk2MDYxMTM2OCBDNy44OTAzMjIyNiwwLjk2MDYxMTM2OCA4LjQ3NTgyMDMxLDEuMjE2NDc1IDguOTY2NjAxNTMsMS43MjgyMzE4MiBDOS4yNjIwNjA1OSwyLjA0MzA2ODE4IDkuNTQ5NDA0MjksMi42MTk1IDkuODI4MTA1NDQsMy40NTc0OTc3MyBMOS45NDU0MTAxMiwzLjQ3NDI3OTU1IEwxMC42NDgwMDc4LDMuNTI0ODYxMzcgTDEwLjc0ODQ5NjEsMy40OTk2Mjk1NSBDMTAuNzc2MzU3NCwzLjM0NzcwNjgyIDEwLjc5MDM5MDYsMy4yMjEzNDA5MSAxMC43OTAzOTA2LDMuMTE5OTcwNDUgQzEwLjc5MDM5MDYsMi43ODI1MzE4MiAxMC43NTEzMDg2LDIuMjY4MDg2MzcgMTAuNjczMDg2LDEuNTc2MzM4NjMgQzEwLjYxMTUzMzIsMS4xMjY1OTc3MyAxMC41NTMxNzM5LDAuNzk0NjU0NTQ1IDEwLjQ5NzQ1MTEsMC41ODA5MjI3MjcgQzkuODc4NjQyNTYsMC4zNzg1NjU5MDkgOS4zODQ5NjA5NywwLjI0MzU0MzE4MiA5LjAxNjkzMzU5LDAuMTc2MTIwNDU1IEM4LjM2NDU1MDc4LDAuMDY5MjU0NTQ1NSA3Ljg5ODc1OTc2LDAuMDE1ODA2ODE4MiA3LjYyMDIzNDM4LDAuMDE1ODA2ODE4MiBDNi4xNzAyNDQxNCwwLjAxNTgwNjgxODIgNS4wNzQ1OTk2MSwwLjM3MzA0MDkwOSA0LjMzMjg2MTMzLDEuMDg3MTI1IEMzLjU4NTY0NDUzLDEuODA2OTExMzcgMy4yMTIwODAwOCwyLjY3NTkwMjI3IDMuMjEyMDgwMDgsMy42OTM3NzI3MyBDMy4yMTIwODAwOCw0LjIwNTQ0MDkxIDMuMzQ1OTA4MjEsNC43MzQwMDkwOSAzLjYxMzYyMzA0LDUuMjc5NTM2MzcgQzMuNzQxNzA4OTksNS41MzI2ODE4MiAzLjg4MzkxNjAxLDUuNzU3NjQwOTEgNC4wNDAwNjgzNiw1Ljk1NDM4NDA5IEw0LjA0MDA2ODM2LDUuOTU0Mzg0MDkgTDQuMDQwMDY4MzYsNS45NTQzODQwOSBaIiBpZD0iU2hhcGUiPjwvcGF0aD4KICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA8cGF0aCBkPSJNOC4yODA3NjE3Miw4LjExMzg5MDkxIEM4Ljg1NTEyNjkxLDguMzUwMDc3MjcgOS4yMzcyMTY3OSw4LjU0OTg2MzYzIDkuNDI2NzA4OTcsOC43MTI3NzcyNyBDOS44Nzg0NjY3OSw5LjEyMzM3MDQ1IDEwLjEwNDI1NzgsOS41NjQ4MDkwNiAxMC4xMDQyNTc4LDEwLjAzNzA5MzIgQzEwLjEwNDI1NzgsMTAuNDE5NTg4NyA5Ljk3MzA5NTcxLDEwLjc4MjI4ODcgOS43MTEwMzUxMiwxMS4xMjUzNDA5IEM5LjQ2MDE5NTMyLDExLjQ2MjYzMTggOS4xMjAxMTcxOCwxMS43MDQ3ODYzIDguNjkwNjI1LDExLjg1MDcxMTMgQzguMjcyNjE3MTksMTIuMDAyODcwNSA3Ljg4NDkzMTY0LDEyLjA3ODU5NTUgNy41MjgyMTI4OSwxMi4wNzg1OTU1IEM3LjEyMTE5MTQsMTIuMDc4NTk1NSA2Ljc1MzE2NDA2LDEyLjAxNjYwOTEgNi40MjQxNjAxNSwxMS44OTI5NjEzIEM2LjA3ODQ1NzAzLDExLjc3NDc3OTUgNS43ODU2NjQwNiwxMS42MTQ3MDIzIDUuNTQ1ODM5ODUsMTEuNDEyMTA5MSBDNS4yOTQ5NDE0LDExLjIwNDAyMDUgNS4wNzE4MTY0LDEwLjkzOTczNjMgNC44NzY2Njk5MiwxMC42MTkxMDkxIEM0Ljg0ODc1LDEwLjU3NDI4ODcgNC44MTM4NTc0MiwxMC40OTgyNjgyIDQuNzcyMDUwNzgsMTAuMzkxNTIwNSBDNC43MzAzMDI3NCwxMC4yODQ1MzYzIDQuNjY3NDMxNjQsMTAuMTI3MjA2OCA0LjU4Mzg3Njk2LDkuOTE5MjM2MzIgQzQuNTAwMjA1MDgsOS43MTEwNTkwNiA0LjQxNjY1MDM5LDkuNTExNDUgNC4zMzI5Nzg1MSw5LjMyMDI5MDk0IEwzLjQ3OTgyNDIyLDkuMzM3MTYxMzIgTDMuNDc5ODI0MjIsOS43MDgzMTEzMiBMMy40NjMwOTU3MSwxMC4wMjA2MzYzIEMzLjQ1NzU4Nzg5LDEwLjIzNDE5MDkgMy40NTc1ODc4OSwxMC40MjUzNzk1IDMuNDYzMDk1NzEsMTAuNTk0MTEzNyBDMy40NzQxNjk5MiwxMC44NjM5ODE4IDMuNDc5ODI0MjIsMTEuMzAyNjcyNyAzLjQ3OTgyNDIyLDExLjkxMDE1NjggTDMuNDc5ODI0MjIsMTIuMDE5ODU5MSBDMy40Nzk4MjQyMiwxMi4wOTg2MjczIDMuNTAyMDg5ODUsMTIuMTYwMzE4MiAzLjU0NjY1MDM5LDEyLjIwNTQ5MzIgQzMuNjMwMjkyOTcsMTIuMjcyNzA5MSAzLjgzMTAzNTE1LDEyLjM1MTU5NTUgNC4xNDg5MDYyNSwxMi40NDE1OTA5IEw1LjMxOTg3MzA0LDEyLjc3ODk3MDUgQzUuNzcxNDg0MzcsMTIuOTA4NDA5MSA2LjMxNTIzNDM3LDEyLjk3MzExMzcgNi45NTA5MTc5NywxMi45NzMxMTM3IEM3LjYzNjg3NSwxMi45NzMxMTM3IDguMjAyNTY4MzYsMTIuOTE0MDUyMyA4LjY0ODkwNjI1LDEyLjc5NTg3MDUgQzkuMDU2MDQ0OTQsMTIuNjk0NDQwOSA5LjQ4MjIyNjUzLDEyLjUwODg5NTUgOS45Mjg3MTA5NywxMi4yMzkxNDU1IEMxMC4zMzAxMzY3LDExLjk4MDI5NzcgMTAuNjM0MTIxMSwxMS43NTI3MDkxIDEwLjg0MDQ1OSwxMS41NTU2NDA5IEMxMS4xMDc4NTE1LDExLjI4MDIxODIgMTEuMzA2MDc0MiwxMC45ODc4MDY4IDExLjQzNDMwNjcsMTAuNjc4MzE4MiBDMTEuNjYzMTE1MywxMC4xMTAzOTU1IDExLjc3NzI4NTEsOS41MTQyNTY3OSAxMS43NzcyODUxLDguODkwMTk3NzMgQzExLjc3NzI4NTEsOC41OTIwMjUgMTEuNzU3OTQ5Miw4LjMzMzQ3MjczIDExLjcxOTA0MjksOC4xMTQwNjgxOCBMOC4yODA3NjE3Miw4LjExNDA2ODE4IEw4LjI4MDc2MTcyLDguMTEzODkwOTEgTDguMjgwNzYxNzIsOC4xMTM4OTA5MSBMOC4yODA3NjE3Miw4LjExMzg5MDkxIFoiIGlkPSJTaGFwZSI+PC9wYXRoPgogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDxwYXRoIGQ9Ik0xNC45MTM4NjcyLDYuNTcwMTQwOTEgQzE0Ljg2MzUzNTEsNi41MTk1ODg2MyAxNC43OTk1ODAxLDYuNDk0MzI3MjcgMTQuNzIxMzg2Nyw2LjQ5NDMyNzI3IEwwLjI2NzYyNjk1Myw2LjQ5NDMyNzI3IEMwLjE4OTUyMTQ4NSw2LjQ5NDMyNzI3IDAuMTI1NDQ5MjE5LDYuNTE5NTg4NjMgMC4wNzUyMzQzNzUsNi41NzAxNDA5MSBDMC4wMjUxNjYwMTU2LDYuNjIwNjkzMTggMCw2LjY4NTM5NzczIDAsNi43NjQyODQwOSBMMCw3LjMwMzk5MDkxIEMwLDcuMzgyODc3MjcgMC4wMjUwNDg4MjgxLDcuNDQ3NDYzNjMgMC4wNzUyMzQzNzUsNy40OTgxMzQwOSBDMC4xMjU0NDkyMTksNy41NDg2ODYzNyAwLjE4OTYzODY3Miw3LjU3Mzc3MDQ1IDAuMjY3NjI2OTUzLDcuNTczNzcwNDUgTDE0LjcyMTM4NjcsNy41NzM3NzA0NSBDMTQuNzk5NTgwMSw3LjU3Mzc3MDQ1IDE0Ljg2MzU2NDQsNy41NDg2ODYzNyAxNC45MTM4NjcyLDcuNDk4MTM0MDkgQzE0Ljk2Mzk5NDIsNy40NDc0NjM2MyAxNC45ODkwNDI5LDcuMzgyODc3MjcgMTQuOTg5MDQyOSw3LjMwMzk5MDkxIEwxNC45ODkwNDI5LDYuNzY0Mjg0MDkgQzE0Ljk4OTA0MjksNi42ODUzOTc3MyAxNC45NjM5OTQyLDYuNjIwNjkzMTggMTQuOTEzODY3Miw2LjU3MDE0MDkxIEwxNC45MTM4NjcyLDYuNTcwMTQwOTEgTDE0LjkxMzg2NzIsNi41NzAxNDA5MSBaIiBpZD0iU2hhcGUiPjwvcGF0aD4KICAgICAgICAgICAgICAgICAgICAgICAgICAgIDwvZz4KICAgICAgICAgICAgICAgICAgICAgICAgPC9nPgogICAgICAgICAgICAgICAgICAgIDwvZz4KICAgICAgICAgICAgICAgIDwvZz4KICAgICAgICAgICAgPC9nPgogICAgICAgIDwvZz4KICAgIDwvZz4KPC9zdmc+"},function(t,e){t.exports="data:image/svg+xml;base64,PD94bWwgdmVyc2lvbj0iMS4wIiBlbmNvZGluZz0iVVRGLTgiIHN0YW5kYWxvbmU9Im5vIj8+Cjxzdmcgd2lkdGg9IjEzcHgiIGhlaWdodD0iMTVweCIgdmlld0JveD0iMCAwIDEzIDE1IiB2ZXJzaW9uPSIxLjEiIHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZyIgeG1sbnM6eGxpbms9Imh0dHA6Ly93d3cudzMub3JnLzE5OTkveGxpbmsiPgogICAgPCEtLSBHZW5lcmF0b3I6IFNrZXRjaCA0MC4zICgzMzgzOSkgLSBodHRwOi8vd3d3LmJvaGVtaWFuY29kaW5nLmNvbS9za2V0Y2ggLS0+CiAgICA8dGl0bGU+Y29kZTwvdGl0bGU+CiAgICA8ZGVzYz5DcmVhdGVkIHdpdGggU2tldGNoLjwvZGVzYz4KICAgIDxkZWZzPjwvZGVmcz4KICAgIDxnIGlkPSJQYWdlLTEiIHN0cm9rZT0ibm9uZSIgc3Ryb2tlLXdpZHRoPSIxIiBmaWxsPSJub25lIiBmaWxsLXJ1bGU9ImV2ZW5vZGQiPgogICAgICAgIDxnIGlkPSJjb2RlIiBmaWxsPSIjNDQ0NDQ0Ij4KICAgICAgICAgICAgPGcgaWQ9IlBhZ2UtMSI+CiAgICAgICAgICAgICAgICA8Zz4KICAgICAgICAgICAgICAgICAgICA8ZyBpZD0iY29kZSI+CiAgICAgICAgICAgICAgICAgICAgICAgIDxnIGlkPSJHcm91cCI+CiAgICAgICAgICAgICAgICAgICAgICAgICAgICA8cGF0aCBkPSJNMS4wMjE0Mjg1NywyLjkwNjI1IEMxLjIwNzE0Mjg2LDQuMTI1IDEuMzkyODU3MTQsNC40MDYyNSAxLjM5Mjg1NzE0LDUuNjI1IEMxLjM5Mjg1NzE0LDYuMzc1IDAsNy4wMzEyNSAwLDcuMDMxMjUgTDAsNy45Njg3NSBDMCw3Ljk2ODc1IDEuMzkyODU3MTQsOC42MjUgMS4zOTI4NTcxNCw5LjM3NSBDMS4zOTI4NTcxNCwxMC41OTM3NSAxLjIwNzE0Mjg2LDEwLjg3NSAxLjAyMTQyODU3LDEyLjA5Mzc1IEMwLjc0Mjg1NzE0MywxNC4wNjI1IDEuNzY0Mjg1NzEsMTUgMi42OTI4NTcxNCwxNSBMNC42NDI4NTcxNCwxNSBMNC42NDI4NTcxNCwxMy4xMjUgQzQuNjQyODU3MTQsMTMuMTI1IDIuOTcxNDI4NTcsMTMuMzEyNSAyLjk3MTQyODU3LDEyLjE4NzUgQzIuOTcxNDI4NTcsMTEuMzQzNzUgMy4xNTcxNDI4NiwxMS4zNDM3NSAzLjM0Mjg1NzE0LDkuNDY4NzUgQzMuNDM1NzE0MjksOC42MjUgMi44Nzg1NzE0Myw3Ljk2ODc1IDIuMzIxNDI4NTcsNy41IEMyLjg3ODU3MTQzLDcuMDMxMjUgMy40MzU3MTQyOSw2LjQ2ODc1IDMuMzQyODU3MTQsNS42MjUgQzMuMDY0Mjg1NzEsMy43NSAyLjk3MTQyODU3LDMuNzUgMi45NzE0Mjg1NywyLjkwNjI1IEMyLjk3MTQyODU3LDEuNzgxMjUgNC42NDI4NTcxNCwxLjg3NSA0LjY0Mjg1NzE0LDEuODc1IEw0LjY0Mjg1NzE0LDAgTDIuNjkyODU3MTQsMCBDMS42NzE0Mjg1NywwIDAuNzQyODU3MTQzLDAuOTM3NSAxLjAyMTQyODU3LDIuOTA2MjUgTDEuMDIxNDI4NTcsMi45MDYyNSBMMS4wMjE0Mjg1NywyLjkwNjI1IFoiIGlkPSJTaGFwZSI+PC9wYXRoPgogICAgICAgICAgICAgICAgICAgICAgICAgICAgPHBhdGggZD0iTTExLjk3ODU3MTQsMi45MDYyNSBDMTEuNzkyODU3MSw0LjEyNSAxMS42MDcxNDI5LDQuNDA2MjUgMTEuNjA3MTQyOSw1LjYyNSBDMTEuNjA3MTQyOSw2LjM3NSAxMyw3LjAzMTI1IDEzLDcuMDMxMjUgTDEzLDcuOTY4NzUgQzEzLDcuOTY4NzUgMTEuNjA3MTQyOSw4LjYyNSAxMS42MDcxNDI5LDkuMzc1IEMxMS42MDcxNDI5LDEwLjU5Mzc1IDExLjc5Mjg1NzEsMTAuODc1IDExLjk3ODU3MTQsMTIuMDkzNzUgQzEyLjI1NzE0MjksMTQuMDYyNSAxMS4yMzU3MTQzLDE1IDEwLjMwNzE0MjksMTUgTDguMzU3MTQyODYsMTUgTDguMzU3MTQyODYsMTMuMTI1IEM4LjM1NzE0Mjg2LDEzLjEyNSAxMC4wMjg1NzE0LDEzLjMxMjUgMTAuMDI4NTcxNCwxMi4xODc1IEMxMC4wMjg1NzE0LDExLjM0Mzc1IDkuODQyODU3MTQsMTEuMzQzNzUgOS42NTcxNDI4Niw5LjQ2ODc1IEM5LjU2NDI4NTcxLDguNjI1IDEwLjEyMTQyODYsNy45Njg3NSAxMC42Nzg1NzE0LDcuNSBDMTAuMTIxNDI4Niw3LjAzMTI1IDkuNTY0Mjg1NzEsNi40Njg3NSA5LjY1NzE0Mjg2LDUuNjI1IEM5Ljg0Mjg1NzE0LDMuNzUgMTAuMDI4NTcxNCwzLjc1IDEwLjAyODU3MTQsMi45MDYyNSBDMTAuMDI4NTcxNCwxLjc4MTI1IDguMzU3MTQyODYsMS44NzUgOC4zNTcxNDI4NiwxLjg3NSBMOC4zNTcxNDI4NiwwIEwxMC4zMDcxNDI5LDAgQzExLjMyODU3MTQsMCAxMi4yNTcxNDI5LDAuOTM3NSAxMS45Nzg1NzE0LDIuOTA2MjUgTDExLjk3ODU3MTQsMi45MDYyNSBMMTEuOTc4NTcxNCwyLjkwNjI1IFoiIGlkPSJTaGFwZSI+PC9wYXRoPgogICAgICAgICAgICAgICAgICAgICAgICA8L2c+CiAgICAgICAgICAgICAgICAgICAgPC9nPgogICAgICAgICAgICAgICAgPC9nPgogICAgICAgICAgICA8L2c+CiAgICAgICAgPC9nPgogICAgPC9nPgo8L3N2Zz4="},function(t,e){t.exports="data:image/svg+xml;base64,PD94bWwgdmVyc2lvbj0iMS4wIiBlbmNvZGluZz0iVVRGLTgiIHN0YW5kYWxvbmU9Im5vIj8+Cjxzdmcgd2lkdGg9IjE0cHgiIGhlaWdodD0iMTRweCIgdmlld0JveD0iMCAwIDE0IDE0IiB2ZXJzaW9uPSIxLjEiIHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZyIgeG1sbnM6eGxpbms9Imh0dHA6Ly93d3cudzMub3JnLzE5OTkveGxpbmsiPgogICAgPCEtLSBHZW5lcmF0b3I6IFNrZXRjaCA0MC4zICgzMzgzOSkgLSBodHRwOi8vd3d3LmJvaGVtaWFuY29kaW5nLmNvbS9za2V0Y2ggLS0+CiAgICA8dGl0bGU+Zm9udC1zaXplPC90aXRsZT4KICAgIDxkZXNjPkNyZWF0ZWQgd2l0aCBTa2V0Y2guPC9kZXNjPgogICAgPGRlZnM+PC9kZWZzPgogICAgPGcgaWQ9IlBhZ2UtMSIgc3Ryb2tlPSJub25lIiBzdHJva2Utd2lkdGg9IjEiIGZpbGw9Im5vbmUiIGZpbGwtcnVsZT0iZXZlbm9kZCI+CiAgICAgICAgPGcgaWQ9ImZvbnQtc2l6ZSIgZmlsbD0iIzAwMDAwMCI+CiAgICAgICAgICAgIDxnIGlkPSJQYWdlLTEiPgogICAgICAgICAgICAgICAgPGc+CiAgICAgICAgICAgICAgICAgICAgPGcgaWQ9ImZvbnQtc2l6ZSI+CiAgICAgICAgICAgICAgICAgICAgICAgIDxnIGlkPSJDYXBhXzEiPgogICAgICAgICAgICAgICAgICAgICAgICAgICAgPGcgaWQ9Ikdyb3VwIj4KICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA8cGF0aCBkPSJNMTEuOTIwOTU3MSwzLjExOTAyNSBDMTIuMDAyNDY2MywzLjIyMjQwNjI1IDEyLjEyNTYzMTksMy4yODI1MTg3NSAxMi4yNTU3OTc2LDMuMjgyNTE4NzUgTDEzLjIyNTgzNDMsMy4yODI1MTg3NSBDMTMuMzQwMDY3NCwzLjI4MjUxODc1IDEzLjQ0OTYxOTYsMy4yMzYxIDEzLjUzMDIyNywzLjE1MzYzMTI1IEMxMy42MTA4MzQzLDMuMDcxMTYyNSAxMy42NTU4ODM1LDIuOTU5MzM3NSAxMy42NTUyODIyLDIuODQyOTE4NzUgTDEzLjY1Njc4NTIsMC40MzM4Njg3NSBDMTMuNjU0MDM2OSwwLjE5NDE2MjUgMTMuNDYyNTQ2LDAuMDAxMjY4NzUgMTMuMjI3MzM3NCwwLjAwMTI2ODc1IEwwLjQyOTQ0Nzg1MiwwLjAwMTI2ODc1IEMwLjE5MjI2MzgwNCwwLjAwMTI2ODc1IDAsMC4xOTcxODEyNSAwLDAuNDM4NzY4NzUgTDAsMi44NDUwMTg3NSBDMCwzLjA4NjYwNjI1IDAuMTkyMjYzODA0LDMuMjgyNTE4NzUgMC40Mjk0NDc4NTIsMy4yODI1MTg3NSBMMS4zOTk4MjgyMiwzLjI4MjUxODc1IEMxLjUzMDMzNzQyLDMuMjgyNTE4NzUgMS42NTM3MTc3OSwzLjIyMjEgMS43MzUxODQwNSwzLjExODMyNSBMMi40NjUxNTk1MSwyLjE4ODgxMjUgTDUuNTM5NjYyNTgsMi4xODg4MTI1IEw1LjUzOTY2MjU4LDEzLjU0Nzg0MzggQzUuNTM5NjYyNTgsMTMuNzg5Mzg3NSA1LjczMTkyNjM4LDEzLjk4NTM0MzggNS45NjkxMTA0MywxMy45ODUzNDM4IEw3LjY4NjkwMTg0LDEzLjk4NTM0MzggQzcuOTI0LDEzLjk4NTM0MzggOC4xMTYzNDk3LDEzLjc4OTM4NzUgOC4xMTYzNDk3LDEzLjU0Nzg0MzggTDguMTE2MzQ5NywyLjE4ODg1NjI1IEwxMS4xODc0NjAxLDIuMTg4ODU2MjUgTDExLjkyMDk1NzEsMy4xMTkwMjUgTDExLjkyMDk1NzEsMy4xMTkwMjUgTDExLjkyMDk1NzEsMy4xMTkwMjUgWiIgaWQ9IlNoYXBlIj48L3BhdGg+CiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPHBhdGggZD0iTTEzLjg5NzY2MjYsMTEuMjYzMzUgQzEzLjc4NDg0NjYsMTEuMTE0MjA2MiAxMy41OTA5MDgsMTEuMDU1MzYyNSAxMy40MTYzODA0LDExLjExNzEzNzUgTDEyLjg2ODU3NjcsMTEuMzExMjU2MiBMMTIuODY4NjYyNiw5LjYxNzEyNSBDMTIuODY4NjYyNiw5LjUwMTEgMTIuODIzNDQxNyw5LjM4OTggMTIuNzQyOTIwMiw5LjMwNzcyNSBDMTIuNjYyMzk4Nyw5LjIyNTY5Mzc1IDEyLjU1MzEwNDMsOS4xNzk1ODEyNSAxMi40MzkyMTQ4LDkuMTc5NTgxMjUgTDEyLjAxMDE5NjMsOS4xNzk1ODEyNSBDMTEuNzczMDk4MSw5LjE3OTU4MTI1IDExLjU4MDc0ODUsOS4zNzU1Mzc1NSAxMS41ODA3NDg1LDkuNjE3MDgxMjMgTDExLjU4MDc0ODUsMTEuMzExMjU2MiBMMTEuMDMyODU4OSwxMS4xMTcxMzc1IEMxMC44NTg0MTcyLDExLjA1NTE4NzUgMTAuNjY0NTY0NCwxMS4xMTQyMDYyIDEwLjU1MTc0ODUsMTEuMjYzMzUgQzEwLjQzODg0NjYsMTEuNDEyNDUgMTAuNDMyNDA0OSwxMS42MTgzODEyIDEwLjUzNTY0NDIsMTEuNzc0NyBMMTEuODY4MzQ5NywxMy43OTIxNDM4IEMxMS45NDgxODQxLDEzLjkxMjk4MTIgMTIuMDgxODI4MywxMy45ODU0MzEyIDEyLjIyNDY2MjYsMTMuOTg1NDMxMiBDMTIuMzY3NTgyOCwxMy45ODU0MzEyIDEyLjUwMTE4NDEsMTMuOTEyOTgxMiAxMi41ODA5NzU1LDEzLjc5MjE0MzggTDEzLjkxMzc2NjksMTEuNzc0NyBDMTQuMDE2OTYzMSwxMS42MTgzODEyIDE0LjAxMDQ3ODUsMTEuNDEyNDUgMTMuODk3NjYyNiwxMS4yNjMzNSBMMTMuODk3NjYyNiwxMS4yNjMzNSBMMTMuODk3NjYyNiwxMS4yNjMzNSBaIiBpZD0iU2hhcGUiPjwvcGF0aD4KICAgICAgICAgICAgICAgICAgICAgICAgICAgIDwvZz4KICAgICAgICAgICAgICAgICAgICAgICAgPC9nPgogICAgICAgICAgICAgICAgICAgIDwvZz4KICAgICAgICAgICAgICAgIDwvZz4KICAgICAgICAgICAgPC9nPgogICAgICAgIDwvZz4KICAgIDwvZz4KPC9zdmc+"},function(t,e){t.exports="data:image/svg+xml;base64,PD94bWwgdmVyc2lvbj0iMS4wIiBlbmNvZGluZz0iVVRGLTgiIHN0YW5kYWxvbmU9Im5vIj8+Cjxzdmcgd2lkdGg9IjE3cHgiIGhlaWdodD0iMTRweCIgdmlld0JveD0iMCAwIDE3IDE0IiB2ZXJzaW9uPSIxLjEiIHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZyIgeG1sbnM6eGxpbms9Imh0dHA6Ly93d3cudzMub3JnLzE5OTkveGxpbmsiPgogICAgPCEtLSBHZW5lcmF0b3I6IFNrZXRjaCA0MC4zICgzMzgzOSkgLSBodHRwOi8vd3d3LmJvaGVtaWFuY29kaW5nLmNvbS9za2V0Y2ggLS0+CiAgICA8dGl0bGU+aW5kZW50PC90aXRsZT4KICAgIDxkZXNjPkNyZWF0ZWQgd2l0aCBTa2V0Y2guPC9kZXNjPgogICAgPGRlZnM+PC9kZWZzPgogICAgPGcgaWQ9IlBhZ2UtMSIgc3Ryb2tlPSJub25lIiBzdHJva2Utd2lkdGg9IjEiIGZpbGw9Im5vbmUiIGZpbGwtcnVsZT0iZXZlbm9kZCI+CiAgICAgICAgPGcgaWQ9ImluZGVudCIgZmlsbD0iIzAwMDAwMCI+CiAgICAgICAgICAgIDxnIGlkPSJMYXllcl8xIj4KICAgICAgICAgICAgICAgIDxnIGlkPSJHcm91cCI+CiAgICAgICAgICAgICAgICAgICAgPHJlY3QgaWQ9IlJlY3RhbmdsZS1wYXRoIiB4PSI1LjcxNjQ4MzUyIiB5PSIzLjIxMDgyNjIxIiB3aWR0aD0iMTEuMjgzNTE2NSIgaGVpZ2h0PSIxLjE5NjU4MTIiPjwvcmVjdD4KICAgICAgICAgICAgICAgICAgICA8cmVjdCBpZD0iUmVjdGFuZ2xlLXBhdGgiIHg9IjAiIHk9IjAuMDE5OTQzMDE5OSIgd2lkdGg9IjE3IiBoZWlnaHQ9IjEuMTk2NTgxMiI+PC9yZWN0PgogICAgICAgICAgICAgICAgICAgIDxyZWN0IGlkPSJSZWN0YW5nbGUtcGF0aCIgeD0iMCIgeT0iMTIuNzgzNDc1OCIgd2lkdGg9IjE3IiBoZWlnaHQ9IjEuMTk2NTgxMiI+PC9yZWN0PgogICAgICAgICAgICAgICAgICAgIDxyZWN0IGlkPSJSZWN0YW5nbGUtcGF0aCIgeD0iNS43MTY0ODM1MiIgeT0iOS41OTI1OTI1OSIgd2lkdGg9IjExLjI4MzUxNjUiIGhlaWdodD0iMS4xOTY1ODEyIj48L3JlY3Q+CiAgICAgICAgICAgICAgICAgICAgPHJlY3QgaWQ9IlJlY3RhbmdsZS1wYXRoIiB4PSI1LjcxNjQ4MzUyIiB5PSI2LjQwMTcwOTQiIHdpZHRoPSIxMS4yODM1MTY1IiBoZWlnaHQ9IjEuMTk2NTgxMiI+PC9yZWN0PgogICAgICAgICAgICAgICAgICAgIDxwb2x5Z29uIGlkPSJTaGFwZSIgcG9pbnRzPSIwLjE4NjgxMzE4NyA5LjQ5MTQwMTcxIDIuNTIwNTk1NiA3IDAuMTg2ODEzMTg3IDQuNTA4NTk4MjkiPjwvcG9seWdvbj4KICAgICAgICAgICAgICAgIDwvZz4KICAgICAgICAgICAgPC9nPgogICAgICAgIDwvZz4KICAgIDwvZz4KPC9zdmc+"},function(t,e){t.exports="data:image/svg+xml;base64,PD94bWwgdmVyc2lvbj0iMS4wIiBlbmNvZGluZz0iVVRGLTgiIHN0YW5kYWxvbmU9Im5vIj8+Cjxzdmcgd2lkdGg9IjE2cHgiIGhlaWdodD0iMTRweCIgdmlld0JveD0iMCAwIDE2IDE0IiB2ZXJzaW9uPSIxLjEiIHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZyIgeG1sbnM6eGxpbms9Imh0dHA6Ly93d3cudzMub3JnLzE5OTkveGxpbmsiPgogICAgPCEtLSBHZW5lcmF0b3I6IFNrZXRjaCA0MC4zICgzMzgzOSkgLSBodHRwOi8vd3d3LmJvaGVtaWFuY29kaW5nLmNvbS9za2V0Y2ggLS0+CiAgICA8dGl0bGU+b3V0ZGVudDwvdGl0bGU+CiAgICA8ZGVzYz5DcmVhdGVkIHdpdGggU2tldGNoLjwvZGVzYz4KICAgIDxkZWZzPjwvZGVmcz4KICAgIDxnIGlkPSJQYWdlLTEiIHN0cm9rZT0ibm9uZSIgc3Ryb2tlLXdpZHRoPSIxIiBmaWxsPSJub25lIiBmaWxsLXJ1bGU9ImV2ZW5vZGQiPgogICAgICAgIDxnIGlkPSJvdXRkZW50IiBmaWxsPSIjMDAwMDAwIj4KICAgICAgICAgICAgPGcgaWQ9IkxheWVyXzEiPgogICAgICAgICAgICAgICAgPGcgaWQ9Ikdyb3VwIj4KICAgICAgICAgICAgICAgICAgICA8cmVjdCBpZD0iUmVjdGFuZ2xlLXBhdGgiIHg9IjUuMzk2MTY2MyIgeT0iMy4xOTM0MzU5IiB3aWR0aD0iMTAuNTczMzA0MiIgaGVpZ2h0PSIxLjE5NjU4MTIiPjwvcmVjdD4KICAgICAgICAgICAgICAgICAgICA8cmVjdCBpZD0iUmVjdGFuZ2xlLXBhdGgiIHg9IjAuMDM5NDkyMzQxNCIgeT0iMC4wMDI1NTI3MDY1NSIgd2lkdGg9IjE1LjkyOTk3ODEiIGhlaWdodD0iMS4xOTY1ODEyIj48L3JlY3Q+CiAgICAgICAgICAgICAgICAgICAgPHJlY3QgaWQ9IlJlY3RhbmdsZS1wYXRoIiB4PSIwLjAzOTQ5MjM0MTQiIHk9IjEyLjc2NjA4NTUiIHdpZHRoPSIxNS45Mjk5NzgxIiBoZWlnaHQ9IjEuMTk2NTgxMiI+PC9yZWN0PgogICAgICAgICAgICAgICAgICAgIDxyZWN0IGlkPSJSZWN0YW5nbGUtcGF0aCIgeD0iNS4zOTYxNjYzIiB5PSI5LjU3NTIwMjI4IiB3aWR0aD0iMTAuNTczMzA0MiIgaGVpZ2h0PSIxLjE5NjU4MTIiPjwvcmVjdD4KICAgICAgICAgICAgICAgICAgICA8cmVjdCBpZD0iUmVjdGFuZ2xlLXBhdGgiIHg9IjUuMzk2MTY2MyIgeT0iNi4zODQzMTkwOSIgd2lkdGg9IjEwLjU3MzMwNDIiIGhlaWdodD0iMS4xOTY1ODEyIj48L3JlY3Q+CiAgICAgICAgICAgICAgICAgICAgPHBvbHlnb24gaWQ9IlNoYXBlIiBwb2ludHM9IjIuMTg2ODg4NCA0LjQ5MTIwNzk4IDAgNi45ODI2MDk2OSAyLjE4Njg4ODQgOS40NzQwMTE0Ij48L3BvbHlnb24+CiAgICAgICAgICAgICAgICA8L2c+CiAgICAgICAgICAgIDwvZz4KICAgICAgICA8L2c+CiAgICA8L2c+Cjwvc3ZnPg=="},function(t,e){t.exports="data:image/svg+xml;base64,PD94bWwgdmVyc2lvbj0iMS4wIiBlbmNvZGluZz0iVVRGLTgiIHN0YW5kYWxvbmU9Im5vIj8+Cjxzdmcgd2lkdGg9IjEzcHgiIGhlaWdodD0iMTNweCIgdmlld0JveD0iMCAwIDEzIDEzIiB2ZXJzaW9uPSIxLjEiIHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZyIgeG1sbnM6eGxpbms9Imh0dHA6Ly93d3cudzMub3JnLzE5OTkveGxpbmsiPgogICAgPCEtLSBHZW5lcmF0b3I6IFNrZXRjaCA0MC4zICgzMzgzOSkgLSBodHRwOi8vd3d3LmJvaGVtaWFuY29kaW5nLmNvbS9za2V0Y2ggLS0+CiAgICA8dGl0bGU+bGlzdC1vcmRlcmVkPC90aXRsZT4KICAgIDxkZXNjPkNyZWF0ZWQgd2l0aCBTa2V0Y2guPC9kZXNjPgogICAgPGRlZnM+PC9kZWZzPgogICAgPGcgaWQ9IlBhZ2UtMSIgc3Ryb2tlPSJub25lIiBzdHJva2Utd2lkdGg9IjEiIGZpbGw9Im5vbmUiIGZpbGwtcnVsZT0iZXZlbm9kZCI+CiAgICAgICAgPGcgaWQ9Imxpc3Qtb3JkZXJlZCIgZmlsbD0iIzAwMDAwMCI+CiAgICAgICAgICAgIDxnIGlkPSJQYWdlLTEiPgogICAgICAgICAgICAgICAgPGc+CiAgICAgICAgICAgICAgICAgICAgPGcgaWQ9Imxpc3Qtb3JkZXJlZCI+CiAgICAgICAgICAgICAgICAgICAgICAgIDxnIGlkPSJDYXBhXzEiPgogICAgICAgICAgICAgICAgICAgICAgICAgICAgPGcgaWQ9Ikdyb3VwIj4KICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA8cGF0aCBkPSJNNC4yMDE5MzQxNiwxLjQ2NTczODAxIEwxMi4zNTI0MDQzLDEuNDY1NzM4MDEgQzEyLjY4OTk5NjksMS40NjU3MzgwMSAxMi45NjM2ODk3LDEuMTQzNTY4MjYgMTIuOTYzNjg5NywwLjc0NjE4MDgxMiBDMTIuOTYzNjg5NywwLjM0ODc5MzM1OCAxMi42ODk5OTY5LDAuMDI2NjIzNjE2MyAxMi4zNTI0MDQzLDAuMDI2NjIzNjE2MyBMNC4yMDE5MzQxNiwwLjAyNjYyMzYxNjMgQzMuODY0MzQxNywwLjAyNjYyMzYxNjMgMy41OTA2NDg5LDAuMzQ4NzkzMzU4IDMuNTkwNjQ4OSwwLjc0NjE4MDgxMiBDMy41OTA2NDg5LDEuMTQzNTY4MjYgMy44NjQzNDE3LDEuNDY1NzM4MDEgNC4yMDE5MzQxNiwxLjQ2NTczODAxIEw0LjIwMTkzNDE2LDEuNDY1NzM4MDEgTDQuMjAxOTM0MTYsMS40NjU3MzgwMSBaIiBpZD0iU2hhcGUiPjwvcGF0aD4KICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA8cGF0aCBkPSJNMTIuMzUyNDA0Myw1Ljc4MzA4MTE4IEw0LjIwMTkzNDE2LDUuNzgzMDgxMTggQzMuODY0MzQxNyw1Ljc4MzA4MTE4IDMuNTkwNjQ4OSw2LjEwNTI1MDkyIDMuNTkwNjQ4OSw2LjUwMjYzODM3IEMzLjU5MDY0ODksNi45MDAwMjU4MyAzLjg2NDM0MTcsNy4yMjIxOTU1NyA0LjIwMTkzNDE2LDcuMjIyMTk1NTcgTDEyLjM1MjQwNDMsNy4yMjIxOTU1NyBDMTIuNjg5OTk2OSw3LjIyMjE5NTU3IDEyLjk2MzY4OTcsNi45MDAwMjU4MyAxMi45NjM2ODk3LDYuNTAyNjM4MzcgQzEyLjk2MzY4OTcsNi4xMDUyMDI5NSAxMi42OTAwMzc3LDUuNzgzMDgxMTggMTIuMzUyNDA0Myw1Ljc4MzA4MTE4IEwxMi4zNTI0MDQzLDUuNzgzMDgxMTggTDEyLjM1MjQwNDMsNS43ODMwODExOCBaIiBpZD0iU2hhcGUiPjwvcGF0aD4KICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA8cGF0aCBkPSJNMTIuMzUyNDA0MywxMS41Mzk1Mzg3IEw0LjIwMTkzNDE2LDExLjUzOTUzODcgQzMuODY0MzQxNywxMS41Mzk1Mzg3IDMuNTkwNjQ4OSwxMS44NjE3MDg1IDMuNTkwNjQ4OSwxMi4yNTkwOTYgQzMuNTkwNjQ4OSwxMi42NTY0ODM0IDMuODY0MzQxNywxMi45Nzg2NTMxIDQuMjAxOTM0MTYsMTIuOTc4NjUzMSBMMTIuMzUyNDA0MywxMi45Nzg2NTMxIEMxMi42ODk5OTY5LDEyLjk3ODY1MzEgMTIuOTYzNjg5NywxMi42NTY0ODM0IDEyLjk2MzY4OTcsMTIuMjU5MDk2IEMxMi45NjM2ODk3LDExLjg2MTcwODUgMTIuNjkwMDM3NywxMS41Mzk1Mzg3IDEyLjM1MjQwNDMsMTEuNTM5NTM4NyBMMTIuMzUyNDA0MywxMS41Mzk1Mzg3IEwxMi4zNTI0MDQzLDExLjUzOTUzODcgWiIgaWQ9IlNoYXBlIj48L3BhdGg+CiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPHBhdGggZD0iTTAuNzY3MjAzNzYyLDEuMjQ4OTU5NDEgTDAuNzY3MjAzNzYyLDMuMDUwOTIyNTEgQzAuNzY3MjAzNzYyLDMuMjQ2MzU0MjUgMC45MDI1MDE1NjgsMy4zOTM3MTk1NiAxLjA4MTk3NDkyLDMuMzkzNzE5NTYgQzEuMjU4NDMyNiwzLjM5MzcxOTU2IDEuMzk2NjIzODMsMy4yNDMxNDAyMyAxLjM5NjYyMzgzLDMuMDUwOTIyNTEgTDEuMzk2NjIzODMsMC4zNTYyMjg3ODIgQzEuMzk2NjIzODMsMC4xNjYyNjU2ODIgMS4yNjQzMDA5NCwwLjAxNzQxMzI4NDEgMS4wOTUzODI0NCwwLjAxNzQxMzI4NDEgQzAuOTQ2Nzk5MzY5LDAuMDE3NDEzMjg0MSAwLjg3MjQ2NzA4NCwwLjEzNDc0OTA3NyAwLjg0ODA1NjQyNiwwLjE3MzMxNzM0MyBDMC44NDcwMzc2MTcsMC4xNzQ5NDgzMzkgMC44NDYwMTg4MDksMC4xNzY1NzkzMzYgMC44NDUsMC4xNzgzMDYyNzMgTDAuNTc5MDUwMTU2LDAuNjIxMTY5NzQyIEMwLjUyNzQxNjkyOCwwLjY4NzI3MzA2MyAwLjQ4MTQ4OTAyOCwwLjc5MyAwLjQ4MTQ4OTAyOCwwLjg5NDQwOTU5NiBDMC40ODE0NDgyNzYsMS4wODc3MzA2MyAwLjYwOTE2NjE0NCwxLjI0NTQwOTYgMC43NjcyMDM3NjIsMS4yNDg5NTk0MSBMMC43NjcyMDM3NjIsMS4yNDg5NTk0MSBMMC43NjcyMDM3NjIsMS4yNDg5NTk0MSBaIiBpZD0iU2hhcGUiPjwvcGF0aD4KICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA8cGF0aCBkPSJNMC4zNTE2OTI3OSw4LjE5MDc2NzQ5IEwxLjU1MDA1NjQzLDguMTkwNzY3NDkgQzEuNzA2OTEyMjMsOC4xOTA3Njc0OSAxLjgzNDU0ODU5LDguMDI4MDk5NjMgMS44MzQ1NDg1OSw3LjgyODE1ODY3IEMxLjgzNDU0ODU5LDcuNjMwMzI4NDEgMS43MDY5NTI5Nyw3LjQ2OTM4NzQ1IDEuNTUwMDU2NDMsNy40NjkzODc0NSBMMC42Nzk5MTIyMjYsNy40NjkzODc0NSBMMC42Nzk5MTIyMjYsNy40NjM0ODcwOSBDMC42Nzk5MTIyMjYsNy4zNTU3OTMzNiAwLjg4OTcwNTMyOSw3LjE4MTUxNjYxIDEuMDU4Mjk3ODEsNy4wNDE0OTA3NyBDMS4zOTM2NDg5LDYuNzYyOTI2MiAxLjgxMDk5MzczLDYuNDE2MjkxNTEgMS44MTA5OTM3Myw1LjgxNTEyNTQ2IEMxLjgxMDk5MzczLDUuMjQ0NjEyNTUgMS40MzU0MjAwNiw0LjgxNDQ2MTI1IDAuOTM3MzQ0ODMxLDQuODE0NDYxMjUgQzAuNDYwNDIwMDYzLDQuODE0NDYxMjUgMC4xMDA4MjEzMTcsNS4yMDAzMzU3OSAwLjEwMDgyMTMxNyw1LjcxMjAzNjkgQzAuMTAwODIxMzE3LDYuMDA4OTc0MTcgMC4yNjUwMTI1MzksNi4xMTQzNjUzMSAwLjQwNTYwODE1LDYuMTE0MzY1MzEgQzAuNjA2ODQzMjYsNi4xMTQzNjUzMSAwLjcyNzEwMzQ0OSw1LjkzNzk3Nzg2IDAuNzI3MTAzNDQ5LDUuNzY3NTM4NzUgQzAuNzI3MTAzNDQ5LDUuNjYxNTcxOTYgMC43NTAyNTA3ODMsNS41Mzk5MTg4MiAwLjkzMDYyMDY5Myw1LjUzOTkxODgyIEMxLjE3NDI3OSw1LjUzOTkxODgyIDEuMTgxMjg4NCw1Ljc5NDA2NjQyIDEuMTgxMjg4NCw1LjgyMzA0MDU5IEMxLjE4MTI4ODQsNi4wNTE0NzYwMiAwLjkyOTQzODg3Miw2LjI2NTA0MDU5IDAuNjg1ODYyMDY5LDYuNDcxNTUzNTEgQzAuMzg0NzgzNjk5LDYuNzI2ODA0NDMgMC4wNDM1MjM1MTEsNy4wMTYxNjIzNiAwLjA0MzUyMzUxMSw3LjQ2MzU4MzAzIEwwLjA0MzUyMzUxMSw3Ljg0NzkyMjUxIEMwLjA0MzQ4Mjc1ODYsOC4wNTI5OTYzMSAwLjIwMjg2NTIwMyw4LjE5MDc2NzQ5IDAuMzUxNjkyNzksOC4xOTA3Njc0OSBMMC4zNTE2OTI3OSw4LjE5MDc2NzQ5IEwwLjM1MTY5Mjc5LDguMTkwNzY3NDkgWiIgaWQ9IlNoYXBlIj48L3BhdGg+CiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPHBhdGggZD0iTTEuNzcwNTI2NjQsMTAuNTQzMDk2IEMxLjc3MDUyNjY0LDkuOTUxMDQ0MjcgMS40NzM1MjM1MSw5LjYxMTUwOTIxIDAuOTU1NzI0MTM5LDkuNjExNTA5MjEgQzAuMjc2Nzg5OTY5LDkuNjExNTA5MjEgMC4wOTczOTgxMTksMTAuMTgyMjYyIDAuMDk3Mzk4MTE5LDEwLjQ4NDA0NDMgQzAuMDk3Mzk4MTE5LDEwLjgzNTM4MDEgMC4zMTkyOTQ2NywxMC44NzMzMjQ3IDAuNDE0Njk1OTI1LDEwLjg3MzMyNDcgQzAuNjAwNDg1ODkzLDEwLjg3MzMyNDcgMC43MjUyNjk1OTIsMTAuNzI2MzkxMiAwLjcyNTI2OTU5MiwxMC41MDc2OTM3IEMwLjcyNTI2OTU5MiwxMC40MjM1NTM1IDAuNzUwNjk5MDYsMTAuMzI2OTg4OSAwLjk0ODg3Nzc0NCwxMC4zMjY5ODg5IEMxLjA5MTMwNzIxLDEwLjMyNjk4ODkgMS4xNDkyOTc4MSwxMC4zNTExNjYxIDEuMTQ5Mjk3ODEsMTAuNTk0MDg4NSBDMS4xNDkyOTc4MSwxMC44MzE0NDY1IDEuMTA2MDE4ODEsMTAuODU3MzAyNSAwLjkzNTU1MTcyMywxMC44NTczMDI1IEMwLjc3MTgwODc3NywxMC44NTczMDI1IDAuNjQ4MzY5OTA2LDExLjAwOTQxNyAwLjY0ODM2OTkwNiwxMS4yMTEwODQ5IEMwLjY0ODM2OTkwNiwxMS40MTA1OTQxIDAuNzczMzE2NjE1LDExLjU2MTA3NzUgMC45Mzg5NzQ5MiwxMS41NjEwNzc1IEMxLjE2NDEzMTY2LDExLjU2MTA3NzUgMS4yMDkzNjY3NywxMS42NjkyOTg5IDEuMjA5MzY2NzcsMTEuODQzOTU5NCBMMS4yMDkzNjY3NywxMS45MTg3NDU0IEMxLjIwOTM2Njc3LDEyLjIxMjYxMjUgMS4xMTIwMDk0MSwxMi4yNjgzMDYzIDAuOTMyMzMyMjkxLDEyLjI2ODMwNjMgQzAuNjg0NDM1NzM2LDEyLjI2ODMwNjMgMC42NjUxNTk4NzUsMTIuMTE4MDYyNyAwLjY2NTE1OTg3NSwxMi4wNzIwMTExIEMwLjY2NTE1OTg3NSwxMS44OTc4MzAzIDAuNTY3MDY4OTY1LDExLjcyMjA2NjQgMC4zNDc5MDI4MjIsMTEuNzIyMDY2NCBDMC4xNTU1NTE3MjQsMTEuNzIyMDY2NCAwLjA0MDcxMTU5ODgsMTEuODYzMTQ3NiAwLjA0MDcxMTU5ODgsMTIuMDk5NTQ2MSBDMC4wNDA3MTE1OTg4LDEyLjUzMDEyOTEgMC4zNTQzNDE2OTMsMTIuOTg3NzY3NSAwLjkzNTU1MTcyMywxMi45ODc3Njc1IEMxLjUwMDEzNDgsMTIuOTg3NzY3NSAxLjgzNzIzODI0LDEyLjU4ODEyNTUgMS44MzcyMzgyNCwxMS45MTg3NDU0IEwxLjgzNzIzODI0LDExLjg0Mzk1OTQgQzEuODM3MjM4MjQsMTEuNTY5NTIwMyAxLjc2MjY2MTQ0LDExLjM0MTk0ODMgMS42MjI3MTc4NywxMS4xNzgzMjEgQzEuNzE4NTY3NCwxMS4wMTUwNzc1IDEuNzcwNTI2NjQsMTAuNzk3MjQzNSAxLjc3MDUyNjY0LDEwLjU0MzA5NiBMMS43NzA1MjY2NCwxMC41NDMwOTYgTDEuNzcwNTI2NjQsMTAuNTQzMDk2IFoiIGlkPSJTaGFwZSI+PC9wYXRoPgogICAgICAgICAgICAgICAgICAgICAgICAgICAgPC9nPgogICAgICAgICAgICAgICAgICAgICAgICA8L2c+CiAgICAgICAgICAgICAgICAgICAgPC9nPgogICAgICAgICAgICAgICAgPC9nPgogICAgICAgICAgICA8L2c+CiAgICAgICAgPC9nPgogICAgPC9nPgo8L3N2Zz4="},function(t,e){t.exports="data:image/svg+xml;base64,PD94bWwgdmVyc2lvbj0iMS4wIiBlbmNvZGluZz0iVVRGLTgiIHN0YW5kYWxvbmU9Im5vIj8+Cjxzdmcgd2lkdGg9IjE2cHgiIGhlaWdodD0iMTRweCIgdmlld0JveD0iMCAwIDE2IDE0IiB2ZXJzaW9uPSIxLjEiIHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZyIgeG1sbnM6eGxpbms9Imh0dHA6Ly93d3cudzMub3JnLzE5OTkveGxpbmsiPgogICAgPCEtLSBHZW5lcmF0b3I6IFNrZXRjaCA0MC4zICgzMzgzOSkgLSBodHRwOi8vd3d3LmJvaGVtaWFuY29kaW5nLmNvbS9za2V0Y2ggLS0+CiAgICA8dGl0bGU+bGlzdC11bm9yZGVyZWQ8L3RpdGxlPgogICAgPGRlc2M+Q3JlYXRlZCB3aXRoIFNrZXRjaC48L2Rlc2M+CiAgICA8ZGVmcz48L2RlZnM+CiAgICA8ZyBpZD0iUGFnZS0xIiBzdHJva2U9Im5vbmUiIHN0cm9rZS13aWR0aD0iMSIgZmlsbD0ibm9uZSIgZmlsbC1ydWxlPSJldmVub2RkIj4KICAgICAgICA8ZyBpZD0ibGlzdC11bm9yZGVyZWQiIGZpbGw9IiMwMDAwMDAiPgogICAgICAgICAgICA8ZyBpZD0iQ2FwYV8xIj4KICAgICAgICAgICAgICAgIDxnIGlkPSJHcm91cCI+CiAgICAgICAgICAgICAgICAgICAgPHBhdGggZD0iTTEuNzIwODE2MzMsMy40MjcwODMzMyBDMi42NzEwMjA0MSwzLjQyNzA4MzMzIDMuNDQxNjMyNjUsMi42NTkwMjc3OCAzLjQ0MTYzMjY1LDEuNzE5MjEyOTYgQzMuNDQxNjMyNjUsMC43NzkzOTgxNDggMi42NzEwMjA0MSwwLjAwODEwMTg1MTg1IDEuNzIwODE2MzMsMC4wMDgxMDE4NTE4NSBDMC43NzA2MTIyNDUsMC4wMDgxMDE4NTE4NSAwLDAuNzc2MTU3NDA3IDAsMS43MTU5NzIyMiBDMCwyLjY1NTc4NzA0IDAuNzczODc3NTUxLDMuNDI3MDgzMzMgMS43MjA4MTYzMywzLjQyNzA4MzMzIEwxLjcyMDgxNjMzLDMuNDI3MDgzMzMgWiBNMS43MjA4MTYzMywwLjgwMjA4MzMzMyBDMi4yMzAyMDQwOCwwLjgwMjA4MzMzMyAyLjY0MTYzMjY1LDEuMjEzNjU3NDEgMi42NDE2MzI2NSwxLjcxNTk3MjIyIEMyLjY0MTYzMjY1LDIuMjE4Mjg3MDQgMi4yMjY5Mzg3OCwyLjYyOTg2MTExIDEuNzIwODE2MzMsMi42Mjk4NjExMSBDMS4yMTQ2OTM4OCwyLjYyOTg2MTExIDAuOCwyLjIxODI4NzA0IDAuOCwxLjcxNTk3MjIyIEMwLjgsMS4yMTM2NTc0MSAxLjIxNDY5Mzg4LDAuODAyMDgzMzMzIDEuNzIwODE2MzMsMC44MDIwODMzMzMgTDEuNzIwODE2MzMsMC44MDIwODMzMzMgWiIgaWQ9IlNoYXBlIj48L3BhdGg+CiAgICAgICAgICAgICAgICAgICAgPHBhdGggZD0iTTEuNzIwODE2MzMsOC43MDMwMDkyNiBDMi42NzEwMjA0MSw4LjcwMzAwOTI2IDMuNDQxNjMyNjUsNy45MzQ5NTM3IDMuNDQxNjMyNjUsNi45OTUxMzg4OSBDMy40NDE2MzI2NSw2LjA1NTMyNDA3IDIuNjcxMDIwNDEsNS4yODcyNjg1MiAxLjcyMDgxNjMzLDUuMjg3MjY4NTIgQzAuNzcwNjEyMjQ1LDUuMjg3MjY4NTIgMCw2LjA1MjA4MzMzIDAsNi45OTUxMzg4OSBDMCw3LjkzODE5NDQ0IDAuNzczODc3NTUxLDguNzAzMDA5MjYgMS43MjA4MTYzMyw4LjcwMzAwOTI2IEwxLjcyMDgxNjMzLDguNzAzMDA5MjYgWiBNMS43MjA4MTYzMyw2LjA4MTI1IEMyLjIzMDIwNDA4LDYuMDgxMjUgMi42NDE2MzI2NSw2LjQ5MjgyNDA3IDIuNjQxNjMyNjUsNi45OTUxMzg4OSBDMi42NDE2MzI2NSw3LjQ5NzQ1MzcgMi4yMjY5Mzg3OCw3LjkwOTAyNzc4IDEuNzIwODE2MzMsNy45MDkwMjc3OCBDMS4yMTQ2OTM4OCw3LjkwOTAyNzc4IDAuOCw3LjUwMDY5NDQ0IDAuOCw2Ljk5NTEzODg5IEMwLjgsNi40ODk1ODMzMyAxLjIxNDY5Mzg4LDYuMDgxMjUgMS43MjA4MTYzMyw2LjA4MTI1IEwxLjcyMDgxNjMzLDYuMDgxMjUgWiIgaWQ9IlNoYXBlIj48L3BhdGg+CiAgICAgICAgICAgICAgICAgICAgPHBhdGggZD0iTTEuNzIwODE2MzMsMTMuOTgyMTc1OSBDMi42NzEwMjA0MSwxMy45ODIxNzU5IDMuNDQxNjMyNjUsMTMuMjE0MTIwNCAzLjQ0MTYzMjY1LDEyLjI3NDMwNTYgQzMuNDQxNjMyNjUsMTEuMzMxMjUgMi42Njc3NTUxLDEwLjU2NjQzNTIgMS43MjA4MTYzMywxMC41NjY0MzUyIEMwLjc3Mzg3NzU1MSwxMC41NjY0MzUyIDAsMTEuMzM0NDkwNyAwLDEyLjI3NDMwNTYgQzAsMTMuMjE0MTIwNCAwLjc3Mzg3NzU1MSwxMy45ODIxNzU5IDEuNzIwODE2MzMsMTMuOTgyMTc1OSBMMS43MjA4MTYzMywxMy45ODIxNzU5IFogTTEuNzIwODE2MzMsMTEuMzU3MTc1OSBDMi4yMzAyMDQwOCwxMS4zNTcxNzU5IDIuNjQxNjMyNjUsMTEuNzY4NzUgMi42NDE2MzI2NSwxMi4yNzEwNjQ4IEMyLjY0MTYzMjY1LDEyLjc3NjYyMDQgMi4yMjY5Mzg3OCwxMy4xODQ5NTM3IDEuNzIwODE2MzMsMTMuMTg0OTUzNyBDMS4yMTQ2OTM4OCwxMy4xODQ5NTM3IDAuOCwxMi43NzMzNzk2IDAuOCwxMi4yNzEwNjQ4IEMwLjgsMTEuNzY4NzUgMS4yMTQ2OTM4OCwxMS4zNTcxNzU5IDEuNzIwODE2MzMsMTEuMzU3MTc1OSBMMS43MjA4MTYzMywxMS4zNTcxNzU5IFoiIGlkPSJTaGFwZSI+PC9wYXRoPgogICAgICAgICAgICAgICAgICAgIDxwYXRoIGQ9Ik01Ljc0MzY3MzQ3LDIuMTE0NTgzMzMgTDE1LjU4ODU3MTQsMi4xMTQ1ODMzMyBDMTUuODEwNjEyMiwyLjExNDU4MzMzIDE1Ljk5MDIwNDEsMS45MzYzNDI1OSAxNS45OTAyMDQxLDEuNzE1OTcyMjIgQzE1Ljk5MDIwNDEsMS40OTU2MDE4NSAxNS44MTA2MTIyLDEuMzE3MzYxMTEgMTUuNTg4NTcxNCwxLjMxNzM2MTExIEw1Ljc0MzY3MzQ3LDEuMzE3MzYxMTEgQzUuNTIxNjMyNjUsMS4zMTczNjExMSA1LjM0MjA0MDgyLDEuNDk1NjAxODUgNS4zNDIwNDA4MiwxLjcxNTk3MjIyIEM1LjM0MjA0MDgyLDEuOTM2MzQyNTkgNS41MjE2MzI2NSwyLjExNDU4MzMzIDUuNzQzNjczNDcsMi4xMTQ1ODMzMyBMNS43NDM2NzM0NywyLjExNDU4MzMzIFoiIGlkPSJTaGFwZSI+PC9wYXRoPgogICAgICAgICAgICAgICAgICAgIDxwYXRoIGQ9Ik01Ljc0MzY3MzQ3LDcuMzkzNzUgTDE1LjU4ODU3MTQsNy4zOTM3NSBDMTUuODEwNjEyMiw3LjM5Mzc1IDE1Ljk5MDIwNDEsNy4yMTU1MDkyNiAxNS45OTAyMDQxLDYuOTk1MTM4ODkgQzE1Ljk5MDIwNDEsNi43NzQ3Njg1MiAxNS44MTA2MTIyLDYuNTk2NTI3NzggMTUuNTg4NTcxNCw2LjU5NjUyNzc4IEw1Ljc0MzY3MzQ3LDYuNTk2NTI3NzggQzUuNTIxNjMyNjUsNi41OTY1Mjc3OCA1LjM0MjA0MDgyLDYuNzc0NzY4NTIgNS4zNDIwNDA4Miw2Ljk5NTEzODg5IEM1LjM0MjA0MDgyLDcuMjE1NTA5MjYgNS41MjE2MzI2NSw3LjM5Mzc1IDUuNzQzNjczNDcsNy4zOTM3NSBMNS43NDM2NzM0Nyw3LjM5Mzc1IFoiIGlkPSJTaGFwZSI+PC9wYXRoPgogICAgICAgICAgICAgICAgICAgIDxwYXRoIGQ9Ik01Ljc0MzY3MzQ3LDEyLjY2OTY3NTkgTDE1LjU4ODU3MTQsMTIuNjY5Njc1OSBDMTUuODEwNjEyMiwxMi42Njk2NzU5IDE1Ljk5MDIwNDEsMTIuNDkxNDM1MiAxNS45OTAyMDQxLDEyLjI3MTA2NDggQzE1Ljk5MDIwNDEsMTIuMDUwNjk0NCAxNS44MTA2MTIyLDExLjg3MjQ1MzcgMTUuNTg4NTcxNCwxMS44NzI0NTM3IEw1Ljc0MzY3MzQ3LDExLjg3MjQ1MzcgQzUuNTIxNjMyNjUsMTEuODcyNDUzNyA1LjM0MjA0MDgyLDEyLjA1MDY5NDQgNS4zNDIwNDA4MiwxMi4yNzEwNjQ4IEM1LjM0MjA0MDgyLDEyLjQ5MTQzNTIgNS41MjE2MzI2NSwxMi42Njk2NzU5IDUuNzQzNjczNDcsMTIuNjY5Njc1OSBMNS43NDM2NzM0NywxMi42Njk2NzU5IFoiIGlkPSJTaGFwZSI+PC9wYXRoPgogICAgICAgICAgICAgICAgPC9nPgogICAgICAgICAgICA8L2c+CiAgICAgICAgPC9nPgogICAgPC9nPgo8L3N2Zz4="},function(t,e){t.exports="data:image/svg+xml;base64,PD94bWwgdmVyc2lvbj0iMS4wIiBlbmNvZGluZz0iVVRGLTgiIHN0YW5kYWxvbmU9Im5vIj8+Cjxzdmcgd2lkdGg9IjE1cHgiIGhlaWdodD0iMTVweCIgdmlld0JveD0iMCAwIDE1IDE1IiB2ZXJzaW9uPSIxLjEiIHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZyIgeG1sbnM6eGxpbms9Imh0dHA6Ly93d3cudzMub3JnLzE5OTkveGxpbmsiPgogICAgPCEtLSBHZW5lcmF0b3I6IFNrZXRjaCA0MC4zICgzMzgzOSkgLSBodHRwOi8vd3d3LmJvaGVtaWFuY29kaW5nLmNvbS9za2V0Y2ggLS0+CiAgICA8dGl0bGU+YWxpZ24tbGVmdDwvdGl0bGU+CiAgICA8ZGVzYz5DcmVhdGVkIHdpdGggU2tldGNoLjwvZGVzYz4KICAgIDxkZWZzPjwvZGVmcz4KICAgIDxnIGlkPSJQYWdlLTEiIHN0cm9rZT0ibm9uZSIgc3Ryb2tlLXdpZHRoPSIxIiBmaWxsPSJub25lIiBmaWxsLXJ1bGU9ImV2ZW5vZGQiPgogICAgICAgIDxnIGlkPSJhbGlnbi1sZWZ0IiBmaWxsPSIjMDAwMDAwIj4KICAgICAgICAgICAgPGcgaWQ9IkNhcGFfMSI+CiAgICAgICAgICAgICAgICA8ZyBpZD0iR3JvdXAiPgogICAgICAgICAgICAgICAgICAgIDxwYXRoIGQ9Ik04LjQ5MzI2MDg3LDE0Ljg4NzE3MzkgTDAuMzI2MDg2OTU3LDE0Ljg4NzE3MzkgQzAuMTQ2MDg2OTU3LDE0Ljg4NzE3MzkgMCwxNC43NDEwODcgMCwxNC41NjEwODcgQzAsMTQuMzgxMDg3IDAuMTQ2MDg2OTU3LDE0LjIzNSAwLjMyNjA4Njk1NywxNC4yMzUgTDguNDkzMjYwODcsMTQuMjM1IEM4LjY3MzI2MDg3LDE0LjIzNSA4LjgxOTM0NzgzLDE0LjM4MTA4NyA4LjgxOTM0NzgzLDE0LjU2MTA4NyBDOC44MTkzNDc4MywxNC43NDEwODcgOC42NzM5MTMwNCwxNC44ODcxNzM5IDguNDkzMjYwODcsMTQuODg3MTczOSBMOC40OTMyNjA4NywxNC44ODcxNzM5IFoiIGlkPSJTaGFwZSI+PC9wYXRoPgogICAgICAgICAgICAgICAgICAgIDxwYXRoIGQ9Ik0xNC42MTc4MjYxLDEwLjE2MTUyMTcgTDAuMzI2MDg2OTU3LDEwLjE2MTUyMTcgQzAuMTQ2MDg2OTU3LDEwLjE2MTUyMTcgMCwxMC4wMTU0MzQ4IDAsOS44MzU0MzQ3OCBDMCw5LjY1NTQzNDc4IDAuMTQ2MDg2OTU3LDkuNTA5MzQ3ODMgMC4zMjYwODY5NTcsOS41MDkzNDc4MyBMMTQuNjE3ODI2MSw5LjUwOTM0NzgzIEMxNC43OTc4MjYxLDkuNTA5MzQ3ODMgMTQuOTQzOTEzLDkuNjU1NDM0NzggMTQuOTQzOTEzLDkuODM1NDM0NzggQzE0Ljk0MzkxMywxMC4wMTU0MzQ4IDE0Ljc5NzgyNjEsMTAuMTYxNTIxNyAxNC42MTc4MjYxLDEwLjE2MTUyMTcgTDE0LjYxNzgyNjEsMTAuMTYxNTIxNyBaIiBpZD0iU2hhcGUiPjwvcGF0aD4KICAgICAgICAgICAgICAgICAgICA8cGF0aCBkPSJNOC40OTMyNjA4Nyw1LjQzNTIxNzM5IEwwLjMyNjA4Njk1Nyw1LjQzNTIxNzM5IEMwLjE0NjA4Njk1Nyw1LjQzNTIxNzM5IDAsNS4yODkxMzA0MyAwLDUuMTA5MTMwNDMgQzAsNC45MjkxMzA0MyAwLjE0NjA4Njk1Nyw0Ljc4MzA0MzQ4IDAuMzI2MDg2OTU3LDQuNzgzMDQzNDggTDguNDkzMjYwODcsNC43ODMwNDM0OCBDOC42NzMyNjA4Nyw0Ljc4MzA0MzQ4IDguODE5MzQ3ODMsNC45MjkxMzA0MyA4LjgxOTM0NzgzLDUuMTA5MTMwNDMgQzguODE5MzQ3ODMsNS4yODkxMzA0MyA4LjY3MzkxMzA0LDUuNDM1MjE3MzkgOC40OTMyNjA4Nyw1LjQzNTIxNzM5IEw4LjQ5MzI2MDg3LDUuNDM1MjE3MzkgWiIgaWQ9IlNoYXBlIj48L3BhdGg+CiAgICAgICAgICAgICAgICAgICAgPHBhdGggZD0iTTE0LjYxNzgyNjEsMC43MDg5MTMwNDMgTDAuMzI2MDg2OTU3LDAuNzA4OTEzMDQzIEMwLjE0NjA4Njk1NywwLjcwODkxMzA0MyAwLDAuNTYyODI2MDg3IDAsMC4zODI4MjYwODcgQzAsMC4yMDI4MjYwODcgMC4xNDYwODY5NTcsMC4wNTY3MzkxMzA0IDAuMzI2MDg2OTU3LDAuMDU2NzM5MTMwNCBMMTQuNjE3ODI2MSwwLjA1NjczOTEzMDQgQzE0Ljc5NzgyNjEsMC4wNTY3MzkxMzA0IDE0Ljk0MzkxMywwLjIwMjgyNjA4NyAxNC45NDM5MTMsMC4zODI4MjYwODcgQzE0Ljk0MzkxMywwLjU2MjgyNjA4NyAxNC43OTc4MjYxLDAuNzA4OTEzMDQzIDE0LjYxNzgyNjEsMC43MDg5MTMwNDMgTDE0LjYxNzgyNjEsMC43MDg5MTMwNDMgWiIgaWQ9IlNoYXBlIj48L3BhdGg+CiAgICAgICAgICAgICAgICA8L2c+CiAgICAgICAgICAgIDwvZz4KICAgICAgICA8L2c+CiAgICA8L2c+Cjwvc3ZnPg=="},function(t,e){t.exports="data:image/svg+xml;base64,PD94bWwgdmVyc2lvbj0iMS4wIiBlbmNvZGluZz0iVVRGLTgiIHN0YW5kYWxvbmU9Im5vIj8+Cjxzdmcgd2lkdGg9IjE1cHgiIGhlaWdodD0iMTVweCIgdmlld0JveD0iMCAwIDE1IDE1IiB2ZXJzaW9uPSIxLjEiIHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZyIgeG1sbnM6eGxpbms9Imh0dHA6Ly93d3cudzMub3JnLzE5OTkveGxpbmsiPgogICAgPCEtLSBHZW5lcmF0b3I6IFNrZXRjaCA0MC4zICgzMzgzOSkgLSBodHRwOi8vd3d3LmJvaGVtaWFuY29kaW5nLmNvbS9za2V0Y2ggLS0+CiAgICA8dGl0bGU+YWxpZ24tY2VudGVyPC90aXRsZT4KICAgIDxkZXNjPkNyZWF0ZWQgd2l0aCBTa2V0Y2guPC9kZXNjPgogICAgPGRlZnM+PC9kZWZzPgogICAgPGcgaWQ9IlBhZ2UtMSIgc3Ryb2tlPSJub25lIiBzdHJva2Utd2lkdGg9IjEiIGZpbGw9Im5vbmUiIGZpbGwtcnVsZT0iZXZlbm9kZCI+CiAgICAgICAgPGcgaWQ9ImFsaWduLWNlbnRlciIgZmlsbD0iIzAwMDAwMCI+CiAgICAgICAgICAgIDxnIGlkPSJHcm91cCI+CiAgICAgICAgICAgICAgICA8cGF0aCBkPSJNMTEuNTU1ODY5NiwxNC44ODcxNzM5IEwzLjM4ODA0MzQ4LDE0Ljg4NzE3MzkgQzMuMjA4MDQzNDgsMTQuODg3MTczOSAzLjA2MTk1NjUyLDE0Ljc0MTA4NyAzLjA2MTk1NjUyLDE0LjU2MTA4NyBDMy4wNjE5NTY1MiwxNC4zODEwODcgMy4yMDgwNDM0OCwxNC4yMzUgMy4zODgwNDM0OCwxNC4yMzUgTDExLjU1NTIxNzQsMTQuMjM1IEMxMS43MzUyMTc0LDE0LjIzNSAxMS44ODEzMDQzLDE0LjM4MTA4NyAxMS44ODEzMDQzLDE0LjU2MTA4NyBDMTEuODgxMzA0MywxNC43NDEwODcgMTEuNzM1ODY5NiwxNC44ODcxNzM5IDExLjU1NTg2OTYsMTQuODg3MTczOSBMMTEuNTU1ODY5NiwxNC44ODcxNzM5IFoiIGlkPSJTaGFwZSI+PC9wYXRoPgogICAgICAgICAgICAgICAgPHBhdGggZD0iTTE0LjYxNzgyNjEsMTAuMTYxNTIxNyBMMC4zMjYwODY5NTcsMTAuMTYxNTIxNyBDMC4xNDYwODY5NTcsMTAuMTYxNTIxNyAwLDEwLjAxNTQzNDggMCw5LjgzNTQzNDc4IEMwLDkuNjU1NDM0NzggMC4xNDYwODY5NTcsOS41MDkzNDc4MyAwLjMyNjA4Njk1Nyw5LjUwOTM0NzgzIEwxNC42MTc4MjYxLDkuNTA5MzQ3ODMgQzE0Ljc5NzgyNjEsOS41MDkzNDc4MyAxNC45NDM5MTMsOS42NTU0MzQ3OCAxNC45NDM5MTMsOS44MzU0MzQ3OCBDMTQuOTQzOTEzLDEwLjAxNTQzNDggMTQuNzk3ODI2MSwxMC4xNjE1MjE3IDE0LjYxNzgyNjEsMTAuMTYxNTIxNyBMMTQuNjE3ODI2MSwxMC4xNjE1MjE3IFoiIGlkPSJTaGFwZSI+PC9wYXRoPgogICAgICAgICAgICAgICAgPHBhdGggZD0iTTExLjU1NTg2OTYsNS40MzUyMTczOSBMMy4zODgwNDM0OCw1LjQzNTIxNzM5IEMzLjIwODA0MzQ4LDUuNDM1MjE3MzkgMy4wNjE5NTY1Miw1LjI4OTEzMDQzIDMuMDYxOTU2NTIsNS4xMDkxMzA0MyBDMy4wNjE5NTY1Miw0LjkyOTEzMDQzIDMuMjA4MDQzNDgsNC43ODMwNDM0OCAzLjM4ODA0MzQ4LDQuNzgzMDQzNDggTDExLjU1NTIxNzQsNC43ODMwNDM0OCBDMTEuNzM1MjE3NCw0Ljc4MzA0MzQ4IDExLjg4MTMwNDMsNC45MjkxMzA0MyAxMS44ODEzMDQzLDUuMTA5MTMwNDMgQzExLjg4MTMwNDMsNS4yODkxMzA0MyAxMS43MzU4Njk2LDUuNDM1MjE3MzkgMTEuNTU1ODY5Niw1LjQzNTIxNzM5IEwxMS41NTU4Njk2LDUuNDM1MjE3MzkgWiIgaWQ9IlNoYXBlIj48L3BhdGg+CiAgICAgICAgICAgICAgICA8cGF0aCBkPSJNMTQuNjE3ODI2MSwwLjcwODkxMzA0MyBMMC4zMjYwODY5NTcsMC43MDg5MTMwNDMgQzAuMTQ2MDg2OTU3LDAuNzA4OTEzMDQzIDAsMC41NjI4MjYwODcgMCwwLjM4MjgyNjA4NyBDMCwwLjIwMjgyNjA4NyAwLjE0NjA4Njk1NywwLjA1NjczOTEzMDQgMC4zMjYwODY5NTcsMC4wNTY3MzkxMzA0IEwxNC42MTc4MjYxLDAuMDU2NzM5MTMwNCBDMTQuNzk3ODI2MSwwLjA1NjczOTEzMDQgMTQuOTQzOTEzLDAuMjAyODI2MDg3IDE0Ljk0MzkxMywwLjM4MjgyNjA4NyBDMTQuOTQzOTEzLDAuNTYyODI2MDg3IDE0Ljc5NzgyNjEsMC43MDg5MTMwNDMgMTQuNjE3ODI2MSwwLjcwODkxMzA0MyBMMTQuNjE3ODI2MSwwLjcwODkxMzA0MyBaIiBpZD0iU2hhcGUiPjwvcGF0aD4KICAgICAgICAgICAgPC9nPgogICAgICAgIDwvZz4KICAgIDwvZz4KPC9zdmc+"},function(t,e){t.exports="data:image/svg+xml;base64,PD94bWwgdmVyc2lvbj0iMS4wIiBlbmNvZGluZz0iVVRGLTgiIHN0YW5kYWxvbmU9Im5vIj8+Cjxzdmcgd2lkdGg9IjE1cHgiIGhlaWdodD0iMTVweCIgdmlld0JveD0iMCAwIDE1IDE1IiB2ZXJzaW9uPSIxLjEiIHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZyIgeG1sbnM6eGxpbms9Imh0dHA6Ly93d3cudzMub3JnLzE5OTkveGxpbmsiPgogICAgPCEtLSBHZW5lcmF0b3I6IFNrZXRjaCA0MC4zICgzMzgzOSkgLSBodHRwOi8vd3d3LmJvaGVtaWFuY29kaW5nLmNvbS9za2V0Y2ggLS0+CiAgICA8dGl0bGU+YWxpZ24tcmlnaHQ8L3RpdGxlPgogICAgPGRlc2M+Q3JlYXRlZCB3aXRoIFNrZXRjaC48L2Rlc2M+CiAgICA8ZGVmcz48L2RlZnM+CiAgICA8ZyBpZD0iUGFnZS0xIiBzdHJva2U9Im5vbmUiIHN0cm9rZS13aWR0aD0iMSIgZmlsbD0ibm9uZSIgZmlsbC1ydWxlPSJldmVub2RkIj4KICAgICAgICA8ZyBpZD0iYWxpZ24tcmlnaHQiIGZpbGw9IiMwMDAwMDAiPgogICAgICAgICAgICA8ZyBpZD0iQ2FwYV8xIj4KICAgICAgICAgICAgICAgIDxnIGlkPSJHcm91cCI+CiAgICAgICAgICAgICAgICAgICAgPHBhdGggZD0iTTE0LjYxNzgyNjEsMTQuODg3MTczOSBMNi40NTA2NTIxNywxNC44ODcxNzM5IEM2LjI3MDY1MjE3LDE0Ljg4NzE3MzkgNi4xMjQ1NjUyMiwxNC43NDEwODcgNi4xMjQ1NjUyMiwxNC41NjEwODcgQzYuMTI0NTY1MjIsMTQuMzgxMDg3IDYuMjcwNjUyMTcsMTQuMjM1IDYuNDUwNjUyMTcsMTQuMjM1IEwxNC42MTc4MjYxLDE0LjIzNSBDMTQuNzk3ODI2MSwxNC4yMzUgMTQuOTQzOTEzLDE0LjM4MTA4NyAxNC45NDM5MTMsMTQuNTYxMDg3IEMxNC45NDM5MTMsMTQuNzQxMDg3IDE0Ljc5NzgyNjEsMTQuODg3MTczOSAxNC42MTc4MjYxLDE0Ljg4NzE3MzkgTDE0LjYxNzgyNjEsMTQuODg3MTczOSBaIiBpZD0iU2hhcGUiPjwvcGF0aD4KICAgICAgICAgICAgICAgICAgICA8cGF0aCBkPSJNMTQuNjE3ODI2MSwxMC4xNjE1MjE3IEwwLjMyNjA4Njk1NywxMC4xNjE1MjE3IEMwLjE0NjA4Njk1NywxMC4xNjE1MjE3IDAsMTAuMDE1NDM0OCAwLDkuODM1NDM0NzggQzAsOS42NTU0MzQ3OCAwLjE0NjA4Njk1Nyw5LjUwOTM0NzgzIDAuMzI2MDg2OTU3LDkuNTA5MzQ3ODMgTDE0LjYxNzgyNjEsOS41MDkzNDc4MyBDMTQuNzk3ODI2MSw5LjUwOTM0NzgzIDE0Ljk0MzkxMyw5LjY1NTQzNDc4IDE0Ljk0MzkxMyw5LjgzNTQzNDc4IEMxNC45NDM5MTMsMTAuMDE1NDM0OCAxNC43OTc4MjYxLDEwLjE2MTUyMTcgMTQuNjE3ODI2MSwxMC4xNjE1MjE3IEwxNC42MTc4MjYxLDEwLjE2MTUyMTcgWiIgaWQ9IlNoYXBlIj48L3BhdGg+CiAgICAgICAgICAgICAgICAgICAgPHBhdGggZD0iTTE0LjYxNzgyNjEsNS40MzUyMTczOSBMNi40NTA2NTIxNyw1LjQzNTIxNzM5IEM2LjI3MDY1MjE3LDUuNDM1MjE3MzkgNi4xMjQ1NjUyMiw1LjI4OTEzMDQzIDYuMTI0NTY1MjIsNS4xMDkxMzA0MyBDNi4xMjQ1NjUyMiw0LjkyOTEzMDQzIDYuMjcwNjUyMTcsNC43ODMwNDM0OCA2LjQ1MDY1MjE3LDQuNzgzMDQzNDggTDE0LjYxNzgyNjEsNC43ODMwNDM0OCBDMTQuNzk3ODI2MSw0Ljc4MzA0MzQ4IDE0Ljk0MzkxMyw0LjkyOTEzMDQzIDE0Ljk0MzkxMyw1LjEwOTEzMDQzIEMxNC45NDM5MTMsNS4yODkxMzA0MyAxNC43OTc4MjYxLDUuNDM1MjE3MzkgMTQuNjE3ODI2MSw1LjQzNTIxNzM5IEwxNC42MTc4MjYxLDUuNDM1MjE3MzkgWiIgaWQ9IlNoYXBlIj48L3BhdGg+CiAgICAgICAgICAgICAgICAgICAgPHBhdGggZD0iTTE0LjYxNzgyNjEsMC43MDg5MTMwNDMgTDAuMzI2MDg2OTU3LDAuNzA4OTEzMDQzIEMwLjE0NjA4Njk1NywwLjcwODkxMzA0MyAwLDAuNTYyODI2MDg3IDAsMC4zODI4MjYwODcgQzAsMC4yMDI4MjYwODcgMC4xNDYwODY5NTcsMC4wNTY3MzkxMzA0IDAuMzI2MDg2OTU3LDAuMDU2NzM5MTMwNCBMMTQuNjE3ODI2MSwwLjA1NjczOTEzMDQgQzE0Ljc5NzgyNjEsMC4wNTY3MzkxMzA0IDE0Ljk0MzkxMywwLjIwMjgyNjA4NyAxNC45NDM5MTMsMC4zODI4MjYwODcgQzE0Ljk0MzkxMywwLjU2MjgyNjA4NyAxNC43OTc4MjYxLDAuNzA4OTEzMDQzIDE0LjYxNzgyNjEsMC43MDg5MTMwNDMgTDE0LjYxNzgyNjEsMC43MDg5MTMwNDMgWiIgaWQ9IlNoYXBlIj48L3BhdGg+CiAgICAgICAgICAgICAgICA8L2c+CiAgICAgICAgICAgIDwvZz4KICAgICAgICA8L2c+CiAgICA8L2c+Cjwvc3ZnPg=="},function(t,e){t.exports="data:image/svg+xml;base64,PD94bWwgdmVyc2lvbj0iMS4wIiBlbmNvZGluZz0iVVRGLTgiIHN0YW5kYWxvbmU9Im5vIj8+Cjxzdmcgd2lkdGg9IjE1cHgiIGhlaWdodD0iMTVweCIgdmlld0JveD0iMCAwIDE1IDE1IiB2ZXJzaW9uPSIxLjEiIHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZyIgeG1sbnM6eGxpbms9Imh0dHA6Ly93d3cudzMub3JnLzE5OTkveGxpbmsiPgogICAgPCEtLSBHZW5lcmF0b3I6IFNrZXRjaCA0MC4zICgzMzgzOSkgLSBodHRwOi8vd3d3LmJvaGVtaWFuY29kaW5nLmNvbS9za2V0Y2ggLS0+CiAgICA8dGl0bGU+YWxpZ24tanVzdGlmeTwvdGl0bGU+CiAgICA8ZGVzYz5DcmVhdGVkIHdpdGggU2tldGNoLjwvZGVzYz4KICAgIDxkZWZzPjwvZGVmcz4KICAgIDxnIGlkPSJQYWdlLTEiIHN0cm9rZT0ibm9uZSIgc3Ryb2tlLXdpZHRoPSIxIiBmaWxsPSJub25lIiBmaWxsLXJ1bGU9ImV2ZW5vZGQiPgogICAgICAgIDxnIGlkPSJhbGlnbi1qdXN0aWZ5IiBmaWxsPSIjMDAwMDAwIj4KICAgICAgICAgICAgPGcgaWQ9IkNhcGFfMSI+CiAgICAgICAgICAgICAgICA8ZyBpZD0iR3JvdXAiPgogICAgICAgICAgICAgICAgICAgIDxwYXRoIGQ9Ik0xNC42MTkxMzA0LDE0Ljg4NzgyNjEgTDAuMzI2MDg2OTU3LDE0Ljg4NzgyNjEgQzAuMTQ2MDg2OTU3LDE0Ljg4NzgyNjEgMCwxNC43NDE3MzkxIDAsMTQuNTYxNzM5MSBDMCwxNC4zODE3MzkxIDAuMTQ2MDg2OTU3LDE0LjIzNTY1MjIgMC4zMjYwODY5NTcsMTQuMjM1NjUyMiBMMTQuNjE5MTMwNCwxNC4yMzU2NTIyIEMxNC43OTkxMzA0LDE0LjIzNTY1MjIgMTQuOTQ1MjE3NCwxNC4zODE3MzkxIDE0Ljk0NTIxNzQsMTQuNTYxNzM5MSBDMTQuOTQ1MjE3NCwxNC43NDE3MzkxIDE0Ljc5OTEzMDQsMTQuODg3ODI2MSAxNC42MTkxMzA0LDE0Ljg4NzgyNjEgTDE0LjYxOTEzMDQsMTQuODg3ODI2MSBaIiBpZD0iU2hhcGUiPjwvcGF0aD4KICAgICAgICAgICAgICAgICAgICA8cGF0aCBkPSJNMTQuNjE5MTMwNCwxMC4xNjIxNzM5IEwwLjMyNjA4Njk1NywxMC4xNjIxNzM5IEMwLjE0NjA4Njk1NywxMC4xNjIxNzM5IDAsMTAuMDE2MDg3IDAsOS44MzYwODY5NiBDMCw5LjY1NjA4Njk2IDAuMTQ2MDg2OTU3LDkuNTEgMC4zMjYwODY5NTcsOS41MSBMMTQuNjE5MTMwNCw5LjUxIEMxNC43OTkxMzA0LDkuNTEgMTQuOTQ1MjE3NCw5LjY1NjA4Njk2IDE0Ljk0NTIxNzQsOS44MzYwODY5NiBDMTQuOTQ1MjE3NCwxMC4wMTYwODcgMTQuNzk5MTMwNCwxMC4xNjIxNzM5IDE0LjYxOTEzMDQsMTAuMTYyMTczOSBMMTQuNjE5MTMwNCwxMC4xNjIxNzM5IFoiIGlkPSJTaGFwZSI+PC9wYXRoPgogICAgICAgICAgICAgICAgICAgIDxwYXRoIGQ9Ik0xNC42MTkxMzA0LDUuNDM1ODY5NTcgTDAuMzI2MDg2OTU3LDUuNDM1ODY5NTcgQzAuMTQ2MDg2OTU3LDUuNDM1ODY5NTcgMCw1LjI4OTc4MjYxIDAsNS4xMDk3ODI2MSBDMCw0LjkyOTc4MjYxIDAuMTQ2MDg2OTU3LDQuNzgzNjk1NjUgMC4zMjYwODY5NTcsNC43ODM2OTU2NSBMMTQuNjE5MTMwNCw0Ljc4MzY5NTY1IEMxNC43OTkxMzA0LDQuNzgzNjk1NjUgMTQuOTQ1MjE3NCw0LjkyOTc4MjYxIDE0Ljk0NTIxNzQsNS4xMDk3ODI2MSBDMTQuOTQ1MjE3NCw1LjI4OTc4MjYxIDE0Ljc5OTEzMDQsNS40MzU4Njk1NyAxNC42MTkxMzA0LDUuNDM1ODY5NTcgTDE0LjYxOTEzMDQsNS40MzU4Njk1NyBaIiBpZD0iU2hhcGUiPjwvcGF0aD4KICAgICAgICAgICAgICAgICAgICA8cGF0aCBkPSJNMTQuNjE5MTMwNCwwLjcwOTU2NTIxNyBMMC4zMjYwODY5NTcsMC43MDk1NjUyMTcgQzAuMTQ2MDg2OTU3LDAuNzA5NTY1MjE3IDAsMC41NjM0NzgyNjEgMCwwLjM4MzQ3ODI2MSBDMCwwLjIwMzQ3ODI2MSAwLjE0NjA4Njk1NywwLjA1NzM5MTMwNDMgMC4zMjYwODY5NTcsMC4wNTczOTEzMDQzIEwxNC42MTkxMzA0LDAuMDU3MzkxMzA0MyBDMTQuNzk5MTMwNCwwLjA1NzM5MTMwNDMgMTQuOTQ1MjE3NCwwLjIwMzQ3ODI2MSAxNC45NDUyMTc0LDAuMzgzNDc4MjYxIEMxNC45NDUyMTc0LDAuNTYzNDc4MjYxIDE0Ljc5OTEzMDQsMC43MDk1NjUyMTcgMTQuNjE5MTMwNCwwLjcwOTU2NTIxNyBMMTQuNjE5MTMwNCwwLjcwOTU2NTIxNyBaIiBpZD0iU2hhcGUiPjwvcGF0aD4KICAgICAgICAgICAgICAgIDwvZz4KICAgICAgICAgICAgPC9nPgogICAgICAgIDwvZz4KICAgIDwvZz4KPC9zdmc+"},function(t,e){t.exports="data:image/svg+xml;base64,PD94bWwgdmVyc2lvbj0iMS4wIiBlbmNvZGluZz0iVVRGLTgiIHN0YW5kYWxvbmU9Im5vIj8+Cjxzdmcgd2lkdGg9IjE1cHgiIGhlaWdodD0iMTVweCIgdmlld0JveD0iMCAwIDE1IDE1IiB2ZXJzaW9uPSIxLjEiIHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZyIgeG1sbnM6eGxpbms9Imh0dHA6Ly93d3cudzMub3JnLzE5OTkveGxpbmsiPgogICAgPCEtLSBHZW5lcmF0b3I6IFNrZXRjaCA0MC4zICgzMzgzOSkgLSBodHRwOi8vd3d3LmJvaGVtaWFuY29kaW5nLmNvbS9za2V0Y2ggLS0+CiAgICA8dGl0bGU+Y29sb3I8L3RpdGxlPgogICAgPGRlc2M+Q3JlYXRlZCB3aXRoIFNrZXRjaC48L2Rlc2M+CiAgICA8ZGVmcz48L2RlZnM+CiAgICA8ZyBpZD0iUGFnZS0xIiBzdHJva2U9Im5vbmUiIHN0cm9rZS13aWR0aD0iMSIgZmlsbD0ibm9uZSIgZmlsbC1ydWxlPSJldmVub2RkIj4KICAgICAgICA8ZyBpZD0iY29sb3IiIGZpbGw9IiMwMDAwMDAiPgogICAgICAgICAgICA8ZyBpZD0iQ2FwYV8xIj4KICAgICAgICAgICAgICAgIDxnIGlkPSJHcm91cCI+CiAgICAgICAgICAgICAgICAgICAgPHBhdGggZD0iTTE0LjQwNjM4NzEsMC41ODUyNTgwNjUgQzEzLjYyNjI5MDMsLTAuMTk0ODcwOTY4IDEyLjM2MTQ1MTYsLTAuMTk1MDk2Nzc0IDExLjU4MDgzODcsMC41ODUgTDExLjA0MTU4MDYsMS4xMjQyNTgwNiBDMTAuNzUxOTAzMiwwLjgzNDYxMjkwMyAxMC4yODI3MDk3LDAuODM0NjEyOTAzIDkuOTkzMDY0NTIsMS4xMjQyNTgwNiBDOS43MDMzNTQ4NCwxLjQxMzY3NzQyIDkuNzAzMzU0ODQsMS44ODMzODcxIDkuOTkzMDY0NTIsMi4xNzI4MDY0NSBMMTAuMTY3Nzc0MiwyLjM0NzYxMjkgTDQuMzQyMzU0ODQsOC4xNzM0NTE2MSBMNC4zNDE4Mzg3MSw4LjE3MzQ1MTYxIEwyLjMxOTc0MTk0LDEwLjE5NTc0MTkgQzIuMTU5MDMyMjYsMTAuMzU2NDUxNiAyLjA2NDI5MDMyLDEwLjU3MTQxOTQgMi4wNTQwOTY3NywxMC43OTg0NTE2IEwyLjA0OTI1ODA2LDEwLjkwNjMyMjYgTDIuMDQ5MjU4MDYsMTAuOTA3ODA2NSBMMS45Njc2Nzc0MiwxMi43MzY5Njc3IEMxLjk2NDMyMjU4LDEyLjgyMTkwMzIgMS45OTYxNjEyOSwxMi45MDQyMjU4IDIuMDU2MDMyMjYsMTIuOTY0MzIyNiBDMi4xMTI1MTYxMywxMy4wMjEwNjQ1IDIuMTg5NzQxOTQsMTMuMDUyNjQ1MiAyLjI2OTkwMzIzLDEzLjA1MjY0NTIgQzIuMjc0MjU4MDYsMTMuMDUyNjQ1MiAyLjI3ODU4MDY1LDEzLjA1MjY0NTIgMi4yODM0NTE2MSwxMy4wNTIzODcxIEwzLjI1MzI1ODA2LDEzLjAwOTQ1MTYgTDMuMjUzNzc0MTksMTMuMDA5NDUxNiBMMy44NDQ2Nzc0MiwxMi45ODMxNjEzIEw0LjExMywxMi45NzEzNTQ4IEM0LjQwOTg3MDk3LDEyLjk1ODA2NDUgNC42OTE4Mzg3MSwxMi44MzM5Njc3IDQuOTAyMzIyNTgsMTIuNjIzNzQxOSBMMTIuNjczMjI1OCw0Ljg1MzA2NDUyIEwxMi44MTg1ODA2LDQuOTk4Mzg3MSBDMTIuOTYzNDE5NCw1LjE0MzE2MTI5IDEzLjE1MzE2MTMsNS4yMTU1ODA2NSAxMy4zNDI4Mzg3LDUuMjE1NTgwNjUgQzEzLjUzMjU0ODQsNS4yMTU1ODA2NSAxMy43MjIzMjI2LDUuMTQzMTYxMjkgMTMuODY3MTI5LDQuOTk4Mzg3MSBDMTQuMTU2ODA2NSw0LjcwODkzNTQ4IDE0LjE1NjgwNjUsNC4yMzkyMjU4MSAxMy44NjcxMjksMy45NDk4Mzg3MSBMMTQuNDA2MzU0OCwzLjQxMDU0ODM5IEMxNS4xODY1MTYxLDIuNjMwNDUxNjEgMTUuMTg2NTE2MSwxLjM2NTYxMjkgMTQuNDA2Mzg3MSwwLjU4NTI1ODA2NSBMMTQuNDA2Mzg3MSwwLjU4NTI1ODA2NSBaIE04Ljc5NDgwNjQ1LDcuMzMzMjI1ODEgTDYuMDY1Nzc0MTksNy44NDgwNjQ1MiBMMTAuNTE3MzIyNiwzLjM5NjMyMjU4IEwxMS42MjQ4MDY1LDQuNTAzMjkwMzIgTDguNzk0ODA2NDUsNy4zMzMyMjU4MSBMOC43OTQ4MDY0NSw3LjMzMzIyNTgxIFoiIGlkPSJTaGFwZSI+PC9wYXRoPgogICAgICAgICAgICAgICAgICAgIDxwYXRoIGQ9Ik0yLjA4MDY0NTE2LDEzLjY3MzI5MDMgQzAuOTMxNzA5Njc3LDEzLjY3MzI5MDMgMCwxMy45NjgyOTAzIDAsMTQuMzMyNDgzOSBDMCwxNC42OTY0ODM5IDAuOTMxNzA5Njc3LDE0Ljk5MTQ1MTYgMi4wODA2NDUxNiwxNC45OTE0NTE2IEMzLjIyOTU4MDY1LDE0Ljk5MTQ1MTYgNC4xNjA4Mzg3MSwxNC42OTY1MTYxIDQuMTYwODM4NzEsMTQuMzMyNDgzOSBDNC4xNjA4Mzg3MSwxMy45NjgyNTgxIDMuMjI5NTgwNjUsMTMuNjczMjkwMyAyLjA4MDY0NTE2LDEzLjY3MzI5MDMgTDIuMDgwNjQ1MTYsMTMuNjczMjkwMyBaIiBpZD0iU2hhcGUiPjwvcGF0aD4KICAgICAgICAgICAgICAgIDwvZz4KICAgICAgICAgICAgPC9nPgogICAgICAgIDwvZz4KICAgIDwvZz4KPC9zdmc+"},function(t,e){t.exports="data:image/svg+xml;base64,PD94bWwgdmVyc2lvbj0iMS4wIiBlbmNvZGluZz0idXRmLTgiPz4KPCEtLSBHZW5lcmF0ZWQgYnkgSWNvTW9vbi5pbyAtLT4KPCFET0NUWVBFIHN2ZyBQVUJMSUMgIi0vL1czQy8vRFREIFNWRyAxLjEvL0VOIiAiaHR0cDovL3d3dy53My5vcmcvR3JhcGhpY3MvU1ZHLzEuMS9EVEQvc3ZnMTEuZHRkIj4KPHN2ZyB2ZXJzaW9uPSIxLjEiIHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZyIgeG1sbnM6eGxpbms9Imh0dHA6Ly93d3cudzMub3JnLzE5OTkveGxpbmsiIHdpZHRoPSIxNSIgaGVpZ2h0PSIxNSIgdmlld0JveD0iMCAwIDE2IDE2Ij4KPHBhdGggZmlsbD0iIzAwMDAwMCIgZD0iTTguMSAxNGw2LjQtNy4yYzAuNi0wLjcgMC42LTEuOC0wLjEtMi41bC0yLjctMi43Yy0wLjMtMC40LTAuOC0wLjYtMS4zLTAuNmgtMS44Yy0wLjUgMC0xIDAuMi0xLjQgMC42bC02LjcgNy42Yy0wLjYgMC43LTAuNiAxLjkgMC4xIDIuNWwyLjcgMi43YzAuMyAwLjQgMC44IDAuNiAxLjMgMC42aDExLjR2LTFoLTcuOXpNNi44IDEzLjljMCAwIDAtMC4xIDAgMGwtMi43LTIuN2MtMC40LTAuNC0wLjQtMC45IDAtMS4zbDMuNC0zLjloLTFsLTMgMy4zYy0wLjYgMC43LTAuNiAxLjcgMC4xIDIuNGwyLjMgMi4zaC0xLjNjLTAuMiAwLTAuNC0wLjEtMC42LTAuMmwtMi44LTIuOGMtMC4zLTAuMy0wLjMtMC44IDAtMS4xbDMuNS0zLjloMS44bDMuNS00aDFsLTMuNSA0IDMuMSAzLjctMy41IDRjLTAuMSAwLjEtMC4yIDAuMS0wLjMgMC4yeiI+PC9wYXRoPgo8L3N2Zz4K"},function(t,e){t.exports="data:image/svg+xml;base64,PD94bWwgdmVyc2lvbj0iMS4wIiBlbmNvZGluZz0iVVRGLTgiIHN0YW5kYWxvbmU9Im5vIj8+Cjxzdmcgd2lkdGg9IjE1cHgiIGhlaWdodD0iMTVweCIgdmlld0JveD0iMCAwIDE1IDE1IiB2ZXJzaW9uPSIxLjEiIHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZyIgeG1sbnM6eGxpbms9Imh0dHA6Ly93d3cudzMub3JnLzE5OTkveGxpbmsiPgogICAgPCEtLSBHZW5lcmF0b3I6IFNrZXRjaCA0MC4zICgzMzgzOSkgLSBodHRwOi8vd3d3LmJvaGVtaWFuY29kaW5nLmNvbS9za2V0Y2ggLS0+CiAgICA8dGl0bGU+bGluazwvdGl0bGU+CiAgICA8ZGVzYz5DcmVhdGVkIHdpdGggU2tldGNoLjwvZGVzYz4KICAgIDxkZWZzPjwvZGVmcz4KICAgIDxnIGlkPSJQYWdlLTEiIHN0cm9rZT0ibm9uZSIgc3Ryb2tlLXdpZHRoPSIxIiBmaWxsPSJub25lIiBmaWxsLXJ1bGU9ImV2ZW5vZGQiPgogICAgICAgIDxnIGlkPSJsaW5rIiBmaWxsPSIjMDAwMDAwIj4KICAgICAgICAgICAgPGcgaWQ9IkNhcGFfMSI+CiAgICAgICAgICAgICAgICA8cGF0aCBkPSJNMTMuOTY3LDAuOTUgQzEzLjM1NTUsMC4zMzg1IDEyLjUzOTc1LDAuMDAxNzUgMTEuNjY5NzUsMC4wMDE3NSBDMTAuOCwwLjAwMTc1IDkuOTg0LDAuMzM4NSA5LjM3MjUsMC45NSBMNy4xMDUsMy4yMTc1IEM2LjI4NjI1LDQuMDM2MjUgNiw1LjE4NjUgNi4yMzk3NSw2LjI0IEM2LjAwNDUsNi4xODcgNS43NjIyNSw2LjE1Njc1IDUuNTE0NzUsNi4xNTY3NSBDNC42NDUsNi4xNTY3NSAzLjgyOSw2LjQ5MzUgMy4yMTc3NSw3LjEwNSBMMC45NSw5LjM3Mjc1IEMtMC4zMTY1LDEwLjYzOTI1IC0wLjMxNjUsMTIuNzAwNzUgMC45NSwxMy45NjcyNSBDMS41NjE1LDE0LjU3ODc1IDIuMzc3MjUsMTQuOTE1NSAzLjI0NzI1LDE0LjkxNTUgQzQuMTE3MjUsMTQuOTE1NSA0LjkzMywxNC41Nzg3NSA1LjU0NDUsMTMuOTY3MjUgTDcuODEyLDExLjY5OTc1IEM4LjYzMDc1LDEwLjg4MSA4LjkxNyw5LjczMDc1IDguNjc3MjUsOC42NzcyNSBDOC45MTI1LDguNzMwMjUgOS4xNTQ3NSw4Ljc2MDUgOS40MDIyNSw4Ljc2MDUgQzEwLjI3MjI1LDguNzYwNSAxMS4wODgyNSw4LjQyMzc1IDExLjY5OTUsNy44MTIyNSBMMTMuOTY3MjUsNS41NDQ3NSBDMTUuMjM0LDQuMjc4IDE1LjIzNCwyLjIxNjc1IDEzLjk2NywwLjk1IEwxMy45NjcsMC45NSBaIE03LjEwNSwxMC45OTI1IEw0LjgzNzUsMTMuMjYgQzQuNDE1LDEzLjY4MjUgMy44NSwxMy45MTUyNSAzLjI0NzI1LDEzLjkxNTI1IEMyLjY0NDUsMTMuOTE1MjUgMi4wNzk3NSwxMy42ODI1IDEuNjU3LDEzLjI2IEMwLjc4MDI1LDEyLjM4MyAwLjc4MDI1LDEwLjk1NjUgMS42NTcsMTAuMDc5NSBMMy45MjQ3NSw3LjgxMiBDNC4zNDcyNSw3LjM4OTUgNC45MTIsNy4xNTY3NSA1LjUxNDc1LDcuMTU2NzUgQzUuOTQ1NzUsNy4xNTY3NSA2LjM1NjI1LDcuMjc3NSA2LjcxMDI1LDcuNDk5NzUgTDQuNzcyMjUsOS40Mzc3NSBDNC41NzcsOS42MzMgNC41NzcsOS45NDk1IDQuNzcyMjUsMTAuMTQ0NzUgQzQuODY5NzUsMTAuMjQyNSA0Ljk5Nzc1LDEwLjI5MTI1IDUuMTI1NzUsMTAuMjkxMjUgQzUuMjUzNzUsMTAuMjkxMjUgNS4zODE3NSwxMC4yNDI1IDUuNDc5MjUsMTAuMTQ0NzUgTDcuNDE3NSw4LjIwNjUgQzcuOTYzLDkuMDc1IDcuODYsMTAuMjM3MjUgNy4xMDUsMTAuOTkyNSBMNy4xMDUsMTAuOTkyNSBaIE0xMy4yNiw0LjgzNzUgTDEwLjk5MjI1LDcuMTA1IEMxMC41Njk3NSw3LjUyNzUgMTAuMDA1LDcuNzYwMjUgOS40MDIsNy43NjAyNSBDOC45NzEsNy43NjAyNSA4LjU2MDc1LDcuNjM5NSA4LjIwNjc1LDcuNDE3MjUgTDEwLjE0NDc1LDUuNDc5MjUgQzEwLjM0LDUuMjg0IDEwLjM0LDQuOTY3NSAxMC4xNDQ3NSw0Ljc3MjI1IEM5Ljk0OTc1LDQuNTc3IDkuNjMyNzUsNC41NzcgOS40Mzc3NSw0Ljc3MjI1IEw3LjQ5OTUsNi43MTA1IEM2Ljk1NCw1Ljg0MiA3LjA1Nyw0LjY4IDcuODEyLDMuOTI0NzUgTDEwLjA3OTUsMS42NTcyNSBDMTAuNTAyLDEuMjM0NzUgMTEuMDY3LDEuMDAyIDExLjY2OTc1LDEuMDAyIEMxMi4yNzI3NSwxLjAwMiAxMi44MzcyNSwxLjIzNDc1IDEzLjI2LDEuNjU3MjUgQzEzLjY4Mjc1LDIuMDc5NzUgMTMuOTE1MjUsMi42NDQ1IDEzLjkxNTI1LDMuMjQ3NSBDMTMuOTE1MjUsMy44NTAyNSAxMy42ODI1LDQuNDE1IDEzLjI2LDQuODM3NSBMMTMuMjYsNC44Mzc1IFoiIGlkPSJTaGFwZSI+PC9wYXRoPgogICAgICAgICAgICA8L2c+CiAgICAgICAgPC9nPgogICAgPC9nPgo8L3N2Zz4="},function(t,e){t.exports="data:image/svg+xml;base64,PD94bWwgdmVyc2lvbj0iMS4wIiBlbmNvZGluZz0iVVRGLTgiIHN0YW5kYWxvbmU9Im5vIj8+Cjxzdmcgd2lkdGg9IjE1cHgiIGhlaWdodD0iMTVweCIgdmlld0JveD0iMCAwIDE1IDE1IiB2ZXJzaW9uPSIxLjEiIHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZyIgeG1sbnM6eGxpbms9Imh0dHA6Ly93d3cudzMub3JnLzE5OTkveGxpbmsiPgogICAgPCEtLSBHZW5lcmF0b3I6IFNrZXRjaCA0MC4zICgzMzgzOSkgLSBodHRwOi8vd3d3LmJvaGVtaWFuY29kaW5nLmNvbS9za2V0Y2ggLS0+CiAgICA8dGl0bGU+dW5saW5rPC90aXRsZT4KICAgIDxkZXNjPkNyZWF0ZWQgd2l0aCBTa2V0Y2guPC9kZXNjPgogICAgPGRlZnM+PC9kZWZzPgogICAgPGcgaWQ9IlBhZ2UtMSIgc3Ryb2tlPSJub25lIiBzdHJva2Utd2lkdGg9IjEiIGZpbGw9Im5vbmUiIGZpbGwtcnVsZT0iZXZlbm9kZCI+CiAgICAgICAgPGcgaWQ9InVubGluayIgZmlsbD0iIzAwMDAwMCI+CiAgICAgICAgICAgIDxnIGlkPSJDYXBhXzEiPgogICAgICAgICAgICAgICAgPGcgaWQ9Ikdyb3VwIj4KICAgICAgICAgICAgICAgICAgICA8cGF0aCBkPSJNMTMuOTU2MjcyNywxLjAzNjYzNjM2IEMxMi41NzQwOTA5LC0wLjM0NTU0NTQ1NSAxMC4zMjQ5MDkxLC0wLjM0NSA4Ljk0MjQ1NDU1LDEuMDM2NjM2MzYgTDYuNDM1NTQ1NDUsMy41NDM1NDU0NSBDNi4yMjI1NDU0NSwzLjc1NjU0NTQ1IDYuMjIyNTQ1NDUsNC4xMDE4MTgxOCA2LjQzNTU0NTQ1LDQuMzE0ODE4MTggQzYuNjQ4NTQ1NDUsNC41Mjc4MTgxOCA2Ljk5MzgxODE4LDQuNTI3ODE4MTggNy4yMDY4MTgxOCw0LjMxNDgxODE4IEw5LjcxMzcyNzI3LDEuODA3OTA5MDkgQzEwLjE3NDkwOTEsMS4zNDcgMTAuNzkxMjcyNywxLjA5MjgxODE4IDExLjQ0OTA5MDksMS4wOTI4MTgxOCBDMTIuMTA3MTgxOCwxLjA5MjgxODE4IDEyLjcyMzU0NTUsMS4zNDcgMTMuMTg0NzI3MywxLjgwODE4MTgyIEMxMy42NDU5MDkxLDIuMjY5MzYzNjQgMTMuOTAwMDkwOSwyLjg4NTcyNzI3IDEzLjkwMDA5MDksMy41NDM4MTgxOCBDMTMuOTAwMDkwOSw0LjIwMTYzNjM2IDEzLjY0NTkwOTEsNC44MTggMTMuMTg0NzI3Myw1LjI3OTE4MTgyIEw5LjkwNjgxODE4LDguNTU3OTA5MDkgQzguOTQ5NTQ1NDUsOS41MTQ2MzYzNiA3LjM5MjU0NTQ1LDkuNTE0NjM2MzYgNi40MzUyNzI3Myw4LjU1NzkwOTA5IEM2LjIyMjI3MjczLDguMzQ0OTA5MDkgNS44NzcsOC4zNDQ5MDkwOSA1LjY2NCw4LjU1NzkwOTA5IEM1LjQ1MSw4Ljc3MDkwOTA5IDUuNDUxLDkuMTE2NDU0NTUgNS42NjQsOS4zMjkxODE4MiBDNi4zNTUwOTA5MSwxMC4wMjAyNzI3IDcuMjYzLDEwLjM2NTgxODIgOC4xNzA5MDkwOSwxMC4zNjU4MTgyIEM5LjA3ODgxODE4LDEwLjM2NTgxODIgOS45ODY3MjcyNywxMC4wMjAyNzI3IDEwLjY3NzgxODIsOS4zMjkxODE4MiBMMTMuOTU2MjcyNyw2LjA1MDcyNzI3IEMxNC42MjM2MzY0LDUuMzgzNjM2MzYgMTQuOTkxMjcyNyw0LjQ5MzE4MTgyIDE0Ljk5MTI3MjcsMy41NDM4MTgxOCBDMTQuOTkxMjcyNywyLjU5NDE4MTgyIDE0LjYyMzYzNjQsMS43MDQgMTMuOTU2MjcyNywxLjAzNjYzNjM2IEwxMy45NTYyNzI3LDEuMDM2NjM2MzYgWiIgaWQ9IlNoYXBlIj48L3BhdGg+CiAgICAgICAgICAgICAgICAgICAgPHBhdGggZD0iTTcuMzk5NjM2MzYsMTEuMDY0NTQ1NSBMNS4yNzgzNjM2NCwxMy4xODU4MTgyIEM0LjgxNzE4MTgyLDEzLjY0NyA0LjIwMDgxODE4LDEzLjkwMTE4MTggMy41NDI3MjcyNywxMy45MDExODE4IEMyLjg4NDkwOTA5LDEzLjkwMTE4MTggMi4yNjgyNzI3MywxMy42NDcgMS44MDcwOTA5MSwxMy4xODU4MTgyIEMwLjg1MDA5MDkwOSwxMi4yMjg4MTgyIDAuODUwMDkwOTA5LDEwLjY3MTU0NTUgMS44MDcwOTA5MSw5LjcxNDU0NTQ1IEw0Ljg5MjcyNzI3LDYuNjI4OTA5MDkgQzUuMzUzOTA5MDksNi4xNjggNS45NzAyNzI3Myw1LjkxMzgxODE4IDYuNjI4MzYzNjQsNS45MTM4MTgxOCBDNy4yODYxODE4Miw1LjkxMzgxODE4IDcuOTAyNTQ1NDUsNi4xNjggOC4zNjM3MjcyNyw2LjYyODkwOTA5IEM4LjU3NjcyNzI3LDYuODQxOTA5MDkgOC45MjIsNi44NDE5MDkwOSA5LjEzNSw2LjYyODkwOTA5IEM5LjM0OCw2LjQxNTkwOTA5IDkuMzQ4LDYuMDcwNjM2MzYgOS4xMzUsNS44NTc2MzYzNiBDNy43NTMwOTA5MSw0LjQ3NTcyNzI3IDUuNTAzOTA5MDksNC40NzU0NTQ1NSA0LjEyMTE4MTgyLDUuODU3NjM2MzYgTDEuMDM1NTQ1NDUsOC45NDM1NDU0NSBDMC4zNjg0NTQ1NDUsOS42MTA2MzYzNiAwLjAwMDgxODE4MTgxOCwxMC41MDEwOTA5IDAuMDAwODE4MTgxODE4LDExLjQ1MDQ1NDUgQzAuMDAwODE4MTgxODE4LDEyLjM5OTU0NTUgMC4zNjg0NTQ1NDUsMTMuMjkgMS4wMzU4MTgxOCwxMy45NTcwOTA5IEMxLjcwMjkwOTA5LDE0LjYyNDQ1NDUgMi41OTMzNjM2NCwxNC45OTIwOTA5IDMuNTQyNDU0NTUsMTQuOTkyMDkwOSBDNC40OTE4MTgxOCwxNC45OTIwOTA5IDUuMzgyMjcyNzMsMTQuNjI0NDU0NSA2LjA0OTM2MzY0LDEzLjk1NzA5MDkgTDguMTcwNjM2MzYsMTEuODM1ODE4MiBDOC4zODM2MzYzNiwxMS42MjI4MTgyIDguMzgzNjM2MzYsMTEuMjc3NTQ1NSA4LjE3MDYzNjM2LDExLjA2NDU0NTUgQzcuOTU3NjM2MzYsMTAuODUxNTQ1NSA3LjYxMjYzNjM2LDEwLjg1MTU0NTUgNy4zOTk2MzYzNiwxMS4wNjQ1NDU1IEw3LjM5OTYzNjM2LDExLjA2NDU0NTUgWiIgaWQ9IlNoYXBlIj48L3BhdGg+CiAgICAgICAgICAgICAgICAgICAgPHBhdGggZD0iTTkuMjczNTQ1NDUsMTIuMDAxOTA5MSBDOC45NzI0NTQ1NSwxMi4wMDE5MDkxIDguNzI4MDkwOTEsMTIuMjQ2MjcyNyA4LjcyODA5MDkxLDEyLjU0NzM2MzYgTDguNzI4MDkwOTEsMTQuMTgzNzI3MyBDOC43MjgwOTA5MSwxNC40ODQ4MTgyIDguOTcyNDU0NTUsMTQuNzI5MTgxOCA5LjI3MzU0NTQ1LDE0LjcyOTE4MTggQzkuNTc0NjM2MzYsMTQuNzI5MTgxOCA5LjgxOSwxNC40ODQ4MTgyIDkuODE5LDE0LjE4MzcyNzMgTDkuODE5LDEyLjU0NzM2MzYgQzkuODE5LDEyLjI0NiA5LjU3NDkwOTA5LDEyLjAwMTkwOTEgOS4yNzM1NDU0NSwxMi4wMDE5MDkxIEw5LjI3MzU0NTQ1LDEyLjAwMTkwOTEgWiIgaWQ9IlNoYXBlIj48L3BhdGg+CiAgICAgICAgICAgICAgICAgICAgPHBhdGggZD0iTTExLjIyOTU0NTUsMTEuNjE2MjcyNyBDMTEuMDE2NTQ1NSwxMS40MDMyNzI3IDEwLjY3MTI3MjcsMTEuNDAzMjcyNyAxMC40NTgyNzI3LDExLjYxNjI3MjcgQzEwLjI0NTI3MjcsMTEuODI5MjcyNyAxMC4yNDUyNzI3LDEyLjE3NDU0NTUgMTAuNDU4MjcyNywxMi4zODc1NDU1IEwxMS42MTUxODE4LDEzLjU0NDQ1NDUgQzExLjcyMTgxODIsMTMuNjUxMDkwOSAxMS44NjExODE4LDEzLjcwNDI3MjcgMTIuMDAwODE4MiwxMy43MDQyNzI3IEMxMi4xNDA0NTQ1LDEzLjcwNDI3MjcgMTIuMjc5ODE4MiwxMy42NTEwOTA5IDEyLjM4NjQ1NDUsMTMuNTQ0NDU0NSBDMTIuNTk5NDU0NSwxMy4zMzE0NTQ1IDEyLjU5OTQ1NDUsMTIuOTg2MTgxOCAxMi4zODY0NTQ1LDEyLjc3MzE4MTggTDExLjIyOTU0NTUsMTEuNjE2MjcyNyBMMTEuMjI5NTQ1NSwxMS42MTYyNzI3IFoiIGlkPSJTaGFwZSI+PC9wYXRoPgogICAgICAgICAgICAgICAgICAgIDxwYXRoIGQ9Ik0xMi41MzY3MjczLDkuODIwMDkwOTEgTDEwLjkwMDM2MzYsOS44MjAwOTA5MSBDMTAuNTk5MjcyNyw5LjgyMDA5MDkxIDEwLjM1NDkwOTEsMTAuMDY0NDU0NSAxMC4zNTQ5MDkxLDEwLjM2NTU0NTUgQzEwLjM1NDkwOTEsMTAuNjY2NjM2NCAxMC41OTkyNzI3LDEwLjkxMSAxMC45MDAzNjM2LDEwLjkxMSBMMTIuNTM2NzI3MywxMC45MTEgQzEyLjgzNzgxODIsMTAuOTExIDEzLjA4MjE4MTgsMTAuNjY2NjM2NCAxMy4wODIxODE4LDEwLjM2NTU0NTUgQzEzLjA4MjE4MTgsMTAuMDY0NDU0NSAxMi44MzgwOTA5LDkuODIwMDkwOTEgMTIuNTM2NzI3Myw5LjgyMDA5MDkxIEwxMi41MzY3MjczLDkuODIwMDkwOTEgWiIgaWQ9IlNoYXBlIj48L3BhdGg+CiAgICAgICAgICAgICAgICAgICAgPHBhdGggZD0iTTQuOTA5OTA5MDksMy41NDczNjM2NCBDNS4yMTEsMy41NDczNjM2NCA1LjQ1NTM2MzY0LDMuMzAzIDUuNDU1MzYzNjQsMy4wMDE5MDkwOSBMNS40NTUzNjM2NCwxLjM2NTU0NTQ1IEM1LjQ1NTM2MzY0LDEuMDY0NDU0NTUgNS4yMTEsMC44MjAwOTA5MDkgNC45MDk5MDkwOSwwLjgyMDA5MDkwOSBDNC42MDg4MTgxOCwwLjgyMDA5MDkwOSA0LjM2NDQ1NDU1LDEuMDY0NDU0NTUgNC4zNjQ0NTQ1NSwxLjM2NTU0NTQ1IEw0LjM2NDQ1NDU1LDMuMDAxOTA5MDkgQzQuMzY0NDU0NTUsMy4zMDMgNC42MDg4MTgxOCwzLjU0NzM2MzY0IDQuOTA5OTA5MDksMy41NDczNjM2NCBMNC45MDk5MDkwOSwzLjU0NzM2MzY0IFoiIGlkPSJTaGFwZSI+PC9wYXRoPgogICAgICAgICAgICAgICAgICAgIDxwYXRoIGQ9Ik0yLjg4NzkwOTA5LDMuOTMzIEMyLjk5NDU0NTQ1LDQuMDM5NjM2MzYgMy4xMzM5MDkwOSw0LjA5MjgxODE4IDMuMjczNTQ1NDUsNC4wOTI4MTgxOCBDMy40MTMxODE4Miw0LjA5MjgxODE4IDMuNTUyNTQ1NDUsNC4wMzk2MzYzNiAzLjY1OTE4MTgyLDMuOTMzIEMzLjg3MjE4MTgyLDMuNzIgMy44NzIxODE4MiwzLjM3NDcyNzI3IDMuNjU5MTgxODIsMy4xNjE3MjcyNyBMMi41MDIyNzI3MywyLjAwNDU0NTQ1IEMyLjI4OTI3MjczLDEuNzkxNTQ1NDUgMS45NDQsMS43OTE1NDU0NSAxLjczMSwyLjAwNDU0NTQ1IEMxLjUxOCwyLjIxNzU0NTQ1IDEuNTE4LDIuNTYyODE4MTggMS43MzEsMi43NzU4MTgxOCBMMi44ODc5MDkwOSwzLjkzMyBMMi44ODc5MDkwOSwzLjkzMyBaIiBpZD0iU2hhcGUiPjwvcGF0aD4KICAgICAgICAgICAgICAgICAgICA8cGF0aCBkPSJNMS42Mjc2MzYzNiw1LjcyOTE4MTgyIEwzLjI2NCw1LjcyOTE4MTgyIEMzLjU2NTA5MDkxLDUuNzI5MTgxODIgMy44MDk0NTQ1NSw1LjQ4NDgxODE4IDMuODA5NDU0NTUsNS4xODM3MjcyNyBDMy44MDk0NTQ1NSw0Ljg4MjYzNjM2IDMuNTY1MDkwOTEsNC42MzgyNzI3MyAzLjI2NCw0LjYzODI3MjczIEwxLjYyNzYzNjM2LDQuNjM4MjcyNzMgQzEuMzI2NTQ1NDUsNC42MzgyNzI3MyAxLjA4MjE4MTgyLDQuODgyNjM2MzYgMS4wODIxODE4Miw1LjE4MzcyNzI3IEMxLjA4MjE4MTgyLDUuNDg0ODE4MTggMS4zMjY1NDU0NSw1LjcyOTE4MTgyIDEuNjI3NjM2MzYsNS43MjkxODE4MiBMMS42Mjc2MzYzNiw1LjcyOTE4MTgyIFoiIGlkPSJTaGFwZSI+PC9wYXRoPgogICAgICAgICAgICAgICAgPC9nPgogICAgICAgICAgICA8L2c+CiAgICAgICAgPC9nPgogICAgPC9nPgo8L3N2Zz4="},function(t,e){t.exports="data:image/svg+xml;base64,PD94bWwgdmVyc2lvbj0iMS4wIiBlbmNvZGluZz0idXRmLTgiPz4KPHN2ZyB3aWR0aD0iMTYuOTk5OTgyODMzODYyMzA1IiBoZWlnaHQ9IjE2Ljk5OTk4MDkyNjUxMzY3MiIgdmlld0JveD0iMTUuNzI4OSAyMi4wODI0IDE3IDE3IiB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciPgogIDxnIHRyYW5zZm9ybT0ibWF0cml4KDAuMTY1NTE1OTg5MDY1MTcwMywgMCwgMCwgMC4xNjU1MTU5ODkwNjUxNzAzLCAxNi41ODUwNjc3NDkwMjM0MzgsIDIyLjkzODQyNjk3MTQzNTU0NykiPgogICAgPHBhdGggZD0iTSA3OS4yODUgMTMuMDg0IEMgNjEuMDMxIC01LjE3MiAzMS4zMzIgLTUuMTcyIDEzLjA4MSAxMy4wOCBDIC01LjE3MyAzMS4zMzEgLTUuMTcxIDYxLjAzMSAxMy4wODMgNzkuMjg2IEMgMzEuMzMyIDk3LjUzNyA2MS4wMzEgOTcuNTM3IDc5LjI4MyA3OS4yODMgQyA5Ny41MzYgNjEuMDMxIDk3LjUzNSAzMS4zMzMgNzkuMjg1IDEzLjA4NCBaIE0gNzQuMTc3IDc0LjE3OCBDIDU4Ljc0MSA4OS42MTQgMzMuNjI1IDg5LjYxNiAxOC4xODcgNzQuMTggQyAyLjc0OCA1OC43NDIgMi43NSAzMy42MjIgMTguMTg3IDE4LjE4NiBDIDMzLjYyMyAyLjc1MSA1OC43NCAyLjc0OSA3NC4xNzkgMTguMTg4IEMgODkuNjE1IDMzLjYyMyA4OS42MTMgNTguNzQzIDc0LjE3NyA3NC4xNzggWiBNIDI4LjcyMSAzMy41MTMgQyAyOC43MjEgMzAuNDkyIDMxLjE3MSAyOC4wNDIgMzQuMTkyIDI4LjA0MiBDIDM3LjIxMyAyOC4wNDIgMzkuNjYzIDMwLjQ5MSAzOS42NjMgMzMuNTEzIEMgMzkuNjYzIDM2LjUzNiAzNy4yMTMgMzguOTg2IDM0LjE5MiAzOC45ODYgQyAzMS4xNzEgMzguOTg2IDI4LjcyMSAzNi41MzYgMjguNzIxIDMzLjUxMyBaIE0gNTMuNTMgMzMuNTEzIEMgNTMuNTMgMzAuNDkyIDU1Ljk4MiAyOC4wNDIgNTkuMDA0IDI4LjA0MiBDIDYyLjAyNCAyOC4wNDIgNjQuNDc0IDMwLjQ5MSA2NC40NzQgMzMuNTEzIEMgNjQuNDc0IDM2LjUzNiA2Mi4wMjUgMzguOTg2IDU5LjAwNCAzOC45ODYgQyA1NS45ODIgMzguOTg2IDUzLjUzIDM2LjUzNiA1My41MyAzMy41MTMgWiBNIDY2LjQ2NSA1NS45MjIgQyA2My4wNzUgNjMuNzY0IDU1LjEzNCA2OC44MyA0Ni4yMzYgNjguODMgQyAzNy4xNDcgNjguODMgMjkuMTU5IDYzLjczOCAyNS44ODUgNTUuODU3IEMgMjUuMzI0IDU0LjUwOCAyNS45NjQgNTIuOTU5IDI3LjMxNCA1Mi4zOTcgQyAyNy42NDYgNTIuMjYgMjcuOTkgNTIuMTk2IDI4LjMyOSA1Mi4xOTYgQyAyOS4zNjcgNTIuMTk2IDMwLjM1MiA1Mi44MDggMzAuNzc0IDUzLjgyNyBDIDMzLjIyNCA1OS43MjcgMzkuMjkzIDYzLjUzNyA0Ni4yMzYgNjMuNTM3IEMgNTMuMDIxIDYzLjUzNyA1OS4wNTQgNTkuNzI0IDYxLjYwNiA1My44MjEgQyA2Mi4xODcgNTIuNDggNjMuNzQ1IDUxLjg2MSA2NS4wODcgNTIuNDQyIEMgNjYuNDI3IDUzLjAyNCA2Ny4wNDYgNTQuNTgxIDY2LjQ2NSA1NS45MjIgWiIvPgogIDwvZz4KPC9zdmc+"},function(t,e){t.exports="data:image/svg+xml;base64,PD94bWwgdmVyc2lvbj0iMS4wIiBlbmNvZGluZz0idXRmLTgiPz4KPHN2ZyB3aWR0aD0iMTYuOTk5OTM3MDU3NDk1MTE3IiBoZWlnaHQ9IjE2Ljk5OTkzNzA1NzQ5NTExNyIgdmlld0JveD0iNS44MTI3NmUtNyAzLjA1NDIwZS04IDE2Ljk5OTkgMTYuOTk5OSIgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIj4KICA8ZyB0cmFuc2Zvcm09Im1hdHJpeCgwLjAzMzIwMjk5ODM0MDEyOTg1LCAwLCAwLCAwLjAzMzIwMjk5ODM0MDEyOTg1LCAtMi44NDIxNzA5NDMwNDA0MDFlLTE0LCAwKSI+CiAgICA8Zz4KICAgICAgPHBhdGggZD0iTTIwMi4wNDIsMTk5LjIzOGMtNi45MzgtMi4xMDMtMTQuMjY4LDEuODItMTYuMzcxLDguNzU5bC01NS4xMzgsMTgyLjA0NWMtMi4xMDIsNi45MzgsMS44MiwxNC4yNjgsOC43NTksMTYuMzcmIzEwOyYjOTsmIzk7JiM5O2MxLjI3LDAuMzg1LDIuNTQ5LDAuNTY4LDMuODExLDAuNTY4YzUuNjMzLDAsMTAuODQxLTMuNjU2LDEyLjU2LTkuMzI2bDU1LjEzOC0xODIuMDQ1JiMxMDsmIzk7JiM5OyYjOTtDMjEyLjkwMSwyMDguNjY4LDIwOC45ODEsMjAxLjMzOCwyMDIuMDQyLDE5OS4yMzh6Ii8+CiAgICA8L2c+CiAgPC9nPgogIDxnIHRyYW5zZm9ybT0ibWF0cml4KDAuMDMzMjAyOTk4MzQwMTI5ODUsIDAsIDAsIDAuMDMzMjAyOTk4MzQwMTI5ODUsIC0yLjg0MjE3MDk0MzA0MDQwMWUtMTQsIDApIj4KICAgIDxnPgogICAgICA8cGF0aCBkPSJNMjY4Ljk5NCwxOTkuMjM4Yy02LjkzLTIuMTAzLTE0LjI2OCwxLjgyLTE2LjM3LDguNzU5bC01NS4xMzgsMTgyLjA0NWMtMi4xMDIsNi45MzgsMS44MiwxNC4yNjgsOC43NTksMTYuMzcmIzEwOyYjOTsmIzk7JiM5O2MxLjI2OSwwLjM4NSwyLjU0OSwwLjU2OCwzLjgxMSwwLjU2OGM1LjYzMywwLDEwLjg0MS0zLjY1NiwxMi41Ni05LjMyNmw1NS4xMzgtMTgyLjA0NSYjMTA7JiM5OyYjOTsmIzk7QzI3OS44NTcsMjA4LjY2OCwyNzUuOTM1LDIwMS4zMzgsMjY4Ljk5NCwxOTkuMjM4eiIvPgogICAgPC9nPgogIDwvZz4KICA8ZyB0cmFuc2Zvcm09Im1hdHJpeCgwLjAzMzIwMjk5ODM0MDEyOTg1LCAwLCAwLCAwLjAzMzIwMjk5ODM0MDEyOTg1LCAtMi44NDIxNzA5NDMwNDA0MDFlLTE0LCAwKSI+CiAgICA8Zz4KICAgICAgPHBhdGggZD0iTTQ5OC44NzIsMEgxMy4xMjhDNS44NzgsMCwwLDUuODc5LDAsMTMuMTI4djQ4NS43NDRDMCw1MDYuMTIxLDUuODc4LDUxMiwxMy4xMjgsNTEyaDQ4NS43NDQmIzEwOyYjOTsmIzk7JiM5O2M3LjI0OSwwLDEzLjEyOC01Ljg3OSwxMy4xMjgtMTMuMTI4VjEzLjEyOEM1MTIsNS44NzksNTA2LjEyMSwwLDQ5OC44NzIsMHogTTEwNS4wMjYsMjYuMjU2aDMwMS45NDl2NTIuNTEzSDEwNS4wMjZWMjYuMjU2eiYjMTA7JiM5OyYjOTsmIzk7IE0yNi4yNTYsMjYuMjU2aDUyLjUxM3Y1Mi41MTNIMjYuMjU2VjI2LjI1NnogTTQ4NS43NDQsNDg1Ljc0NEgyNi4yNTZWMTA1LjAyNmg0NTkuNDg3VjQ4NS43NDR6IE00ODUuNzQ0LDc4Ljc2OWgtNTIuNTEzVjI2LjI1NiYjMTA7JiM5OyYjOTsmIzk7aDUyLjUxM1Y3OC43Njl6Ii8+CiAgICA8L2c+CiAgPC9nPgogIDxnIHRyYW5zZm9ybT0ibWF0cml4KDAuMDMzMjAyOTk4MzQwMTI5ODUsIDAsIDAsIDAuMDMzMjAyOTk4MzQwMTI5ODUsIC0yLjg0MjE3MDk0MzA0MDQwMWUtMTQsIDApIj4KICAgIDxnPgogICAgICA8Y2lyY2xlIGN4PSI5My44NjciIGN5PSIyNDUuMDY0IiByPSIxMy4xMjgiLz4KICAgIDwvZz4KICA8L2c+CiAgPGcgdHJhbnNmb3JtPSJtYXRyaXgoMC4wMzMyMDI5OTgzNDAxMjk4NSwgMCwgMCwgMC4wMzMyMDI5OTgzNDAxMjk4NSwgLTIuODQyMTcwOTQzMDQwNDAxZS0xNCwgMCkiPgogICAgPGc+CiAgICAgIDxjaXJjbGUgY3g9IjkzLjg2NyIgY3k9IjM2MC41OTIiIHI9IjEzLjEyOCIvPgogICAgPC9nPgogIDwvZz4KICA8ZyB0cmFuc2Zvcm09Im1hdHJpeCgwLjAzMzIwMjk5ODM0MDEyOTg1LCAwLCAwLCAwLjAzMzIwMjk5ODM0MDEyOTg1LCAtMi44NDIxNzA5NDMwNDA0MDFlLTE0LCAwKSI+CiAgICA8Zz4KICAgICAgPHBhdGggZD0iTTQyOS4yOTIsMzgwLjcxOEgzMDcuMmMtNy4yNDksMC0xMy4xMjgsNS44NzktMTMuMTI4LDEzLjEyOGMwLDcuMjQ5LDUuODc5LDEzLjEyOCwxMy4xMjgsMTMuMTI4aDEyMi4wOTImIzEwOyYjOTsmIzk7JiM5O2M3LjI0OSwwLDEzLjEyOC01Ljg3OSwxMy4xMjgtMTMuMTI4QzQ0Mi40MjEsMzg2LjU5Nyw0MzYuNTQyLDM4MC43MTgsNDI5LjI5MiwzODAuNzE4eiIvPgogICAgPC9nPgogIDwvZz4KICA8ZyB0cmFuc2Zvcm09Im1hdHJpeCgwLjAzMzIwMjk5ODM0MDEyOTg1LCAwLCAwLCAwLjAzMzIwMjk5ODM0MDEyOTg1LCAtMi44NDIxNzA5NDMwNDA0MDFlLTE0LCAwKSIvPgogIDxnIHRyYW5zZm9ybT0ibWF0cml4KDAuMDMzMjAyOTk4MzQwMTI5ODUsIDAsIDAsIDAuMDMzMjAyOTk4MzQwMTI5ODUsIC0yLjg0MjE3MDk0MzA0MDQwMWUtMTQsIDApIi8+CiAgPGcgdHJhbnNmb3JtPSJtYXRyaXgoMC4wMzMyMDI5OTgzNDAxMjk4NSwgMCwgMCwgMC4wMzMyMDI5OTgzNDAxMjk4NSwgLTIuODQyMTcwOTQzMDQwNDAxZS0xNCwgMCkiLz4KICA8ZyB0cmFuc2Zvcm09Im1hdHJpeCgwLjAzMzIwMjk5ODM0MDEyOTg1LCAwLCAwLCAwLjAzMzIwMjk5ODM0MDEyOTg1LCAtMi44NDIxNzA5NDMwNDA0MDFlLTE0LCAwKSIvPgogIDxnIHRyYW5zZm9ybT0ibWF0cml4KDAuMDMzMjAyOTk4MzQwMTI5ODUsIDAsIDAsIDAuMDMzMjAyOTk4MzQwMTI5ODUsIC0yLjg0MjE3MDk0MzA0MDQwMWUtMTQsIDApIi8+CiAgPGcgdHJhbnNmb3JtPSJtYXRyaXgoMC4wMzMyMDI5OTgzNDAxMjk4NSwgMCwgMCwgMC4wMzMyMDI5OTgzNDAxMjk4NSwgLTIuODQyMTcwOTQzMDQwNDAxZS0xNCwgMCkiLz4KICA8ZyB0cmFuc2Zvcm09Im1hdHJpeCgwLjAzMzIwMjk5ODM0MDEyOTg1LCAwLCAwLCAwLjAzMzIwMjk5ODM0MDEyOTg1LCAtMi44NDIxNzA5NDMwNDA0MDFlLTE0LCAwKSIvPgogIDxnIHRyYW5zZm9ybT0ibWF0cml4KDAuMDMzMjAyOTk4MzQwMTI5ODUsIDAsIDAsIDAuMDMzMjAyOTk4MzQwMTI5ODUsIC0yLjg0MjE3MDk0MzA0MDQwMWUtMTQsIDApIi8+CiAgPGcgdHJhbnNmb3JtPSJtYXRyaXgoMC4wMzMyMDI5OTgzNDAxMjk4NSwgMCwgMCwgMC4wMzMyMDI5OTgzNDAxMjk4NSwgLTIuODQyMTcwOTQzMDQwNDAxZS0xNCwgMCkiLz4KICA8ZyB0cmFuc2Zvcm09Im1hdHJpeCgwLjAzMzIwMjk5ODM0MDEyOTg1LCAwLCAwLCAwLjAzMzIwMjk5ODM0MDEyOTg1LCAtMi44NDIxNzA5NDMwNDA0MDFlLTE0LCAwKSIvPgogIDxnIHRyYW5zZm9ybT0ibWF0cml4KDAuMDMzMjAyOTk4MzQwMTI5ODUsIDAsIDAsIDAuMDMzMjAyOTk4MzQwMTI5ODUsIC0yLjg0MjE3MDk0MzA0MDQwMWUtMTQsIDApIi8+CiAgPGcgdHJhbnNmb3JtPSJtYXRyaXgoMC4wMzMyMDI5OTgzNDAxMjk4NSwgMCwgMCwgMC4wMzMyMDI5OTgzNDAxMjk4NSwgLTIuODQyMTcwOTQzMDQwNDAxZS0xNCwgMCkiLz4KICA8ZyB0cmFuc2Zvcm09Im1hdHJpeCgwLjAzMzIwMjk5ODM0MDEyOTg1LCAwLCAwLCAwLjAzMzIwMjk5ODM0MDEyOTg1LCAtMi44NDIxNzA5NDMwNDA0MDFlLTE0LCAwKSIvPgogIDxnIHRyYW5zZm9ybT0ibWF0cml4KDAuMDMzMjAyOTk4MzQwMTI5ODUsIDAsIDAsIDAuMDMzMjAyOTk4MzQwMTI5ODUsIC0yLjg0MjE3MDk0MzA0MDQwMWUtMTQsIDApIi8+CiAgPGcgdHJhbnNmb3JtPSJtYXRyaXgoMC4wMzMyMDI5OTgzNDAxMjk4NSwgMCwgMCwgMC4wMzMyMDI5OTgzNDAxMjk4NSwgLTIuODQyMTcwOTQzMDQwNDAxZS0xNCwgMCkiLz4KPC9zdmc+"},function(t,e){t.exports="data:image/svg+xml;base64,PD94bWwgdmVyc2lvbj0iMS4wIiBlbmNvZGluZz0iVVRGLTgiIHN0YW5kYWxvbmU9Im5vIj8+Cjxzdmcgd2lkdGg9IjE1cHgiIGhlaWdodD0iMTRweCIgdmlld0JveD0iMCAwIDE1IDE0IiB2ZXJzaW9uPSIxLjEiIHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZyIgeG1sbnM6eGxpbms9Imh0dHA6Ly93d3cudzMub3JnLzE5OTkveGxpbmsiPgogICAgPCEtLSBHZW5lcmF0b3I6IFNrZXRjaCA0MC4zICgzMzgzOSkgLSBodHRwOi8vd3d3LmJvaGVtaWFuY29kaW5nLmNvbS9za2V0Y2ggLS0+CiAgICA8dGl0bGU+aW1hZ2U8L3RpdGxlPgogICAgPGRlc2M+Q3JlYXRlZCB3aXRoIFNrZXRjaC48L2Rlc2M+CiAgICA8ZGVmcz48L2RlZnM+CiAgICA8ZyBpZD0iUGFnZS0xIiBzdHJva2U9Im5vbmUiIHN0cm9rZS13aWR0aD0iMSIgZmlsbD0ibm9uZSIgZmlsbC1ydWxlPSJldmVub2RkIj4KICAgICAgICA8ZyBpZD0iaW1hZ2UiIGZpbGw9IiMwMDAwMDAiPgogICAgICAgICAgICA8ZyBpZD0iQ2FwYV8xIj4KICAgICAgICAgICAgICAgIDxnIGlkPSJHcm91cCI+CiAgICAgICAgICAgICAgICAgICAgPHBhdGggZD0iTTE0Ljc0MTM3OTMsMCBMMC4yNTg2MjA2OSwwIEMwLjExNTg2MjA2OSwwIDAsMC4xMzYwNDM0NzggMCwwLjMwNDM0NzgyNiBMMCwxMy42OTU2NTIyIEMwLDEzLjg2Mzk1NjUgMC4xMTU4NjIwNjksMTQgMC4yNTg2MjA2OSwxNCBMMTQuNzQxMzc5MywxNCBDMTQuODg0MTM3OSwxNCAxNSwxMy44NjM5NTY1IDE1LDEzLjY5NTY1MjIgTDE1LDAuMzA0MzQ3ODI2IEMxNSwwLjEzNjA0MzQ3OCAxNC44ODQxMzc5LDAgMTQuNzQxMzc5MywwIEwxNC43NDEzNzkzLDAgWiBNMTQuNDgyNzU4NiwxMy4zOTEzMDQzIEwwLjUxNzI0MTM3OSwxMy4zOTEzMDQzIEwwLjUxNzI0MTM3OSwwLjYwODY5NTY1MiBMMTQuNDgyNzU4NiwwLjYwODY5NTY1MiBMMTQuNDgyNzU4NiwxMy4zOTEzMDQzIEwxNC40ODI3NTg2LDEzLjM5MTMwNDMgWiIgaWQ9IlNoYXBlIj48L3BhdGg+CiAgICAgICAgICAgICAgICAgICAgPHBhdGggZD0iTTQuMTM3OTMxMDMsNi43Mzc2NTIxNyBDNC45MzIxNTUxNyw2LjczNzY1MjE3IDUuNTc4MTg5NjYsNS45NzczOTEzIDUuNTc4MTg5NjYsNS4wNDMwNDM0OCBDNS41NzgxODk2Niw0LjEwODA4Njk2IDQuOTMyMTU1MTcsMy4zNDc4MjYwOSA0LjEzNzkzMTAzLDMuMzQ3ODI2MDkgQzMuMzQzNzA2OSwzLjM0NzgyNjA5IDIuNjk3NjcyNDEsNC4xMDgwODY5NiAyLjY5NzY3MjQxLDUuMDQyNzM5MTMgQzIuNjk3NjcyNDEsNS45NzczOTEzIDMuMzQzNzA2OSw2LjczNzY1MjE3IDQuMTM3OTMxMDMsNi43Mzc2NTIxNyBMNC4xMzc5MzEwMyw2LjczNzY1MjE3IFogTTQuMTM3OTMxMDMsMy45NTY1MjE3NCBDNC42NDY4OTY1NSwzLjk1NjUyMTc0IDUuMDYwOTQ4MjgsNC40NDQwODY5NiA1LjA2MDk0ODI4LDUuMDQyNzM5MTMgQzUuMDYwOTQ4MjgsNS42NDEzOTEzIDQuNjQ2ODk2NTUsNi4xMjg5NTY1MiA0LjEzNzkzMTAzLDYuMTI4OTU2NTIgQzMuNjI4OTY1NTIsNi4xMjg5NTY1MiAzLjIxNDkxMzc5LDUuNjQxNjk1NjUgMy4yMTQ5MTM3OSw1LjA0MzA0MzQ4IEMzLjIxNDkxMzc5LDQuNDQ0MzkxMyAzLjYyODk2NTUyLDMuOTU2NTIxNzQgNC4xMzc5MzEwMywzLjk1NjUyMTc0IEw0LjEzNzkzMTAzLDMuOTU2NTIxNzQgWiIgaWQ9IlNoYXBlIj48L3BhdGg+CiAgICAgICAgICAgICAgICAgICAgPHBhdGggZD0iTTEuODEwMzQ0ODMsMTIuMTczOTEzIEMxLjg3MDg2MjA3LDEyLjE3MzkxMyAxLjkzMTg5NjU1LDEyLjE0ODk1NjUgMS45ODEwMzQ0OCwxMi4wOTgxMzA0IEw2LjE5OTkxMzc5LDcuNzI3MDg2OTYgTDguODY0MjI0MTQsMTAuODYyMTczOSBDOC45NjUzNDQ4MywxMC45ODExNzM5IDkuMTI4NzkzMSwxMC45ODExNzM5IDkuMjI5OTEzNzksMTAuODYyMTczOSBDOS4zMzEwMzQ0OCwxMC43NDMxNzM5IDkuMzMxMDM0NDgsMTAuNTUwODI2MSA5LjIyOTkxMzc5LDEwLjQzMTgyNjEgTDcuOTg2NzI0MTQsOC45Njg4MjYwOSBMMTAuMzYxMTIwNyw1LjkwODkxMzA0IEwxMy4yNzM0NDgzLDkuMDUwNjk1NjUgQzEzLjM3ODcwNjksOS4xNjQyMTczOSAxMy41NDI0MTM4LDkuMTU1Njk1NjUgMTMuNjM4ODc5Myw5LjAzMTgyNjA5IEMxMy43MzUzNDQ4LDguOTA3OTU2NTIgMTMuNzI4MzYyMSw4LjcxNTMwNDM1IDEzLjYyMjg0NDgsOC42MDE3ODI2MSBMMTAuNTE5Mzk2Niw1LjI1Mzk1NjUyIEMxMC40Njg3MDY5LDUuMTk5NDc4MjYgMTAuNDAxMjA2OSw1LjE3MjM5MTMgMTAuMzMzMTg5Nyw1LjE3NDIxNzM5IEMxMC4yNjQ2NTUyLDUuMTc3ODY5NTcgMTAuMiw1LjIxMzQ3ODI2IDEwLjE1MzcwNjksNS4yNzMxMzA0MyBMNy42MjA3NzU4Niw4LjUzNzg2OTU3IEw2LjM5NDEzNzkzLDcuMDk0MzQ3ODMgQzYuMjk3NDEzNzksNi45ODA4MjYwOSA2LjE0Mjc1ODYyLDYuOTc1MDQzNDggNi4wNDAzNDQ4Myw3LjA4MDk1NjUyIEwxLjYzOTM5NjU1LDExLjY0MSBDMS41MzIwNjg5NywxMS43NTIwODcgMS41MjE3MjQxNCwxMS45NDQ0MzQ4IDEuNjE2MTIwNjksMTIuMDcwNzM5MSBDMS42NjczMjc1OSwxMi4xMzkyMTc0IDEuNzM4NzA2OSwxMi4xNzM5MTMgMS44MTAzNDQ4MywxMi4xNzM5MTMgTDEuODEwMzQ0ODMsMTIuMTczOTEzIFoiIGlkPSJTaGFwZSI+PC9wYXRoPgogICAgICAgICAgICAgICAgPC9nPgogICAgICAgICAgICA8L2c+CiAgICAgICAgPC9nPgogICAgPC9nPgo8L3N2Zz4="},function(t,e){t.exports="data:image/svg+xml;base64,PD94bWwgdmVyc2lvbj0iMS4wIiBlbmNvZGluZz0iVVRGLTgiIHN0YW5kYWxvbmU9Im5vIj8+Cjxzdmcgd2lkdGg9IjE0cHgiIGhlaWdodD0iMTdweCIgdmlld0JveD0iMCAwIDE0IDE3IiB2ZXJzaW9uPSIxLjEiIHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZyIgeG1sbnM6eGxpbms9Imh0dHA6Ly93d3cudzMub3JnLzE5OTkveGxpbmsiPgogICAgPCEtLSBHZW5lcmF0b3I6IFNrZXRjaCA0MC4zICgzMzgzOSkgLSBodHRwOi8vd3d3LmJvaGVtaWFuY29kaW5nLmNvbS9za2V0Y2ggLS0+CiAgICA8dGl0bGU+dW5kbzwvdGl0bGU+CiAgICA8ZGVzYz5DcmVhdGVkIHdpdGggU2tldGNoLjwvZGVzYz4KICAgIDxkZWZzPjwvZGVmcz4KICAgIDxnIGlkPSJQYWdlLTEiIHN0cm9rZT0ibm9uZSIgc3Ryb2tlLXdpZHRoPSIxIiBmaWxsPSJub25lIiBmaWxsLXJ1bGU9ImV2ZW5vZGQiPgogICAgICAgIDxnIGlkPSJ1bmRvIiBmaWxsPSIjMDAwMDAwIj4KICAgICAgICAgICAgPGcgaWQ9IkNhcGFfMSI+CiAgICAgICAgICAgICAgICA8cGF0aCBkPSJNNywxNC44NzUgQzkuNjcyMzE3MzEsMTQuODc1IDExLjg0NjE1MzgsMTIuNzMwMjc3MyAxMS44NDYxNTM4LDEwLjA5Mzc1IEMxMS44NDYxNTM4LDcuNDU3MjIyNjYgOS42NzIzMTczMSw1LjMxMjUgNyw1LjMxMjUgTDcsOC41IEwxLjYxNTM4NDYyLDQuMjUgTDcsMCBMNywzLjE4NzUgQzEwLjg1OTY5MjMsMy4xODc1IDE0LDYuMjg1NzgzMiAxNCwxMC4wOTM3NSBDMTQsMTMuOTAxNzUgMTAuODU5NjkyMywxNyA3LDE3IEMzLjE0MDM0MTM1LDE3IDAsMTMuOTAxNzUgMCwxMC4wOTM3NSBMMi4xNTM4NDYxNSwxMC4wOTM3NSBDMi4xNTM4NDYxNSwxMi43MzAyNzczIDQuMzI3NjgyNjksMTQuODc1IDcsMTQuODc1IEw3LDE0Ljg3NSBaIiBpZD0iU2hhcGUiPjwvcGF0aD4KICAgICAgICAgICAgPC9nPgogICAgICAgIDwvZz4KICAgIDwvZz4KPC9zdmc+"},function(t,e){t.exports="data:image/svg+xml;base64,PD94bWwgdmVyc2lvbj0iMS4wIiBlbmNvZGluZz0iVVRGLTgiIHN0YW5kYWxvbmU9Im5vIj8+Cjxzdmcgd2lkdGg9IjEzcHgiIGhlaWdodD0iMTZweCIgdmlld0JveD0iMCAwIDEzIDE2IiB2ZXJzaW9uPSIxLjEiIHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZyIgeG1sbnM6eGxpbms9Imh0dHA6Ly93d3cudzMub3JnLzE5OTkveGxpbmsiPgogICAgPCEtLSBHZW5lcmF0b3I6IFNrZXRjaCA0MC4zICgzMzgzOSkgLSBodHRwOi8vd3d3LmJvaGVtaWFuY29kaW5nLmNvbS9za2V0Y2ggLS0+CiAgICA8dGl0bGU+cmVkbzwvdGl0bGU+CiAgICA8ZGVzYz5DcmVhdGVkIHdpdGggU2tldGNoLjwvZGVzYz4KICAgIDxkZWZzPjwvZGVmcz4KICAgIDxnIGlkPSJQYWdlLTEiIHN0cm9rZT0ibm9uZSIgc3Ryb2tlLXdpZHRoPSIxIiBmaWxsPSJub25lIiBmaWxsLXJ1bGU9ImV2ZW5vZGQiPgogICAgICAgIDxnIGlkPSJyZWRvIiBmaWxsPSIjMDAwMDAwIj4KICAgICAgICAgICAgPGcgaWQ9IkNhcGFfMSI+CiAgICAgICAgICAgICAgICA8cGF0aCBkPSJNNi41MDM1MjE1MiwxMy45NzcyNTEgQzQuMDI2ODczNDIsMTMuOTc3MjUxIDIuMDEyMTY5NjIsMTEuOTYyMTM5OSAyLjAxMjE2OTYyLDkuNDg0NTc2MTMgQzIuMDEyMTY5NjIsNy4wMDcxNDQwMyA0LjAyNjg3MzQyLDQuOTkxODY4MzEgNi41MDM1MjE1Miw0Ljk5MTg2ODMxIEw2LjUwMzUyMTUyLDcuOTg3MDI4ODEgTDExLjQ5Mzg0MywzLjk5MzU0NzMzIEw2LjUwMzUyMTUyLDAgTDYuNTAzNTIxNTIsMi45OTUxNjA0OSBDMi45MjY0ODEwMSwyLjk5NTE2MDQ5IDAuMDE2MTI2NTgyMyw1LjkwNjUwMjA2IDAuMDE2MTI2NTgyMyw5LjQ4NDYwOTA1IEMwLjAxNjEyNjU4MjMsMTMuMDYyOTEzNiAyLjkyNjQ4MTAxLDE1Ljk3NDA5MDUgNi41MDM1MjE1MiwxNS45NzQwOTA1IEMxMC4wODA1NjIsMTUuOTc0MDkwNSAxMi45OTA4MTc3LDEzLjA2MjkxMzYgMTIuOTkwODE3Nyw5LjQ4NDYwOTA1IEwxMC45OTQ5MDYzLDkuNDg0NjA5MDUgQzEwLjk5NDkzOTIsMTEuOTYyMTM5OSA4Ljk4MDE2OTYyLDEzLjk3NzI1MSA2LjUwMzUyMTUyLDEzLjk3NzI1MSBMNi41MDM1MjE1MiwxMy45NzcyNTEgWiIgaWQ9IlNoYXBlIj48L3BhdGg+CiAgICAgICAgICAgIDwvZz4KICAgICAgICA8L2c+CiAgICA8L2c+Cjwvc3ZnPg=="},function(t,e){t.exports="data:image/svg+xml;base64,PD94bWwgdmVyc2lvbj0iMS4wIiBlbmNvZGluZz0idXRmLTgiPz4KPHN2ZyB3aWR0aD0iMTYuOTk5ODQ1NTA0NzYwNzQyIiBoZWlnaHQ9IjE0Ljk5OTg1MjE4MDQ4MDk1NyIgdmlld0JveD0iMC4wMDAwMDIzMzA0MyAxLjY4NzY3ZS03IDE2Ljk5OTggMTQuOTk5OSIgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIj4KICA8ZyB0cmFuc2Zvcm09Im1hdHJpeCgwLjAzNDU2ODAwMDU4NDg0MDc3NSwgMCwgMCwgMC4wMzQxNjkwMDMzNjc0MjQwMSwgMCwgMCkiPgogICAgPHBhdGggZD0iTTM0My4yNzMsMzQwLjgyNGgtODEuMTc5bC05Mi4zNzktMTA4LjM3N0w3OS40MjksMzQwLjgyNEgwbDEzMC44NjQtMTQ4LjE4N0w2LjI5NSw1Mi43OTJIODYuNDNsODYuNzk3LDEwMS4zODgmIzEwOyYjOTsmIzk7bDg3LjQ2MS0xMDEuMzg4aDc2LjYzOUwyMTEuMzUyLDE5Mi42MzdMMzQzLjI3MywzNDAuODI0eiBNMzkzLjE1NCw0MDEuMDZsNTIuODYtNDAuMDM0YzE4LjU0Mi0xMi43MzEsMzAuNzI0LTI0LjU1OSwzNi41NjMtMzUuNDY0JiMxMDsmIzk7JiM5O2M1Ljg0LTEwLjksOC43NDgtMjIuNjIxLDguNzQ4LTM1LjE3NmMwLTIwLjUwNC02Ljg1Ni0zNy4wNTUtMjAuNTU4LTQ5LjY1M2MtMTMuNzAxLTEyLjYwMi0zMS43MjMtMTguODk2LTU0LjA0OC0xOC44OTYmIzEwOyYjOTsmIzk7Yy0yMS41MjEsMC0zOC43NTEsNi4zNzItNTEuNjM2LDE5LjExMmMtMTIuOTIyLDEyLjc1LTE5LjM3LDMxLjk2LTE5LjM3LDU3LjY0OGg0MS41MjNjMC0xNS4zMjcsMi43MTMtMjUuOTI1LDguMTMzLTMxLjgwMSYjMTA7JiM5OyYjOTtjNS40MjYtNS44NzUsMTIuODYyLTguODE4LDIyLjMzMS04LjgxOGM5LjQ2MywwLDE2Ljk0LDIuOTksMjIuNDg0LDguOTYxYzUuNTA5LDUuOTcsOC4yNywxMy4zOTQsOC4yNywyMi4yNiYjMTA7JiM5OyYjOTtjMCw4Ljg1NC0yLjU1NCwxNi44NjktNy42OSwyNC4wMzljLTUuMTMsNy4xNy0xOS4zODEsMTkuMjYzLTQyLjc3NiwzNi4yODZjLTIwLjAyLDE0LjYzNS00Ny4wOTEsMjguNDMxLTU1LjIxOCw0MS4zNjMmIzEwOyYjOTsmIzk7bDAuNDA3LDQ4LjEwM2gxNDguNjAzdi0zNy45MzZoLTk4LjYyN1Y0MDEuMDZ6Ii8+CiAgPC9nPgogIDxnIHRyYW5zZm9ybT0ibWF0cml4KDAuMDM0NTY4MDAwNTg0ODQwNzc1LCAwLCAwLCAwLjAzNDE2OTAwMzM2NzQyNDAxLCAwLCAwKSIvPgogIDxnIHRyYW5zZm9ybT0ibWF0cml4KDAuMDM0NTY4MDAwNTg0ODQwNzc1LCAwLCAwLCAwLjAzNDE2OTAwMzM2NzQyNDAxLCAwLCAwKSIvPgogIDxnIHRyYW5zZm9ybT0ibWF0cml4KDAuMDM0NTY4MDAwNTg0ODQwNzc1LCAwLCAwLCAwLjAzNDE2OTAwMzM2NzQyNDAxLCAwLCAwKSIvPgogIDxnIHRyYW5zZm9ybT0ibWF0cml4KDAuMDM0NTY4MDAwNTg0ODQwNzc1LCAwLCAwLCAwLjAzNDE2OTAwMzM2NzQyNDAxLCAwLCAwKSIvPgogIDxnIHRyYW5zZm9ybT0ibWF0cml4KDAuMDM0NTY4MDAwNTg0ODQwNzc1LCAwLCAwLCAwLjAzNDE2OTAwMzM2NzQyNDAxLCAwLCAwKSIvPgogIDxnIHRyYW5zZm9ybT0ibWF0cml4KDAuMDM0NTY4MDAwNTg0ODQwNzc1LCAwLCAwLCAwLjAzNDE2OTAwMzM2NzQyNDAxLCAwLCAwKSIvPgogIDxnIHRyYW5zZm9ybT0ibWF0cml4KDAuMDM0NTY4MDAwNTg0ODQwNzc1LCAwLCAwLCAwLjAzNDE2OTAwMzM2NzQyNDAxLCAwLCAwKSIvPgogIDxnIHRyYW5zZm9ybT0ibWF0cml4KDAuMDM0NTY4MDAwNTg0ODQwNzc1LCAwLCAwLCAwLjAzNDE2OTAwMzM2NzQyNDAxLCAwLCAwKSIvPgogIDxnIHRyYW5zZm9ybT0ibWF0cml4KDAuMDM0NTY4MDAwNTg0ODQwNzc1LCAwLCAwLCAwLjAzNDE2OTAwMzM2NzQyNDAxLCAwLCAwKSIvPgogIDxnIHRyYW5zZm9ybT0ibWF0cml4KDAuMDM0NTY4MDAwNTg0ODQwNzc1LCAwLCAwLCAwLjAzNDE2OTAwMzM2NzQyNDAxLCAwLCAwKSIvPgogIDxnIHRyYW5zZm9ybT0ibWF0cml4KDAuMDM0NTY4MDAwNTg0ODQwNzc1LCAwLCAwLCAwLjAzNDE2OTAwMzM2NzQyNDAxLCAwLCAwKSIvPgogIDxnIHRyYW5zZm9ybT0ibWF0cml4KDAuMDM0NTY4MDAwNTg0ODQwNzc1LCAwLCAwLCAwLjAzNDE2OTAwMzM2NzQyNDAxLCAwLCAwKSIvPgogIDxnIHRyYW5zZm9ybT0ibWF0cml4KDAuMDM0NTY4MDAwNTg0ODQwNzc1LCAwLCAwLCAwLjAzNDE2OTAwMzM2NzQyNDAxLCAwLCAwKSIvPgogIDxnIHRyYW5zZm9ybT0ibWF0cml4KDAuMDM0NTY4MDAwNTg0ODQwNzc1LCAwLCAwLCAwLjAzNDE2OTAwMzM2NzQyNDAxLCAwLCAwKSIvPgogIDxnIHRyYW5zZm9ybT0ibWF0cml4KDAuMDM0NTY4MDAwNTg0ODQwNzc1LCAwLCAwLCAwLjAzNDE2OTAwMzM2NzQyNDAxLCAwLCAwKSIvPgo8L3N2Zz4="},function(t,e){t.exports="data:image/svg+xml;base64,PD94bWwgdmVyc2lvbj0iMS4wIiBlbmNvZGluZz0idXRmLTgiPz4KPHN2ZyB3aWR0aD0iMTYuOTk5OTMxMzM1NDQ5MjIiIGhlaWdodD0iMTUuMDAwMTk4MzY0MjU3ODEyIiB2aWV3Qm94PSItMC4wMDAwMDQxMjc5NiAyLjI2MjUzZS03IDE2Ljk5OTkgMTUuMDAwMiIgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIj4KICA8ZyB0cmFuc2Zvcm09Im1hdHJpeCgwLjAzNDU2MTAwMDc2NDM2OTk3LCAwLCAwLCAwLjAzMjYyNzAwMTQwNDc2MjI3LCAwLCAwKSI+CiAgICA8cGF0aCBkPSJNMjExLjM1NywzMTEuNTZsMTMxLjkyMiwxNDguMTg4aC04MS4xNzhsLTkyLjM4LTEwOC4zNzlMNzkuNDM1LDQ1OS43NDhIMEwxMzAuODYxLDMxMS41Nkw2LjMwMSwxNzEuNzE0aDgwLjEzNSYjMTA7JiM5OyYjOTtsODYuNzk0LDEwMS4zOTFsODcuNDctMTAxLjM5MWg3Ni42MzlMMjExLjM1NywzMTEuNTZ6IE0zOTEuNzM2LDIxMS4zNmw1NC4zNzMtNDAuMDMzYzE4LjU0Mi0xMi43NDEsMzAuNzI0LTI0LjU2LDM2LjU2My0zNS40NjgmIzEwOyYjOTsmIzk7YzUuODM0LTEwLjkwMiw4Ljc0OC0yMi42MTgsOC43NDgtMzUuMTcyYzAtMjAuNTA4LTYuODU2LTM3LjA2MS0yMC41NTItNDkuNjU2Yy0xMy43MDctMTIuNjAyLTMxLjcyOS0xOC44OTctNTQuMDU0LTE4Ljg5NyYjMTA7JiM5OyYjOTtjLTIxLjUyNywwLTM4Ljc0NSw2LjM3NS01MS42MzcsMTkuMTE1QzM1Mi4yNTgsNjMuOTk2LDM0NS44MSw4My4yMDYsMzQ1LjgxLDEwOC45aDQxLjUyM2MwLTE1LjMzLDIuNzE5LTI1LjkyOCw4LjE0NS0zMS44MDYmIzEwOyYjOTsmIzk7YzUuNDI2LTUuODc5LDEyLjg2MS04LjgxOSwyMi4zMzEtOC44MTljOS40NTcsMCwxNi45MjksMi45OTEsMjIuNDczLDguOTY0YzUuNTIxLDUuOTY3LDguMjc1LDEzLjM4OCw4LjI3NSwyMi4yNTcmIzEwOyYjOTsmIzk7YzAsOC44NTQtMi41NTQsMTYuODY2LTcuNjg1LDI0LjAzOXMtMTkuMzg3LDE5LjI3Mi00Mi43ODIsMzYuMjk4Yy0yMC4wMTQsMTQuNjM1LTQ3LjA5NywyOC40MjItNTUuMjE4LDQxLjM2NGwwLjQwNyw0OC4wOTMmIzEwOyYjOTsmIzk7aDE0OC42MDN2LTM3LjkzSDM5MS43MzZ6Ii8+CiAgPC9nPgogIDxnIHRyYW5zZm9ybT0ibWF0cml4KDAuMDM0NTYxMDAwNzY0MzY5OTcsIDAsIDAsIDAuMDMyNjI3MDAxNDA0NzYyMjcsIDAsIDApIi8+CiAgPGcgdHJhbnNmb3JtPSJtYXRyaXgoMC4wMzQ1NjEwMDA3NjQzNjk5NywgMCwgMCwgMC4wMzI2MjcwMDE0MDQ3NjIyNywgMCwgMCkiLz4KICA8ZyB0cmFuc2Zvcm09Im1hdHJpeCgwLjAzNDU2MTAwMDc2NDM2OTk3LCAwLCAwLCAwLjAzMjYyNzAwMTQwNDc2MjI3LCAwLCAwKSIvPgogIDxnIHRyYW5zZm9ybT0ibWF0cml4KDAuMDM0NTYxMDAwNzY0MzY5OTcsIDAsIDAsIDAuMDMyNjI3MDAxNDA0NzYyMjcsIDAsIDApIi8+CiAgPGcgdHJhbnNmb3JtPSJtYXRyaXgoMC4wMzQ1NjEwMDA3NjQzNjk5NywgMCwgMCwgMC4wMzI2MjcwMDE0MDQ3NjIyNywgMCwgMCkiLz4KICA8ZyB0cmFuc2Zvcm09Im1hdHJpeCgwLjAzNDU2MTAwMDc2NDM2OTk3LCAwLCAwLCAwLjAzMjYyNzAwMTQwNDc2MjI3LCAwLCAwKSIvPgogIDxnIHRyYW5zZm9ybT0ibWF0cml4KDAuMDM0NTYxMDAwNzY0MzY5OTcsIDAsIDAsIDAuMDMyNjI3MDAxNDA0NzYyMjcsIDAsIDApIi8+CiAgPGcgdHJhbnNmb3JtPSJtYXRyaXgoMC4wMzQ1NjEwMDA3NjQzNjk5NywgMCwgMCwgMC4wMzI2MjcwMDE0MDQ3NjIyNywgMCwgMCkiLz4KICA8ZyB0cmFuc2Zvcm09Im1hdHJpeCgwLjAzNDU2MTAwMDc2NDM2OTk3LCAwLCAwLCAwLjAzMjYyNzAwMTQwNDc2MjI3LCAwLCAwKSIvPgogIDxnIHRyYW5zZm9ybT0ibWF0cml4KDAuMDM0NTYxMDAwNzY0MzY5OTcsIDAsIDAsIDAuMDMyNjI3MDAxNDA0NzYyMjcsIDAsIDApIi8+CiAgPGcgdHJhbnNmb3JtPSJtYXRyaXgoMC4wMzQ1NjEwMDA3NjQzNjk5NywgMCwgMCwgMC4wMzI2MjcwMDE0MDQ3NjIyNywgMCwgMCkiLz4KICA8ZyB0cmFuc2Zvcm09Im1hdHJpeCgwLjAzNDU2MTAwMDc2NDM2OTk3LCAwLCAwLCAwLjAzMjYyNzAwMTQwNDc2MjI3LCAwLCAwKSIvPgogIDxnIHRyYW5zZm9ybT0ibWF0cml4KDAuMDM0NTYxMDAwNzY0MzY5OTcsIDAsIDAsIDAuMDMyNjI3MDAxNDA0NzYyMjcsIDAsIDApIi8+CiAgPGcgdHJhbnNmb3JtPSJtYXRyaXgoMC4wMzQ1NjEwMDA3NjQzNjk5NywgMCwgMCwgMC4wMzI2MjcwMDE0MDQ3NjIyNywgMCwgMCkiLz4KICA8ZyB0cmFuc2Zvcm09Im1hdHJpeCgwLjAzNDU2MTAwMDc2NDM2OTk3LCAwLCAwLCAwLjAzMjYyNzAwMTQwNDc2MjI3LCAwLCAwKSIvPgo8L3N2Zz4="},function(t,e,n){"use strict";function r(t){return t&&t.__esModule?t:{default:t}}var o=n(260),i=r(o),a=n(261),s=r(a),u=n(262),c=r(u),l=n(263),f=r(l),p=n(264),d=r(p),g=n(265),M=r(g),h=n(266),y=r(h),m=n(267),I=r(m),w=n(268),D=r(w),N=n(269),v=r(N),C=n(270),j=r(C),z=n(271),T=r(z);t.exports={en:i.default,fr:s.default,zh:c.default,ru:f.default,pt:d.default,ko:M.default,it:y.default,nl:I.default,de:D.default,da:v.default,zh_tw:j.default,pl:T.default}},function(t,e,n){"use strict";t.exports={"generic.add":"Add","generic.cancel":"Cancel","components.controls.blocktype.h1":"H1","components.controls.blocktype.h2":"H2","components.controls.blocktype.h3":"H3","components.controls.blocktype.h4":"H4","components.controls.blocktype.h5":"H5","components.controls.blocktype.h6":"H6","components.controls.blocktype.blockquote":"Blockquote","components.controls.blocktype.code":"Code","components.controls.blocktype.blocktype":"Block Type","components.controls.blocktype.normal":"Normal","components.controls.colorpicker.colorpicker":"Color Picker","components.controls.colorpicker.text":"Text","components.controls.colorpicker.background":"Highlight","components.controls.embedded.embedded":"Embedded","components.controls.embedded.embeddedlink":"Embedded Link","components.controls.embedded.enterlink":"Enter link","components.controls.emoji.emoji":"Emoji","components.controls.fontfamily.fontfamily":"Font","components.controls.fontsize.fontsize":"Font Size","components.controls.history.history":"History","components.controls.history.undo":"Undo","components.controls.history.redo":"Redo","components.controls.image.image":"Image","components.controls.image.fileUpload":"File Upload","components.controls.image.byURL":"URL","components.controls.image.dropFileText":"Drop the file or click to upload","components.controls.inline.bold":"Bold","components.controls.inline.italic":"Italic","components.controls.inline.underline":"Underline","components.controls.inline.strikethrough":"Strikethrough","components.controls.inline.monospace":"Monospace","components.controls.inline.superscript":"Superscript","components.controls.inline.subscript":"Subscript","components.controls.link.linkTitle":"Link Title","components.controls.link.linkTarget":"Link Target","components.controls.link.linkTargetOption":"Open link in new window","components.controls.link.link":"Link","components.controls.link.unlink":"Unlink","components.controls.list.list":"List","components.controls.list.unordered":"Unordered","components.controls.list.ordered":"Ordered","components.controls.list.indent":"Indent","components.controls.list.outdent":"Outdent","components.controls.remove.remove":"Remove","components.controls.textalign.textalign":"Text Align","components.controls.textalign.left":"Left","components.controls.textalign.center":"Center","components.controls.textalign.right":"Right","components.controls.textalign.justify":"Justify"}},function(t,e,n){"use strict";t.exports={"generic.add":"Ok","generic.cancel":"Annuler","components.controls.blocktype.h1":"Titre 1","components.controls.blocktype.h2":"Titre 2","components.controls.blocktype.h3":"Titre 3","components.controls.blocktype.h4":"Titre 4","components.controls.blocktype.h5":"Titre 5","components.controls.blocktype.h6":"Titre 6","components.controls.blocktype.blockquote":"Citation","components.controls.blocktype.code":"Code","components.controls.blocktype.blocktype":"Type bloc","components.controls.blocktype.normal":"Normal","components.controls.colorpicker.colorpicker":"Palette de couleur","components.controls.colorpicker.text":"Texte","components.controls.colorpicker.background":"Fond","components.controls.embedded.embedded":"Embedded","components.controls.embedded.embeddedlink":"Lien iFrame","components.controls.embedded.enterlink":"Entrer le lien","components.controls.emoji.emoji":"Emoji","components.controls.fontfamily.fontfamily":"Police","components.controls.fontsize.fontsize":"Taille de police","components.controls.history.history":"Historique","components.controls.history.undo":"Précédent","components.controls.history.redo":"Suivant","components.controls.image.image":"Image","components.controls.image.fileUpload":"Téléchargement","components.controls.image.byURL":"URL","components.controls.image.dropFileText":"Glisser une image ou cliquer pour télécharger","components.controls.inline.bold":"Gras","components.controls.inline.italic":"Italique","components.controls.inline.underline":"Souligner","components.controls.inline.strikethrough":"Barrer","components.controls.inline.monospace":"Monospace","components.controls.inline.superscript":"Exposant","components.controls.inline.subscript":"Indice","components.controls.link.linkTitle":"Titre du lien","components.controls.link.linkTarget":"Cible du lien","components.controls.link.linkTargetOption":"Ouvrir le lien dans une nouvelle fenêtre","components.controls.link.link":"Lier","components.controls.link.unlink":"Délier","components.controls.list.list":"Liste","components.controls.list.unordered":"Désordonnée","components.controls.list.ordered":"Ordonnée","components.controls.list.indent":"Augmenter le retrait","components.controls.list.outdent":"Diminuer le retrat","components.controls.remove.remove":"Supprimer","components.controls.textalign.textalign":"Alignement du texte","components.controls.textalign.left":"Gauche","components.controls.textalign.center":"Centre","components.controls.textalign.right":"Droite","components.controls.textalign.justify":"Justifier"}},function(t,e,n){"use strict";t.exports={"generic.add":"添加","generic.cancel":"取消","components.controls.blocktype.h1":"标题1","components.controls.blocktype.h2":"标题2","components.controls.blocktype.h3":"标题3","components.controls.blocktype.h4":"标题4","components.controls.blocktype.h5":"标题5","components.controls.blocktype.h6":"标题6","components.controls.blocktype.blockquote":"引用","components.controls.blocktype.code":"源码","components.controls.blocktype.blocktype":"样式","components.controls.blocktype.normal":"正文","components.controls.colorpicker.colorpicker":"选色器","components.controls.colorpicker.text":"文字","components.controls.colorpicker.background":"背景","components.controls.embedded.embedded":"内嵌","components.controls.embedded.embeddedlink":"内嵌网页","components.controls.embedded.enterlink":"输入网页地址","components.controls.emoji.emoji":"表情符号","components.controls.fontfamily.fontfamily":"字体","components.controls.fontsize.fontsize":"字号","components.controls.history.history":"历史","components.controls.history.undo":"撤销","components.controls.history.redo":"恢复","components.controls.image.image":"图片","components.controls.image.fileUpload":"来自文件","components.controls.image.byURL":"在线图片","components.controls.image.dropFileText":"点击或者拖拽文件上传","components.controls.inline.bold":"粗体","components.controls.inline.italic":"斜体","components.controls.inline.underline":"下划线","components.controls.inline.strikethrough":"删除线","components.controls.inline.monospace":"等宽字体","components.controls.inline.superscript":"上标","components.controls.inline.subscript":"下标","components.controls.link.linkTitle":"超链接","components.controls.link.linkTarget":"输入链接地址","components.controls.link.linkTargetOption":"在新窗口中打开链接","components.controls.link.link":"链接","components.controls.link.unlink":"删除链接","components.controls.list.list":"列表","components.controls.list.unordered":"项目符号","components.controls.list.ordered":"编号","components.controls.list.indent":"增加缩进量","components.controls.list.outdent":"减少缩进量","components.controls.remove.remove":"清除格式","components.controls.textalign.textalign":"文本对齐","components.controls.textalign.left":"文本左对齐","components.controls.textalign.center":"居中","components.controls.textalign.right":"文本右对齐","components.controls.textalign.justify":"两端对齐"}},function(t,e,n){"use strict";t.exports={"generic.add":"Добавить","generic.cancel":"Отменить","components.controls.blocktype.h1":"Заголовок 1","components.controls.blocktype.h2":"Заголовок 2","components.controls.blocktype.h3":"Заголовок 3","components.controls.blocktype.h4":"Заголовок 4","components.controls.blocktype.h5":"Заголовок 5","components.controls.blocktype.h6":"Заголовок 6","components.controls.blocktype.blockquote":"Цитата","components.controls.blocktype.code":"Код","components.controls.blocktype.blocktype":"Форматирование","components.controls.blocktype.normal":"Обычный","components.controls.colorpicker.colorpicker":"Выбор цвета","components.controls.colorpicker.text":"Текст","components.controls.colorpicker.background":"Фон","components.controls.embedded.embedded":"Встраивание","components.controls.embedded.embeddedlink":"Ссылка в iFrame","components.controls.embedded.enterlink":"Вставьте ссылку","components.controls.emoji.emoji":"Эмодзи","components.controls.fontfamily.fontfamily":"Шрифт","components.controls.fontsize.fontsize":"Размер шрифта","components.controls.history.history":"История","components.controls.history.undo":"Отменить","components.controls.history.redo":"Вернуть","components.controls.image.image":"Изображение","components.controls.image.fileUpload":"Файлы","components.controls.image.byURL":"URL","components.controls.image.dropFileText":"Переместите в эту область файлы или кликните для загрузки","components.controls.inline.bold":"Жирный","components.controls.inline.italic":"Курсив","components.controls.inline.underline":"Подчеркивание","components.controls.inline.strikethrough":"Зачеркивание","components.controls.inline.monospace":"Monospace","components.controls.inline.superscript":"Верхний индекс","components.controls.inline.subscript":"Нижний индекс","components.controls.link.linkTitle":"Текст","components.controls.link.linkTarget":"Адрес ссылки","components.controls.link.linkTargetOption":"Открывать в новом окне","components.controls.link.link":"Ссылка","components.controls.link.unlink":"Убрать ссылку","components.controls.list.list":"Список","components.controls.list.unordered":"Неупорядоченный","components.controls.list.ordered":"Упорядоченный","components.controls.list.indent":"Отступ","components.controls.list.outdent":"Выступ","components.controls.remove.remove":"Удалить","components.controls.textalign.textalign":"Выравнивание текста","components.controls.textalign.left":"Слева","components.controls.textalign.center":"По центру","components.controls.textalign.right":"Справа","components.controls.textalign.justify":"Выравнить"}},function(t,e,n){"use strict";t.exports={"generic.add":"Ok","generic.cancel":"Cancelar","components.controls.blocktype.h1":"Título 1","components.controls.blocktype.h2":"Título 2","components.controls.blocktype.h3":"Título 3","components.controls.blocktype.h4":"Título 4","components.controls.blocktype.h5":"Título 5","components.controls.blocktype.h6":"Título 6","components.controls.blocktype.blockquote":"Citação","components.controls.blocktype.code":"Code","components.controls.blocktype.blocktype":"Estilo","components.controls.blocktype.normal":"Normal","components.controls.colorpicker.colorpicker":"Paleta de cores","components.controls.colorpicker.text":"Texto","components.controls.colorpicker.background":"Fundo","components.controls.embedded.embedded":"Embarcado","components.controls.embedded.embeddedlink":"Link embarcado","components.controls.embedded.enterlink":"Coloque o link","components.controls.emoji.emoji":"Emoji","components.controls.fontfamily.fontfamily":"Fonte","components.controls.fontsize.fontsize":"Tamanho da Fonte","components.controls.history.history":"Histórico","components.controls.history.undo":"Desfazer","components.controls.history.redo":"Refazer","components.controls.image.image":"Imagem","components.controls.image.fileUpload":"Carregar arquivo","components.controls.image.byURL":"URL","components.controls.image.dropFileText":"Arraste uma imagem aqui ou clique para carregar","components.controls.inline.bold":"Negrito","components.controls.inline.italic":"Itálico","components.controls.inline.underline":"Sublinhado","components.controls.inline.strikethrough":"Strikethrough","components.controls.inline.monospace":"Monospace","components.controls.inline.superscript":"Sobrescrito","components.controls.inline.subscript":"Subscrito","components.controls.link.linkTitle":"Título do link","components.controls.link.linkTarget":"Alvo do link","components.controls.link.linkTargetOption":"Abrir link em outra janela","components.controls.link.link":"Adicionar Link","components.controls.link.unlink":"Remover link","components.controls.list.list":"Lista","components.controls.list.unordered":"Sem ordenção","components.controls.list.ordered":"Ordenada","components.controls.list.indent":"Aumentar recuo","components.controls.list.outdent":"Diminuir recuo","components.controls.remove.remove":"Remover","components.controls.textalign.textalign":"Alinhamento do texto","components.controls.textalign.left":"À Esquerda","components.controls.textalign.center":"Centralizado","components.controls.textalign.right":"À Direita","components.controls.textalign.justify":"Justificado"}},function(t,e,n){"use strict";t.exports={"generic.add":"입력","generic.cancel":"취소","components.controls.blocktype.h1":"제목1","components.controls.blocktype.h2":"제목2","components.controls.blocktype.h3":"제목3","components.controls.blocktype.h4":"제목4","components.controls.blocktype.h5":"제목5","components.controls.blocktype.h6":"제목6","components.controls.blocktype.blockquote":"인용","components.controls.blocktype.code":"Code","components.controls.blocktype.blocktype":"블록","components.controls.blocktype.normal":"표준","components.controls.colorpicker.colorpicker":"색상 선택","components.controls.colorpicker.text":"글꼴색","components.controls.colorpicker.background":"배경색","components.controls.embedded.embedded":"임베드","components.controls.embedded.embeddedlink":"임베드 링크","components.controls.embedded.enterlink":"주소를 입력하세요","components.controls.emoji.emoji":"이모지","components.controls.fontfamily.fontfamily":"글꼴","components.controls.fontsize.fontsize":"글꼴 크기","components.controls.history.history":"히스토리","components.controls.history.undo":"실행 취소","components.controls.history.redo":"다시 실행","components.controls.image.image":"이미지","components.controls.image.fileUpload":"파일 업로드","components.controls.image.byURL":"주소","components.controls.image.dropFileText":"클릭하거나 파일을 드롭하여 업로드하세요","components.controls.inline.bold":"굵게","components.controls.inline.italic":"기울임꼴","components.controls.inline.underline":"밑줄","components.controls.inline.strikethrough":"취소선","components.controls.inline.monospace":"고정 너비","components.controls.inline.superscript":"위 첨자","components.controls.inline.subscript":"아래 첨자","components.controls.link.linkTitle":"링크 제목","components.controls.link.linkTarget":"링크 타겟","components.controls.link.linkTargetOption":"새창으로 열기","components.controls.link.link":"링크","components.controls.link.unlink":"링크 제거","components.controls.list.list":"리스트","components.controls.list.unordered":"일반 리스트","components.controls.list.ordered":"순서 리스트","components.controls.list.indent":"들여쓰기","components.controls.list.outdent":"내어쓰기","components.controls.remove.remove":"삭제","components.controls.textalign.textalign":"텍스트 정렬","components.controls.textalign.left":"왼쪽","components.controls.textalign.center":"중앙","components.controls.textalign.right":"오른쪽","components.controls.textalign.justify":"양쪽"}},function(t,e,n){"use strict";t.exports={"generic.add":"Aggiungi","generic.cancel":"Annulla","components.controls.blocktype.h1":"H1","components.controls.blocktype.h2":"H2","components.controls.blocktype.h3":"H3","components.controls.blocktype.h4":"H4","components.controls.blocktype.h5":"H5","components.controls.blocktype.h6":"H6","components.controls.blocktype.blockquote":"Citazione","components.controls.blocktype.code":"Codice","components.controls.blocktype.blocktype":"Stili","components.controls.blocktype.normal":"Normale","components.controls.colorpicker.colorpicker":"Colore testo","components.controls.colorpicker.text":"Testo","components.controls.colorpicker.background":"Evidenziazione","components.controls.embedded.embedded":"Incorpora","components.controls.embedded.embeddedlink":"Incorpora link","components.controls.embedded.enterlink":"Inserisci link","components.controls.emoji.emoji":"Emoji","components.controls.fontfamily.fontfamily":"Carattere","components.controls.fontsize.fontsize":"Dimensione carattere","components.controls.history.history":"Modifiche","components.controls.history.undo":"Annulla","components.controls.history.redo":"Ripristina","components.controls.image.image":"Immagine","components.controls.image.fileUpload":"Carica immagine","components.controls.image.byURL":"URL","components.controls.image.dropFileText":"Trascina il file o clicca per caricare","components.controls.inline.bold":"Grassetto","components.controls.inline.italic":"Corsivo","components.controls.inline.underline":"Sottolineato","components.controls.inline.strikethrough":"Barrato","components.controls.inline.monospace":"Monospace","components.controls.inline.superscript":"Apice","components.controls.inline.subscript":"Pedice","components.controls.link.linkTitle":"Testo","components.controls.link.linkTarget":"Link","components.controls.link.linkTargetOption":"Apri link in una nuova finestra","components.controls.link.link":"Inserisci link","components.controls.link.unlink":"Rimuovi link","components.controls.list.list":"Lista","components.controls.list.unordered":"Elenco puntato","components.controls.list.ordered":"Elenco numerato","components.controls.list.indent":"Indent","components.controls.list.outdent":"Outdent","components.controls.remove.remove":"Rimuovi formattazione","components.controls.textalign.textalign":"Allineamento del testo","components.controls.textalign.left":"Allinea a sinistra","components.controls.textalign.center":"Allinea al centro","components.controls.textalign.right":"Allinea a destra","components.controls.textalign.justify":"Giustifica"}},function(t,e,n){"use strict";t.exports={"generic.add":"Toevoegen","generic.cancel":"Annuleren","components.controls.blocktype.h1":"H1","components.controls.blocktype.h2":"H2","components.controls.blocktype.h3":"H3","components.controls.blocktype.h4":"H4","components.controls.blocktype.h5":"H5","components.controls.blocktype.h6":"H6","components.controls.blocktype.blockquote":"Blockquote","components.controls.blocktype.code":"Code","components.controls.blocktype.blocktype":"Blocktype","components.controls.blocktype.normal":"Normaal","components.controls.colorpicker.colorpicker":"Kleurkiezer","components.controls.colorpicker.text":"Tekst","components.controls.colorpicker.background":"Achtergrond","components.controls.embedded.embedded":"Ingevoegd","components.controls.embedded.embeddedlink":"Ingevoegde link","components.controls.embedded.enterlink":"Voeg link toe","components.controls.emoji.emoji":"Emoji","components.controls.fontfamily.fontfamily":"Lettertype","components.controls.fontsize.fontsize":"Lettergrootte","components.controls.history.history":"Geschiedenis","components.controls.history.undo":"Ongedaan maken","components.controls.history.redo":"Opnieuw","components.controls.image.image":"Afbeelding","components.controls.image.fileUpload":"Bestand uploaden","components.controls.image.byURL":"URL","components.controls.image.dropFileText":"Drop het bestand hier of klik om te uploaden","components.controls.inline.bold":"Dikgedrukt","components.controls.inline.italic":"Schuingedrukt","components.controls.inline.underline":"Onderstrepen","components.controls.inline.strikethrough":"Doorstrepen","components.controls.inline.monospace":"Monospace","components.controls.inline.superscript":"Superscript","components.controls.inline.subscript":"Subscript","components.controls.link.linkTitle":"Linktitel","components.controls.link.linkTarget":"Link bestemming","components.controls.link.linkTargetOption":"Open link in een nieuw venster","components.controls.link.link":"Link","components.controls.link.unlink":"Unlink","components.controls.list.list":"Lijst","components.controls.list.unordered":"Ongeordend","components.controls.list.ordered":"Geordend","components.controls.list.indent":"Inspringen","components.controls.list.outdent":"Inspringen verkleinen","components.controls.remove.remove":"Verwijderen","components.controls.textalign.textalign":"Tekst uitlijnen","components.controls.textalign.left":"Links","components.controls.textalign.center":"Gecentreerd","components.controls.textalign.right":"Rechts","components.controls.textalign.justify":"Uitgelijnd"}},function(t,e,n){"use strict";t.exports={"generic.add":"Hinzufügen","generic.cancel":"Annullieren","components.controls.blocktype.h1":"H1","components.controls.blocktype.h2":"H2","components.controls.blocktype.h3":"H3","components.controls.blocktype.h4":"H4","components.controls.blocktype.h5":"H5","components.controls.blocktype.h6":"H6","components.controls.blocktype.blockquote":"Blockquote","components.controls.blocktype.code":"Code","components.controls.blocktype.blocktype":"Blocktyp","components.controls.blocktype.normal":"Normal","components.controls.colorpicker.colorpicker":"Farbwähler","components.controls.colorpicker.text":"Text","components.controls.colorpicker.background":"Hintergrund","components.controls.embedded.embedded":"Eingebettet","components.controls.embedded.embeddedlink":"Eingebetteten Link","components.controls.embedded.enterlink":"Link eingeben","components.controls.emoji.emoji":"Emoji","components.controls.fontfamily.fontfamily":"Schriftfamilie","components.controls.fontsize.fontsize":"Schriftgröße","components.controls.history.history":"Geschichte","components.controls.history.undo":"Lösen","components.controls.history.redo":"Wiederholen","components.controls.image.image":"Bild","components.controls.image.fileUpload":"Datei-Upload","components.controls.image.byURL":"URL","components.controls.image.dropFileText":"Drop die Datei oder klicken Sie zum Hochladen","components.controls.inline.bold":"Fett gedruckt","components.controls.inline.italic":"Kursiv gedruckt","components.controls.inline.underline":"Unterstreichen","components.controls.inline.strikethrough":"Durchdringt","components.controls.inline.monospace":"Monospace","components.controls.inline.superscript":"Überschrift","components.controls.inline.subscript":"Unterschrift","components.controls.link.linkTitle":"Link-Titel","components.controls.link.linkTarget":"Link-Ziel","components.controls.link.linkTargetOption":"Link in einem neuen Fenster öffnen","components.controls.link.link":"Link","components.controls.link.unlink":"Aufheben","components.controls.list.list":"Liste","components.controls.list.unordered":"Ungeordnet","components.controls.list.ordered":"Geordnet","components.controls.list.indent":"Einzug","components.controls.list.outdent":"Einzug reduzieren","components.controls.remove.remove":"Entfernen","components.controls.textalign.textalign":"Textausrichtung","components.controls.textalign.left":"Links","components.controls.textalign.center":"Center","components.controls.textalign.right":"Rechts","components.controls.textalign.justify":"Ausgerichtet"}},function(t,e,n){"use strict";t.exports={"generic.add":"Tilføj","generic.cancel":"Annuller","components.controls.blocktype.h1":"Overskrift 1","components.controls.blocktype.h2":"Overskrift 2","components.controls.blocktype.h3":"Overskrift 3","components.controls.blocktype.h4":"Overskrift 4","components.controls.blocktype.h5":"Overskrift 5","components.controls.blocktype.h6":"Overskrift 6","components.controls.blocktype.blockquote":"Blokcitat","components.controls.blocktype.code":"Kode","components.controls.blocktype.blocktype":"Blok Type","components.controls.blocktype.normal":"Normal","components.controls.colorpicker.colorpicker":"Farver","components.controls.colorpicker.text":"Tekst","components.controls.colorpicker.background":"Baggrund","components.controls.embedded.embedded":"Indlejre","components.controls.embedded.embeddedlink":"Indlejre Link","components.controls.embedded.enterlink":"Indtast link","components.controls.emoji.emoji":"Emoji","components.controls.fontfamily.fontfamily":"Fonttype","components.controls.fontsize.fontsize":"Fontstørrelser","components.controls.history.history":"Historie","components.controls.history.undo":"Fortryd","components.controls.history.redo":"Gendan","components.controls.image.image":"Billede","components.controls.image.fileUpload":"Filoverførsel","components.controls.image.byURL":"URL","components.controls.image.dropFileText":"Drop filen eller klik for at uploade","components.controls.inline.bold":"Fed","components.controls.inline.italic":"Kursiv","components.controls.inline.underline":"Understrege","components.controls.inline.strikethrough":"Gennemstreget","components.controls.inline.monospace":"Monospace","components.controls.inline.superscript":"Hævet","components.controls.inline.subscript":"Sænket","components.controls.link.linkTitle":"Link Titel","components.controls.link.linkTarget":"Link Mål","components.controls.link.linkTargetOption":"Åbn link i nyt vindue","components.controls.link.link":"Link","components.controls.link.unlink":"Fjern link","components.controls.list.list":"Liste","components.controls.list.unordered":"Uordnet","components.controls.list.ordered":"Ordnet","components.controls.list.indent":"Indrykning","components.controls.list.outdent":"Udrykning","components.controls.remove.remove":"Fjern","components.controls.textalign.textalign":"Tekstjustering","components.controls.textalign.left":"Venstre","components.controls.textalign.center":"Center","components.controls.textalign.right":"Højre","components.controls.textalign.justify":"Margener"}},function(t,e,n){"use strict";t.exports={"generic.add":"新增","generic.cancel":"取消","components.controls.blocktype.h1":"標題1","components.controls.blocktype.h2":"標題2","components.controls.blocktype.h3":"標題3","components.controls.blocktype.h4":"標題4","components.controls.blocktype.h5":"標題5","components.controls.blocktype.h6":"標題6","components.controls.blocktype.blockquote":"引用","components.controls.blocktype.code":"程式碼","components.controls.blocktype.blocktype":"樣式","components.controls.blocktype.normal":"正文","components.controls.colorpicker.colorpicker":"選色器","components.controls.colorpicker.text":"文字","components.controls.colorpicker.background":"背景","components.controls.embedded.embedded":"內嵌","components.controls.embedded.embeddedlink":"內嵌網頁","components.controls.embedded.enterlink":"輸入網頁地址","components.controls.emoji.emoji":"表情符號","components.controls.fontfamily.fontfamily":"字體","components.controls.fontsize.fontsize":"字體大小","components.controls.history.history":"歷史紀錄","components.controls.history.undo":"復原","components.controls.history.redo":"重做","components.controls.image.image":"圖片","components.controls.image.fileUpload":"檔案上傳","components.controls.image.byURL":"網址","components.controls.image.dropFileText":"點擊或拖曳檔案上傳","components.controls.inline.bold":"粗體","components.controls.inline.italic":"斜體","components.controls.inline.underline":"底線","components.controls.inline.strikethrough":"刪除線","components.controls.inline.monospace":"等寬字體","components.controls.inline.superscript":"上標","components.controls.inline.subscript":"下標","components.controls.link.linkTitle":"超連結","components.controls.link.linkTarget":"輸入連結位址","components.controls.link.linkTargetOption":"在新視窗打開連結","components.controls.link.link":"連結","components.controls.link.unlink":"刪除連結","components.controls.list.list":"列表","components.controls.list.unordered":"項目符號","components.controls.list.ordered":"編號","components.controls.list.indent":"增加縮排","components.controls.list.outdent":"減少縮排","components.controls.remove.remove":"清除格式","components.controls.textalign.textalign":"文字對齊","components.controls.textalign.left":"文字向左對齊","components.controls.textalign.center":"文字置中","components.controls.textalign.right":"文字向右對齊","components.controls.textalign.justify":"兩端對齊"}},function(t,e,n){"use strict";t.exports={"generic.add":"Dodaj","generic.cancel":"Anuluj","components.controls.blocktype.h1":"Nagłówek 1","components.controls.blocktype.h2":"Nagłówek 2","components.controls.blocktype.h3":"Nagłówek 3","components.controls.blocktype.h4":"Nagłówek 4","components.controls.blocktype.h5":"Nagłówek 5","components.controls.blocktype.h6":"Nagłówek 6","components.controls.blocktype.blockquote":"Cytat","components.controls.blocktype.code":"Kod","components.controls.blocktype.blocktype":"Format","components.controls.blocktype.normal":"Normalny","components.controls.colorpicker.colorpicker":"Kolor","components.controls.colorpicker.text":"Tekst","components.controls.colorpicker.background":"Tło","components.controls.embedded.embedded":"Osadź","components.controls.embedded.embeddedlink":"Osadź odnośnik","components.controls.embedded.enterlink":"Wprowadź odnośnik","components.controls.emoji.emoji":"Emoji","components.controls.fontfamily.fontfamily":"Krój czcionki","components.controls.fontsize.fontsize":"Rozmiar czcionki","components.controls.history.history":"Historia","components.controls.history.undo":"Cofnij","components.controls.history.redo":"Ponów","components.controls.image.image":"Obrazek","components.controls.image.fileUpload":"Prześlij plik","components.controls.image.byURL":"URL","components.controls.image.dropFileText":"Upuść plik lub kliknij, aby przesłać","components.controls.inline.bold":"Pogrubienie","components.controls.inline.italic":"Kursywa","components.controls.inline.underline":"Podkreślenie","components.controls.inline.strikethrough":"Przekreślenie","components.controls.inline.monospace":"Monospace","components.controls.inline.superscript":"Indeks górny","components.controls.inline.subscript":"Indeks dolny","components.controls.link.linkTitle":"Tytuł odnośnika","components.controls.link.linkTarget":"Adres odnośnika","components.controls.link.linkTargetOption":"Otwórz odnośnik w nowej karcie","components.controls.link.link":"Wstaw odnośnik","components.controls.link.unlink":"Usuń odnośnik","components.controls.list.list":"Lista","components.controls.list.unordered":"Lista nieuporządkowana","components.controls.list.ordered":"Lista uporządkowana","components.controls.list.indent":"Zwiększ wcięcie","components.controls.list.outdent":"Zmniejsz wcięcie","components.controls.remove.remove":"Usuń","components.controls.textalign.textalign":"Wyrównaj tekst","components.controls.textalign.left":"Do lewej","components.controls.textalign.center":"Do środka","components.controls.textalign.right":"Do prawej","components.controls.textalign.justify":"Wyjustuj"}},function(t,e){t.exports={"rdw-editor-main":"rdw-editor-main","rdw-editor-toolbar":"rdw-editor-toolbar","public-DraftStyleDefault-block":"public-DraftStyleDefault-block","rdw-editor-wrapper":"rdw-editor-wrapper"}},function(t,e){t.exports={"DraftEditor-editorContainer":"DraftEditor-editorContainer","DraftEditor-root":"DraftEditor-root","public-DraftEditor-content":"public-DraftEditor-content","public-DraftEditor-block":"public-DraftEditor-block","DraftEditor-alignLeft":"DraftEditor-alignLeft","public-DraftStyleDefault-block":"public-DraftStyleDefault-block","public-DraftEditorPlaceholder-root":"public-DraftEditorPlaceholder-root","DraftEditor-alignCenter":"DraftEditor-alignCenter","DraftEditor-alignRight":"DraftEditor-alignRight","public-DraftEditorPlaceholder-hasFocus":"public-DraftEditorPlaceholder-hasFocus","DraftEditorPlaceholder-hidden":"DraftEditorPlaceholder-hidden","public-DraftStyleDefault-ltr":"public-DraftStyleDefault-ltr","public-DraftStyleDefault-rtl":"public-DraftStyleDefault-rtl","public-DraftStyleDefault-listLTR":"public-DraftStyleDefault-listLTR","public-DraftStyleDefault-listRTL":"public-DraftStyleDefault-listRTL","public-DraftStyleDefault-ol":"public-DraftStyleDefault-ol","public-DraftStyleDefault-ul":"public-DraftStyleDefault-ul","public-DraftStyleDefault-depth0":"public-DraftStyleDefault-depth0","public-DraftStyleDefault-depth1":"public-DraftStyleDefault-depth1","public-DraftStyleDefault-depth2":"public-DraftStyleDefault-depth2","public-DraftStyleDefault-depth3":"public-DraftStyleDefault-depth3","public-DraftStyleDefault-depth4":"public-DraftStyleDefault-depth4","public-DraftStyleDefault-unorderedListItem":"public-DraftStyleDefault-unorderedListItem","public-DraftStyleDefault-orderedListItem":"public-DraftStyleDefault-orderedListItem","public-DraftStyleDefault-reset":"public-DraftStyleDefault-reset"}},function(t,e,n){"use strict";t.exports=function(t){function e(r){if(n[r])return n[r].exports;var o=n[r]={i:r,l:!1,exports:{}};return t[r].call(o.exports,o,o.exports,e),o.l=!0,o.exports}var n={};return e.m=t,e.c=n,e.d=function(t,n,r){e.o(t,n)||Object.defineProperty(t,n,{configurable:!1,enumerable:!0,get:r})},e.n=function(t){var n=t&&t.__esModule?function(){return t.default}:function(){return t};return e.d(n,"a",n),n},e.o=function(t,e){return Object.prototype.hasOwnProperty.call(t,e)},e.p="",e(e.s=1)}([function(t,e,n){function r(t){return t&&C[t]}function o(t){var e="";return(0,v.forEach)(t,function(t,n){n&&(e+=t+":"+n+";")}),e}function i(t,e){var n=[];if(e)for(var r=0,o=0,i=t,a=e.trigger||"#",s=e.separator||" ";i.length>0&&o>=0;)if(i[0]===a?(o=0,r=0,i=i.substr(a.length)):(o=i.indexOf(s+a))>=0&&(i=i.substr(o+(s+a).length),r+=o+s.length),o>=0){var u=i.indexOf(s)>=0?i.indexOf(s):i.length,c=i.substr(0,u);c&&c.length>0&&n.push({offset:r,length:c.length+a.length,type:"HASHTAG"}),r+=a.length}return n}function a(t,e){var n=[],r=0,o=t.entityRanges.map(function(t){return{offset:t.offset,length:t.length,key:t.key,type:"ENTITY"}});return o=o.concat(i(t.text,e)),o=o.sort(function(t,e){return t.offset-e.offset}),o.forEach(function(t){t.offset>r&&n.push({start:r,end:t.offset}),n.push({start:t.offset,end:t.offset+t.length,entityKey:t.key,type:t.type}),r=t.offset+t.length}),r<t.text.length&&n.push({start:r,end:t.text.length}),n}function s(t){return!!(t.entityRanges.length>0&&(0,v.isEmptyString)(t.text)||"atomic"===t.type)}function u(t){var e=t.text,n=t.inlineStyleRanges,r={BOLD:new Array(e.length),ITALIC:new Array(e.length),UNDERLINE:new Array(e.length),STRIKETHROUGH:new Array(e.length),CODE:new Array(e.length),SUPERSCRIPT:new Array(e.length),SUBSCRIPT:new Array(e.length),COLOR:new Array(e.length),BGCOLOR:new Array(e.length),FONTSIZE:new Array(e.length),FONTFAMILY:new Array(e.length),length:e.length};return n&&n.length>0&&n.forEach(function(t){for(var e=t.offset,n=e+t.length,o=e;o<n;o+=1)0===t.style.indexOf("color-")?r.COLOR[o]=t.style.substring(6):0===t.style.indexOf("bgcolor-")?r.BGCOLOR[o]=t.style.substring(8):0===t.style.indexOf("fontsize-")?r.FONTSIZE[o]=t.style.substring(9):0===t.style.indexOf("fontfamily-")?r.FONTFAMILY[o]=t.style.substring(11):r[t.style]&&(r[t.style][o]=!0)}),r}function c(t,e){var n={};return t.COLOR[e]&&(n.COLOR=t.COLOR[e]),t.BGCOLOR[e]&&(n.BGCOLOR=t.BGCOLOR[e]),t.FONTSIZE[e]&&(n.FONTSIZE=t.FONTSIZE[e]),t.FONTFAMILY[e]&&(n.FONTFAMILY=t.FONTFAMILY[e]),t.UNDERLINE[e]&&(n.UNDERLINE=!0),t.ITALIC[e]&&(n.ITALIC=!0),t.BOLD[e]&&(n.BOLD=!0),t.STRIKETHROUGH[e]&&(n.STRIKETHROUGH=!0),t.CODE[e]&&(n.CODE=!0),t.SUBSCRIPT[e]&&(n.SUBSCRIPT=!0),t.SUPERSCRIPT[e]&&(n.SUPERSCRIPT=!0),n}function l(t,e,n){var r=!0;return n>0&&n<t.length?e.forEach(function(e){r=r&&t[e][n]===t[e][n-1]}):r=!1,r}function f(t,e){return"BOLD"===t?"<strong>"+e+"</strong>":"ITALIC"===t?"<em>"+e+"</em>":"UNDERLINE"===t?"<ins>"+e+"</ins>":"STRIKETHROUGH"===t?"<del>"+e+"</del>":"CODE"===t?"<code>"+e+"</code>":"SUPERSCRIPT"===t?"<sup>"+e+"</sup>":"SUBSCRIPT"===t?"<sub>"+e+"</sub>":e}function p(t){return t&&t.length>0?t.map(function(t){switch(t){case"\n":return"<br>";case"&":return"&amp;";case"<":return"&lt;";case">":return"&gt;";default:return t}}).join(""):""}function d(t,e){if(t&&(t.COLOR||t.BGCOLOR||t.FONTSIZE||t.FONTFAMILY)){var n='style="';return t.COLOR&&(n+="color: "+t.COLOR+";"),t.BGCOLOR&&(n+="background-color: "+t.BGCOLOR+";"),t.FONTSIZE&&(n+="font-size: "+t.FONTSIZE+"px;"),t.FONTFAMILY&&(n+="font-family: "+t.FONTFAMILY+";"),"<span "+(n+='"')+">"+e+"</span>"}return e}function g(t,e,n,r){var o=t[e];if("function"==typeof r){var i=r(o,n);if(i)return i}if("MENTION"===o.type)return'<a href="'+o.data.url+'" class="wysiwyg-mention" data-mention data-value="'+o.data.value+'">'+n+"</a>";if("LINK"===o.type){var a=o.data.target||"_self";return'<a href="'+o.data.url+'" target="'+a+'">'+n+"</a>"}return"IMAGE"===o.type?'<img src="'+o.data.src+'" alt="'+o.data.alt+'" style="float:'+(o.data.alignment||"none")+";height: "+o.data.height+";width: "+o.data.width+'"/>':"EMBEDDED_LINK"===o.type?'<iframe width="'+o.data.width+'" height="'+o.data.height+'" src="'+o.data.src+'" frameBorder="0"></iframe>':n}function M(t,e,n,r){var o=[],i=t.text;if(i.length>0)for(var a=u(t),s=void 0,f=n;f<r;f+=1)f!==n&&l(a,e,f)?(s.text.push(i[f]),s.end=f+1):(s={styles:c(a,f),text:[i[f]],start:f,end:f+1},o.push(s));return o}function h(t){if(t){for(var e=t,n=0;n<e.length&&" "===t[n];n+=1)e=e.replace(" ","&nbsp;");return e}return t}function y(t){if(t){for(var e=t,n=e.length-1;n>=0&&" "===e[n];n-=1)e=e.substring(0,n)+"&nbsp;"+e.substring(n+1);return e}return t}function m(t){var e=t.styles,n=t.text,r=p(n);return(0,v.forEach)(e,function(t,e){r=f(t,r,e)}),r}function I(t,e){var n=M(t,["BOLD","ITALIC","UNDERLINE","STRIKETHROUGH","CODE","SUPERSCRIPT","SUBSCRIPT"],e.start,e.end),r="";return n.forEach(function(t){r+=m(t)}),r=d(e.styles,r)}function w(t,e,n,r){var o=[];M(t,["COLOR","BGCOLOR","FONTSIZE","FONTFAMILY"],n.start,n.end).forEach(function(e){o.push(I(t,e))});var i=o.join("");return"ENTITY"===n.type?void 0!==n.entityKey&&null!==n.entityKey&&(i=g(e,n.entityKey,i,r)):"HASHTAG"===n.type&&(i='<a href="'+i+'" class="wysiwyg-hashtag">'+i+"</a>"),i}function D(t,e,n,r){var o=[],i=a(t,n);return i.forEach(function(n,a){var s=w(t,e,n,r);0===a&&(s=h(s)),a===i.length-1&&(s=y(s)),o.push(s)}),o.join("")}function N(t,e,n,i,a){var u=[];if(s(t))u.push(g(e,t.entityRanges[0].key,void 0,a));else{var c=r(t.type);if(c){u.push("<"+c);var l=o(t.data);l&&u.push(' style="'+l+'"'),i&&u.push(' dir = "auto"'),u.push(">"),u.push(D(t,e,n,a)),u.push("</"+c+">")}}return u.push("\n"),u.join("")}Object.defineProperty(e,"__esModule",{value:!0}),e.getBlockTag=r,e.getBlockStyle=o,e.getStylesAtOffset=c,e.sameStyleAsPrevious=l,e.addInlineStyleMarkup=f,e.addStylePropertyMarkup=d,e.trimLeadingZeros=h,e.trimTrailingZeros=y,e.getBlockInnerMarkup=D,e.getBlockMarkup=N;var v=n(3),C={unstyled:"p","header-one":"h1","header-two":"h2","header-three":"h3","header-four":"h4","header-five":"h5","header-six":"h6","unordered-list-item":"ul","ordered-list-item":"ol",blockquote:"blockquote",code:"pre"}},function(t,e,n){t.exports=n(2)},function(t,e,n){function r(t,e,n,r){var a=[];if(t){var s=t.blocks,u=t.entityMap;if(s&&s.length>0){var c=[];if(s.forEach(function(t){if((0,i.isList)(t.type))c.push(t);else{if(c.length>0){var s=(0,i.getListMarkup)(c,u,e,r);a.push(s),c=[]}var l=(0,o.getBlockMarkup)(t,u,e,n,r);a.push(l)}}),c.length>0){var l=(0,i.getListMarkup)(c,u,e,n,r);a.push(l),c=[]}}}return a.join("")}Object.defineProperty(e,"__esModule",{value:!0}),e.default=r;var o=n(0),i=n(4)},function(t,e,n){function r(t,e){if(t)for(var n in t)({}).hasOwnProperty.call(t,n)&&e(n,t[n])}function o(t){return void 0===t||null===t||0===t.length||0===t.trim().length}Object.defineProperty(e,"__esModule",{value:!0}),e.forEach=r,e.isEmptyString=o},function(t,e,n){function r(t){return"unordered-list-item"===t||"ordered-list-item"===t}function o(t,e,n,r,a){var s=[],u=[],c=void 0;return t.forEach(function(t){var l=!1;if(c?c.type!==t.type?(s.push("</"+(0,i.getBlockTag)(c.type)+">\n"),s.push("<"+(0,i.getBlockTag)(t.type)+">\n")):c.depth===t.depth?u&&u.length>0&&(s.push(o(u,e,n,r,a)),u=[]):(l=!0,u.push(t)):s.push("<"+(0,i.getBlockTag)(t.type)+">\n"),!l){s.push("<li");var f=(0,i.getBlockStyle)(t.data);f&&s.push(' style="'+f+'"'),r&&s.push(' dir = "auto"'),s.push(">"),s.push((0,i.getBlockInnerMarkup)(t,e,n,a)),s.push("</li>\n"),c=t}}),u&&u.length>0&&s.push(o(u,e,n,r,a)),s.push("</"+(0,i.getBlockTag)(c.type)+">\n"),s.join("")}Object.defineProperty(e,"__esModule",{value:!0}),e.isList=r,e.getListMarkup=o;var i=n(0)}])}]);
/*!
 * accounting.js v0.4.2, copyright 2014 Open Exchange Rates, MIT license, http://openexchangerates.github.io/accounting.js
 */

(function(p,z){function q(a){return!!(""===a||a&&a.charCodeAt&&a.substr)}function m(a){return u?u(a):"[object Array]"===v.call(a)}function r(a){return"[object Object]"===v.call(a)}function s(a,b){var d,a=a||{},b=b||{};for(d in b)b.hasOwnProperty(d)&&null==a[d]&&(a[d]=b[d]);return a}function j(a,b,d){var c=[],e,h;if(!a)return c;if(w&&a.map===w)return a.map(b,d);for(e=0,h=a.length;e<h;e++)c[e]=b.call(d,a[e],e,a);return c}function n(a,b){a=Math.round(Math.abs(a));return isNaN(a)?b:a}function x(a){var b=c.settings.currency.format;"function"===typeof a&&(a=a());return q(a)&&a.match("%v")?{pos:a,neg:a.replace("-","").replace("%v","-%v"),zero:a}:!a||!a.pos||!a.pos.match("%v")?!q(b)?b:c.settings.currency.format={pos:b,neg:b.replace("%v","-%v"),zero:b}:a}var c={version:"0.4.1",settings:{currency:{symbol:"$",format:"%s%v",decimal:".",thousand:",",precision:2,grouping:3},number:{precision:0,grouping:3,thousand:",",decimal:"."}}},w=Array.prototype.map,u=Array.isArray,v=Object.prototype.toString,o=c.unformat=c.parse=function(a,b){if(m(a))return j(a,function(a){return o(a,b)});a=a||0;if("number"===typeof a)return a;var b=b||".",c=RegExp("[^0-9-"+b+"]",["g"]),c=parseFloat((""+a).replace(/\((.*)\)/,"-$1").replace(c,"").replace(b,"."));return!isNaN(c)?c:0},y=c.toFixed=function(a,b){var b=n(b,c.settings.number.precision),d=Math.pow(10,b);return(Math.round(c.unformat(a)*d)/d).toFixed(b)},t=c.formatNumber=c.format=function(a,b,d,i){if(m(a))return j(a,function(a){return t(a,b,d,i)});var a=o(a),e=s(r(b)?b:{precision:b,thousand:d,decimal:i},c.settings.number),h=n(e.precision),f=0>a?"-":"",g=parseInt(y(Math.abs(a||0),h),10)+"",l=3<g.length?g.length%3:0;return f+(l?g.substr(0,l)+e.thousand:"")+g.substr(l).replace(/(\d{3})(?=\d)/g,"$1"+e.thousand)+(h?e.decimal+y(Math.abs(a),h).split(".")[1]:"")},A=c.formatMoney=function(a,b,d,i,e,h){if(m(a))return j(a,function(a){return A(a,b,d,i,e,h)});var a=o(a),f=s(r(b)?b:{symbol:b,precision:d,thousand:i,decimal:e,format:h},c.settings.currency),g=x(f.format);return(0<a?g.pos:0>a?g.neg:g.zero).replace("%s",f.symbol).replace("%v",t(Math.abs(a),n(f.precision),f.thousand,f.decimal))};c.formatColumn=function(a,b,d,i,e,h){if(!a)return[];var f=s(r(b)?b:{symbol:b,precision:d,thousand:i,decimal:e,format:h},c.settings.currency),g=x(f.format),l=g.pos.indexOf("%s")<g.pos.indexOf("%v")?!0:!1,k=0,a=j(a,function(a){if(m(a))return c.formatColumn(a,f);a=o(a);a=(0<a?g.pos:0>a?g.neg:g.zero).replace("%s",f.symbol).replace("%v",t(Math.abs(a),n(f.precision),f.thousand,f.decimal));if(a.length>k)k=a.length;return a});return j(a,function(a){return q(a)&&a.length<k?l?a.replace(f.symbol,f.symbol+Array(k-a.length+1).join(" ")):Array(k-a.length+1).join(" ")+a:a})};if("undefined"!==typeof exports){if("undefined"!==typeof module&&module.exports)exports=module.exports=c;exports.accounting=c}else"function"===typeof define&&define.amd?define([],function(){return c}):(c.noConflict=function(a){return function(){p.accounting=a;c.noConflict=z;return c}}(p.accounting),p.accounting=c)})(this);
/*! selectize.js - v0.12.6 | https://github.com/selectize/selectize.js | Apache License (v2) */


!function(a,b){"function"==typeof define&&define.amd?define("sifter",b):"object"==typeof exports?module.exports=b():a.Sifter=b()}(this,function(){var a=function(a,b){this.items=a,this.settings=b||{diacritics:!0}};a.prototype.tokenize=function(a){if(!(a=e(String(a||"").toLowerCase()))||!a.length)return[];var b,c,d,g,i=[],j=a.split(/ +/);for(b=0,c=j.length;b<c;b++){if(d=f(j[b]),this.settings.diacritics)for(g in h)h.hasOwnProperty(g)&&(d=d.replace(new RegExp(g,"g"),h[g]));i.push({string:j[b],regex:new RegExp(d,"i")})}return i},a.prototype.iterator=function(a,b){var c;c=g(a)?Array.prototype.forEach||function(a){for(var b=0,c=this.length;b<c;b++)a(this[b],b,this)}:function(a){for(var b in this)this.hasOwnProperty(b)&&a(this[b],b,this)},c.apply(a,[b])},a.prototype.getScoreFunction=function(a,b){var c,e,f,g,h;c=this,a=c.prepareSearch(a,b),f=a.tokens,e=a.options.fields,g=f.length,h=a.options.nesting;var i=function(a,b){var c,d;return a?(a=String(a||""),-1===(d=a.search(b.regex))?0:(c=b.string.length/a.length,0===d&&(c+=.5),c)):0},j=function(){var a=e.length;return a?1===a?function(a,b){return i(d(b,e[0],h),a)}:function(b,c){for(var f=0,g=0;f<a;f++)g+=i(d(c,e[f],h),b);return g/a}:function(){return 0}}();return g?1===g?function(a){return j(f[0],a)}:"and"===a.options.conjunction?function(a){for(var b,c=0,d=0;c<g;c++){if((b=j(f[c],a))<=0)return 0;d+=b}return d/g}:function(a){for(var b=0,c=0;b<g;b++)c+=j(f[b],a);return c/g}:function(){return 0}},a.prototype.getSortFunction=function(a,c){var e,f,g,h,i,j,k,l,m,n,o;if(g=this,a=g.prepareSearch(a,c),o=!a.query&&c.sort_empty||c.sort,m=function(a,b){return"$score"===a?b.score:d(g.items[b.id],a,c.nesting)},i=[],o)for(e=0,f=o.length;e<f;e++)(a.query||"$score"!==o[e].field)&&i.push(o[e]);if(a.query){for(n=!0,e=0,f=i.length;e<f;e++)if("$score"===i[e].field){n=!1;break}n&&i.unshift({field:"$score",direction:"desc"})}else for(e=0,f=i.length;e<f;e++)if("$score"===i[e].field){i.splice(e,1);break}for(l=[],e=0,f=i.length;e<f;e++)l.push("desc"===i[e].direction?-1:1);return j=i.length,j?1===j?(h=i[0].field,k=l[0],function(a,c){return k*b(m(h,a),m(h,c))}):function(a,c){var d,e,f;for(d=0;d<j;d++)if(f=i[d].field,e=l[d]*b(m(f,a),m(f,c)))return e;return 0}:null},a.prototype.prepareSearch=function(a,b){if("object"==typeof a)return a;b=c({},b);var d=b.fields,e=b.sort,f=b.sort_empty;return d&&!g(d)&&(b.fields=[d]),e&&!g(e)&&(b.sort=[e]),f&&!g(f)&&(b.sort_empty=[f]),{options:b,query:String(a||"").toLowerCase(),tokens:this.tokenize(a),total:0,items:[]}},a.prototype.search=function(a,b){var c,d,e,f,g=this;return d=this.prepareSearch(a,b),b=d.options,a=d.query,f=b.score||g.getScoreFunction(d),a.length?g.iterator(g.items,function(a,e){c=f(a),(!1===b.filter||c>0)&&d.items.push({score:c,id:e})}):g.iterator(g.items,function(a,b){d.items.push({score:1,id:b})}),e=g.getSortFunction(d,b),e&&d.items.sort(e),d.total=d.items.length,"number"==typeof b.limit&&(d.items=d.items.slice(0,b.limit)),d};var b=function(a,b){return"number"==typeof a&&"number"==typeof b?a>b?1:a<b?-1:0:(a=i(String(a||"")),b=i(String(b||"")),a>b?1:b>a?-1:0)},c=function(a,b){var c,d,e,f;for(c=1,d=arguments.length;c<d;c++)if(f=arguments[c])for(e in f)f.hasOwnProperty(e)&&(a[e]=f[e]);return a},d=function(a,b,c){if(a&&b){if(!c)return a[b];for(var d=b.split(".");d.length&&(a=a[d.shift()]););return a}},e=function(a){return(a+"").replace(/^\s+|\s+$|/g,"")},f=function(a){return(a+"").replace(/([.?*+^$[\]\\(){}|-])/g,"\\$1")},g=Array.isArray||"undefined"!=typeof $&&$.isArray||function(a){return"[object Array]"===Object.prototype.toString.call(a)},h={a:"[aḀḁĂăÂâǍǎȺⱥȦȧẠạÄäÀàÁáĀāÃãÅåąĄÃąĄ]",b:"[b␢βΒB฿𐌁ᛒ]",c:"[cĆćĈĉČčĊċC̄c̄ÇçḈḉȻȼƇƈɕᴄＣｃ]",d:"[dĎďḊḋḐḑḌḍḒḓḎḏĐđD̦d̦ƉɖƊɗƋƌᵭᶁᶑȡᴅＤｄð]",e:"[eÉéÈèÊêḘḙĚěĔĕẼẽḚḛẺẻĖėËëĒēȨȩĘęᶒɆɇȄȅẾếỀềỄễỂểḜḝḖḗḔḕȆȇẸẹỆệⱸᴇＥｅɘǝƏƐε]",f:"[fƑƒḞḟ]",g:"[gɢ₲ǤǥĜĝĞğĢģƓɠĠġ]",h:"[hĤĥĦħḨḩẖẖḤḥḢḣɦʰǶƕ]",i:"[iÍíÌìĬĭÎîǏǐÏïḮḯĨĩĮįĪīỈỉȈȉȊȋỊịḬḭƗɨɨ̆ᵻᶖİiIıɪＩｉ]",j:"[jȷĴĵɈɉʝɟʲ]",k:"[kƘƙꝀꝁḰḱǨǩḲḳḴḵκϰ₭]",l:"[lŁłĽľĻļĹĺḶḷḸḹḼḽḺḻĿŀȽƚⱠⱡⱢɫɬᶅɭȴʟＬｌ]",n:"[nŃńǸǹŇňÑñṄṅŅņṆṇṊṋṈṉN̈n̈ƝɲȠƞᵰᶇɳȵɴＮｎŊŋ]",o:"[oØøÖöÓóÒòÔôǑǒŐőŎŏȮȯỌọƟɵƠơỎỏŌōÕõǪǫȌȍՕօ]",p:"[pṔṕṖṗⱣᵽƤƥᵱ]",q:"[qꝖꝗʠɊɋꝘꝙq̃]",r:"[rŔŕɌɍŘřŖŗṘṙȐȑȒȓṚṛⱤɽ]",s:"[sŚśṠṡṢṣꞨꞩŜŝŠšŞşȘșS̈s̈]",t:"[tŤťṪṫŢţṬṭƮʈȚțṰṱṮṯƬƭ]",u:"[uŬŭɄʉỤụÜüÚúÙùÛûǓǔŰűŬŭƯưỦủŪūŨũŲųȔȕ∪]",v:"[vṼṽṾṿƲʋꝞꝟⱱʋ]",w:"[wẂẃẀẁŴŵẄẅẆẇẈẉ]",x:"[xẌẍẊẋχ]",y:"[yÝýỲỳŶŷŸÿỸỹẎẏỴỵɎɏƳƴ]",z:"[zŹźẐẑŽžŻżẒẓẔẕƵƶ]"},i=function(){var a,b,c,d,e="",f={};for(c in h)if(h.hasOwnProperty(c))for(d=h[c].substring(2,h[c].length-1),e+=d,a=0,b=d.length;a<b;a++)f[d.charAt(a)]=c;var g=new RegExp("["+e+"]","g");return function(a){return a.replace(g,function(a){return f[a]}).toLowerCase()}}();return a}),function(a,b){"function"==typeof define&&define.amd?define("microplugin",b):"object"==typeof exports?module.exports=b():a.MicroPlugin=b()}(this,function(){var a={};a.mixin=function(a){a.plugins={},a.prototype.initializePlugins=function(a){var c,d,e,f=this,g=[];if(f.plugins={names:[],settings:{},requested:{},loaded:{}},b.isArray(a))for(c=0,d=a.length;c<d;c++)"string"==typeof a[c]?g.push(a[c]):(f.plugins.settings[a[c].name]=a[c].options,g.push(a[c].name));else if(a)for(e in a)a.hasOwnProperty(e)&&(f.plugins.settings[e]=a[e],g.push(e));for(;g.length;)f.require(g.shift())},a.prototype.loadPlugin=function(b){var c=this,d=c.plugins,e=a.plugins[b];if(!a.plugins.hasOwnProperty(b))throw new Error('Unable to find "'+b+'" plugin');d.requested[b]=!0,d.loaded[b]=e.fn.apply(c,[c.plugins.settings[b]||{}]),d.names.push(b)},a.prototype.require=function(a){var b=this,c=b.plugins;if(!b.plugins.loaded.hasOwnProperty(a)){if(c.requested[a])throw new Error('Plugin has circular dependency ("'+a+'")');b.loadPlugin(a)}return c.loaded[a]},a.define=function(b,c){a.plugins[b]={name:b,fn:c}}};var b={isArray:Array.isArray||function(a){return"[object Array]"===Object.prototype.toString.call(a)}};return a}),function(a,b){"function"==typeof define&&define.amd?define("selectize",["jquery","sifter","microplugin"],b):"object"==typeof exports?module.exports=b(require("jquery"),require("sifter"),require("microplugin")):a.Selectize=b(a.jQuery,a.Sifter,a.MicroPlugin)}(this,function(a,b,c){"use strict";var d=function(a,b){if("string"!=typeof b||b.length){var c="string"==typeof b?new RegExp(b,"i"):b,d=function(a){var b=0;if(3===a.nodeType){var e=a.data.search(c);if(e>=0&&a.data.length>0){var f=a.data.match(c),g=document.createElement("span");g.className="highlight";var h=a.splitText(e),i=(h.splitText(f[0].length),h.cloneNode(!0));g.appendChild(i),h.parentNode.replaceChild(g,h),b=1}}else if(1===a.nodeType&&a.childNodes&&!/(script|style)/i.test(a.tagName)&&("highlight"!==a.className||"SPAN"!==a.tagName))for(var j=0;j<a.childNodes.length;++j)j+=d(a.childNodes[j]);return b};return a.each(function(){d(this)})}};a.fn.removeHighlight=function(){return this.find("span.highlight").each(function(){this.parentNode.firstChild.nodeName;var a=this.parentNode;a.replaceChild(this.firstChild,this),a.normalize()}).end()};var e=function(){};e.prototype={on:function(a,b){this._events=this._events||{},this._events[a]=this._events[a]||[],this._events[a].push(b)},off:function(a,b){var c=arguments.length;return 0===c?delete this._events:1===c?delete this._events[a]:(this._events=this._events||{},void(a in this._events!=!1&&this._events[a].splice(this._events[a].indexOf(b),1)))},trigger:function(a){if(this._events=this._events||{},a in this._events!=!1)for(var b=0;b<this._events[a].length;b++)this._events[a][b].apply(this,Array.prototype.slice.call(arguments,1))}},e.mixin=function(a){for(var b=["on","off","trigger"],c=0;c<b.length;c++)a.prototype[b[c]]=e.prototype[b[c]]};var f=/Mac/.test(navigator.userAgent),g=f?91:17,h=f?18:17,i=!/android/i.test(window.navigator.userAgent)&&!!document.createElement("input").validity,j=function(a){return void 0!==a},k=function(a){return void 0===a||null===a?null:"boolean"==typeof a?a?"1":"0":a+""},l=function(a){return(a+"").replace(/&/g,"&amp;").replace(/</g,"&lt;").replace(/>/g,"&gt;").replace(/"/g,"&quot;")},m={};m.before=function(a,b,c){var d=a[b];a[b]=function(){return c.apply(a,arguments),d.apply(a,arguments)}},m.after=function(a,b,c){var d=a[b];a[b]=function(){var b=d.apply(a,arguments);return c.apply(a,arguments),b}};var n=function(a){var b=!1;return function(){b||(b=!0,a.apply(this,arguments))}},o=function(a,b){var c;return function(){var d=this,e=arguments;window.clearTimeout(c),c=window.setTimeout(function(){a.apply(d,e)},b)}},p=function(a,b,c){var d,e=a.trigger,f={};a.trigger=function(){var c=arguments[0];if(-1===b.indexOf(c))return e.apply(a,arguments);f[c]=arguments},c.apply(a,[]),a.trigger=e;for(d in f)f.hasOwnProperty(d)&&e.apply(a,f[d])},q=function(a,b,c,d){a.on(b,c,function(b){for(var c=b.target;c&&c.parentNode!==a[0];)c=c.parentNode;return b.currentTarget=c,d.apply(this,[b])})},r=function(a){var b={};if("selectionStart"in a)b.start=a.selectionStart,b.length=a.selectionEnd-b.start;else if(document.selection){a.focus();var c=document.selection.createRange(),d=document.selection.createRange().text.length;c.moveStart("character",-a.value.length),b.start=c.text.length-d,b.length=d}return b},s=function(a,b,c){var d,e,f={};if(c)for(d=0,e=c.length;d<e;d++)f[c[d]]=a.css(c[d]);else f=a.css();b.css(f)},t=function(b,c){return b?(w.$testInput||(w.$testInput=a("<span />").css({position:"absolute",top:-99999,left:-99999,width:"auto",padding:0,whiteSpace:"pre"}).appendTo("body")),w.$testInput.text(b),s(c,w.$testInput,["letterSpacing","fontSize","fontFamily","fontWeight","textTransform"]),w.$testInput.width()):0},u=function(a){var b=null,c=function(c,d){var e,f,g,h,i,j,k,l;c=c||window.event||{},d=d||{},c.metaKey||c.altKey||(d.force||!1!==a.data("grow"))&&(e=a.val(),c.type&&"keydown"===c.type.toLowerCase()&&(f=c.keyCode,g=f>=48&&f<=57||f>=65&&f<=90||f>=96&&f<=111||f>=186&&f<=222||32===f,46===f||8===f?(l=r(a[0]),l.length?e=e.substring(0,l.start)+e.substring(l.start+l.length):8===f&&l.start?e=e.substring(0,l.start-1)+e.substring(l.start+1):46===f&&void 0!==l.start&&(e=e.substring(0,l.start)+e.substring(l.start+1))):g&&(j=c.shiftKey,k=String.fromCharCode(c.keyCode),k=j?k.toUpperCase():k.toLowerCase(),e+=k)),h=a.attr("placeholder"),!e&&h&&(e=h),(i=t(e,a)+4)!==b&&(b=i,a.width(i),a.triggerHandler("resize")))};a.on("keydown keyup update blur",c),c()},v=function(a){var b=document.createElement("div");return b.appendChild(a.cloneNode(!0)),b.innerHTML},w=function(c,d){var e,f,g,h,i=this;h=c[0],h.selectize=i;var j=window.getComputedStyle&&window.getComputedStyle(h,null);if(g=j?j.getPropertyValue("direction"):h.currentStyle&&h.currentStyle.direction,g=g||c.parents("[dir]:first").attr("dir")||"",a.extend(i,{order:0,settings:d,$input:c,tabIndex:c.attr("tabindex")||"",tagType:"select"===h.tagName.toLowerCase()?1:2,rtl:/rtl/i.test(g),eventNS:".selectize"+ ++w.count,highlightedValue:null,isBlurring:!1,isOpen:!1,isDisabled:!1,isRequired:c.is("[required]"),isInvalid:!1,isLocked:!1,isFocused:!1,isInputHidden:!1,isSetup:!1,isShiftDown:!1,isCmdDown:!1,isCtrlDown:!1,ignoreFocus:!1,ignoreBlur:!1,ignoreHover:!1,hasOptions:!1,currentResults:null,lastValue:"",caretPos:0,loading:0,loadedSearches:{},$activeOption:null,$activeItems:[],optgroups:{},options:{},userOptions:{},items:[],renderCache:{},onSearchChange:null===d.loadThrottle?i.onSearchChange:o(i.onSearchChange,d.loadThrottle)}),i.sifter=new b(this.options,{diacritics:d.diacritics}),i.settings.options){for(e=0,f=i.settings.options.length;e<f;e++)i.registerOption(i.settings.options[e]);delete i.settings.options}if(i.settings.optgroups){for(e=0,f=i.settings.optgroups.length;e<f;e++)i.registerOptionGroup(i.settings.optgroups[e]);delete i.settings.optgroups}i.settings.mode=i.settings.mode||(1===i.settings.maxItems?"single":"multi"),"boolean"!=typeof i.settings.hideSelected&&(i.settings.hideSelected="multi"===i.settings.mode),i.initializePlugins(i.settings.plugins),i.setupCallbacks(),i.setupTemplates(),i.setup()};return e.mixin(w),void 0!==c?c.mixin(w):function(a,b){b||(b={});console.error("Selectize: "+a),b.explanation&&(console.group&&console.group(),console.error(b.explanation),console.group&&console.groupEnd())}("Dependency MicroPlugin is missing",{explanation:'Make sure you either: (1) are using the "standalone" version of Selectize, or (2) require MicroPlugin before you load Selectize.'}),a.extend(w.prototype,{setup:function(){var b,c,d,e,j,k,l,m,n,o,p=this,r=p.settings,s=p.eventNS,t=a(window),v=a(document),w=p.$input;if(l=p.settings.mode,m=w.attr("class")||"",b=a("<div>").addClass(r.wrapperClass).addClass(m).addClass(l),c=a("<div>").addClass(r.inputClass).addClass("items").appendTo(b),d=a('<input type="text" autocomplete="off" />').appendTo(c).attr("tabindex",w.is(":disabled")?"-1":p.tabIndex),k=a(r.dropdownParent||b),e=a("<div>").addClass(r.dropdownClass).addClass(l).hide().appendTo(k),j=a("<div>").addClass(r.dropdownContentClass).appendTo(e),(o=w.attr("id"))&&(d.attr("id",o+"-selectized"),a("label[for='"+o+"']").attr("for",o+"-selectized")),p.settings.copyClassesToDropdown&&e.addClass(m),b.css({width:w[0].style.width}),p.plugins.names.length&&(n="plugin-"+p.plugins.names.join(" plugin-"),b.addClass(n),e.addClass(n)),(null===r.maxItems||r.maxItems>1)&&1===p.tagType&&w.attr("multiple","multiple"),p.settings.placeholder&&d.attr("placeholder",r.placeholder),!p.settings.splitOn&&p.settings.delimiter){var x=p.settings.delimiter.replace(/[-\/\\^$*+?.()|[\]{}]/g,"\\$&");p.settings.splitOn=new RegExp("\\s*"+x+"+\\s*")}w.attr("autocorrect")&&d.attr("autocorrect",w.attr("autocorrect")),w.attr("autocapitalize")&&d.attr("autocapitalize",w.attr("autocapitalize")),d[0].type=w[0].type,p.$wrapper=b,p.$control=c,p.$control_input=d,p.$dropdown=e,p.$dropdown_content=j,e.on("mouseenter mousedown click","[data-disabled]>[data-selectable]",function(a){a.stopImmediatePropagation()}),e.on("mouseenter","[data-selectable]",function(){return p.onOptionHover.apply(p,arguments)}),e.on("mousedown click","[data-selectable]",function(){return p.onOptionSelect.apply(p,arguments)}),q(c,"mousedown","*:not(input)",function(){return p.onItemSelect.apply(p,arguments)}),u(d),c.on({mousedown:function(){return p.onMouseDown.apply(p,arguments)},click:function(){return p.onClick.apply(p,arguments)}}),d.on({mousedown:function(a){a.stopPropagation()},keydown:function(){return p.onKeyDown.apply(p,arguments)},keyup:function(){return p.onKeyUp.apply(p,arguments)},keypress:function(){return p.onKeyPress.apply(p,arguments)},resize:function(){p.positionDropdown.apply(p,[])},blur:function(){return p.onBlur.apply(p,arguments)},focus:function(){return p.ignoreBlur=!1,p.onFocus.apply(p,arguments)},paste:function(){return p.onPaste.apply(p,arguments)}}),v.on("keydown"+s,function(a){p.isCmdDown=a[f?"metaKey":"ctrlKey"],p.isCtrlDown=a[f?"altKey":"ctrlKey"],p.isShiftDown=a.shiftKey}),v.on("keyup"+s,function(a){a.keyCode===h&&(p.isCtrlDown=!1),16===a.keyCode&&(p.isShiftDown=!1),a.keyCode===g&&(p.isCmdDown=!1)}),v.on("mousedown"+s,function(a){if(p.isFocused){if(a.target===p.$dropdown[0]||a.target.parentNode===p.$dropdown[0])return!1;p.$control.has(a.target).length||a.target===p.$control[0]||p.blur(a.target)}}),t.on(["scroll"+s,"resize"+s].join(" "),function(){p.isOpen&&p.positionDropdown.apply(p,arguments)}),t.on("mousemove"+s,function(){p.ignoreHover=!1}),this.revertSettings={$children:w.children().detach(),tabindex:w.attr("tabindex")},w.attr("tabindex",-1).hide().after(p.$wrapper),a.isArray(r.items)&&(p.setValue(r.items),delete r.items),i&&w.on("invalid"+s,function(a){a.preventDefault(),p.isInvalid=!0,p.refreshState()}),p.updateOriginalInput(),p.refreshItems(),p.refreshState(),p.updatePlaceholder(),p.isSetup=!0,w.is(":disabled")&&p.disable(),p.on("change",this.onChange),w.data("selectize",p),w.addClass("selectized"),p.trigger("initialize"),!0===r.preload&&p.onSearchChange("")},setupTemplates:function(){var b=this,c=b.settings.labelField,d=b.settings.optgroupLabelField,e={optgroup:function(a){return'<div class="optgroup">'+a.html+"</div>"},optgroup_header:function(a,b){return'<div class="optgroup-header">'+b(a[d])+"</div>"},option:function(a,b){return'<div class="option">'+b(a[c])+"</div>"},item:function(a,b){return'<div class="item">'+b(a[c])+"</div>"},option_create:function(a,b){return'<div class="create">Add <strong>'+b(a.input)+"</strong>&hellip;</div>"}};b.settings.render=a.extend({},e,b.settings.render)},setupCallbacks:function(){var a,b,c={initialize:"onInitialize",change:"onChange",item_add:"onItemAdd",item_remove:"onItemRemove",clear:"onClear",option_add:"onOptionAdd",option_remove:"onOptionRemove",option_clear:"onOptionClear",optgroup_add:"onOptionGroupAdd",optgroup_remove:"onOptionGroupRemove",optgroup_clear:"onOptionGroupClear",dropdown_open:"onDropdownOpen",dropdown_close:"onDropdownClose",type:"onType",load:"onLoad",focus:"onFocus",blur:"onBlur"};for(a in c)c.hasOwnProperty(a)&&(b=this.settings[c[a]])&&this.on(a,b)},onClick:function(a){var b=this;b.isFocused&&b.isOpen||(b.focus(),a.preventDefault())},onMouseDown:function(b){var c=this,d=b.isDefaultPrevented();a(b.target);if(c.isFocused){if(b.target!==c.$control_input[0])return"single"===c.settings.mode?c.isOpen?c.close():c.open():d||c.setActiveItem(null),!1}else d||window.setTimeout(function(){c.focus()},0)},onChange:function(){this.$input.trigger("change")},onPaste:function(b){var c=this;if(c.isFull()||c.isInputHidden||c.isLocked)return void b.preventDefault();c.settings.splitOn&&setTimeout(function(){var b=c.$control_input.val();if(b.match(c.settings.splitOn))for(var d=a.trim(b).split(c.settings.splitOn),e=0,f=d.length;e<f;e++)c.createItem(d[e])},0)},onKeyPress:function(a){if(this.isLocked)return a&&a.preventDefault();var b=String.fromCharCode(a.keyCode||a.which);return this.settings.create&&"multi"===this.settings.mode&&b===this.settings.delimiter?(this.createItem(),a.preventDefault(),!1):void 0},onKeyDown:function(a){var b=(a.target,this.$control_input[0],this);if(b.isLocked)return void(9!==a.keyCode&&a.preventDefault());switch(a.keyCode){case 65:if(b.isCmdDown)return void b.selectAll();break;case 27:return void(b.isOpen&&(a.preventDefault(),a.stopPropagation(),b.close()));case 78:if(!a.ctrlKey||a.altKey)break;case 40:if(!b.isOpen&&b.hasOptions)b.open();else if(b.$activeOption){b.ignoreHover=!0;var c=b.getAdjacentOption(b.$activeOption,1);c.length&&b.setActiveOption(c,!0,!0)}return void a.preventDefault();case 80:if(!a.ctrlKey||a.altKey)break;case 38:if(b.$activeOption){b.ignoreHover=!0;var d=b.getAdjacentOption(b.$activeOption,-1);d.length&&b.setActiveOption(d,!0,!0)}return void a.preventDefault();case 13:return void(b.isOpen&&b.$activeOption&&(b.onOptionSelect({currentTarget:b.$activeOption}),a.preventDefault()));case 37:return void b.advanceSelection(-1,a);case 39:return void b.advanceSelection(1,a);case 9:return b.settings.selectOnTab&&b.isOpen&&b.$activeOption&&(b.onOptionSelect({currentTarget:b.$activeOption}),b.isFull()||a.preventDefault()),void(b.settings.create&&b.createItem()&&a.preventDefault());case 8:case 46:return void b.deleteSelection(a)}return!b.isFull()&&!b.isInputHidden||(f?a.metaKey:a.ctrlKey)?void 0:void a.preventDefault()},onKeyUp:function(a){var b=this;if(b.isLocked)return a&&a.preventDefault();var c=b.$control_input.val()||"";b.lastValue!==c&&(b.lastValue=c,b.onSearchChange(c),b.refreshOptions(),b.trigger("type",c))},onSearchChange:function(a){var b=this,c=b.settings.load;c&&(b.loadedSearches.hasOwnProperty(a)||(b.loadedSearches[a]=!0,b.load(function(d){c.apply(b,[a,d])})))},onFocus:function(a){var b=this,c=b.isFocused;if(b.isDisabled)return b.blur(),a&&a.preventDefault(),!1;b.ignoreFocus||(b.isFocused=!0,"focus"===b.settings.preload&&b.onSearchChange(""),c||b.trigger("focus"),b.$activeItems.length||(b.showInput(),b.setActiveItem(null),b.refreshOptions(!!b.settings.openOnFocus)),b.refreshState())},onBlur:function(a,b){var c=this;if(c.isFocused&&(c.isFocused=!1,!c.ignoreFocus)){if(!c.ignoreBlur&&document.activeElement===c.$dropdown_content[0])return c.ignoreBlur=!0,void c.onFocus(a);var d=function(){c.close(),c.setTextboxValue(""),c.setActiveItem(null),c.setActiveOption(null),c.setCaret(c.items.length),c.refreshState(),b&&b.focus&&b.focus(),c.isBlurring=!1,c.ignoreFocus=!1,c.trigger("blur")};c.isBlurring=!0,c.ignoreFocus=!0,c.settings.create&&c.settings.createOnBlur?c.createItem(null,!1,d):d()}},onOptionHover:function(a){this.ignoreHover||this.setActiveOption(a.currentTarget,!1)},onOptionSelect:function(b){var c,d,e=this;b.preventDefault&&(b.preventDefault(),b.stopPropagation()),d=a(b.currentTarget),d.hasClass("create")?e.createItem(null,function(){e.settings.closeAfterSelect&&e.close()}):void 0!==(c=d.attr("data-value"))&&(e.lastQuery=null,e.setTextboxValue(""),e.addItem(c),e.settings.closeAfterSelect?e.close():!e.settings.hideSelected&&b.type&&/mouse/.test(b.type)&&e.setActiveOption(e.getOption(c)))},onItemSelect:function(a){var b=this;b.isLocked||"multi"===b.settings.mode&&(a.preventDefault(),b.setActiveItem(a.currentTarget,a))},load:function(a){var b=this,c=b.$wrapper.addClass(b.settings.loadingClass);b.loading++,a.apply(b,[function(a){b.loading=Math.max(b.loading-1,0),a&&a.length&&(b.addOption(a),b.refreshOptions(b.isFocused&&!b.isInputHidden)),b.loading||c.removeClass(b.settings.loadingClass),b.trigger("load",a)}])},setTextboxValue:function(a){var b=this.$control_input;b.val()!==a&&(b.val(a).triggerHandler("update"),this.lastValue=a)},getValue:function(){return 1===this.tagType&&this.$input.attr("multiple")?this.items:this.items.join(this.settings.delimiter)},setValue:function(a,b){p(this,b?[]:["change"],function(){this.clear(b),this.addItems(a,b)})},setActiveItem:function(b,c){var d,e,f,g,h,i,j,k,l=this;if("single"!==l.settings.mode){if(b=a(b),!b.length)return a(l.$activeItems).removeClass("active"),l.$activeItems=[],void(l.isFocused&&l.showInput());if("mousedown"===(d=c&&c.type.toLowerCase())&&l.isShiftDown&&l.$activeItems.length){for(k=l.$control.children(".active:last"),g=Array.prototype.indexOf.apply(l.$control[0].childNodes,[k[0]]),h=Array.prototype.indexOf.apply(l.$control[0].childNodes,[b[0]]),g>h&&(j=g,g=h,h=j),e=g;e<=h;e++)i=l.$control[0].childNodes[e],-1===l.$activeItems.indexOf(i)&&(a(i).addClass("active"),l.$activeItems.push(i));c.preventDefault()}else"mousedown"===d&&l.isCtrlDown||"keydown"===d&&this.isShiftDown?b.hasClass("active")?(f=l.$activeItems.indexOf(b[0]),l.$activeItems.splice(f,1),b.removeClass("active")):l.$activeItems.push(b.addClass("active")[0]):(a(l.$activeItems).removeClass("active"),l.$activeItems=[b.addClass("active")[0]]);l.hideInput(),this.isFocused||l.focus()}},setActiveOption:function(b,c,d){var e,f,g,h,i,k=this;k.$activeOption&&k.$activeOption.removeClass("active"),k.$activeOption=null,b=a(b),b.length&&(k.$activeOption=b.addClass("active"),!c&&j(c)||(e=k.$dropdown_content.height(),f=k.$activeOption.outerHeight(!0),c=k.$dropdown_content.scrollTop()||0,g=k.$activeOption.offset().top-k.$dropdown_content.offset().top+c,h=g,i=g-e+f,g+f>e+c?k.$dropdown_content.stop().animate({scrollTop:i},d?k.settings.scrollDuration:0):g<c&&k.$dropdown_content.stop().animate({scrollTop:h},d?k.settings.scrollDuration:0)))},selectAll:function(){var a=this;"single"!==a.settings.mode&&(a.$activeItems=Array.prototype.slice.apply(a.$control.children(":not(input)").addClass("active")),a.$activeItems.length&&(a.hideInput(),a.close()),a.focus())},hideInput:function(){var a=this;a.setTextboxValue(""),a.$control_input.css({opacity:0,position:"absolute",left:a.rtl?1e4:-1e4}),a.isInputHidden=!0},showInput:function(){this.$control_input.css({opacity:1,position:"relative",left:0}),this.isInputHidden=!1},focus:function(){var a=this;a.isDisabled||(a.ignoreFocus=!0,a.$control_input[0].focus(),window.setTimeout(function(){a.ignoreFocus=!1,a.onFocus()},0))},blur:function(a){this.$control_input[0].blur(),this.onBlur(null,a)},getScoreFunction:function(a){return this.sifter.getScoreFunction(a,this.getSearchOptions())},getSearchOptions:function(){var a=this.settings,b=a.sortField;return"string"==typeof b&&(b=[{field:b}]),{fields:a.searchField,conjunction:a.searchConjunction,sort:b,nesting:a.nesting}},search:function(b){var c,d,e,f=this,g=f.settings,h=this.getSearchOptions();if(g.score&&"function"!=typeof(e=f.settings.score.apply(this,[b])))throw new Error('Selectize "score" setting must be a function that returns a function');if(b!==f.lastQuery?(f.lastQuery=b,d=f.sifter.search(b,a.extend(h,{score:e})),f.currentResults=d):d=a.extend(!0,{},f.currentResults),g.hideSelected)for(c=d.items.length-1;c>=0;c--)-1!==f.items.indexOf(k(d.items[c].id))&&d.items.splice(c,1);return d},refreshOptions:function(b){var c,e,f,g,h,i,j,l,m,n,o,p,q,r,s,t;void 0===b&&(b=!0);var u=this,w=a.trim(u.$control_input.val()),x=u.search(w),y=u.$dropdown_content,z=u.$activeOption&&k(u.$activeOption.attr("data-value"));for(g=x.items.length,"number"==typeof u.settings.maxOptions&&(g=Math.min(g,u.settings.maxOptions)),h={},i=[],c=0;c<g;c++)for(j=u.options[x.items[c].id],l=u.render("option",j),m=j[u.settings.optgroupField]||"",n=a.isArray(m)?m:[m],e=0,f=n&&n.length;e<f;e++)m=n[e],u.optgroups.hasOwnProperty(m)||(m=""),h.hasOwnProperty(m)||(h[m]=document.createDocumentFragment(),i.push(m)),h[m].appendChild(l);for(this.settings.lockOptgroupOrder&&i.sort(function(a,b){return(u.optgroups[a].$order||0)-(u.optgroups[b].$order||0)}),o=document.createDocumentFragment(),c=0,g=i.length;c<g;c++)m=i[c],u.optgroups.hasOwnProperty(m)&&h[m].childNodes.length?(p=document.createDocumentFragment(),p.appendChild(u.render("optgroup_header",u.optgroups[m])),p.appendChild(h[m]),o.appendChild(u.render("optgroup",a.extend({},u.optgroups[m],{html:v(p),dom:p})))):o.appendChild(h[m]);if(y.html(o),u.settings.highlight&&(y.removeHighlight(),x.query.length&&x.tokens.length))for(c=0,g=x.tokens.length;c<g;c++)d(y,x.tokens[c].regex);if(!u.settings.hideSelected)for(c=0,g=u.items.length;c<g;c++)u.getOption(u.items[c]).addClass("selected");q=u.canCreate(w),q&&(y.prepend(u.render("option_create",{input:w})),t=a(y[0].childNodes[0])),u.hasOptions=x.items.length>0||q,u.hasOptions?(x.items.length>0?(s=z&&u.getOption(z),s&&s.length?r=s:"single"===u.settings.mode&&u.items.length&&(r=u.getOption(u.items[0])),r&&r.length||(r=t&&!u.settings.addPrecedence?u.getAdjacentOption(t,1):y.find("[data-selectable]:first"))):r=t,u.setActiveOption(r),b&&!u.isOpen&&u.open()):(u.setActiveOption(null),b&&u.isOpen&&u.close())},addOption:function(b){var c,d,e,f=this;if(a.isArray(b))for(c=0,d=b.length;c<d;c++)f.addOption(b[c]);else(e=f.registerOption(b))&&(f.userOptions[e]=!0,f.lastQuery=null,f.trigger("option_add",e,b))},registerOption:function(a){var b=k(a[this.settings.valueField]);return void 0!==b&&null!==b&&!this.options.hasOwnProperty(b)&&(a.$order=a.$order||++this.order,this.options[b]=a,b)},registerOptionGroup:function(a){var b=k(a[this.settings.optgroupValueField]);return!!b&&(a.$order=a.$order||++this.order,this.optgroups[b]=a,b)},addOptionGroup:function(a,b){b[this.settings.optgroupValueField]=a,(a=this.registerOptionGroup(b))&&this.trigger("optgroup_add",a,b)},removeOptionGroup:function(a){this.optgroups.hasOwnProperty(a)&&(delete this.optgroups[a],this.renderCache={},this.trigger("optgroup_remove",a))},clearOptionGroups:function(){this.optgroups={},this.renderCache={},this.trigger("optgroup_clear")},updateOption:function(b,c){var d,e,f,g,h,i,j,l=this;if(b=k(b),f=k(c[l.settings.valueField]),null!==b&&l.options.hasOwnProperty(b)){if("string"!=typeof f)throw new Error("Value must be set in option data");j=l.options[b].$order,f!==b&&(delete l.options[b],-1!==(g=l.items.indexOf(b))&&l.items.splice(g,1,f)),c.$order=c.$order||j,l.options[f]=c,h=l.renderCache.item,i=l.renderCache.option,h&&(delete h[b],delete h[f]),i&&(delete i[b],delete i[f]),-1!==l.items.indexOf(f)&&(d=l.getItem(b),e=a(l.render("item",c)),d.hasClass("active")&&e.addClass("active"),d.replaceWith(e)),l.lastQuery=null,l.isOpen&&l.refreshOptions(!1)}},removeOption:function(a,b){var c=this;a=k(a);var d=c.renderCache.item,e=c.renderCache.option;d&&delete d[a],e&&delete e[a],delete c.userOptions[a],delete c.options[a],c.lastQuery=null,c.trigger("option_remove",a),c.removeItem(a,b)},clearOptions:function(){var b=this;b.loadedSearches={},b.userOptions={},b.renderCache={};var c=b.options;a.each(b.options,function(a,d){-1==b.items.indexOf(a)&&delete c[a]}),b.options=b.sifter.items=c,b.lastQuery=null,b.trigger("option_clear")},getOption:function(a){return this.getElementWithValue(a,this.$dropdown_content.find("[data-selectable]"))},getAdjacentOption:function(b,c){var d=this.$dropdown.find("[data-selectable]"),e=d.index(b)+c;return e>=0&&e<d.length?d.eq(e):a()},getElementWithValue:function(b,c){if(void 0!==(b=k(b))&&null!==b)for(var d=0,e=c.length;d<e;d++)if(c[d].getAttribute("data-value")===b)return a(c[d]);return a()},getItem:function(a){return this.getElementWithValue(a,this.$control.children())},addItems:function(b,c){this.buffer=document.createDocumentFragment();for(var d=this.$control[0].childNodes,e=0;e<d.length;e++)this.buffer.appendChild(d[e]);for(var f=a.isArray(b)?b:[b],e=0,g=f.length;e<g;e++)this.isPending=e<g-1,this.addItem(f[e],c);var h=this.$control[0];h.insertBefore(this.buffer,h.firstChild),this.buffer=null},addItem:function(b,c){p(this,c?[]:["change"],function(){var d,e,f,g,h,i=this,j=i.settings.mode;if(b=k(b),-1!==i.items.indexOf(b))return void("single"===j&&i.close());i.options.hasOwnProperty(b)&&("single"===j&&i.clear(c),"multi"===j&&i.isFull()||(d=a(i.render("item",i.options[b])),h=i.isFull(),i.items.splice(i.caretPos,0,b),i.insertAtCaret(d),(!i.isPending||!h&&i.isFull())&&i.refreshState(),i.isSetup&&(f=i.$dropdown_content.find("[data-selectable]"),i.isPending||(e=i.getOption(b),g=i.getAdjacentOption(e,1).attr("data-value"),i.refreshOptions(i.isFocused&&"single"!==j),g&&i.setActiveOption(i.getOption(g))),!f.length||i.isFull()?i.close():i.isPending||i.positionDropdown(),i.updatePlaceholder(),i.trigger("item_add",b,d),i.isPending||i.updateOriginalInput({silent:c}))))})},removeItem:function(b,c){var d,e,f,g=this;d=b instanceof a?b:g.getItem(b),b=k(d.attr("data-value")),-1!==(e=g.items.indexOf(b))&&(d.remove(),d.hasClass("active")&&(f=g.$activeItems.indexOf(d[0]),g.$activeItems.splice(f,1)),g.items.splice(e,1),g.lastQuery=null,!g.settings.persist&&g.userOptions.hasOwnProperty(b)&&g.removeOption(b,c),e<g.caretPos&&g.setCaret(g.caretPos-1),g.refreshState(),g.updatePlaceholder(),g.updateOriginalInput({silent:c}),g.positionDropdown(),g.trigger("item_remove",b,d))},createItem:function(b,c){var d=this,e=d.caretPos;b=b||a.trim(d.$control_input.val()||"");var f=arguments[arguments.length-1];if("function"!=typeof f&&(f=function(){}),"boolean"!=typeof c&&(c=!0),!d.canCreate(b))return f(),!1;d.lock();var g="function"==typeof d.settings.create?this.settings.create:function(a){var b={};return b[d.settings.labelField]=a,b[d.settings.valueField]=a,b},h=n(function(a){if(d.unlock(),!a||"object"!=typeof a)return f();var b=k(a[d.settings.valueField]);if("string"!=typeof b)return f();d.setTextboxValue(""),d.addOption(a),d.setCaret(e),d.addItem(b),d.refreshOptions(c&&"single"!==d.settings.mode),f(a)}),i=g.apply(this,[b,h]);return void 0!==i&&h(i),!0},refreshItems:function(){this.lastQuery=null,this.isSetup&&this.addItem(this.items),this.refreshState(),this.updateOriginalInput()},refreshState:function(){this.refreshValidityState(),this.refreshClasses()},refreshValidityState:function(){if(!this.isRequired)return!1;var a=!this.items.length;this.isInvalid=a,this.$control_input.prop("required",a),this.$input.prop("required",!a)},refreshClasses:function(){var b=this,c=b.isFull(),d=b.isLocked;b.$wrapper.toggleClass("rtl",b.rtl),b.$control.toggleClass("focus",b.isFocused).toggleClass("disabled",b.isDisabled).toggleClass("required",b.isRequired).toggleClass("invalid",b.isInvalid).toggleClass("locked",d).toggleClass("full",c).toggleClass("not-full",!c).toggleClass("input-active",b.isFocused&&!b.isInputHidden).toggleClass("dropdown-active",b.isOpen).toggleClass("has-options",!a.isEmptyObject(b.options)).toggleClass("has-items",b.items.length>0),b.$control_input.data("grow",!c&&!d)},isFull:function(){
return null!==this.settings.maxItems&&this.items.length>=this.settings.maxItems},updateOriginalInput:function(a){var b,c,d,e,f=this;if(a=a||{},1===f.tagType){for(d=[],b=0,c=f.items.length;b<c;b++)e=f.options[f.items[b]][f.settings.labelField]||"",d.push('<option value="'+l(f.items[b])+'" selected="selected">'+l(e)+"</option>");d.length||this.$input.attr("multiple")||d.push('<option value="" selected="selected"></option>'),f.$input.html(d.join(""))}else f.$input.val(f.getValue()),f.$input.attr("value",f.$input.val());f.isSetup&&(a.silent||f.trigger("change",f.$input.val()))},updatePlaceholder:function(){if(this.settings.placeholder){var a=this.$control_input;this.items.length?a.removeAttr("placeholder"):a.attr("placeholder",this.settings.placeholder),a.triggerHandler("update",{force:!0})}},open:function(){var a=this;a.isLocked||a.isOpen||"multi"===a.settings.mode&&a.isFull()||(a.focus(),a.isOpen=!0,a.refreshState(),a.$dropdown.css({visibility:"hidden",display:"block"}),a.positionDropdown(),a.$dropdown.css({visibility:"visible"}),a.trigger("dropdown_open",a.$dropdown))},close:function(){var a=this,b=a.isOpen;"single"===a.settings.mode&&a.items.length&&(a.hideInput(),a.isBlurring||a.$control_input.blur()),a.isOpen=!1,a.$dropdown.hide(),a.setActiveOption(null),a.refreshState(),b&&a.trigger("dropdown_close",a.$dropdown)},positionDropdown:function(){var a=this.$control,b="body"===this.settings.dropdownParent?a.offset():a.position();b.top+=a.outerHeight(!0),this.$dropdown.css({width:a[0].getBoundingClientRect().width,top:b.top,left:b.left})},clear:function(a){var b=this;b.items.length&&(b.$control.children(":not(input)").remove(),b.items=[],b.lastQuery=null,b.setCaret(0),b.setActiveItem(null),b.updatePlaceholder(),b.updateOriginalInput({silent:a}),b.refreshState(),b.showInput(),b.trigger("clear"))},insertAtCaret:function(a){var b=Math.min(this.caretPos,this.items.length),c=a[0],d=this.buffer||this.$control[0];0===b?d.insertBefore(c,d.firstChild):d.insertBefore(c,d.childNodes[b]),this.setCaret(b+1)},deleteSelection:function(b){var c,d,e,f,g,h,i,j,k,l=this;if(e=b&&8===b.keyCode?-1:1,f=r(l.$control_input[0]),l.$activeOption&&!l.settings.hideSelected&&(i=l.getAdjacentOption(l.$activeOption,-1).attr("data-value")),g=[],l.$activeItems.length){for(k=l.$control.children(".active:"+(e>0?"last":"first")),h=l.$control.children(":not(input)").index(k),e>0&&h++,c=0,d=l.$activeItems.length;c<d;c++)g.push(a(l.$activeItems[c]).attr("data-value"));b&&(b.preventDefault(),b.stopPropagation())}else(l.isFocused||"single"===l.settings.mode)&&l.items.length&&(e<0&&0===f.start&&0===f.length?g.push(l.items[l.caretPos-1]):e>0&&f.start===l.$control_input.val().length&&g.push(l.items[l.caretPos]));if(!g.length||"function"==typeof l.settings.onDelete&&!1===l.settings.onDelete.apply(l,[g]))return!1;for(void 0!==h&&l.setCaret(h);g.length;)l.removeItem(g.pop());return l.showInput(),l.positionDropdown(),l.refreshOptions(!0),i&&(j=l.getOption(i),j.length&&l.setActiveOption(j)),!0},advanceSelection:function(a,b){var c,d,e,f,g,h=this;0!==a&&(h.rtl&&(a*=-1),c=a>0?"last":"first",d=r(h.$control_input[0]),h.isFocused&&!h.isInputHidden?(f=h.$control_input.val().length,(a<0?0===d.start&&0===d.length:d.start===f)&&!f&&h.advanceCaret(a,b)):(g=h.$control.children(".active:"+c),g.length&&(e=h.$control.children(":not(input)").index(g),h.setActiveItem(null),h.setCaret(a>0?e+1:e))))},advanceCaret:function(a,b){var c,d,e=this;0!==a&&(c=a>0?"next":"prev",e.isShiftDown?(d=e.$control_input[c](),d.length&&(e.hideInput(),e.setActiveItem(d),b&&b.preventDefault())):e.setCaret(e.caretPos+a))},setCaret:function(b){var c=this;if(b="single"===c.settings.mode?c.items.length:Math.max(0,Math.min(c.items.length,b)),!c.isPending){var d,e,f,g;for(f=c.$control.children(":not(input)"),d=0,e=f.length;d<e;d++)g=a(f[d]).detach(),d<b?c.$control_input.before(g):c.$control.append(g)}c.caretPos=b},lock:function(){this.close(),this.isLocked=!0,this.refreshState()},unlock:function(){this.isLocked=!1,this.refreshState()},disable:function(){var a=this;a.$input.prop("disabled",!0),a.$control_input.prop("disabled",!0).prop("tabindex",-1),a.isDisabled=!0,a.lock()},enable:function(){var a=this;a.$input.prop("disabled",!1),a.$control_input.prop("disabled",!1).prop("tabindex",a.tabIndex),a.isDisabled=!1,a.unlock()},destroy:function(){var b=this,c=b.eventNS,d=b.revertSettings;b.trigger("destroy"),b.off(),b.$wrapper.remove(),b.$dropdown.remove(),b.$input.html("").append(d.$children).removeAttr("tabindex").removeClass("selectized").attr({tabindex:d.tabindex}).show(),b.$control_input.removeData("grow"),b.$input.removeData("selectize"),0==--w.count&&w.$testInput&&(w.$testInput.remove(),w.$testInput=void 0),a(window).off(c),a(document).off(c),a(document.body).off(c),delete b.$input[0].selectize},render:function(b,c){var d,e,f="",g=!1,h=this;return"option"!==b&&"item"!==b||(d=k(c[h.settings.valueField]),g=!!d),g&&(j(h.renderCache[b])||(h.renderCache[b]={}),h.renderCache[b].hasOwnProperty(d))?h.renderCache[b][d]:(f=a(h.settings.render[b].apply(this,[c,l])),"option"===b||"option_create"===b?c[h.settings.disabledField]||f.attr("data-selectable",""):"optgroup"===b&&(e=c[h.settings.optgroupValueField]||"",f.attr("data-group",e),c[h.settings.disabledField]&&f.attr("data-disabled","")),"option"!==b&&"item"!==b||f.attr("data-value",d||""),g&&(h.renderCache[b][d]=f[0]),f[0])},clearCache:function(a){var b=this;void 0===a?b.renderCache={}:delete b.renderCache[a]},canCreate:function(a){var b=this;if(!b.settings.create)return!1;var c=b.settings.createFilter;return a.length&&("function"!=typeof c||c.apply(b,[a]))&&("string"!=typeof c||new RegExp(c).test(a))&&(!(c instanceof RegExp)||c.test(a))}}),w.count=0,w.defaults={options:[],optgroups:[],plugins:[],delimiter:",",splitOn:null,persist:!0,diacritics:!0,create:!1,createOnBlur:!1,createFilter:null,highlight:!0,openOnFocus:!0,maxOptions:1e3,maxItems:null,hideSelected:null,addPrecedence:!1,selectOnTab:!1,preload:!1,allowEmptyOption:!1,closeAfterSelect:!1,scrollDuration:60,loadThrottle:300,loadingClass:"loading",dataAttr:"data-data",optgroupField:"optgroup",valueField:"value",labelField:"text",disabledField:"disabled",optgroupLabelField:"label",optgroupValueField:"value",lockOptgroupOrder:!1,sortField:"$order",searchField:["text"],searchConjunction:"and",mode:null,wrapperClass:"selectize-control",inputClass:"selectize-input",dropdownClass:"selectize-dropdown",dropdownContentClass:"selectize-dropdown-content",dropdownParent:null,copyClassesToDropdown:!0,render:{}},a.fn.selectize=function(b){var c=a.fn.selectize.defaults,d=a.extend({},c,b),e=d.dataAttr,f=d.labelField,g=d.valueField,h=d.disabledField,i=d.optgroupField,j=d.optgroupLabelField,l=d.optgroupValueField,m=function(b,c){var h,i,j,k,l=b.attr(e);if(l)for(c.options=JSON.parse(l),h=0,i=c.options.length;h<i;h++)c.items.push(c.options[h][g]);else{var m=a.trim(b.val()||"");if(!d.allowEmptyOption&&!m.length)return;for(j=m.split(d.delimiter),h=0,i=j.length;h<i;h++)k={},k[f]=j[h],k[g]=j[h],c.options.push(k);c.items=j}},n=function(b,c){var m,n,o,p,q=c.options,r={},s=function(a){var b=e&&a.attr(e);return"string"==typeof b&&b.length?JSON.parse(b):null},t=function(b,e){b=a(b);var j=k(b.val());if(j||d.allowEmptyOption)if(r.hasOwnProperty(j)){if(e){var l=r[j][i];l?a.isArray(l)?l.push(e):r[j][i]=[l,e]:r[j][i]=e}}else{var m=s(b)||{};m[f]=m[f]||b.text(),m[g]=m[g]||j,m[h]=m[h]||b.prop("disabled"),m[i]=m[i]||e,r[j]=m,q.push(m),b.is(":selected")&&c.items.push(j)}};for(c.maxItems=b.attr("multiple")?null:1,p=b.children(),m=0,n=p.length;m<n;m++)o=p[m].tagName.toLowerCase(),"optgroup"===o?function(b){var d,e,f,g,i;for(b=a(b),f=b.attr("label"),f&&(g=s(b)||{},g[j]=f,g[l]=f,g[h]=b.prop("disabled"),c.optgroups.push(g)),i=a("option",b),d=0,e=i.length;d<e;d++)t(i[d],f)}(p[m]):"option"===o&&t(p[m])};return this.each(function(){if(!this.selectize){var e=a(this),f=this.tagName.toLowerCase(),g=e.attr("placeholder")||e.attr("data-placeholder");g||d.allowEmptyOption||(g=e.children('option[value=""]').text());var h={placeholder:g,options:[],optgroups:[],items:[]};"select"===f?n(e,h):m(e,h),new w(e,a.extend(!0,{},c,h,b))}})},a.fn.selectize.defaults=w.defaults,a.fn.selectize.support={validity:i},w.define("drag_drop",function(b){if(!a.fn.sortable)throw new Error('The "drag_drop" plugin requires jQuery UI "sortable".');if("multi"===this.settings.mode){var c=this;c.lock=function(){var a=c.lock;return function(){var b=c.$control.data("sortable");return b&&b.disable(),a.apply(c,arguments)}}(),c.unlock=function(){var a=c.unlock;return function(){var b=c.$control.data("sortable");return b&&b.enable(),a.apply(c,arguments)}}(),c.setup=function(){var b=c.setup;return function(){b.apply(this,arguments);var d=c.$control.sortable({items:"[data-value]",forcePlaceholderSize:!0,disabled:c.isLocked,start:function(a,b){b.placeholder.css("width",b.helper.css("width")),d.css({overflow:"visible"})},stop:function(){d.css({overflow:"hidden"});var b=c.$activeItems?c.$activeItems.slice():null,e=[];d.children("[data-value]").each(function(){e.push(a(this).attr("data-value"))}),c.setValue(e),c.setActiveItem(b)}})}}()}}),w.define("dropdown_header",function(b){var c=this;b=a.extend({title:"Untitled",headerClass:"selectize-dropdown-header",titleRowClass:"selectize-dropdown-header-title",labelClass:"selectize-dropdown-header-label",closeClass:"selectize-dropdown-header-close",html:function(a){return'<div class="'+a.headerClass+'"><div class="'+a.titleRowClass+'"><span class="'+a.labelClass+'">'+a.title+'</span><a href="javascript:void(0)" class="'+a.closeClass+'">&times;</a></div></div>'}},b),c.setup=function(){var d=c.setup;return function(){d.apply(c,arguments),c.$dropdown_header=a(b.html(b)),c.$dropdown.prepend(c.$dropdown_header)}}()}),w.define("optgroup_columns",function(b){var c=this;b=a.extend({equalizeWidth:!0,equalizeHeight:!0},b),this.getAdjacentOption=function(b,c){var d=b.closest("[data-group]").find("[data-selectable]"),e=d.index(b)+c;return e>=0&&e<d.length?d.eq(e):a()},this.onKeyDown=function(){var a=c.onKeyDown;return function(b){var d,e,f,g;return!this.isOpen||37!==b.keyCode&&39!==b.keyCode?a.apply(this,arguments):(c.ignoreHover=!0,g=this.$activeOption.closest("[data-group]"),d=g.find("[data-selectable]").index(this.$activeOption),g=37===b.keyCode?g.prev("[data-group]"):g.next("[data-group]"),f=g.find("[data-selectable]"),e=f.eq(Math.min(f.length-1,d)),void(e.length&&this.setActiveOption(e)))}}();var d=function(){var a,b=d.width,c=document;return void 0===b&&(a=c.createElement("div"),a.innerHTML='<div style="width:50px;height:50px;position:absolute;left:-50px;top:-50px;overflow:auto;"><div style="width:1px;height:100px;"></div></div>',a=a.firstChild,c.body.appendChild(a),b=d.width=a.offsetWidth-a.clientWidth,c.body.removeChild(a)),b},e=function(){var e,f,g,h,i,j,k;if(k=a("[data-group]",c.$dropdown_content),(f=k.length)&&c.$dropdown_content.width()){if(b.equalizeHeight){for(g=0,e=0;e<f;e++)g=Math.max(g,k.eq(e).height());k.css({height:g})}b.equalizeWidth&&(j=c.$dropdown_content.innerWidth()-d(),h=Math.round(j/f),k.css({width:h}),f>1&&(i=j-h*(f-1),k.eq(f-1).css({width:i})))}};(b.equalizeHeight||b.equalizeWidth)&&(m.after(this,"positionDropdown",e),m.after(this,"refreshOptions",e))}),w.define("remove_button",function(b){b=a.extend({label:"&times;",title:"Remove",className:"remove",append:!0},b);if("single"===this.settings.mode)return void function(b,c){c.className="remove-single";var d=b,e='<a href="javascript:void(0)" class="'+c.className+'" tabindex="-1" title="'+l(c.title)+'">'+c.label+"</a>",f=function(b,c){return a("<span>").append(b).append(c)};b.setup=function(){var g=d.setup;return function(){if(c.append){var h=a(d.$input.context).attr("id"),i=(a("#"+h),d.settings.render.item);d.settings.render.item=function(a){return f(i.apply(b,arguments),e)}}g.apply(b,arguments),b.$control.on("click","."+c.className,function(a){a.preventDefault(),d.isLocked||d.clear()})}}()}(this,b);!function(b,c){var d=b,e='<a href="javascript:void(0)" class="'+c.className+'" tabindex="-1" title="'+l(c.title)+'">'+c.label+"</a>",f=function(a,b){var c=a.search(/(<\/[^>]+>\s*)$/);return a.substring(0,c)+b+a.substring(c)};b.setup=function(){var g=d.setup;return function(){if(c.append){var h=d.settings.render.item;d.settings.render.item=function(a){return f(h.apply(b,arguments),e)}}g.apply(b,arguments),b.$control.on("click","."+c.className,function(b){if(b.preventDefault(),!d.isLocked){var c=a(b.currentTarget).parent();d.setActiveItem(c),d.deleteSelection()&&d.setCaret(d.items.length)}})}}()}(this,b)}),w.define("restore_on_backspace",function(a){var b=this;a.text=a.text||function(a){return a[this.settings.labelField]},this.onKeyDown=function(){var c=b.onKeyDown;return function(b){var d,e;return 8===b.keyCode&&""===this.$control_input.val()&&!this.$activeItems.length&&(d=this.caretPos-1)>=0&&d<this.items.length?(e=this.options[this.items[d]],this.deleteSelection(b)&&(this.setTextboxValue(a.text.apply(this,[e])),this.refreshOptions(!0)),void b.preventDefault()):c.apply(this,arguments)}}()}),w});
// This is a manifest file that'll be compiled into including all the files listed below.
// Add new JavaScript/Coffee code in separate files in this directory and they'll automatically
// be included in the compiled file accessible from http://example.com/assets/application.js
// It's not advisable to add code directly here, but if you do, it'll appear at the bottom of the
// the compiled file.



























Didlogic.Admin = Didlogic.Admin || {}

Didlogic.Admin.Channels = (function () {
  function Channels() {
    var _this = this
    this.timer = setInterval(function () {
      return _this.load_table()
    }, 10000)
  }

  Channels.prototype.load_table = function () {
    return $.ajax({
      url: "/admin/channels",
      dataType: "script",
      type: "get",
      beforeSend: function (xhr, settings) {
        return xhr.setRequestHeader(
          "accept",
          "*/*;q=0.5, text/javascript, application/javascript, application/ecmascript, application/x-ecmascript"
        )
      },
      error: function () {
        return console.log("Error")
      }
    })
  }

  return Channels
})()

$(document).ready(function () {
  $(".channel-limits .close").on("click", function (e) {
    e.preventDefault()
    $(".channel-limits").hide()
  })

  if (!$("#user_api_v2_buy_enabled").is(":checked")) {
    $("#api_vendor_enabled").hide()
  }

  $("#user_api_v2_buy_enabled").change(function () {
    if (this.checked) {
      $("#api_vendor_enabled").show()
    } else {
      $("#api_vendor_enabled").hide()
    }
  })
})

function humanize(string) {
  string = string
    .toLowerCase()
    .replace(/[_-]+/g, " ")
    .replace(/\s{2,}/g, " ")
    .trim()
  return string.charAt(0).toUpperCase() + string.slice(1)
}

// hooks

var modules = [
  "admin/sortable-table",
  "admin/multitable-hover",
  "admin/multitable-compare",
  "admin/metrics",
  "admin/salesman-metrics",
  "admin/subscription-metrics",
  "admin/profit-graph",
  "admin/user-permissions",
  "admin/statistics",
  "admin/did_destinations"
]

_.each(modules, function (module) {
  System.import(module).then(function (m) {
    m.setup()
  })
})
;
